{
  "version": 3,
  "sources": ["../bundle-Ll1JrC/strip-cf-connecting-ip-header.js", "../../../node_modules/unenv/dist/runtime/_internal/utils.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs", "../../../node_modules/unenv/dist/runtime/node/perf_hooks.mjs", "../../../node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs", "../../../node_modules/unenv/dist/runtime/mock/noop.mjs", "../../../node_modules/unenv/dist/runtime/node/console.mjs", "../../../node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs", "../../../node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console", "../../../node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs", "../../../node_modules/unenv/dist/runtime/node/tty.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/process/process.mjs", "../../../node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs", "../../../node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process", "wrangler-modules-watch:wrangler:modules-watch", "../../../node_modules/wrangler/templates/modules-watch-stub.js", "../../../node_modules/fast-xml-parser/src/util.js", "../../../node_modules/fast-xml-parser/src/validator.js", "../../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js", "../../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js", "../../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js", "../../../node_modules/strnum/strnum.js", "../../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js", "../../../node_modules/fast-xml-parser/src/xmlparser/node2json.js", "../../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js", "../../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js", "../../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js", "../../../node_modules/fast-xml-parser/src/fxp.js", "../../../node_modules/bowser/es5.js", "../bundle-Ll1JrC/middleware-loader.entry.ts", "../bundle-Ll1JrC/middleware-insertion-facade.js", "../../../src/index.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/EC2Client.js", "../../../node_modules/@aws-sdk/middleware-host-header/dist-es/index.js", "../../../node_modules/@smithy/protocol-http/dist-es/index.js", "../../../node_modules/@smithy/protocol-http/dist-es/extensions/index.js", "../../../node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js", "../../../node_modules/@smithy/protocol-http/dist-es/Field.js", "../../../node_modules/@smithy/types/dist-es/index.js", "../../../node_modules/@smithy/types/dist-es/abort.js", "../../../node_modules/@smithy/types/dist-es/auth/index.js", "../../../node_modules/@smithy/types/dist-es/auth/auth.js", "../../../node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js", "../../../node_modules/@smithy/types/dist-es/auth/HttpAuthScheme.js", "../../../node_modules/@smithy/types/dist-es/auth/HttpAuthSchemeProvider.js", "../../../node_modules/@smithy/types/dist-es/auth/HttpSigner.js", "../../../node_modules/@smithy/types/dist-es/auth/IdentityProviderConfig.js", "../../../node_modules/@smithy/types/dist-es/blob/blob-payload-input-types.js", "../../../node_modules/@smithy/types/dist-es/checksum.js", "../../../node_modules/@smithy/types/dist-es/client.js", "../../../node_modules/@smithy/types/dist-es/command.js", "../../../node_modules/@smithy/types/dist-es/connection/index.js", "../../../node_modules/@smithy/types/dist-es/connection/config.js", "../../../node_modules/@smithy/types/dist-es/connection/manager.js", "../../../node_modules/@smithy/types/dist-es/connection/pool.js", "../../../node_modules/@smithy/types/dist-es/crypto.js", "../../../node_modules/@smithy/types/dist-es/encode.js", "../../../node_modules/@smithy/types/dist-es/endpoint.js", "../../../node_modules/@smithy/types/dist-es/endpoints/index.js", "../../../node_modules/@smithy/types/dist-es/endpoints/EndpointRuleObject.js", "../../../node_modules/@smithy/types/dist-es/endpoints/ErrorRuleObject.js", "../../../node_modules/@smithy/types/dist-es/endpoints/RuleSetObject.js", "../../../node_modules/@smithy/types/dist-es/endpoints/shared.js", "../../../node_modules/@smithy/types/dist-es/endpoints/TreeRuleObject.js", "../../../node_modules/@smithy/types/dist-es/eventStream.js", "../../../node_modules/@smithy/types/dist-es/extensions/index.js", "../../../node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js", "../../../node_modules/@smithy/types/dist-es/extensions/checksum.js", "../../../node_modules/@smithy/types/dist-es/extensions/defaultExtensionConfiguration.js", "../../../node_modules/@smithy/types/dist-es/feature-ids.js", "../../../node_modules/@smithy/types/dist-es/http.js", "../../../node_modules/@smithy/types/dist-es/http/httpHandlerInitialization.js", "../../../node_modules/@smithy/types/dist-es/identity/index.js", "../../../node_modules/@smithy/types/dist-es/identity/apiKeyIdentity.js", "../../../node_modules/@smithy/types/dist-es/identity/awsCredentialIdentity.js", "../../../node_modules/@smithy/types/dist-es/identity/identity.js", "../../../node_modules/@smithy/types/dist-es/identity/tokenIdentity.js", "../../../node_modules/@smithy/types/dist-es/logger.js", "../../../node_modules/@smithy/types/dist-es/middleware.js", "../../../node_modules/@smithy/types/dist-es/pagination.js", "../../../node_modules/@smithy/types/dist-es/profile.js", "../../../node_modules/@smithy/types/dist-es/response.js", "../../../node_modules/@smithy/types/dist-es/retry.js", "../../../node_modules/@smithy/types/dist-es/schema/schema.js", "../../../node_modules/@smithy/types/dist-es/schema/sentinels.js", "../../../node_modules/@smithy/types/dist-es/serde.js", "../../../node_modules/@smithy/types/dist-es/shapes.js", "../../../node_modules/@smithy/types/dist-es/signature.js", "../../../node_modules/@smithy/types/dist-es/stream.js", "../../../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-common-types.js", "../../../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-input-types.js", "../../../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-output-types.js", "../../../node_modules/@smithy/types/dist-es/transfer.js", "../../../node_modules/@smithy/types/dist-es/transform/client-payload-blob-type-narrow.js", "../../../node_modules/@smithy/types/dist-es/transform/mutable.js", "../../../node_modules/@smithy/types/dist-es/transform/no-undefined.js", "../../../node_modules/@smithy/types/dist-es/transform/type-transform.js", "../../../node_modules/@smithy/types/dist-es/uri.js", "../../../node_modules/@smithy/types/dist-es/util.js", "../../../node_modules/@smithy/types/dist-es/waiter.js", "../../../node_modules/@smithy/protocol-http/dist-es/Fields.js", "../../../node_modules/@smithy/protocol-http/dist-es/httpHandler.js", "../../../node_modules/@smithy/protocol-http/dist-es/httpRequest.js", "../../../node_modules/@smithy/protocol-http/dist-es/httpResponse.js", "../../../node_modules/@smithy/protocol-http/dist-es/isValidHostname.js", "../../../node_modules/@smithy/protocol-http/dist-es/types.js", "../../../node_modules/@aws-sdk/middleware-logger/dist-es/index.js", "../../../node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js", "../../../node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js", "../../../node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js", "../../../node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js", "../../../node_modules/@smithy/core/dist-es/index.js", "../../../node_modules/@smithy/core/dist-es/getSmithyContext.js", "../../../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js", "../../../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js", "../../../node_modules/@smithy/util-middleware/dist-es/index.js", "../../../node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js", "../../../node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js", "../../../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/resolveAuthOptions.js", "../../../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js", "../../../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js", "../../../node_modules/@smithy/middleware-serde/dist-es/index.js", "../../../node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js", "../../../node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js", "../../../node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js", "../../../node_modules/@smithy/core/dist-es/middleware-http-signing/index.js", "../../../node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js", "../../../node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js", "../../../node_modules/@smithy/core/dist-es/normalizeProvider.js", "../../../node_modules/@smithy/core/dist-es/pagination/createPaginator.js", "../../../node_modules/@smithy/core/dist-es/protocols/requestBuilder.js", "../../../node_modules/@smithy/core/dist-es/submodules/protocols/index.js", "../../../node_modules/@smithy/core/dist-es/submodules/protocols/collect-stream-body.js", "../../../node_modules/@smithy/util-stream/dist-es/index.js", "../../../node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js", "../../../node_modules/@smithy/util-stream/dist-es/blob/transforms.js", "../../../node_modules/@smithy/util-base64/dist-es/index.js", "../../../node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js", "../../../node_modules/@smithy/util-base64/dist-es/constants.browser.js", "../../../node_modules/@smithy/util-base64/dist-es/toBase64.browser.js", "../../../node_modules/@smithy/util-utf8/dist-es/index.js", "../../../node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js", "../../../node_modules/@smithy/util-utf8/dist-es/toUint8Array.js", "../../../node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js", "../../../node_modules/@smithy/util-stream/dist-es/checksum/ChecksumStream.browser.js", "../../../node_modules/@smithy/util-stream/dist-es/checksum/createChecksumStream.browser.js", "../../../node_modules/@smithy/util-stream/dist-es/stream-type-check.js", "../../../node_modules/@smithy/util-stream/dist-es/createBufferedReadableStream.js", "../../../node_modules/@smithy/util-stream/dist-es/ByteArrayCollector.js", "../../../node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.browser.js", "../../../node_modules/@smithy/util-stream/dist-es/headStream.browser.js", "../../../node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js", "../../../node_modules/@smithy/fetch-http-handler/dist-es/index.js", "../../../node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js", "../../../node_modules/@smithy/querystring-builder/dist-es/index.js", "../../../node_modules/@smithy/util-uri-escape/dist-es/index.js", "../../../node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js", "../../../node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js", "../../../node_modules/@smithy/fetch-http-handler/dist-es/create-request.js", "../../../node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js", "../../../node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js", "../../../node_modules/@smithy/util-hex-encoding/dist-es/index.js", "../../../node_modules/@smithy/util-stream/dist-es/splitStream.browser.js", "../../../node_modules/@smithy/core/dist-es/submodules/protocols/extended-encode-uri-component.js", "../../../node_modules/@smithy/core/dist-es/submodules/protocols/requestBuilder.js", "../../../node_modules/@smithy/core/dist-es/submodules/protocols/resolve-path.js", "../../../node_modules/@smithy/core/dist-es/setFeature.js", "../../../node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js", "../../../node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js", "../../../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js", "../../../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js", "../../../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js", "../../../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js", "../../../node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js", "../../../node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/index.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/aws.js", "../../../node_modules/@smithy/util-endpoints/dist-es/index.js", "../../../node_modules/@smithy/util-endpoints/dist-es/cache/EndpointCache.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/isIpAddress.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/isValidHostLabel.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/customEndpointFunctions.js", "../../../node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js", "../../../node_modules/@smithy/util-endpoints/dist-es/debug/index.js", "../../../node_modules/@smithy/util-endpoints/dist-es/debug/debugId.js", "../../../node_modules/@smithy/util-endpoints/dist-es/debug/toDebugString.js", "../../../node_modules/@smithy/util-endpoints/dist-es/types/index.js", "../../../node_modules/@smithy/util-endpoints/dist-es/types/EndpointError.js", "../../../node_modules/@smithy/util-endpoints/dist-es/types/EndpointFunctions.js", "../../../node_modules/@smithy/util-endpoints/dist-es/types/EndpointRuleObject.js", "../../../node_modules/@smithy/util-endpoints/dist-es/types/ErrorRuleObject.js", "../../../node_modules/@smithy/util-endpoints/dist-es/types/RuleSetObject.js", "../../../node_modules/@smithy/util-endpoints/dist-es/types/TreeRuleObject.js", "../../../node_modules/@smithy/util-endpoints/dist-es/types/shared.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/index.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/index.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/booleanEquals.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/getAttrPathList.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/isSet.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/not.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/parseURL.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/stringEquals.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/substring.js", "../../../node_modules/@smithy/util-endpoints/dist-es/lib/uriEncode.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTemplate.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/getReferenceValue.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointHeaders.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperty.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointUrl.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateErrorRule.js", "../../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTreeRule.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointRuleObject.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/types/ErrorRuleObject.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/types/RuleSetObject.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/types/TreeRuleObject.js", "../../../node_modules/@aws-sdk/util-endpoints/dist-es/types/shared.js", "../../../node_modules/@aws-sdk/middleware-user-agent/dist-es/check-features.js", "../../../node_modules/@aws-sdk/core/dist-es/submodules/client/setCredentialFeature.js", "../../../node_modules/@aws-sdk/core/dist-es/submodules/client/setFeature.js", "../../../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/index.js", "../../../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js", "../../../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getDateHeader.js", "../../../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getSkewCorrectedDate.js", "../../../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.js", "../../../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/isClockSkewed.js", "../../../node_modules/@smithy/property-provider/dist-es/index.js", "../../../node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js", "../../../node_modules/@smithy/property-provider/dist-es/ProviderError.js", "../../../node_modules/@smithy/property-provider/dist-es/TokenProviderError.js", "../../../node_modules/@smithy/property-provider/dist-es/chain.js", "../../../node_modules/@smithy/property-provider/dist-es/fromStatic.js", "../../../node_modules/@smithy/property-provider/dist-es/memoize.js", "../../../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js", "../../../node_modules/@smithy/signature-v4/dist-es/index.js", "../../../node_modules/@smithy/signature-v4/dist-es/SignatureV4.js", "../../../node_modules/@smithy/signature-v4/dist-es/constants.js", "../../../node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js", "../../../node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js", "../../../node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js", "../../../node_modules/@smithy/is-array-buffer/dist-es/index.js", "../../../node_modules/@smithy/signature-v4/dist-es/HeaderFormatter.js", "../../../node_modules/@smithy/signature-v4/dist-es/headerUtil.js", "../../../node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js", "../../../node_modules/@smithy/signature-v4/dist-es/prepareRequest.js", "../../../node_modules/@smithy/signature-v4/dist-es/SignatureV4Base.js", "../../../node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js", "../../../node_modules/@smithy/signature-v4/dist-es/utilDate.js", "../../../node_modules/@smithy/signature-v4/dist-es/signature-v4a-container.js", "../../../node_modules/@smithy/smithy-client/dist-es/index.js", "../../../node_modules/@smithy/smithy-client/dist-es/client.js", "../../../node_modules/@smithy/middleware-stack/dist-es/index.js", "../../../node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js", "../../../node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js", "../../../node_modules/@smithy/smithy-client/dist-es/command.js", "../../../node_modules/@smithy/smithy-client/dist-es/constants.js", "../../../node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js", "../../../node_modules/@smithy/smithy-client/dist-es/default-error-handler.js", "../../../node_modules/@smithy/smithy-client/dist-es/exceptions.js", "../../../node_modules/@smithy/smithy-client/dist-es/defaults-mode.js", "../../../node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js", "../../../node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js", "../../../node_modules/@smithy/smithy-client/dist-es/extensions/index.js", "../../../node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js", "../../../node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js", "../../../node_modules/@smithy/smithy-client/dist-es/extensions/retry.js", "../../../node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js", "../../../node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js", "../../../node_modules/@smithy/smithy-client/dist-es/is-serializable-header-value.js", "../../../node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js", "../../../node_modules/@smithy/smithy-client/dist-es/object-mapping.js", "../../../node_modules/@smithy/smithy-client/dist-es/resolve-path.js", "../../../node_modules/@smithy/smithy-client/dist-es/ser-utils.js", "../../../node_modules/@smithy/smithy-client/dist-es/serde-json.js", "../../../node_modules/@smithy/core/dist-es/submodules/serde/index.js", "../../../node_modules/@smithy/core/dist-es/submodules/serde/parse-utils.js", "../../../node_modules/@smithy/core/dist-es/submodules/serde/date-utils.js", "../../../node_modules/@smithy/core/dist-es/submodules/serde/quote-header.js", "../../../node_modules/@smithy/core/dist-es/submodules/serde/split-header.js", "../../../node_modules/@smithy/core/dist-es/submodules/serde/value/NumericValue.js", "../../../node_modules/@smithy/core/dist-es/submodules/serde/lazy-json.js", "../../../node_modules/@smithy/core/dist-es/submodules/serde/split-every.js", "../../../node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js", "../../../node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js", "../../../node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js", "../../../node_modules/@aws-sdk/middleware-user-agent/dist-es/encode-features.js", "../../../node_modules/@smithy/config-resolver/dist-es/index.js", "../../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/index.js", "../../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js", "../../../node_modules/@smithy/util-config-provider/dist-es/index.js", "../../../node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js", "../../../node_modules/@smithy/util-config-provider/dist-es/numberSelector.js", "../../../node_modules/@smithy/util-config-provider/dist-es/types.js", "../../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js", "../../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js", "../../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js", "../../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/utils/getEndpointFromRegion.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionConfig/index.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionInfo/index.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionInfo/PartitionHash.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionInfo/RegionHash.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionInfo/getRegionInfo.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionInfo/getHostnameFromVariants.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedHostname.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedPartition.js", "../../../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedSigningRegion.js", "../../../node_modules/@smithy/middleware-content-length/dist-es/index.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/index.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/index.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.browser.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js", "../../../node_modules/@smithy/url-parser/dist-es/index.js", "../../../node_modules/@smithy/querystring-parser/dist-es/index.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js", "../../../node_modules/@smithy/middleware-endpoint/dist-es/types.js", "../../../node_modules/@smithy/middleware-retry/dist-es/index.js", "../../../node_modules/@smithy/middleware-retry/dist-es/AdaptiveRetryStrategy.js", "../../../node_modules/@smithy/util-retry/dist-es/index.js", "../../../node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js", "../../../node_modules/@smithy/util-retry/dist-es/config.js", "../../../node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js", "../../../node_modules/@smithy/service-error-classification/dist-es/index.js", "../../../node_modules/@smithy/service-error-classification/dist-es/constants.js", "../../../node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js", "../../../node_modules/@smithy/util-retry/dist-es/constants.js", "../../../node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js", "../../../node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js", "../../../node_modules/@smithy/util-retry/dist-es/ConfiguredRetryStrategy.js", "../../../node_modules/@smithy/util-retry/dist-es/types.js", "../../../node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js", "../../../node_modules/uuid/dist/esm-browser/index.js", "../../../node_modules/uuid/dist/esm-browser/rng.js", "../../../node_modules/uuid/dist/esm-browser/stringify.js", "../../../node_modules/uuid/dist/esm-browser/v4.js", "../../../node_modules/uuid/dist/esm-browser/native.js", "../../../node_modules/@smithy/middleware-retry/dist-es/defaultRetryQuota.js", "../../../node_modules/@smithy/middleware-retry/dist-es/delayDecider.js", "../../../node_modules/@smithy/middleware-retry/dist-es/retryDecider.js", "../../../node_modules/@smithy/middleware-retry/dist-es/util.js", "../../../node_modules/@smithy/middleware-retry/dist-es/configurations.js", "../../../node_modules/@smithy/middleware-retry/dist-es/omitRetryHeadersMiddleware.js", "../../../node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js", "../../../node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.browser.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/auth/httpAuthSchemeProvider.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/endpoint/EndpointParameters.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/runtimeConfig.browser.js", "../../../node_modules/@aws-sdk/client-ec2/package.json", "../../../node_modules/@aws-crypto/sha256-browser/src/index.ts", "../../../node_modules/@aws-crypto/sha256-browser/src/crossPlatformSha256.ts", "../../../node_modules/@aws-crypto/sha256-browser/src/webCryptoSha256.ts", "../../../node_modules/@aws-crypto/util/src/index.ts", "../../../node_modules/@aws-crypto/util/src/convertToBuffer.ts", "../../../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/index.js", "../../../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js", "../../../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js", "../../../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js", "../../../node_modules/@aws-crypto/util/src/isEmptyData.ts", "../../../node_modules/@aws-crypto/util/src/numToUint8.ts", "../../../node_modules/@aws-crypto/util/src/uint32ArrayFrom.ts", "../../../node_modules/@aws-crypto/sha256-browser/src/constants.ts", "../../../node_modules/@aws-sdk/util-locate-window/dist-es/index.js", "../../../node_modules/@aws-crypto/sha256-js/src/index.ts", "../../../node_modules/tslib/tslib.es6.mjs", "../../../node_modules/@aws-crypto/sha256-js/src/constants.ts", "../../../node_modules/@aws-crypto/sha256-js/src/RawSha256.ts", "../../../node_modules/@aws-crypto/sha256-js/src/jsSha256.ts", "../../../node_modules/@aws-crypto/supports-web-crypto/src/index.ts", "../../../node_modules/@aws-crypto/supports-web-crypto/src/supportsWebCrypto.ts", "../../../node_modules/@aws-sdk/util-user-agent-browser/dist-es/index.js", "../../../node_modules/@smithy/invalid-dependency/dist-es/index.js", "../../../node_modules/@smithy/invalid-dependency/dist-es/invalidFunction.js", "../../../node_modules/@smithy/invalid-dependency/dist-es/invalidProvider.js", "../../../node_modules/@smithy/util-body-length-browser/dist-es/index.js", "../../../node_modules/@smithy/util-body-length-browser/dist-es/calculateBodyLength.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/runtimeConfig.shared.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/endpoint/endpointResolver.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/endpoint/ruleset.js", "../../../node_modules/@smithy/util-defaults-mode-browser/dist-es/index.js", "../../../node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js", "../../../node_modules/@smithy/util-defaults-mode-browser/dist-es/constants.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/runtimeExtensions.js", "../../../node_modules/@aws-sdk/region-config-resolver/dist-es/index.js", "../../../node_modules/@aws-sdk/region-config-resolver/dist-es/extensions/index.js", "../../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/index.js", "../../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/config.js", "../../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/resolveRegionConfig.js", "../../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/getRealRegion.js", "../../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/isFipsRegion.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/auth/httpAuthExtensionConfiguration.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/protocols/Aws_ec2.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/models/EC2ServiceException.js", "../../../node_modules/@aws-sdk/client-ec2/dist-es/commands/DescribeInstancesCommand.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/CloudWatchClient.js", "../../../node_modules/@smithy/middleware-compression/dist-es/index.js", "../../../node_modules/@smithy/middleware-compression/dist-es/NODE_DISABLE_REQUEST_COMPRESSION_CONFIG_OPTIONS.js", "../../../node_modules/@smithy/middleware-compression/dist-es/NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES_CONFIG_OPTIONS.js", "../../../node_modules/@smithy/middleware-compression/dist-es/compressionMiddleware.js", "../../../node_modules/@smithy/middleware-compression/dist-es/compressStream.browser.js", "../../../node_modules/@smithy/middleware-compression/dist-es/compressString.browser.js", "../../../node_modules/@smithy/middleware-compression/dist-es/constants.js", "../../../node_modules/@smithy/middleware-compression/dist-es/isStreaming.js", "../../../node_modules/@smithy/middleware-compression/dist-es/configurations.js", "../../../node_modules/@smithy/middleware-compression/dist-es/getCompressionPlugin.js", "../../../node_modules/@smithy/middleware-compression/dist-es/resolveCompressionConfig.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/auth/httpAuthSchemeProvider.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/EndpointParameters.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/runtimeConfig.browser.js", "../../../node_modules/@aws-sdk/client-cloudwatch/package.json", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/runtimeConfig.shared.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/endpointResolver.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/ruleset.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/runtimeExtensions.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/auth/httpAuthExtensionConfiguration.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/protocols/Aws_query.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/models/CloudWatchServiceException.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/models/models_0.js", "../../../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/GetMetricStatisticsCommand.js", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../../../node_modules/wrangler/templates/middleware/common.ts"],
  "sourceRoot": "D:\\Code\\EC2-network-monitor\\.wrangler\\tmp\\dev-ElQLMQ",
  "sourcesContent": ["function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "/* @__NO_SIDE_EFFECTS__ */\nexport function rawHeaders(headers) {\n\tconst rawHeaders = [];\n\tfor (const key in headers) {\n\t\tif (Array.isArray(headers[key])) {\n\t\t\tfor (const h of headers[key]) {\n\t\t\t\trawHeaders.push(key, h);\n\t\t\t}\n\t\t} else {\n\t\t\trawHeaders.push(key, headers[key]);\n\t\t}\n\t}\n\treturn rawHeaders;\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function mergeFns(...functions) {\n\treturn function(...args) {\n\t\tfor (const fn of functions) {\n\t\t\tfn(...args);\n\t\t}\n\t};\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function createNotImplementedError(name) {\n\treturn new Error(`[unenv] ${name} is not implemented yet!`);\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplemented(name) {\n\tconst fn = () => {\n\t\tthrow createNotImplementedError(name);\n\t};\n\treturn Object.assign(fn, { __unenv__: true });\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplementedAsync(name) {\n\tconst fn = notImplemented(name);\n\tfn.__promisify__ = () => notImplemented(name + \".__promisify__\");\n\tfn.native = fn;\n\treturn fn;\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplementedClass(name) {\n\treturn class {\n\t\t__unenv__ = true;\n\t\tconstructor() {\n\t\t\tthrow new Error(`[unenv] ${name} is not implemented yet!`);\n\t\t}\n\t};\n}\n", "import { createNotImplementedError } from \"../../../_internal/utils.mjs\";\nconst _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();\nconst _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;\nconst nodeTiming = {\n\tname: \"node\",\n\tentryType: \"node\",\n\tstartTime: 0,\n\tduration: 0,\n\tnodeStart: 0,\n\tv8Start: 0,\n\tbootstrapComplete: 0,\n\tenvironment: 0,\n\tloopStart: 0,\n\tloopExit: 0,\n\tidleTime: 0,\n\tuvMetricsInfo: {\n\t\tloopCount: 0,\n\t\tevents: 0,\n\t\teventsWaiting: 0\n\t},\n\tdetail: undefined,\n\ttoJSON() {\n\t\treturn this;\n\t}\n};\nexport class PerformanceEntry {\n\t__unenv__ = true;\n\tdetail;\n\tentryType = \"event\";\n\tname;\n\tstartTime;\n\tconstructor(name, options) {\n\t\tthis.name = name;\n\t\tthis.startTime = options?.startTime || _performanceNow();\n\t\tthis.detail = options?.detail;\n\t}\n\tget duration() {\n\t\treturn _performanceNow() - this.startTime;\n\t}\n\ttoJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tentryType: this.entryType,\n\t\t\tstartTime: this.startTime,\n\t\t\tduration: this.duration,\n\t\t\tdetail: this.detail\n\t\t};\n\t}\n}\nexport const PerformanceMark = class PerformanceMark extends PerformanceEntry {\n\tentryType = \"mark\";\n\tconstructor() {\n\t\tsuper(...arguments);\n\t}\n\tget duration() {\n\t\treturn 0;\n\t}\n};\nexport class PerformanceMeasure extends PerformanceEntry {\n\tentryType = \"measure\";\n}\nexport class PerformanceResourceTiming extends PerformanceEntry {\n\tentryType = \"resource\";\n\tserverTiming = [];\n\tconnectEnd = 0;\n\tconnectStart = 0;\n\tdecodedBodySize = 0;\n\tdomainLookupEnd = 0;\n\tdomainLookupStart = 0;\n\tencodedBodySize = 0;\n\tfetchStart = 0;\n\tinitiatorType = \"\";\n\tname = \"\";\n\tnextHopProtocol = \"\";\n\tredirectEnd = 0;\n\tredirectStart = 0;\n\trequestStart = 0;\n\tresponseEnd = 0;\n\tresponseStart = 0;\n\tsecureConnectionStart = 0;\n\tstartTime = 0;\n\ttransferSize = 0;\n\tworkerStart = 0;\n\tresponseStatus = 0;\n}\nexport class PerformanceObserverEntryList {\n\t__unenv__ = true;\n\tgetEntries() {\n\t\treturn [];\n\t}\n\tgetEntriesByName(_name, _type) {\n\t\treturn [];\n\t}\n\tgetEntriesByType(type) {\n\t\treturn [];\n\t}\n}\nexport class Performance {\n\t__unenv__ = true;\n\ttimeOrigin = _timeOrigin;\n\teventCounts = new Map();\n\t_entries = [];\n\t_resourceTimingBufferSize = 0;\n\tnavigation = undefined;\n\ttiming = undefined;\n\ttimerify(_fn, _options) {\n\t\tthrow createNotImplementedError(\"Performance.timerify\");\n\t}\n\tget nodeTiming() {\n\t\treturn nodeTiming;\n\t}\n\teventLoopUtilization() {\n\t\treturn {};\n\t}\n\tmarkResourceTiming() {\n\t\treturn new PerformanceResourceTiming(\"\");\n\t}\n\tonresourcetimingbufferfull = null;\n\tnow() {\n\t\tif (this.timeOrigin === _timeOrigin) {\n\t\t\treturn _performanceNow();\n\t\t}\n\t\treturn Date.now() - this.timeOrigin;\n\t}\n\tclearMarks(markName) {\n\t\tthis._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== \"mark\");\n\t}\n\tclearMeasures(measureName) {\n\t\tthis._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== \"measure\");\n\t}\n\tclearResourceTimings() {\n\t\tthis._entries = this._entries.filter((e) => e.entryType !== \"resource\" || e.entryType !== \"navigation\");\n\t}\n\tgetEntries() {\n\t\treturn this._entries;\n\t}\n\tgetEntriesByName(name, type) {\n\t\treturn this._entries.filter((e) => e.name === name && (!type || e.entryType === type));\n\t}\n\tgetEntriesByType(type) {\n\t\treturn this._entries.filter((e) => e.entryType === type);\n\t}\n\tmark(name, options) {\n\t\tconst entry = new PerformanceMark(name, options);\n\t\tthis._entries.push(entry);\n\t\treturn entry;\n\t}\n\tmeasure(measureName, startOrMeasureOptions, endMark) {\n\t\tlet start;\n\t\tlet end;\n\t\tif (typeof startOrMeasureOptions === \"string\") {\n\t\t\tstart = this.getEntriesByName(startOrMeasureOptions, \"mark\")[0]?.startTime;\n\t\t\tend = this.getEntriesByName(endMark, \"mark\")[0]?.startTime;\n\t\t} else {\n\t\t\tstart = Number.parseFloat(startOrMeasureOptions?.start) || this.now();\n\t\t\tend = Number.parseFloat(startOrMeasureOptions?.end) || this.now();\n\t\t}\n\t\tconst entry = new PerformanceMeasure(measureName, {\n\t\t\tstartTime: start,\n\t\t\tdetail: {\n\t\t\t\tstart,\n\t\t\t\tend\n\t\t\t}\n\t\t});\n\t\tthis._entries.push(entry);\n\t\treturn entry;\n\t}\n\tsetResourceTimingBufferSize(maxSize) {\n\t\tthis._resourceTimingBufferSize = maxSize;\n\t}\n\taddEventListener(type, listener, options) {\n\t\tthrow createNotImplementedError(\"Performance.addEventListener\");\n\t}\n\tremoveEventListener(type, listener, options) {\n\t\tthrow createNotImplementedError(\"Performance.removeEventListener\");\n\t}\n\tdispatchEvent(event) {\n\t\tthrow createNotImplementedError(\"Performance.dispatchEvent\");\n\t}\n\ttoJSON() {\n\t\treturn this;\n\t}\n}\nexport class PerformanceObserver {\n\t__unenv__ = true;\n\tstatic supportedEntryTypes = [];\n\t_callback = null;\n\tconstructor(callback) {\n\t\tthis._callback = callback;\n\t}\n\ttakeRecords() {\n\t\treturn [];\n\t}\n\tdisconnect() {\n\t\tthrow createNotImplementedError(\"PerformanceObserver.disconnect\");\n\t}\n\tobserve(options) {\n\t\tthrow createNotImplementedError(\"PerformanceObserver.observe\");\n\t}\n\tbind(fn) {\n\t\treturn fn;\n\t}\n\trunInAsyncScope(fn, thisArg, ...args) {\n\t\treturn fn.call(thisArg, ...args);\n\t}\n\tasyncId() {\n\t\treturn 0;\n\t}\n\ttriggerAsyncId() {\n\t\treturn 0;\n\t}\n\temitDestroy() {\n\t\treturn this;\n\t}\n}\nexport const performance = globalThis.performance && \"addEventListener\" in globalThis.performance ? globalThis.performance : new Performance();\n", "import { IntervalHistogram, RecordableHistogram } from \"./internal/perf_hooks/histogram.mjs\";\nimport { performance, Performance, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceObserverEntryList, PerformanceObserver, PerformanceResourceTiming } from \"./internal/perf_hooks/performance.mjs\";\nexport * from \"./internal/perf_hooks/performance.mjs\";\nimport { NODE_PERFORMANCE_GC_MAJOR, NODE_PERFORMANCE_GC_MINOR, NODE_PERFORMANCE_GC_INCREMENTAL, NODE_PERFORMANCE_GC_WEAKCB, NODE_PERFORMANCE_GC_FLAGS_NO, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED, NODE_PERFORMANCE_GC_FLAGS_FORCED, NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING, NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE, NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY, NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE, NODE_PERFORMANCE_ENTRY_TYPE_GC, NODE_PERFORMANCE_ENTRY_TYPE_HTTP, NODE_PERFORMANCE_ENTRY_TYPE_HTTP2, NODE_PERFORMANCE_ENTRY_TYPE_NET, NODE_PERFORMANCE_ENTRY_TYPE_DNS, NODE_PERFORMANCE_MILESTONE_TIME_ORIGIN_TIMESTAMP, NODE_PERFORMANCE_MILESTONE_TIME_ORIGIN, NODE_PERFORMANCE_MILESTONE_ENVIRONMENT, NODE_PERFORMANCE_MILESTONE_NODE_START, NODE_PERFORMANCE_MILESTONE_V8_START, NODE_PERFORMANCE_MILESTONE_LOOP_START, NODE_PERFORMANCE_MILESTONE_LOOP_EXIT, NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE } from \"./internal/perf_hooks/constants.mjs\";\nexport const constants = {\n\tNODE_PERFORMANCE_GC_MAJOR,\n\tNODE_PERFORMANCE_GC_MINOR,\n\tNODE_PERFORMANCE_GC_INCREMENTAL,\n\tNODE_PERFORMANCE_GC_WEAKCB,\n\tNODE_PERFORMANCE_GC_FLAGS_NO,\n\tNODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED,\n\tNODE_PERFORMANCE_GC_FLAGS_FORCED,\n\tNODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING,\n\tNODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE,\n\tNODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY,\n\tNODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE,\n\tNODE_PERFORMANCE_ENTRY_TYPE_GC,\n\tNODE_PERFORMANCE_ENTRY_TYPE_HTTP,\n\tNODE_PERFORMANCE_ENTRY_TYPE_HTTP2,\n\tNODE_PERFORMANCE_ENTRY_TYPE_NET,\n\tNODE_PERFORMANCE_ENTRY_TYPE_DNS,\n\tNODE_PERFORMANCE_MILESTONE_TIME_ORIGIN_TIMESTAMP,\n\tNODE_PERFORMANCE_MILESTONE_TIME_ORIGIN,\n\tNODE_PERFORMANCE_MILESTONE_ENVIRONMENT,\n\tNODE_PERFORMANCE_MILESTONE_NODE_START,\n\tNODE_PERFORMANCE_MILESTONE_V8_START,\n\tNODE_PERFORMANCE_MILESTONE_LOOP_START,\n\tNODE_PERFORMANCE_MILESTONE_LOOP_EXIT,\n\tNODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE\n};\nexport const monitorEventLoopDelay = function(_options) {\n\treturn new IntervalHistogram();\n};\nexport const createHistogram = function(_options) {\n\treturn new RecordableHistogram();\n};\nexport default {\n\tPerformance,\n\tPerformanceMark,\n\tPerformanceEntry,\n\tPerformanceMeasure,\n\tPerformanceObserverEntryList,\n\tPerformanceObserver,\n\tPerformanceResourceTiming,\n\tperformance,\n\tconstants,\n\tcreateHistogram,\n\tmonitorEventLoopDelay\n};\n", "import {\n  performance,\n  Performance,\n  PerformanceEntry,\n  PerformanceMark,\n  PerformanceMeasure,\n  PerformanceObserver,\n  PerformanceObserverEntryList,\n  PerformanceResourceTiming\n} from \"node:perf_hooks\";\nglobalThis.performance = performance;\nglobalThis.Performance = Performance;\nglobalThis.PerformanceEntry = PerformanceEntry;\nglobalThis.PerformanceMark = PerformanceMark;\nglobalThis.PerformanceMeasure = PerformanceMeasure;\nglobalThis.PerformanceObserver = PerformanceObserver;\nglobalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;\nglobalThis.PerformanceResourceTiming = PerformanceResourceTiming;\n", "export default Object.assign(() => {}, { __unenv__: true });\n", "import { Writable } from \"node:stream\";\nimport noop from \"../mock/noop.mjs\";\nimport { notImplemented, notImplementedClass } from \"../_internal/utils.mjs\";\nconst _console = globalThis.console;\nexport const _ignoreErrors = true;\nexport const _stderr = new Writable();\nexport const _stdout = new Writable();\nexport const log = _console?.log ?? noop;\nexport const info = _console?.info ?? log;\nexport const trace = _console?.trace ?? info;\nexport const debug = _console?.debug ?? log;\nexport const table = _console?.table ?? log;\nexport const error = _console?.error ?? log;\nexport const warn = _console?.warn ?? error;\nexport const createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented(\"console.createTask\");\nexport const assert = /* @__PURE__ */ notImplemented(\"console.assert\");\nexport const clear = _console?.clear ?? noop;\nexport const count = _console?.count ?? noop;\nexport const countReset = _console?.countReset ?? noop;\nexport const dir = _console?.dir ?? noop;\nexport const dirxml = _console?.dirxml ?? noop;\nexport const group = _console?.group ?? noop;\nexport const groupEnd = _console?.groupEnd ?? noop;\nexport const groupCollapsed = _console?.groupCollapsed ?? noop;\nexport const profile = _console?.profile ?? noop;\nexport const profileEnd = _console?.profileEnd ?? noop;\nexport const time = _console?.time ?? noop;\nexport const timeEnd = _console?.timeEnd ?? noop;\nexport const timeLog = _console?.timeLog ?? noop;\nexport const timeStamp = _console?.timeStamp ?? noop;\nexport const Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass(\"console.Console\");\nexport const _times = /* @__PURE__ */ new Map();\nexport function context() {\n\treturn _console;\n}\nexport const _stdoutErrorHandler = noop;\nexport const _stderrErrorHandler = noop;\nexport default {\n\t_times,\n\t_ignoreErrors,\n\t_stdoutErrorHandler,\n\t_stderrErrorHandler,\n\t_stdout,\n\t_stderr,\n\tassert,\n\tclear,\n\tConsole,\n\tcount,\n\tcountReset,\n\tdebug,\n\tdir,\n\tdirxml,\n\terror,\n\tcontext,\n\tcreateTask,\n\tgroup,\n\tgroupEnd,\n\tgroupCollapsed,\n\tinfo,\n\tlog,\n\tprofile,\n\tprofileEnd,\n\ttable,\n\ttime,\n\ttimeEnd,\n\ttimeLog,\n\ttimeStamp,\n\ttrace,\n\twarn\n};\n", "import {\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times,\n  Console\n} from \"unenv/node/console\";\nexport {\n  Console,\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times\n} from \"unenv/node/console\";\nconst workerdConsole = globalThis[\"console\"];\nexport const {\n  assert,\n  clear,\n  // @ts-expect-error undocumented public API\n  context,\n  count,\n  countReset,\n  // @ts-expect-error undocumented public API\n  createTask,\n  debug,\n  dir,\n  dirxml,\n  error,\n  group,\n  groupCollapsed,\n  groupEnd,\n  info,\n  log,\n  profile,\n  profileEnd,\n  table,\n  time,\n  timeEnd,\n  timeLog,\n  timeStamp,\n  trace,\n  warn\n} = workerdConsole;\nObject.assign(workerdConsole, {\n  Console,\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times\n});\nexport default workerdConsole;\n", "import { default as defaultExport } from \"@cloudflare/unenv-preset/node/console\";\nglobalThis.console = defaultExport;", "export const hrtime = /* @__PURE__ */ Object.assign(function hrtime(startTime) {\n\tconst now = Date.now();\n\tconst seconds = Math.trunc(now / 1e3);\n\tconst nanos = now % 1e3 * 1e6;\n\tif (startTime) {\n\t\tlet diffSeconds = seconds - startTime[0];\n\t\tlet diffNanos = nanos - startTime[0];\n\t\tif (diffNanos < 0) {\n\t\t\tdiffSeconds = diffSeconds - 1;\n\t\t\tdiffNanos = 1e9 + diffNanos;\n\t\t}\n\t\treturn [diffSeconds, diffNanos];\n\t}\n\treturn [seconds, nanos];\n}, { bigint: function bigint() {\n\treturn BigInt(Date.now() * 1e6);\n} });\n", "export class WriteStream {\n\tfd;\n\tcolumns = 80;\n\trows = 24;\n\tisTTY = false;\n\tconstructor(fd) {\n\t\tthis.fd = fd;\n\t}\n\tclearLine(dir, callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tclearScreenDown(callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tcursorTo(x, y, callback) {\n\t\tcallback && typeof callback === \"function\" && callback();\n\t\treturn false;\n\t}\n\tmoveCursor(dx, dy, callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tgetColorDepth(env) {\n\t\treturn 1;\n\t}\n\thasColors(count, env) {\n\t\treturn false;\n\t}\n\tgetWindowSize() {\n\t\treturn [this.columns, this.rows];\n\t}\n\twrite(str, encoding, cb) {\n\t\tif (str instanceof Uint8Array) {\n\t\t\tstr = new TextDecoder().decode(str);\n\t\t}\n\t\ttry {\n\t\t\tconsole.log(str);\n\t\t} catch {}\n\t\tcb && typeof cb === \"function\" && cb();\n\t\treturn false;\n\t}\n}\n", "export class ReadStream {\n\tfd;\n\tisRaw = false;\n\tisTTY = false;\n\tconstructor(fd) {\n\t\tthis.fd = fd;\n\t}\n\tsetRawMode(mode) {\n\t\tthis.isRaw = mode;\n\t\treturn this;\n\t}\n}\n", "import { WriteStream } from \"./internal/tty/write-stream.mjs\";\nexport { ReadStream } from \"./internal/tty/read-stream.mjs\";\nexport { WriteStream } from \"./internal/tty/write-stream.mjs\";\nexport const isatty = function() {\n\treturn false;\n};\nexport default {\n\tReadStream: WriteStream,\n\tWriteStream,\n\tisatty\n};\n", "export const NODE_VERSION = \"22.14.0\";\n", "import { EventEmitter } from \"node:events\";\nimport { ReadStream, WriteStream } from \"node:tty\";\nimport { notImplemented, createNotImplementedError } from \"../../../_internal/utils.mjs\";\nimport { NODE_VERSION } from \"./node-version.mjs\";\nexport class Process extends EventEmitter {\n\tenv;\n\thrtime;\n\tnextTick;\n\tconstructor(impl) {\n\t\tsuper();\n\t\tthis.env = impl.env;\n\t\tthis.hrtime = impl.hrtime;\n\t\tthis.nextTick = impl.nextTick;\n\t\tfor (const prop of [...Object.getOwnPropertyNames(Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {\n\t\t\tconst value = this[prop];\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\tthis[prop] = value.bind(this);\n\t\t\t}\n\t\t}\n\t}\n\temitWarning(warning, type, code) {\n\t\tconsole.warn(`${code ? `[${code}] ` : \"\"}${type ? `${type}: ` : \"\"}${warning}`);\n\t}\n\temit(...args) {\n\t\treturn super.emit(...args);\n\t}\n\tlisteners(eventName) {\n\t\treturn super.listeners(eventName);\n\t}\n\t#stdin;\n\t#stdout;\n\t#stderr;\n\tget stdin() {\n\t\treturn this.#stdin ??= new ReadStream(0);\n\t}\n\tget stdout() {\n\t\treturn this.#stdout ??= new WriteStream(1);\n\t}\n\tget stderr() {\n\t\treturn this.#stderr ??= new WriteStream(2);\n\t}\n\t#cwd = \"/\";\n\tchdir(cwd) {\n\t\tthis.#cwd = cwd;\n\t}\n\tcwd() {\n\t\treturn this.#cwd;\n\t}\n\tarch = \"\";\n\tplatform = \"\";\n\targv = [];\n\targv0 = \"\";\n\texecArgv = [];\n\texecPath = \"\";\n\ttitle = \"\";\n\tpid = 200;\n\tppid = 100;\n\tget version() {\n\t\treturn `v${NODE_VERSION}`;\n\t}\n\tget versions() {\n\t\treturn { node: NODE_VERSION };\n\t}\n\tget allowedNodeEnvironmentFlags() {\n\t\treturn new Set();\n\t}\n\tget sourceMapsEnabled() {\n\t\treturn false;\n\t}\n\tget debugPort() {\n\t\treturn 0;\n\t}\n\tget throwDeprecation() {\n\t\treturn false;\n\t}\n\tget traceDeprecation() {\n\t\treturn false;\n\t}\n\tget features() {\n\t\treturn {};\n\t}\n\tget release() {\n\t\treturn {};\n\t}\n\tget connected() {\n\t\treturn false;\n\t}\n\tget config() {\n\t\treturn {};\n\t}\n\tget moduleLoadList() {\n\t\treturn [];\n\t}\n\tconstrainedMemory() {\n\t\treturn 0;\n\t}\n\tavailableMemory() {\n\t\treturn 0;\n\t}\n\tuptime() {\n\t\treturn 0;\n\t}\n\tresourceUsage() {\n\t\treturn {};\n\t}\n\tref() {}\n\tunref() {}\n\tumask() {\n\t\tthrow createNotImplementedError(\"process.umask\");\n\t}\n\tgetBuiltinModule() {\n\t\treturn undefined;\n\t}\n\tgetActiveResourcesInfo() {\n\t\tthrow createNotImplementedError(\"process.getActiveResourcesInfo\");\n\t}\n\texit() {\n\t\tthrow createNotImplementedError(\"process.exit\");\n\t}\n\treallyExit() {\n\t\tthrow createNotImplementedError(\"process.reallyExit\");\n\t}\n\tkill() {\n\t\tthrow createNotImplementedError(\"process.kill\");\n\t}\n\tabort() {\n\t\tthrow createNotImplementedError(\"process.abort\");\n\t}\n\tdlopen() {\n\t\tthrow createNotImplementedError(\"process.dlopen\");\n\t}\n\tsetSourceMapsEnabled() {\n\t\tthrow createNotImplementedError(\"process.setSourceMapsEnabled\");\n\t}\n\tloadEnvFile() {\n\t\tthrow createNotImplementedError(\"process.loadEnvFile\");\n\t}\n\tdisconnect() {\n\t\tthrow createNotImplementedError(\"process.disconnect\");\n\t}\n\tcpuUsage() {\n\t\tthrow createNotImplementedError(\"process.cpuUsage\");\n\t}\n\tsetUncaughtExceptionCaptureCallback() {\n\t\tthrow createNotImplementedError(\"process.setUncaughtExceptionCaptureCallback\");\n\t}\n\thasUncaughtExceptionCaptureCallback() {\n\t\tthrow createNotImplementedError(\"process.hasUncaughtExceptionCaptureCallback\");\n\t}\n\tinitgroups() {\n\t\tthrow createNotImplementedError(\"process.initgroups\");\n\t}\n\topenStdin() {\n\t\tthrow createNotImplementedError(\"process.openStdin\");\n\t}\n\tassert() {\n\t\tthrow createNotImplementedError(\"process.assert\");\n\t}\n\tbinding() {\n\t\tthrow createNotImplementedError(\"process.binding\");\n\t}\n\tpermission = { has: /* @__PURE__ */ notImplemented(\"process.permission.has\") };\n\treport = {\n\t\tdirectory: \"\",\n\t\tfilename: \"\",\n\t\tsignal: \"SIGUSR2\",\n\t\tcompact: false,\n\t\treportOnFatalError: false,\n\t\treportOnSignal: false,\n\t\treportOnUncaughtException: false,\n\t\tgetReport: /* @__PURE__ */ notImplemented(\"process.report.getReport\"),\n\t\twriteReport: /* @__PURE__ */ notImplemented(\"process.report.writeReport\")\n\t};\n\tfinalization = {\n\t\tregister: /* @__PURE__ */ notImplemented(\"process.finalization.register\"),\n\t\tunregister: /* @__PURE__ */ notImplemented(\"process.finalization.unregister\"),\n\t\tregisterBeforeExit: /* @__PURE__ */ notImplemented(\"process.finalization.registerBeforeExit\")\n\t};\n\tmemoryUsage = Object.assign(() => ({\n\t\tarrayBuffers: 0,\n\t\trss: 0,\n\t\texternal: 0,\n\t\theapTotal: 0,\n\t\theapUsed: 0\n\t}), { rss: () => 0 });\n\tmainModule = undefined;\n\tdomain = undefined;\n\tsend = undefined;\n\texitCode = undefined;\n\tchannel = undefined;\n\tgetegid = undefined;\n\tgeteuid = undefined;\n\tgetgid = undefined;\n\tgetgroups = undefined;\n\tgetuid = undefined;\n\tsetegid = undefined;\n\tseteuid = undefined;\n\tsetgid = undefined;\n\tsetgroups = undefined;\n\tsetuid = undefined;\n\t_events = undefined;\n\t_eventsCount = undefined;\n\t_exiting = undefined;\n\t_maxListeners = undefined;\n\t_debugEnd = undefined;\n\t_debugProcess = undefined;\n\t_fatalException = undefined;\n\t_getActiveHandles = undefined;\n\t_getActiveRequests = undefined;\n\t_kill = undefined;\n\t_preload_modules = undefined;\n\t_rawDebug = undefined;\n\t_startProfilerIdleNotifier = undefined;\n\t_stopProfilerIdleNotifier = undefined;\n\t_tickCallback = undefined;\n\t_disconnect = undefined;\n\t_handleQueue = undefined;\n\t_pendingMessage = undefined;\n\t_channel = undefined;\n\t_send = undefined;\n\t_linkedBinding = undefined;\n}\n", "import { hrtime as UnenvHrTime } from \"unenv/node/internal/process/hrtime\";\nimport { Process as UnenvProcess } from \"unenv/node/internal/process/process\";\nconst globalProcess = globalThis[\"process\"];\nexport const getBuiltinModule = globalProcess.getBuiltinModule;\nexport const { exit, platform, nextTick } = getBuiltinModule(\n  \"node:process\"\n);\nconst unenvProcess = new UnenvProcess({\n  env: globalProcess.env,\n  hrtime: UnenvHrTime,\n  nextTick\n});\nexport const {\n  abort,\n  addListener,\n  allowedNodeEnvironmentFlags,\n  hasUncaughtExceptionCaptureCallback,\n  setUncaughtExceptionCaptureCallback,\n  loadEnvFile,\n  sourceMapsEnabled,\n  arch,\n  argv,\n  argv0,\n  chdir,\n  config,\n  connected,\n  constrainedMemory,\n  availableMemory,\n  cpuUsage,\n  cwd,\n  debugPort,\n  dlopen,\n  disconnect,\n  emit,\n  emitWarning,\n  env,\n  eventNames,\n  execArgv,\n  execPath,\n  finalization,\n  features,\n  getActiveResourcesInfo,\n  getMaxListeners,\n  hrtime,\n  kill,\n  listeners,\n  listenerCount,\n  memoryUsage,\n  on,\n  off,\n  once,\n  pid,\n  ppid,\n  prependListener,\n  prependOnceListener,\n  rawListeners,\n  release,\n  removeAllListeners,\n  removeListener,\n  report,\n  resourceUsage,\n  setMaxListeners,\n  setSourceMapsEnabled,\n  stderr,\n  stdin,\n  stdout,\n  title,\n  throwDeprecation,\n  traceDeprecation,\n  umask,\n  uptime,\n  version,\n  versions,\n  domain,\n  initgroups,\n  moduleLoadList,\n  reallyExit,\n  openStdin,\n  assert,\n  binding,\n  send,\n  exitCode,\n  channel,\n  getegid,\n  geteuid,\n  getgid,\n  getgroups,\n  getuid,\n  setegid,\n  seteuid,\n  setgid,\n  setgroups,\n  setuid,\n  permission,\n  mainModule,\n  _events,\n  _eventsCount,\n  _exiting,\n  _maxListeners,\n  _debugEnd,\n  _debugProcess,\n  _fatalException,\n  _getActiveHandles,\n  _getActiveRequests,\n  _kill,\n  _preload_modules,\n  _rawDebug,\n  _startProfilerIdleNotifier,\n  _stopProfilerIdleNotifier,\n  _tickCallback,\n  _disconnect,\n  _handleQueue,\n  _pendingMessage,\n  _channel,\n  _send,\n  _linkedBinding\n} = unenvProcess;\nconst _process = {\n  abort,\n  addListener,\n  allowedNodeEnvironmentFlags,\n  hasUncaughtExceptionCaptureCallback,\n  setUncaughtExceptionCaptureCallback,\n  loadEnvFile,\n  sourceMapsEnabled,\n  arch,\n  argv,\n  argv0,\n  chdir,\n  config,\n  connected,\n  constrainedMemory,\n  availableMemory,\n  cpuUsage,\n  cwd,\n  debugPort,\n  dlopen,\n  disconnect,\n  emit,\n  emitWarning,\n  env,\n  eventNames,\n  execArgv,\n  execPath,\n  exit,\n  finalization,\n  features,\n  getBuiltinModule,\n  getActiveResourcesInfo,\n  getMaxListeners,\n  hrtime,\n  kill,\n  listeners,\n  listenerCount,\n  memoryUsage,\n  nextTick,\n  on,\n  off,\n  once,\n  pid,\n  platform,\n  ppid,\n  prependListener,\n  prependOnceListener,\n  rawListeners,\n  release,\n  removeAllListeners,\n  removeListener,\n  report,\n  resourceUsage,\n  setMaxListeners,\n  setSourceMapsEnabled,\n  stderr,\n  stdin,\n  stdout,\n  title,\n  throwDeprecation,\n  traceDeprecation,\n  umask,\n  uptime,\n  version,\n  versions,\n  // @ts-expect-error old API\n  domain,\n  initgroups,\n  moduleLoadList,\n  reallyExit,\n  openStdin,\n  assert,\n  binding,\n  send,\n  exitCode,\n  channel,\n  getegid,\n  geteuid,\n  getgid,\n  getgroups,\n  getuid,\n  setegid,\n  seteuid,\n  setgid,\n  setgroups,\n  setuid,\n  permission,\n  mainModule,\n  _events,\n  _eventsCount,\n  _exiting,\n  _maxListeners,\n  _debugEnd,\n  _debugProcess,\n  _fatalException,\n  _getActiveHandles,\n  _getActiveRequests,\n  _kill,\n  _preload_modules,\n  _rawDebug,\n  _startProfilerIdleNotifier,\n  _stopProfilerIdleNotifier,\n  _tickCallback,\n  _disconnect,\n  _handleQueue,\n  _pendingMessage,\n  _channel,\n  _send,\n  _linkedBinding\n};\nexport default _process;\n", "import { default as defaultExport } from \"@cloudflare/unenv-preset/node/process\";\nglobalThis.process = defaultExport;", "", "// `esbuild` doesn't support returning `watch*` options from `onStart()`\n// plugin callbacks. Instead, we define an empty virtual module that is\n// imported by this injected file. Importing the module registers watchers.\nimport \"wrangler:modules-watch\";\n", "'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n", "'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else if (tags.length === 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' has not been opened.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n", "\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n};\n   \nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;", "'use strict';\n\nclass XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n  };\n};\n\n\nmodule.exports = XmlNode;", "const util = require('../util');\n\n//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ validateEntityName(entityName) ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\nfunction validateEntityName(name){\n    if (util.isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n\nmodule.exports = readDocType;\n", "const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n// const octRegex = /^0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n \nconst consider = {\n    hex :  true,\n    // oct: false,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true,\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    \n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if(str===\"0\") return 0;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return parse_int(trimmedStr, 16);\n    // }else if (options.oct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    }else if (trimmedStr.search(/[eE]/)!== -1) { //eNotation\n        const notation = trimmedStr.match(/^([-\\+])?(0*)([0-9]*(\\.[0-9]*)?[eE][-\\+]?[0-9]+)$/); \n        // +00.123 => [ , '+', '00', '.123', ..\n        if(notation){\n            // console.log(notation)\n            if(options.leadingZeros){ //accept with leading zeros\n                trimmedStr = (notation[1] || \"\") + notation[3];\n            }else{\n                if(notation[2] === \"0\" && notation[3][0]=== \".\"){ //valid number\n                }else{\n                    return str;\n                }\n            }\n            return options.eNotation ? Number(trimmedStr) : str;\n        }else{\n            return str;\n        }\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        // +00.123 => [ , '+', '00', '.123', ..\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else if(options.leadingZeros && leadingZeros===str) return 0; //00\n            \n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    return (numTrimmedByZeros === numStr) || (sign+numTrimmedByZeros === numStr) ? num : str\n                }else  {\n                    return (trimmedStr === numStr) || (trimmedStr === sign+numStr) ? num : str\n                }\n            }\n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\n\nfunction parse_int(numStr, base){\n    //polyfill\n    if(parseInt) return parseInt(numStr, base);\n    else if(Number.parseInt) return Number.parseInt(numStr, base);\n    else if(window && window.parseInt) return window.parseInt(numStr, base);\n    else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\")\n}\n\nmodule.exports = toNumber;", "'use strict';\n///@ts-check\n\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"\u00A2\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"\u00A3\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"\u00A5\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"\u20AC\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"\u00A9\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"\u00AE\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"\u20B9\" },\n      \"num_dec\": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },\n      \"num_hex\": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath)\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n        if(val == undefined) val = \"\";\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            \n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath)\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath){\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  }else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode);\n  }else{\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n", "'use strict';\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\nexports.prettify = prettify;\n", "const { buildOptions} = require(\"./OptionsBuilder\");\nconst OrderedObjParser = require(\"./OrderedObjParser\");\nconst { prettify} = require(\"./node2json\");\nconst validator = require('../validator');\n\nclass XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData === \"string\"){\n        }else if( xmlData.toString){\n            xmlData = xmlData.toString();\n        }else{\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n}\n\nmodule.exports = XMLParser;", "const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n", "'use strict';\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = require('./orderedJs2Xml');\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attributesGroupName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataPropName: false,\n  format: false,\n  indentBy: '  ',\n  suppressEmptyNode: false,\n  suppressUnpairedNode: true,\n  suppressBooleanAttributes: true,\n  tagValueProcessor: function(key, a) {\n    return a;\n  },\n  attributeValueProcessor: function(attrName, a) {\n    return a;\n  },\n  preserveOrder: false,\n  commentPropName: false,\n  unpairedTags: [],\n  entities: [\n    { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },//it must be on top\n    { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n    { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n    { regex: new RegExp(\"\\'\", \"g\"), val: \"&apos;\" },\n    { regex: new RegExp(\"\\\"\", \"g\"), val: \"&quot;\" }\n  ],\n  processEntities: true,\n  stopNodes: [],\n  // transformTagName: false,\n  // transformAttributeName: false,\n  oneListGroup: false\n};\n\nfunction Builder(options) {\n  this.options = Object.assign({}, defaultOptions, options);\n  if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n}\n\nBuilder.prototype.build = function(jObj) {\n  if(this.options.preserveOrder){\n    return buildFromOrderedJs(jObj, this.options);\n  }else {\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\n      jObj = {\n        [this.options.arrayNodeName] : jObj\n      }\n    }\n    return this.j2x(jObj, 0).val;\n  }\n};\n\nBuilder.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node only if it is not an attribute\n      if (this.isAttribute(key)) {\n        val += '';\n      }\n    } else if (jObj[key] === null) {\n      // null attribute should be ignored by the attribute list, but should not cause the tag closing\n      if (this.isAttribute(key)) {\n        val += '';\n      } else if (key[0] === '?') {\n        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n      } else {\n        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n      }\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextValNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\n      }else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\n          val += this.replaceEntitiesValue(newval);\n        } else {\n          val += this.buildTextValNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      const arrLen = jObj[key].length;\n      let listTagVal = \"\";\n      let listTagAttr = \"\";\n      for (let j = 0; j < arrLen; j++) {\n        const item = jObj[key][j];\n        if (typeof item === 'undefined') {\n          // supress undefined node\n        } else if (item === null) {\n          if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (typeof item === 'object') {\n          if(this.options.oneListGroup){\n            const result = this.j2x(item, level + 1);\n            listTagVal += result.val;\n            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {\n              listTagAttr += result.attrStr\n            }\n          }else{\n            listTagVal += this.processTextOrObjNode(item, key, level)\n          }\n        } else {\n          if (this.options.oneListGroup) {\n            let textValue = this.options.tagValueProcessor(key, item);\n            textValue = this.replaceEntitiesValue(textValue);\n            listTagVal += textValue;\n          } else {\n            listTagVal += this.buildTextValNode(item, key, '', level);\n          }\n        }\n      }\n      if(this.options.oneListGroup){\n        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);\n      }\n      val += listTagVal;\n    } else {\n      //nested node\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nBuilder.prototype.buildAttrPairStr = function(attrName, val){\n  val = this.options.attributeValueProcessor(attrName, '' + val);\n  val = this.replaceEntitiesValue(val);\n  if (this.options.suppressBooleanAttributes && val === \"true\") {\n    return ' ' + attrName;\n  } else return ' ' + attrName + '=\"' + val + '\"';\n}\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n  } else {\n    return this.buildObjectNode(result.val, key, result.attrStr, level);\n  }\n}\n\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n  if(val === \"\"){\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }\n  }else{\n\n    let tagEndExp = '</' + key + this.tagEndChar;\n    let piClosingChar = \"\";\n    \n    if(key[0] === \"?\") {\n      piClosingChar = \"?\";\n      tagEndExp = \"\";\n    }\n  \n    // attrStr is an empty string in case the attribute came as undefined or null\n    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {\n      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n      return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    }else {\n      return (\n        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\n        val +\n        this.indentate(level) + tagEndExp    );\n    }\n  }\n}\n\nBuilder.prototype.closeTag = function(key){\n  let closeTag = \"\";\n  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\n    if(!this.options.suppressUnpairedNode) closeTag = \"/\"\n  }else if(this.options.suppressEmptyNode){ //empty\n    closeTag = \"/\";\n  }else{\n    closeTag = `></${key}`\n  }\n  return closeTag;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n      // return this.buildTagStr(level,key, attrStr);\n    }\n  }\n}\n\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\n  }else if(key[0] === \"?\") {//PI tag\n    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; \n  }else{\n    let textValue = this.options.tagValueProcessor(key, val);\n    textValue = this.replaceEntitiesValue(textValue);\n  \n    if( textValue === ''){\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }else{\n      return this.indentate(level) + '<' + key + attrStr + '>' +\n         textValue +\n        '</' + key + this.tagEndChar;\n    }\n  }\n}\n\nBuilder.prototype.replaceEntitiesValue = function(textValue){\n  if(textValue && textValue.length > 0 && this.options.processEntities){\n    for (let i=0; i<this.options.entities.length; i++) {\n      const entity = this.options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = Builder;\n", "'use strict';\n\nconst validator = require('./validator');\nconst XMLParser = require('./xmlparser/XMLParser');\nconst XMLBuilder = require('./xmlbuilder/json2xml');\n\nmodule.exports = {\n  XMLParser: XMLParser,\n  XMLValidator: validator,\n  XMLBuilder: XMLBuilder\n}", "!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.bowser=t():e.bowser=t()}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=90)}({17:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||\"\"},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||\"\"},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case\"NT\":return\"NT\";case\"XP\":return\"XP\";case\"NT 5.0\":return\"2000\";case\"NT 5.1\":return\"XP\";case\"NT 5.2\":return\"2003\";case\"NT 6.0\":return\"Vista\";case\"NT 6.1\":return\"7\";case\"NT 6.2\":return\"8\";case\"NT 6.3\":return\"8.1\";case\"NT 10.0\":return\"10\";default:return}},e.getMacOSVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return\"Leopard\";case 6:return\"Snow Leopard\";case 7:return\"Lion\";case 8:return\"Mountain Lion\";case 9:return\"Mavericks\";case 10:return\"Yosemite\";case 11:return\"El Capitan\";case 12:return\"Sierra\";case 13:return\"High Sierra\";case 14:return\"Mojave\";case 15:return\"Catalina\";default:return}},e.getAndroidVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?\"Cupcake\":1===t[0]&&t[1]>=6?\"Donut\":2===t[0]&&t[1]<2?\"Eclair\":2===t[0]&&2===t[1]?\"Froyo\":2===t[0]&&t[1]>2?\"Gingerbread\":3===t[0]?\"Honeycomb\":4===t[0]&&t[1]<1?\"Ice Cream Sandwich\":4===t[0]&&t[1]<4?\"Jelly Bean\":4===t[0]&&t[1]>=4?\"KitKat\":5===t[0]?\"Lollipop\":6===t[0]?\"Marshmallow\":7===t[0]?\"Nougat\":8===t[0]?\"Oreo\":9===t[0]?\"Pie\":void 0},e.getVersionPrecision=function(e){return e.split(\".\").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(\".0\");return e.map(n.split(\".\"),(function(e){return new Array(20-e.length).join(\"0\")+e})).reverse()}));for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1}else if(u[0][a]<u[1][a])return-1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];\"object\"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||\"\"},e}();t.default=i,e.exports=t.default},18:function(e,t,r){\"use strict\";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={\"Amazon Silk\":\"amazon_silk\",\"Android Browser\":\"android\",Bada:\"bada\",BlackBerry:\"blackberry\",Chrome:\"chrome\",Chromium:\"chromium\",Electron:\"electron\",Epiphany:\"epiphany\",Firefox:\"firefox\",Focus:\"focus\",Generic:\"generic\",\"Google Search\":\"google_search\",Googlebot:\"googlebot\",\"Internet Explorer\":\"ie\",\"K-Meleon\":\"k_meleon\",Maxthon:\"maxthon\",\"Microsoft Edge\":\"edge\",\"MZ Browser\":\"mz\",\"NAVER Whale Browser\":\"naver\",Opera:\"opera\",\"Opera Coast\":\"opera_coast\",PhantomJS:\"phantomjs\",Puffin:\"puffin\",QupZilla:\"qupzilla\",QQ:\"qq\",QQLite:\"qqlite\",Safari:\"safari\",Sailfish:\"sailfish\",\"Samsung Internet for Android\":\"samsung_internet\",SeaMonkey:\"seamonkey\",Sleipnir:\"sleipnir\",Swing:\"swing\",Tizen:\"tizen\",\"UC Browser\":\"uc\",Vivaldi:\"vivaldi\",\"WebOS Browser\":\"webos\",WeChat:\"wechat\",\"Yandex Browser\":\"yandex\",Roku:\"roku\"};t.BROWSER_MAP={amazon_silk:\"Amazon Silk\",android:\"Android Browser\",bada:\"Bada\",blackberry:\"BlackBerry\",chrome:\"Chrome\",chromium:\"Chromium\",electron:\"Electron\",epiphany:\"Epiphany\",firefox:\"Firefox\",focus:\"Focus\",generic:\"Generic\",googlebot:\"Googlebot\",google_search:\"Google Search\",ie:\"Internet Explorer\",k_meleon:\"K-Meleon\",maxthon:\"Maxthon\",edge:\"Microsoft Edge\",mz:\"MZ Browser\",naver:\"NAVER Whale Browser\",opera:\"Opera\",opera_coast:\"Opera Coast\",phantomjs:\"PhantomJS\",puffin:\"Puffin\",qupzilla:\"QupZilla\",qq:\"QQ Browser\",qqlite:\"QQ Browser Lite\",safari:\"Safari\",sailfish:\"Sailfish\",samsung_internet:\"Samsung Internet for Android\",seamonkey:\"SeaMonkey\",sleipnir:\"Sleipnir\",swing:\"Swing\",tizen:\"Tizen\",uc:\"UC Browser\",vivaldi:\"Vivaldi\",webos:\"WebOS Browser\",wechat:\"WeChat\",yandex:\"Yandex Browser\"};t.PLATFORMS_MAP={tablet:\"tablet\",mobile:\"mobile\",desktop:\"desktop\",tv:\"tv\"};t.OS_MAP={WindowsPhone:\"Windows Phone\",Windows:\"Windows\",MacOS:\"macOS\",iOS:\"iOS\",Android:\"Android\",WebOS:\"WebOS\",BlackBerry:\"BlackBerry\",Bada:\"Bada\",Tizen:\"Tizen\",Linux:\"Linux\",ChromeOS:\"Chrome OS\",PlayStation4:\"PlayStation 4\",Roku:\"Roku\"};t.ENGINE_MAP={EdgeHTML:\"EdgeHTML\",Blink:\"Blink\",Trident:\"Trident\",Presto:\"Presto\",Gecko:\"Gecko\",WebKit:\"WebKit\"}},90:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),\"string\"!=typeof e)throw new Error(\"UserAgent should be a string\");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:\"BROWSER_MAP\",get:function(){return s.BROWSER_MAP}},{key:\"ENGINE_MAP\",get:function(){return s.ENGINE_MAP}},{key:\"OS_MAP\",get:function(){return s.OS_MAP}},{key:\"PLATFORMS_MAP\",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default},91:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||\"\"===e)throw new Error(\"UserAgent parameter can't be empty\");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||\"\":this.getBrowser().name||\"\"},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||\"\":t||\"\"},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||\"\":t||\"\"},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||\"\":this.getEngine().name||\"\"},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];\"string\"==typeof a?(i[t]=a,s+=1):\"object\"==typeof a&&(r[t]=a,n+=1)})),n>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if(\"string\"==typeof i)return\">\"===e[0]||\"<\"===e[0]?(r=e.substr(1),\"=\"===e[1]?(n=!0,r=e.substr(2)):t=[],\">\"===e[0]?t.push(1):t.push(-1)):\"=\"===e[0]?r=e.substr(1):\"~\"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\\/(\\d+(\\.?_?\\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:\"Googlebot\"},r=i.default.getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\\/|opios/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(/(?:opr|opios)[\\s/](\\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:\"Samsung Internet for Android\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:\"NAVER Whale Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\\s/](\\d+(?:\\.\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:\"MZ Browser\"},r=i.default.getFirstMatch(/(?:MZBrowser)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:\"Focus\"},r=i.default.getFirstMatch(/(?:focus)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:\"Swing\"},r=i.default.getFirstMatch(/(?:swing)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:\"Opera Coast\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\\/\\d+(?:.?_?\\d+)+/i],describe:function(e){var t={name:\"Opera Touch\"},r=i.default.getFirstMatch(/(?:opt)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:\"Yandex Browser\"},r=i.default.getFirstMatch(/(?:yabrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:\"UC Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:\"Maxthon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:\"Epiphany\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:\"Puffin\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:\"Sleipnir\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:\"K-Meleon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:\"WeChat\"},r=i.default.getFirstMatch(/(?:micromessenger)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?\"QQ Browser Lite\":\"QQ Browser\"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:\"Internet Explorer\"},r=i.default.getFirstMatch(/(?:msie |rv:)(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\\sedg\\//i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getFirstMatch(/\\sedg\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:\"Vivaldi\"},r=i.default.getFirstMatch(/vivaldi\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:\"SeaMonkey\"},r=i.default.getFirstMatch(/seamonkey\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:\"Sailfish\"},r=i.default.getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:\"Amazon Silk\"},r=i.default.getFirstMatch(/silk\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:\"PhantomJS\"},r=i.default.getFirstMatch(/phantomjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:\"SlimerJS\"},r=i.default.getFirstMatch(/slimerjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t={name:\"BlackBerry\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:\"WebOS Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:\"Bada\"},r=i.default.getFirstMatch(/dolfin\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:\"Tizen\"},r=i.default.getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:\"QupZilla\"},r=i.default.getFirstMatch(/(?:qupzilla)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:\"Firefox\"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:\"Electron\"},r=i.default.getFirstMatch(/(?:electron)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:\"Miui\"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:\"Chromium\"},r=i.default.getFirstMatch(/(?:chromium)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:\"Chrome\"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:\"Google Search\"},r=i.default.getFirstMatch(/(?:GSA)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:\"Android Browser\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:\"PlayStation 4\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:\"Safari\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search(\"\\\\(\")?/^(.*)\\/(.*)[ \\t]\\((.*)/:/^(.*)\\/(.*) /;return{name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default},93:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\\/DVP-(\\d+\\.\\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i,e),r=i.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\\/)(\\d[\\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\\d+(\\.?_?\\d+)+)/i,e).replace(/[_\\s]/g,\".\"),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i,e).replace(/[_\\s]/g,\".\");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\\s/-](\\d+(\\.\\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\\/(\\d+(\\.\\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\\d+\\/(\\d+([_\\s]\\d+)*)/i,e)||i.default.getFirstMatch(/\\bbb(\\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default},94:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return{type:\"bot\",vendor:\"Google\"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&\"Nova\",r={type:s.PLATFORMS_MAP.mobile,vendor:\"Huawei\"};return t&&(r.model=t),r}},{test:[/nexus\\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Nexus\"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\",model:\"Kindle Fire HD 7\"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:\"Apple\",model:t}}},{test:[/nexus\\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Nexus\"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"blackberry\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"BlackBerry\"}}},{test:function(e){return\"bada\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"windows phone\"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Microsoft\"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(\".\")[0]);return\"android\"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return\"android\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"macos\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:\"Apple\"}}},{test:function(e){return\"windows\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"linux\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"playstation 4\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return\"roku\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default},95:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return\"microsoft edge\"===e.getBrowserName(!0)},describe:function(e){if(/\\sedg\\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\\/(\\d+(\\.?_?\\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\\/537\\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default}})}));", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"D:\\\\Code\\\\EC2-network-monitor\\\\.wrangler\\\\tmp\\\\bundle-Ll1JrC\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"D:\\\\Code\\\\EC2-network-monitor\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"D:\\\\Code\\\\EC2-network-monitor\\\\.wrangler\\\\tmp\\\\bundle-Ll1JrC\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"D:\\\\Code\\\\EC2-network-monitor\\\\.wrangler\\\\tmp\\\\bundle-Ll1JrC\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"D:\\\\Code\\\\EC2-network-monitor\\\\src\\\\index.js\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"D:\\\\Code\\\\EC2-network-monitor\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"D:\\\\Code\\\\EC2-network-monitor\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"D:\\\\Code\\\\EC2-network-monitor\\\\src\\\\index.js\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "import { EC2Client, DescribeInstancesCommand } from '@aws-sdk/client-ec2';\r\nimport { CloudWatchClient, GetMetricStatisticsCommand } from '@aws-sdk/client-cloudwatch';\r\nimport * as Sentry from \"@sentry/cloudflare\";\r\n\r\n\r\n\r\nfunction formatBytes(bytes) {\r\n  const units = ['B', 'KB', 'MB', 'GB', 'TB'];\r\n  let value = bytes;\r\n  let unitIndex = 0;\r\n  \r\n  while (value >= 1024 && unitIndex < units.length - 1) {\r\n    value /= 1024;\r\n    unitIndex++;\r\n  }\r\n  \r\n  return `${value.toFixed(2)} ${units[unitIndex]}`;\r\n}\r\n\r\nfunction buildTableData(data) {\r\n  // \u6309\u65E5\u671F\u5206\u7EC4\r\n  const dailyStats = {};\r\n  let totalIn = 0, totalOut = 0;\r\n  data.forEach(metric => {\r\n    const date = new Date(metric.Timestamp).toISOString().split('T')[0];\r\n    if (!dailyStats[date]) dailyStats[date] = { in: 0, out: 0, count: 0 };\r\n    dailyStats[date].in += metric.Average;\r\n    dailyStats[date].out += metric.OutAverage || 0;\r\n    dailyStats[date].count++;\r\n  });\r\n  const rows = [];\r\n  Object.entries(dailyStats).sort().forEach(([date, stats]) => {\r\n    const avgIn = stats.in / stats.count;\r\n    const avgOut = stats.out / stats.count;\r\n    totalIn += avgIn;\r\n    totalOut += avgOut;\r\n    rows.push([date, formatBytes(avgIn), formatBytes(avgOut)]);\r\n  });\r\n  rows.push(['\u603B\u8BA1', formatBytes(totalIn), formatBytes(totalOut)]);\r\n  return rows;\r\n}\r\n\r\nfunction buildPlainTable(rows) {\r\n  // \u8BA1\u7B97\u6BCF\u5217\u6700\u5927\u5BBD\u5EA6\r\n  const colWidths = [0, 0, 0];\r\n  const header = ['\u65E5\u671F', '\u8F93\u5165\u6D41\u91CF', '\u8F93\u51FA\u6D41\u91CF'];\r\n  [header, ...rows].forEach(row => {\r\n    row.forEach((cell, i) => {\r\n      colWidths[i] = Math.max(colWidths[i], cell.length);\r\n    });\r\n  });\r\n  // \u751F\u6210\u8868\u683C\u6587\u672C\r\n  const lines = [];\r\n  const headerLine = header.map((h, i) => h.padEnd(colWidths[i], ' ')).join('  ');\r\n  lines.push(headerLine);\r\n  lines.push('-'.repeat(headerLine.length));\r\n  rows.slice(0, -1).forEach(row => {\r\n    lines.push(row.map((cell, i) => cell.padEnd(colWidths[i], ' ')).join('  '));\r\n  });\r\n  // \u603B\u8BA1\u884C\r\n  lines.push('-'.repeat(headerLine.length));\r\n  const totalRow = rows[rows.length - 1].map((cell, i) => cell.padEnd(colWidths[i], ' ')).join('  ');\r\n  lines.push(totalRow);\r\n  return lines.join('\\n');\r\n}\r\n\r\nfunction buildMarkdownTable(rows) {\r\n  let md = '| \u65E5\u671F | \u8F93\u5165\u6D41\u91CF | \u8F93\u51FA\u6D41\u91CF |\\n|------|----------|----------|\\n';\r\n  rows.slice(0, -1).forEach(row => {\r\n    md += `| ${row[0]} | ${row[1]} | ${row[2]} |\\n`;\r\n  });\r\n  const total = rows[rows.length - 1];\r\n  md += `| **${total[0]}** | **${total[1]}** | **${total[2]}** |\\n`;\r\n  return md;\r\n}\r\n\r\nasync function sendGotifyMessage(url, token, message) {\r\n  const gotifyUrl = `${url}?token=${token}`;\r\n  const body = JSON.stringify({\r\n    title: \"EC2\u6D41\u91CF\u65E5\u62A5\",\r\n    message: message,\r\n    priority: 5\r\n  });\r\n  return await fetch(gotifyUrl, {\r\n    method: \"POST\",\r\n    headers: { \"Content-Type\": \"application/json\" },\r\n    body\r\n  });\r\n}\r\n\r\nasync function sendTelegramMessage(botToken, chatId, message) {\r\n\r\n  const url = `https://api.telegram.org/bot${botToken}/sendMessage`;\r\n  const body = JSON.stringify({\r\n    chat_id: chatId,\r\n    text: '```\\n' + message + '\\n```',\r\n    parse_mode: 'Markdown'\r\n  });\r\n  console.log('Telegram\u63A8\u9001\u8BF7\u6C42URL:', url);\r\n  console.log('Telegram\u63A8\u9001\u8BF7\u6C42Body:', body);\r\n  try {\r\n    const resp = await fetch(url, {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      body\r\n    });\r\n    console.log('Telegram\u63A8\u9001\u54CD\u5E94\u72B6\u6001:', resp.status);\r\n    const respText = await resp.text();\r\n    console.log('Telegram\u63A8\u9001\u54CD\u5E94\u5185\u5BB9:', respText);\r\n    return resp;\r\n  } catch (err) {\r\n    console.log('Telegram\u63A8\u9001\u5F02\u5E38:', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\nexport default {\r\n  async fetch(request, env, ctx) {\r\n  Sentry.init({ dsn: \"https://4aa85c04c06643ffb0f0ea089376234c@gp.liuq.ip-ddns.com/5\" });\r\n\r\n    // \u53EA\u5728\u4E3B\u9875\u9762\u8BF7\u6C42\u65F6\u63A8\u9001\uFF0C\u5FFD\u7565/favicon.ico\u7B49\r\n    const urlObj = new URL(request.url);\r\n    const isMainPage = urlObj.pathname === '/';\r\n\r\n    // \u914D\u7F6E AWS \u5BA2\u6237\u7AEF\r\n    const ec2Client = new EC2Client({\r\n      region: env.AWS_REGION,\r\n      credentials: {\r\n        accessKeyId: env.AWS_ACCESS_KEY_ID,\r\n        secretAccessKey: env.AWS_SECRET_ACCESS_KEY\r\n      }\r\n    });\r\n\r\n    const cloudWatchClient = new CloudWatchClient({\r\n      region: env.AWS_REGION,\r\n      credentials: {\r\n        accessKeyId: env.AWS_ACCESS_KEY_ID,\r\n        secretAccessKey: env.AWS_SECRET_ACCESS_KEY\r\n      }\r\n    });\r\n\r\n    try {\r\n      // \u83B7\u53D6 EC2 \u5B9E\u4F8B\u4FE1\u606F\r\n      const ec2Command = new DescribeInstancesCommand({\r\n        InstanceIds: [env.EC2_INSTANCE_ID]\r\n      });\r\n      await ec2Client.send(ec2Command);\r\n\r\n      // \u83B7\u53D6\u672C\u6708\u7684\u5F00\u59CB\u548C\u7ED3\u675F\u65F6\u95F4\r\n      const now = new Date();\r\n      const nowDateStr = now.toISOString().split('T')[0];\r\n      const startTime = new Date(now.getFullYear(), now.getMonth(), 1);\r\n      const endTime = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);\r\n\r\n      // \u83B7\u53D6\u5165\u7AD9\u6D41\u91CF\r\n      const networkInCommand = new GetMetricStatisticsCommand({\r\n        Namespace: 'AWS/EC2',\r\n        MetricName: 'NetworkIn',\r\n        Dimensions: [\r\n          {\r\n            Name: 'InstanceId',\r\n            Value: env.EC2_INSTANCE_ID\r\n          }\r\n        ],\r\n        StartTime: startTime,\r\n        EndTime: endTime,\r\n        Period: 86400, // \u6309\u5929\u7EDF\u8BA1\r\n        Statistics: ['Average']\r\n      });\r\n\r\n      // \u83B7\u53D6\u51FA\u7AD9\u6D41\u91CF\r\n      const networkOutCommand = new GetMetricStatisticsCommand({\r\n        Namespace: 'AWS/EC2',\r\n        MetricName: 'NetworkOut',\r\n        Dimensions: [\r\n          {\r\n            Name: 'InstanceId',\r\n            Value: env.EC2_INSTANCE_ID\r\n          }\r\n        ],\r\n        StartTime: startTime,\r\n        EndTime: endTime,\r\n        Period: 86400, // \u6309\u5929\u7EDF\u8BA1\r\n        Statistics: ['Average']\r\n      });\r\n\r\n      const [networkInResponse, networkOutResponse] = await Promise.all([\r\n        cloudWatchClient.send(networkInCommand),\r\n        cloudWatchClient.send(networkOutCommand)\r\n      ]);\r\n\r\n      // \u5408\u5E76\u5165\u7AD9\u548C\u51FA\u7AD9\u6570\u636E\r\n      const combinedMetrics = networkInResponse.Datapoints.map((inMetric, index) => ({\r\n        ...inMetric,\r\n        OutAverage: networkOutResponse.Datapoints[index]?.Average || 0\r\n      }));\r\n\r\n      // \u6784\u5EFA\u8868\u683C\u6570\u636E\r\n      const rows = buildTableData(combinedMetrics);\r\n\r\n      const plainTable = buildPlainTable(rows);\r\n      const title = `${nowDateStr} EC2\u6D41\u91CF\u4F7F\u7528\u7EDF\u8BA1`;\r\n      const pushContent = `${title}\\n\\n${plainTable}`;\r\n\r\n      // \u63A8\u9001\u6E20\u9053\u63A7\u5236\r\n      const channel = env.PUSH_CHANNEL || '1';\r\n      if (isMainPage) {\r\n        if (channel === '1' || channel === '0') {\r\n          if (env.GOTIFY_URL && env.GOTIFY_TOKEN) {\r\n            console.log('\u51C6\u5907\u63A8\u9001Gotify...');\r\n            try {\r\n              const gotifyResp = await sendGotifyMessage(env.GOTIFY_URL, env.GOTIFY_TOKEN, pushContent);\r\n              console.log('Gotify\u63A8\u9001\u54CD\u5E94\u72B6\u6001:', gotifyResp.status);\r\n              const gotifyText = await gotifyResp.text();\r\n              console.log('Gotify\u63A8\u9001\u54CD\u5E94\u5185\u5BB9:', gotifyText);\r\n            } catch (pushErr) {\r\n              console.log('Gotify\u63A8\u9001\u5F02\u5E38:', pushErr);\r\n            }\r\n          } else {\r\n            console.log('\u672A\u914D\u7F6EGOTIFY_URL\u6216GOTIFY_TOKEN\uFF0C\u4E0D\u63A8\u9001Gotify');\r\n          }\r\n        }\r\n        if (channel === '2' || channel === '0') {\r\n          if (env.TG_BOT_TOKEN && env.TG_CHAT_ID) {\r\n            console.log('\u51C6\u5907\u63A8\u9001Telegram...');\r\n            try {\r\n              await sendTelegramMessage(env.TG_BOT_TOKEN, env.TG_CHAT_ID, pushContent);\r\n            } catch (tgErr) {\r\n              console.log('Telegram\u63A8\u9001\u5F02\u5E38:', tgErr);\r\n            }\r\n          } else {\r\n            console.log('\u672A\u914D\u7F6ETG_BOT_TOKEN\u6216TG_CHAT_ID\uFF0C\u4E0D\u63A8\u9001Telegram');\r\n          }\r\n        }\r\n      } else {\r\n        console.log('\u975E\u4E3B\u9875\u9762\u8BF7\u6C42\uFF0C\u4E0D\u63A8\u9001\u6D88\u606F\uFF0Cpath:', urlObj.pathname);\r\n      }\r\n\r\n      // \u9875\u9762\u8FD4\u56DEMarkdown\u8868\u683C\r\n      const markdownTable = buildMarkdownTable(rows);\r\n      return new Response(markdownTable, {\r\n        headers: {\r\n          'Content-Type': 'text/plain; charset=utf-8',\r\n          'Access-Control-Allow-Origin': '*'\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.log('\u4E3B\u6D41\u7A0B\u5F02\u5E38:', error);\r\n      return new Response(`\u9519\u8BEF: ${error.message}`, {\r\n        status: 500,\r\n        headers: {\r\n          'Content-Type': 'text/plain; charset=utf-8',\r\n          'Access-Control-Allow-Origin': '*'\r\n        }\r\n      });\r\n    }\r\n  }\r\n}; ", "import { getHostHeaderPlugin, resolveHostHeaderConfig, } from \"@aws-sdk/middleware-host-header\";\nimport { getLoggerPlugin } from \"@aws-sdk/middleware-logger\";\nimport { getRecursionDetectionPlugin } from \"@aws-sdk/middleware-recursion-detection\";\nimport { getUserAgentPlugin, resolveUserAgentConfig, } from \"@aws-sdk/middleware-user-agent\";\nimport { resolveRegionConfig } from \"@smithy/config-resolver\";\nimport { DefaultIdentityProviderConfig, getHttpAuthSchemeEndpointRuleSetPlugin, getHttpSigningPlugin, } from \"@smithy/core\";\nimport { getContentLengthPlugin } from \"@smithy/middleware-content-length\";\nimport { resolveEndpointConfig } from \"@smithy/middleware-endpoint\";\nimport { getRetryPlugin, resolveRetryConfig } from \"@smithy/middleware-retry\";\nimport { Client as __Client, } from \"@smithy/smithy-client\";\nimport { defaultEC2HttpAuthSchemeParametersProvider, resolveHttpAuthSchemeConfig, } from \"./auth/httpAuthSchemeProvider\";\nimport { resolveClientEndpointParameters, } from \"./endpoint/EndpointParameters\";\nimport { getRuntimeConfig as __getRuntimeConfig } from \"./runtimeConfig\";\nimport { resolveRuntimeExtensions } from \"./runtimeExtensions\";\nexport { __Client };\nexport class EC2Client extends __Client {\n    config;\n    constructor(...[configuration]) {\n        const _config_0 = __getRuntimeConfig(configuration || {});\n        super(_config_0);\n        this.initConfig = _config_0;\n        const _config_1 = resolveClientEndpointParameters(_config_0);\n        const _config_2 = resolveUserAgentConfig(_config_1);\n        const _config_3 = resolveRetryConfig(_config_2);\n        const _config_4 = resolveRegionConfig(_config_3);\n        const _config_5 = resolveHostHeaderConfig(_config_4);\n        const _config_6 = resolveEndpointConfig(_config_5);\n        const _config_7 = resolveHttpAuthSchemeConfig(_config_6);\n        const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);\n        this.config = _config_8;\n        this.middlewareStack.use(getUserAgentPlugin(this.config));\n        this.middlewareStack.use(getRetryPlugin(this.config));\n        this.middlewareStack.use(getContentLengthPlugin(this.config));\n        this.middlewareStack.use(getHostHeaderPlugin(this.config));\n        this.middlewareStack.use(getLoggerPlugin(this.config));\n        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));\n        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {\n            httpAuthSchemeParametersProvider: defaultEC2HttpAuthSchemeParametersProvider,\n            identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({\n                \"aws.auth#sigv4\": config.credentials,\n            }),\n        }));\n        this.middlewareStack.use(getHttpSigningPlugin(this.config));\n    }\n    destroy() {\n        super.destroy();\n    }\n}\n", "import { HttpRequest } from \"@smithy/protocol-http\";\nexport function resolveHostHeaderConfig(input) {\n    return input;\n}\nexport const hostHeaderMiddleware = (options) => (next) => async (args) => {\n    if (!HttpRequest.isInstance(args.request))\n        return next(args);\n    const { request } = args;\n    const { handlerProtocol = \"\" } = options.requestHandler.metadata || {};\n    if (handlerProtocol.indexOf(\"h2\") >= 0 && !request.headers[\":authority\"]) {\n        delete request.headers[\"host\"];\n        request.headers[\":authority\"] = request.hostname + (request.port ? \":\" + request.port : \"\");\n    }\n    else if (!request.headers[\"host\"]) {\n        let host = request.hostname;\n        if (request.port != null)\n            host += `:${request.port}`;\n        request.headers[\"host\"] = host;\n    }\n    return next(args);\n};\nexport const hostHeaderMiddlewareOptions = {\n    name: \"hostHeaderMiddleware\",\n    step: \"build\",\n    priority: \"low\",\n    tags: [\"HOST\"],\n    override: true,\n};\nexport const getHostHeaderPlugin = (options) => ({\n    applyToStack: (clientStack) => {\n        clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);\n    },\n});\n", "export * from \"./extensions\";\nexport * from \"./Field\";\nexport * from \"./Fields\";\nexport * from \"./httpHandler\";\nexport * from \"./httpRequest\";\nexport * from \"./httpResponse\";\nexport * from \"./isValidHostname\";\nexport * from \"./types\";\n", "export * from \"./httpExtensionConfiguration\";\n", "export const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {\n    return {\n        setHttpHandler(handler) {\n            runtimeConfig.httpHandler = handler;\n        },\n        httpHandler() {\n            return runtimeConfig.httpHandler;\n        },\n        updateHttpClientConfig(key, value) {\n            runtimeConfig.httpHandler?.updateHttpClientConfig(key, value);\n        },\n        httpHandlerConfigs() {\n            return runtimeConfig.httpHandler.httpHandlerConfigs();\n        },\n    };\n};\nexport const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {\n    return {\n        httpHandler: httpHandlerExtensionConfiguration.httpHandler(),\n    };\n};\n", "import { FieldPosition } from \"@smithy/types\";\nexport class Field {\n    constructor({ name, kind = FieldPosition.HEADER, values = [] }) {\n        this.name = name;\n        this.kind = kind;\n        this.values = values;\n    }\n    add(value) {\n        this.values.push(value);\n    }\n    set(values) {\n        this.values = values;\n    }\n    remove(value) {\n        this.values = this.values.filter((v) => v !== value);\n    }\n    toString() {\n        return this.values.map((v) => (v.includes(\",\") || v.includes(\" \") ? `\"${v}\"` : v)).join(\", \");\n    }\n    get() {\n        return this.values;\n    }\n}\n", "export * from \"./abort\";\nexport * from \"./auth\";\nexport * from \"./blob/blob-payload-input-types\";\nexport * from \"./checksum\";\nexport * from \"./client\";\nexport * from \"./command\";\nexport * from \"./connection\";\nexport * from \"./crypto\";\nexport * from \"./encode\";\nexport * from \"./endpoint\";\nexport * from \"./endpoints\";\nexport * from \"./eventStream\";\nexport * from \"./extensions\";\nexport * from \"./feature-ids\";\nexport * from \"./http\";\nexport * from \"./http/httpHandlerInitialization\";\nexport * from \"./identity\";\nexport * from \"./logger\";\nexport * from \"./middleware\";\nexport * from \"./pagination\";\nexport * from \"./profile\";\nexport * from \"./response\";\nexport * from \"./retry\";\nexport * from \"./schema/schema\";\nexport * from \"./schema/sentinels\";\nexport * from \"./serde\";\nexport * from \"./shapes\";\nexport * from \"./signature\";\nexport * from \"./stream\";\nexport * from \"./streaming-payload/streaming-blob-common-types\";\nexport * from \"./streaming-payload/streaming-blob-payload-input-types\";\nexport * from \"./streaming-payload/streaming-blob-payload-output-types\";\nexport * from \"./transfer\";\nexport * from \"./transform/client-payload-blob-type-narrow\";\nexport * from \"./transform/mutable\";\nexport * from \"./transform/no-undefined\";\nexport * from \"./transform/type-transform\";\nexport * from \"./uri\";\nexport * from \"./util\";\nexport * from \"./waiter\";\n", "export {};\n", "export * from \"./auth\";\nexport * from \"./HttpApiKeyAuth\";\nexport * from \"./HttpAuthScheme\";\nexport * from \"./HttpAuthSchemeProvider\";\nexport * from \"./HttpSigner\";\nexport * from \"./IdentityProviderConfig\";\n", "export var HttpAuthLocation;\n(function (HttpAuthLocation) {\n    HttpAuthLocation[\"HEADER\"] = \"header\";\n    HttpAuthLocation[\"QUERY\"] = \"query\";\n})(HttpAuthLocation || (HttpAuthLocation = {}));\n", "export var HttpApiKeyAuthLocation;\n(function (HttpApiKeyAuthLocation) {\n    HttpApiKeyAuthLocation[\"HEADER\"] = \"header\";\n    HttpApiKeyAuthLocation[\"QUERY\"] = \"query\";\n})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export * from \"./config\";\nexport * from \"./manager\";\nexport * from \"./pool\";\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export var EndpointURLScheme;\n(function (EndpointURLScheme) {\n    EndpointURLScheme[\"HTTP\"] = \"http\";\n    EndpointURLScheme[\"HTTPS\"] = \"https\";\n})(EndpointURLScheme || (EndpointURLScheme = {}));\n", "export * from \"./EndpointRuleObject\";\nexport * from \"./ErrorRuleObject\";\nexport * from \"./RuleSetObject\";\nexport * from \"./shared\";\nexport * from \"./TreeRuleObject\";\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export * from \"./defaultClientConfiguration\";\nexport * from \"./defaultExtensionConfiguration\";\nexport { AlgorithmId } from \"./checksum\";\n", "import { getChecksumConfiguration, resolveChecksumRuntimeConfig } from \"./checksum\";\nexport const getDefaultClientConfiguration = (runtimeConfig) => {\n    return getChecksumConfiguration(runtimeConfig);\n};\nexport const resolveDefaultRuntimeConfig = (config) => {\n    return resolveChecksumRuntimeConfig(config);\n};\n", "export var AlgorithmId;\n(function (AlgorithmId) {\n    AlgorithmId[\"MD5\"] = \"md5\";\n    AlgorithmId[\"CRC32\"] = \"crc32\";\n    AlgorithmId[\"CRC32C\"] = \"crc32c\";\n    AlgorithmId[\"SHA1\"] = \"sha1\";\n    AlgorithmId[\"SHA256\"] = \"sha256\";\n})(AlgorithmId || (AlgorithmId = {}));\nexport const getChecksumConfiguration = (runtimeConfig) => {\n    const checksumAlgorithms = [];\n    if (runtimeConfig.sha256 !== undefined) {\n        checksumAlgorithms.push({\n            algorithmId: () => AlgorithmId.SHA256,\n            checksumConstructor: () => runtimeConfig.sha256,\n        });\n    }\n    if (runtimeConfig.md5 != undefined) {\n        checksumAlgorithms.push({\n            algorithmId: () => AlgorithmId.MD5,\n            checksumConstructor: () => runtimeConfig.md5,\n        });\n    }\n    return {\n        addChecksumAlgorithm(algo) {\n            checksumAlgorithms.push(algo);\n        },\n        checksumAlgorithms() {\n            return checksumAlgorithms;\n        },\n    };\n};\nexport const resolveChecksumRuntimeConfig = (clientConfig) => {\n    const runtimeConfig = {};\n    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {\n        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();\n    });\n    return runtimeConfig;\n};\n", "export {};\n", "export {};\n", "export var FieldPosition;\n(function (FieldPosition) {\n    FieldPosition[FieldPosition[\"HEADER\"] = 0] = \"HEADER\";\n    FieldPosition[FieldPosition[\"TRAILER\"] = 1] = \"TRAILER\";\n})(FieldPosition || (FieldPosition = {}));\n", "export {};\n", "export * from \"./apiKeyIdentity\";\nexport * from \"./awsCredentialIdentity\";\nexport * from \"./identity\";\nexport * from \"./tokenIdentity\";\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export const SMITHY_CONTEXT_KEY = \"__smithy_context\";\n", "export {};\n", "export var IniSectionType;\n(function (IniSectionType) {\n    IniSectionType[\"PROFILE\"] = \"profile\";\n    IniSectionType[\"SSO_SESSION\"] = \"sso-session\";\n    IniSectionType[\"SERVICES\"] = \"services\";\n})(IniSectionType || (IniSectionType = {}));\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export var RequestHandlerProtocol;\n(function (RequestHandlerProtocol) {\n    RequestHandlerProtocol[\"HTTP_0_9\"] = \"http/0.9\";\n    RequestHandlerProtocol[\"HTTP_1_0\"] = \"http/1.0\";\n    RequestHandlerProtocol[\"TDS_8_0\"] = \"tds/8.0\";\n})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export class Fields {\n    constructor({ fields = [], encoding = \"utf-8\" }) {\n        this.entries = {};\n        fields.forEach(this.setField.bind(this));\n        this.encoding = encoding;\n    }\n    setField(field) {\n        this.entries[field.name.toLowerCase()] = field;\n    }\n    getField(name) {\n        return this.entries[name.toLowerCase()];\n    }\n    removeField(name) {\n        delete this.entries[name.toLowerCase()];\n    }\n    getByType(kind) {\n        return Object.values(this.entries).filter((field) => field.kind === kind);\n    }\n}\n", "export {};\n", "export class HttpRequest {\n    constructor(options) {\n        this.method = options.method || \"GET\";\n        this.hostname = options.hostname || \"localhost\";\n        this.port = options.port;\n        this.query = options.query || {};\n        this.headers = options.headers || {};\n        this.body = options.body;\n        this.protocol = options.protocol\n            ? options.protocol.slice(-1) !== \":\"\n                ? `${options.protocol}:`\n                : options.protocol\n            : \"https:\";\n        this.path = options.path ? (options.path.charAt(0) !== \"/\" ? `/${options.path}` : options.path) : \"/\";\n        this.username = options.username;\n        this.password = options.password;\n        this.fragment = options.fragment;\n    }\n    static clone(request) {\n        const cloned = new HttpRequest({\n            ...request,\n            headers: { ...request.headers },\n        });\n        if (cloned.query) {\n            cloned.query = cloneQuery(cloned.query);\n        }\n        return cloned;\n    }\n    static isInstance(request) {\n        if (!request) {\n            return false;\n        }\n        const req = request;\n        return (\"method\" in req &&\n            \"protocol\" in req &&\n            \"hostname\" in req &&\n            \"path\" in req &&\n            typeof req[\"query\"] === \"object\" &&\n            typeof req[\"headers\"] === \"object\");\n    }\n    clone() {\n        return HttpRequest.clone(this);\n    }\n}\nfunction cloneQuery(query) {\n    return Object.keys(query).reduce((carry, paramName) => {\n        const param = query[paramName];\n        return {\n            ...carry,\n            [paramName]: Array.isArray(param) ? [...param] : param,\n        };\n    }, {});\n}\n", "export class HttpResponse {\n    constructor(options) {\n        this.statusCode = options.statusCode;\n        this.reason = options.reason;\n        this.headers = options.headers || {};\n        this.body = options.body;\n    }\n    static isInstance(response) {\n        if (!response)\n            return false;\n        const resp = response;\n        return typeof resp.statusCode === \"number\" && typeof resp.headers === \"object\";\n    }\n}\n", "export function isValidHostname(hostname) {\n    const hostPattern = /^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$/;\n    return hostPattern.test(hostname);\n}\n", "export {};\n", "export * from \"./loggerMiddleware\";\n", "export const loggerMiddleware = () => (next, context) => async (args) => {\n    try {\n        const response = await next(args);\n        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;\n        const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;\n        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;\n        const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;\n        const { $metadata, ...outputWithoutMetadata } = response.output;\n        logger?.info?.({\n            clientName,\n            commandName,\n            input: inputFilterSensitiveLog(args.input),\n            output: outputFilterSensitiveLog(outputWithoutMetadata),\n            metadata: $metadata,\n        });\n        return response;\n    }\n    catch (error) {\n        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;\n        const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;\n        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;\n        logger?.error?.({\n            clientName,\n            commandName,\n            input: inputFilterSensitiveLog(args.input),\n            error,\n            metadata: error.$metadata,\n        });\n        throw error;\n    }\n};\nexport const loggerMiddlewareOptions = {\n    name: \"loggerMiddleware\",\n    tags: [\"LOGGER\"],\n    step: \"initialize\",\n    override: true,\n};\nexport const getLoggerPlugin = (options) => ({\n    applyToStack: (clientStack) => {\n        clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);\n    },\n});\n", "import { HttpRequest } from \"@smithy/protocol-http\";\nconst TRACE_ID_HEADER_NAME = \"X-Amzn-Trace-Id\";\nconst ENV_LAMBDA_FUNCTION_NAME = \"AWS_LAMBDA_FUNCTION_NAME\";\nconst ENV_TRACE_ID = \"_X_AMZN_TRACE_ID\";\nexport const recursionDetectionMiddleware = (options) => (next) => async (args) => {\n    const { request } = args;\n    if (!HttpRequest.isInstance(request) || options.runtime !== \"node\") {\n        return next(args);\n    }\n    const traceIdHeader = Object.keys(request.headers ?? {}).find((h) => h.toLowerCase() === TRACE_ID_HEADER_NAME.toLowerCase()) ??\n        TRACE_ID_HEADER_NAME;\n    if (request.headers.hasOwnProperty(traceIdHeader)) {\n        return next(args);\n    }\n    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];\n    const traceId = process.env[ENV_TRACE_ID];\n    const nonEmptyString = (str) => typeof str === \"string\" && str.length > 0;\n    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {\n        request.headers[TRACE_ID_HEADER_NAME] = traceId;\n    }\n    return next({\n        ...args,\n        request,\n    });\n};\nexport const addRecursionDetectionMiddlewareOptions = {\n    step: \"build\",\n    tags: [\"RECURSION_DETECTION\"],\n    name: \"recursionDetectionMiddleware\",\n    override: true,\n    priority: \"low\",\n};\nexport const getRecursionDetectionPlugin = (options) => ({\n    applyToStack: (clientStack) => {\n        clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);\n    },\n});\n", "export * from \"./configurations\";\nexport * from \"./user-agent-middleware\";\n", "import { normalizeProvider } from \"@smithy/core\";\nexport const DEFAULT_UA_APP_ID = undefined;\nfunction isValidUserAgentAppId(appId) {\n    if (appId === undefined) {\n        return true;\n    }\n    return typeof appId === \"string\" && appId.length <= 50;\n}\nexport function resolveUserAgentConfig(input) {\n    const normalizedAppIdProvider = normalizeProvider(input.userAgentAppId ?? DEFAULT_UA_APP_ID);\n    const { customUserAgent } = input;\n    return Object.assign(input, {\n        customUserAgent: typeof customUserAgent === \"string\" ? [[customUserAgent]] : customUserAgent,\n        userAgentAppId: async () => {\n            const appId = await normalizedAppIdProvider();\n            if (!isValidUserAgentAppId(appId)) {\n                const logger = input.logger?.constructor?.name === \"NoOpLogger\" || !input.logger ? console : input.logger;\n                if (typeof appId !== \"string\") {\n                    logger?.warn(\"userAgentAppId must be a string or undefined.\");\n                }\n                else if (appId.length > 50) {\n                    logger?.warn(\"The provided userAgentAppId exceeds the maximum length of 50 characters.\");\n                }\n            }\n            return appId;\n        },\n    });\n}\n", "export * from \"./getSmithyContext\";\nexport * from \"./middleware-http-auth-scheme\";\nexport * from \"./middleware-http-signing\";\nexport * from \"./normalizeProvider\";\nexport { createPaginator } from \"./pagination/createPaginator\";\nexport * from \"./protocols/requestBuilder\";\nexport * from \"./setFeature\";\nexport * from \"./util-identity-and-auth\";\n", "import { SMITHY_CONTEXT_KEY } from \"@smithy/types\";\nexport const getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});\n", "export * from \"./httpAuthSchemeMiddleware\";\nexport * from \"./getHttpAuthSchemeEndpointRuleSetPlugin\";\nexport * from \"./getHttpAuthSchemePlugin\";\n", "import { SMITHY_CONTEXT_KEY, } from \"@smithy/types\";\nimport { getSmithyContext } from \"@smithy/util-middleware\";\nimport { resolveAuthOptions } from \"./resolveAuthOptions\";\nfunction convertHttpAuthSchemesToMap(httpAuthSchemes) {\n    const map = new Map();\n    for (const scheme of httpAuthSchemes) {\n        map.set(scheme.schemeId, scheme);\n    }\n    return map;\n}\nexport const httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {\n    const options = config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input));\n    const authSchemePreference = config.authSchemePreference ? await config.authSchemePreference() : [];\n    const resolvedOptions = resolveAuthOptions(options, authSchemePreference);\n    const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);\n    const smithyContext = getSmithyContext(context);\n    const failureReasons = [];\n    for (const option of resolvedOptions) {\n        const scheme = authSchemes.get(option.schemeId);\n        if (!scheme) {\n            failureReasons.push(`HttpAuthScheme \\`${option.schemeId}\\` was not enabled for this service.`);\n            continue;\n        }\n        const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));\n        if (!identityProvider) {\n            failureReasons.push(`HttpAuthScheme \\`${option.schemeId}\\` did not have an IdentityProvider configured.`);\n            continue;\n        }\n        const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config, context) || {};\n        option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);\n        option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);\n        smithyContext.selectedHttpAuthScheme = {\n            httpAuthOption: option,\n            identity: await identityProvider(option.identityProperties),\n            signer: scheme.signer,\n        };\n        break;\n    }\n    if (!smithyContext.selectedHttpAuthScheme) {\n        throw new Error(failureReasons.join(\"\\n\"));\n    }\n    return next(args);\n};\n", "export * from \"./getSmithyContext\";\nexport * from \"./normalizeProvider\";\n", "import { SMITHY_CONTEXT_KEY } from \"@smithy/types\";\nexport const getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});\n", "export const normalizeProvider = (input) => {\n    if (typeof input === \"function\")\n        return input;\n    const promisified = Promise.resolve(input);\n    return () => promisified;\n};\n", "export const resolveAuthOptions = (candidateAuthOptions, authSchemePreference) => {\n    if (!authSchemePreference || authSchemePreference.length === 0) {\n        return candidateAuthOptions;\n    }\n    const preferredAuthOptions = [];\n    for (const preferredSchemeName of authSchemePreference) {\n        for (const candidateAuthOption of candidateAuthOptions) {\n            const candidateAuthSchemeName = candidateAuthOption.schemeId.split(\"#\")[1];\n            if (candidateAuthSchemeName === preferredSchemeName) {\n                preferredAuthOptions.push(candidateAuthOption);\n            }\n        }\n    }\n    for (const candidateAuthOption of candidateAuthOptions) {\n        if (!preferredAuthOptions.find(({ schemeId }) => schemeId === candidateAuthOption.schemeId)) {\n            preferredAuthOptions.push(candidateAuthOption);\n        }\n    }\n    return preferredAuthOptions;\n};\n", "import { httpAuthSchemeMiddleware } from \"./httpAuthSchemeMiddleware\";\nexport const httpAuthSchemeEndpointRuleSetMiddlewareOptions = {\n    step: \"serialize\",\n    tags: [\"HTTP_AUTH_SCHEME\"],\n    name: \"httpAuthSchemeMiddleware\",\n    override: true,\n    relation: \"before\",\n    toMiddleware: \"endpointV2Middleware\",\n};\nexport const getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }) => ({\n    applyToStack: (clientStack) => {\n        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {\n            httpAuthSchemeParametersProvider,\n            identityProviderConfigProvider,\n        }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);\n    },\n});\n", "import { serializerMiddlewareOption } from \"@smithy/middleware-serde\";\nimport { httpAuthSchemeMiddleware } from \"./httpAuthSchemeMiddleware\";\nexport const httpAuthSchemeMiddlewareOptions = {\n    step: \"serialize\",\n    tags: [\"HTTP_AUTH_SCHEME\"],\n    name: \"httpAuthSchemeMiddleware\",\n    override: true,\n    relation: \"before\",\n    toMiddleware: serializerMiddlewareOption.name,\n};\nexport const getHttpAuthSchemePlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }) => ({\n    applyToStack: (clientStack) => {\n        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {\n            httpAuthSchemeParametersProvider,\n            identityProviderConfigProvider,\n        }), httpAuthSchemeMiddlewareOptions);\n    },\n});\n", "export * from \"./deserializerMiddleware\";\nexport * from \"./serdePlugin\";\nexport * from \"./serializerMiddleware\";\n", "import { HttpResponse } from \"@smithy/protocol-http\";\nexport const deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {\n    const { response } = await next(args);\n    try {\n        const parsed = await deserializer(response, options);\n        return {\n            response,\n            output: parsed,\n        };\n    }\n    catch (error) {\n        Object.defineProperty(error, \"$response\", {\n            value: response,\n        });\n        if (!(\"$metadata\" in error)) {\n            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;\n            try {\n                error.message += \"\\n  \" + hint;\n            }\n            catch (e) {\n                if (!context.logger || context.logger?.constructor?.name === \"NoOpLogger\") {\n                    console.warn(hint);\n                }\n                else {\n                    context.logger?.warn?.(hint);\n                }\n            }\n            if (typeof error.$responseBodyText !== \"undefined\") {\n                if (error.$response) {\n                    error.$response.body = error.$responseBodyText;\n                }\n            }\n            try {\n                if (HttpResponse.isInstance(response)) {\n                    const { headers = {} } = response;\n                    const headerEntries = Object.entries(headers);\n                    error.$metadata = {\n                        httpStatusCode: response.statusCode,\n                        requestId: findHeader(/^x-[\\w-]+-request-?id$/, headerEntries),\n                        extendedRequestId: findHeader(/^x-[\\w-]+-id-2$/, headerEntries),\n                        cfId: findHeader(/^x-[\\w-]+-cf-id$/, headerEntries),\n                    };\n                }\n            }\n            catch (e) {\n            }\n        }\n        throw error;\n    }\n};\nconst findHeader = (pattern, headers) => {\n    return (headers.find(([k]) => {\n        return k.match(pattern);\n    }) || [void 0, void 1])[1];\n};\n", "import { deserializerMiddleware } from \"./deserializerMiddleware\";\nimport { serializerMiddleware } from \"./serializerMiddleware\";\nexport const deserializerMiddlewareOption = {\n    name: \"deserializerMiddleware\",\n    step: \"deserialize\",\n    tags: [\"DESERIALIZER\"],\n    override: true,\n};\nexport const serializerMiddlewareOption = {\n    name: \"serializerMiddleware\",\n    step: \"serialize\",\n    tags: [\"SERIALIZER\"],\n    override: true,\n};\nexport function getSerdePlugin(config, serializer, deserializer) {\n    return {\n        applyToStack: (commandStack) => {\n            commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);\n            commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);\n        },\n    };\n}\n", "export const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {\n    const endpointConfig = options;\n    const endpoint = context.endpointV2?.url && endpointConfig.urlParser\n        ? async () => endpointConfig.urlParser(context.endpointV2.url)\n        : endpointConfig.endpoint;\n    if (!endpoint) {\n        throw new Error(\"No valid endpoint provider available.\");\n    }\n    const request = await serializer(args.input, { ...options, endpoint });\n    return next({\n        ...args,\n        request,\n    });\n};\n", "export * from \"./httpSigningMiddleware\";\nexport * from \"./getHttpSigningMiddleware\";\n", "import { HttpRequest } from \"@smithy/protocol-http\";\nimport { SMITHY_CONTEXT_KEY, } from \"@smithy/types\";\nimport { getSmithyContext } from \"@smithy/util-middleware\";\nconst defaultErrorHandler = (signingProperties) => (error) => {\n    throw error;\n};\nconst defaultSuccessHandler = (httpResponse, signingProperties) => { };\nexport const httpSigningMiddleware = (config) => (next, context) => async (args) => {\n    if (!HttpRequest.isInstance(args.request)) {\n        return next(args);\n    }\n    const smithyContext = getSmithyContext(context);\n    const scheme = smithyContext.selectedHttpAuthScheme;\n    if (!scheme) {\n        throw new Error(`No HttpAuthScheme was selected: unable to sign request`);\n    }\n    const { httpAuthOption: { signingProperties = {} }, identity, signer, } = scheme;\n    const output = await next({\n        ...args,\n        request: await signer.sign(args.request, identity, signingProperties),\n    }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));\n    (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);\n    return output;\n};\n", "import { httpSigningMiddleware } from \"./httpSigningMiddleware\";\nexport const httpSigningMiddlewareOptions = {\n    step: \"finalizeRequest\",\n    tags: [\"HTTP_SIGNING\"],\n    name: \"httpSigningMiddleware\",\n    aliases: [\"apiKeyMiddleware\", \"tokenMiddleware\", \"awsAuthMiddleware\"],\n    override: true,\n    relation: \"after\",\n    toMiddleware: \"retryMiddleware\",\n};\nexport const getHttpSigningPlugin = (config) => ({\n    applyToStack: (clientStack) => {\n        clientStack.addRelativeTo(httpSigningMiddleware(config), httpSigningMiddlewareOptions);\n    },\n});\n", "export const normalizeProvider = (input) => {\n    if (typeof input === \"function\")\n        return input;\n    const promisified = Promise.resolve(input);\n    return () => promisified;\n};\n", "const makePagedClientRequest = async (CommandCtor, client, input, withCommand = (_) => _, ...args) => {\n    let command = new CommandCtor(input);\n    command = withCommand(command) ?? command;\n    return await client.send(command, ...args);\n};\nexport function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {\n    return async function* paginateOperation(config, input, ...additionalArguments) {\n        const _input = input;\n        let token = config.startingToken ?? _input[inputTokenName];\n        let hasNext = true;\n        let page;\n        while (hasNext) {\n            _input[inputTokenName] = token;\n            if (pageSizeTokenName) {\n                _input[pageSizeTokenName] = _input[pageSizeTokenName] ?? config.pageSize;\n            }\n            if (config.client instanceof ClientCtor) {\n                page = await makePagedClientRequest(CommandCtor, config.client, input, config.withCommand, ...additionalArguments);\n            }\n            else {\n                throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);\n            }\n            yield page;\n            const prevToken = token;\n            token = get(page, outputTokenName);\n            hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));\n        }\n        return undefined;\n    };\n}\nconst get = (fromObject, path) => {\n    let cursor = fromObject;\n    const pathComponents = path.split(\".\");\n    for (const step of pathComponents) {\n        if (!cursor || typeof cursor !== \"object\") {\n            return undefined;\n        }\n        cursor = cursor[step];\n    }\n    return cursor;\n};\n", "export { requestBuilder } from \"@smithy/core/protocols\";\n", "export * from \"./collect-stream-body\";\nexport * from \"./extended-encode-uri-component\";\nexport * from \"./requestBuilder\";\nexport * from \"./resolve-path\";\n", "import { Uint8ArrayBlobAdapter } from \"@smithy/util-stream\";\nexport const collectBody = async (streamBody = new Uint8Array(), context) => {\n    if (streamBody instanceof Uint8Array) {\n        return Uint8ArrayBlobAdapter.mutate(streamBody);\n    }\n    if (!streamBody) {\n        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());\n    }\n    const fromContext = context.streamCollector(streamBody);\n    return Uint8ArrayBlobAdapter.mutate(await fromContext);\n};\n", "export * from \"./blob/Uint8ArrayBlobAdapter\";\nexport * from \"./checksum/ChecksumStream\";\nexport * from \"./checksum/createChecksumStream\";\nexport * from \"./createBufferedReadable\";\nexport * from \"./getAwsChunkedEncodingStream\";\nexport * from \"./headStream\";\nexport * from \"./sdk-stream-mixin\";\nexport * from \"./splitStream\";\nexport * from \"./stream-type-check\";\n", "import { transformFromString, transformToString } from \"./transforms\";\nexport class Uint8ArrayBlobAdapter extends Uint8Array {\n    static fromString(source, encoding = \"utf-8\") {\n        switch (typeof source) {\n            case \"string\":\n                return transformFromString(source, encoding);\n            default:\n                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);\n        }\n    }\n    static mutate(source) {\n        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);\n        return source;\n    }\n    transformToString(encoding = \"utf-8\") {\n        return transformToString(this, encoding);\n    }\n}\n", "import { fromBase64, toBase64 } from \"@smithy/util-base64\";\nimport { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nimport { Uint8ArrayBlobAdapter } from \"./Uint8ArrayBlobAdapter\";\nexport function transformToString(payload, encoding = \"utf-8\") {\n    if (encoding === \"base64\") {\n        return toBase64(payload);\n    }\n    return toUtf8(payload);\n}\nexport function transformFromString(str, encoding) {\n    if (encoding === \"base64\") {\n        return Uint8ArrayBlobAdapter.mutate(fromBase64(str));\n    }\n    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));\n}\n", "export * from \"./fromBase64\";\nexport * from \"./toBase64\";\n", "import { alphabetByEncoding, bitsPerByte, bitsPerLetter } from \"./constants.browser\";\nexport const fromBase64 = (input) => {\n    let totalByteLength = (input.length / 4) * 3;\n    if (input.slice(-2) === \"==\") {\n        totalByteLength -= 2;\n    }\n    else if (input.slice(-1) === \"=\") {\n        totalByteLength--;\n    }\n    const out = new ArrayBuffer(totalByteLength);\n    const dataView = new DataView(out);\n    for (let i = 0; i < input.length; i += 4) {\n        let bits = 0;\n        let bitLength = 0;\n        for (let j = i, limit = i + 3; j <= limit; j++) {\n            if (input[j] !== \"=\") {\n                if (!(input[j] in alphabetByEncoding)) {\n                    throw new TypeError(`Invalid character ${input[j]} in base64 string.`);\n                }\n                bits |= alphabetByEncoding[input[j]] << ((limit - j) * bitsPerLetter);\n                bitLength += bitsPerLetter;\n            }\n            else {\n                bits >>= bitsPerLetter;\n            }\n        }\n        const chunkOffset = (i / 4) * 3;\n        bits >>= bitLength % bitsPerByte;\n        const byteLength = Math.floor(bitLength / bitsPerByte);\n        for (let k = 0; k < byteLength; k++) {\n            const offset = (byteLength - k - 1) * bitsPerByte;\n            dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);\n        }\n    }\n    return new Uint8Array(out);\n};\n", "const alphabetByEncoding = {};\nconst alphabetByValue = new Array(64);\nfor (let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n    const char = String.fromCharCode(i + start);\n    alphabetByEncoding[char] = i;\n    alphabetByValue[i] = char;\n}\nfor (let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n    const char = String.fromCharCode(i + start);\n    const index = i + 26;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nfor (let i = 0; i < 10; i++) {\n    alphabetByEncoding[i.toString(10)] = i + 52;\n    const char = i.toString(10);\n    const index = i + 52;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\nconst bitsPerLetter = 6;\nconst bitsPerByte = 8;\nconst maxLetterValue = 0b111111;\nexport { alphabetByEncoding, alphabetByValue, bitsPerLetter, bitsPerByte, maxLetterValue };\n", "import { fromUtf8 } from \"@smithy/util-utf8\";\nimport { alphabetByValue, bitsPerByte, bitsPerLetter, maxLetterValue } from \"./constants.browser\";\nexport function toBase64(_input) {\n    let input;\n    if (typeof _input === \"string\") {\n        input = fromUtf8(_input);\n    }\n    else {\n        input = _input;\n    }\n    const isArrayLike = typeof input === \"object\" && typeof input.length === \"number\";\n    const isUint8Array = typeof input === \"object\" &&\n        typeof input.byteOffset === \"number\" &&\n        typeof input.byteLength === \"number\";\n    if (!isArrayLike && !isUint8Array) {\n        throw new Error(\"@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.\");\n    }\n    let str = \"\";\n    for (let i = 0; i < input.length; i += 3) {\n        let bits = 0;\n        let bitLength = 0;\n        for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n            bits |= input[j] << ((limit - j - 1) * bitsPerByte);\n            bitLength += bitsPerByte;\n        }\n        const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n        bits <<= bitClusterCount * bitsPerLetter - bitLength;\n        for (let k = 1; k <= bitClusterCount; k++) {\n            const offset = (bitClusterCount - k) * bitsPerLetter;\n            str += alphabetByValue[(bits & (maxLetterValue << offset)) >> offset];\n        }\n        str += \"==\".slice(0, 4 - bitClusterCount);\n    }\n    return str;\n}\n", "export * from \"./fromUtf8\";\nexport * from \"./toUint8Array\";\nexport * from \"./toUtf8\";\n", "export const fromUtf8 = (input) => new TextEncoder().encode(input);\n", "import { fromUtf8 } from \"./fromUtf8\";\nexport const toUint8Array = (data) => {\n    if (typeof data === \"string\") {\n        return fromUtf8(data);\n    }\n    if (ArrayBuffer.isView(data)) {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n    }\n    return new Uint8Array(data);\n};\n", "export const toUtf8 = (input) => {\n    if (typeof input === \"string\") {\n        return input;\n    }\n    if (typeof input !== \"object\" || typeof input.byteOffset !== \"number\" || typeof input.byteLength !== \"number\") {\n        throw new Error(\"@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.\");\n    }\n    return new TextDecoder(\"utf-8\").decode(input);\n};\n", "const ReadableStreamRef = typeof ReadableStream === \"function\" ? ReadableStream : function () { };\nexport class ChecksumStream extends ReadableStreamRef {\n}\n", "import { toBase64 } from \"@smithy/util-base64\";\nimport { isReadableStream } from \"../stream-type-check\";\nimport { ChecksumStream } from \"./ChecksumStream.browser\";\nexport const createChecksumStream = ({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder, }) => {\n    if (!isReadableStream(source)) {\n        throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);\n    }\n    const encoder = base64Encoder ?? toBase64;\n    if (typeof TransformStream !== \"function\") {\n        throw new Error(\"@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.\");\n    }\n    const transform = new TransformStream({\n        start() { },\n        async transform(chunk, controller) {\n            checksum.update(chunk);\n            controller.enqueue(chunk);\n        },\n        async flush(controller) {\n            const digest = await checksum.digest();\n            const received = encoder(digest);\n            if (expectedChecksum !== received) {\n                const error = new Error(`Checksum mismatch: expected \"${expectedChecksum}\" but received \"${received}\"` +\n                    ` in response header \"${checksumSourceLocation}\".`);\n                controller.error(error);\n            }\n            else {\n                controller.terminate();\n            }\n        },\n    });\n    source.pipeThrough(transform);\n    const readable = transform.readable;\n    Object.setPrototypeOf(readable, ChecksumStream.prototype);\n    return readable;\n};\n", "export const isReadableStream = (stream) => typeof ReadableStream === \"function\" &&\n    (stream?.constructor?.name === ReadableStream.name || stream instanceof ReadableStream);\nexport const isBlob = (blob) => {\n    return typeof Blob === \"function\" && (blob?.constructor?.name === Blob.name || blob instanceof Blob);\n};\n", "import { ByteArrayCollector } from \"./ByteArrayCollector\";\nexport function createBufferedReadableStream(upstream, size, logger) {\n    const reader = upstream.getReader();\n    let streamBufferingLoggedWarning = false;\n    let bytesSeen = 0;\n    const buffers = [\"\", new ByteArrayCollector((size) => new Uint8Array(size))];\n    let mode = -1;\n    const pull = async (controller) => {\n        const { value, done } = await reader.read();\n        const chunk = value;\n        if (done) {\n            if (mode !== -1) {\n                const remainder = flush(buffers, mode);\n                if (sizeOf(remainder) > 0) {\n                    controller.enqueue(remainder);\n                }\n            }\n            controller.close();\n        }\n        else {\n            const chunkMode = modeOf(chunk, false);\n            if (mode !== chunkMode) {\n                if (mode >= 0) {\n                    controller.enqueue(flush(buffers, mode));\n                }\n                mode = chunkMode;\n            }\n            if (mode === -1) {\n                controller.enqueue(chunk);\n                return;\n            }\n            const chunkSize = sizeOf(chunk);\n            bytesSeen += chunkSize;\n            const bufferSize = sizeOf(buffers[mode]);\n            if (chunkSize >= size && bufferSize === 0) {\n                controller.enqueue(chunk);\n            }\n            else {\n                const newSize = merge(buffers, mode, chunk);\n                if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {\n                    streamBufferingLoggedWarning = true;\n                    logger?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);\n                }\n                if (newSize >= size) {\n                    controller.enqueue(flush(buffers, mode));\n                }\n                else {\n                    await pull(controller);\n                }\n            }\n        }\n    };\n    return new ReadableStream({\n        pull,\n    });\n}\nexport const createBufferedReadable = createBufferedReadableStream;\nexport function merge(buffers, mode, chunk) {\n    switch (mode) {\n        case 0:\n            buffers[0] += chunk;\n            return sizeOf(buffers[0]);\n        case 1:\n        case 2:\n            buffers[mode].push(chunk);\n            return sizeOf(buffers[mode]);\n    }\n}\nexport function flush(buffers, mode) {\n    switch (mode) {\n        case 0:\n            const s = buffers[0];\n            buffers[0] = \"\";\n            return s;\n        case 1:\n        case 2:\n            return buffers[mode].flush();\n    }\n    throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);\n}\nexport function sizeOf(chunk) {\n    return chunk?.byteLength ?? chunk?.length ?? 0;\n}\nexport function modeOf(chunk, allowBuffer = true) {\n    if (allowBuffer && typeof Buffer !== \"undefined\" && chunk instanceof Buffer) {\n        return 2;\n    }\n    if (chunk instanceof Uint8Array) {\n        return 1;\n    }\n    if (typeof chunk === \"string\") {\n        return 0;\n    }\n    return -1;\n}\n", "export class ByteArrayCollector {\n    constructor(allocByteArray) {\n        this.allocByteArray = allocByteArray;\n        this.byteLength = 0;\n        this.byteArrays = [];\n    }\n    push(byteArray) {\n        this.byteArrays.push(byteArray);\n        this.byteLength += byteArray.byteLength;\n    }\n    flush() {\n        if (this.byteArrays.length === 1) {\n            const bytes = this.byteArrays[0];\n            this.reset();\n            return bytes;\n        }\n        const aggregation = this.allocByteArray(this.byteLength);\n        let cursor = 0;\n        for (let i = 0; i < this.byteArrays.length; ++i) {\n            const bytes = this.byteArrays[i];\n            aggregation.set(bytes, cursor);\n            cursor += bytes.byteLength;\n        }\n        this.reset();\n        return aggregation;\n    }\n    reset() {\n        this.byteArrays = [];\n        this.byteLength = 0;\n    }\n}\n", "export const getAwsChunkedEncodingStream = (readableStream, options) => {\n    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;\n    const checksumRequired = base64Encoder !== undefined &&\n        bodyLengthChecker !== undefined &&\n        checksumAlgorithmFn !== undefined &&\n        checksumLocationName !== undefined &&\n        streamHasher !== undefined;\n    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n        async pull(controller) {\n            const { value, done } = await reader.read();\n            if (done) {\n                controller.enqueue(`0\\r\\n`);\n                if (checksumRequired) {\n                    const checksum = base64Encoder(await digest);\n                    controller.enqueue(`${checksumLocationName}:${checksum}\\r\\n`);\n                    controller.enqueue(`\\r\\n`);\n                }\n                controller.close();\n            }\n            else {\n                controller.enqueue(`${(bodyLengthChecker(value) || 0).toString(16)}\\r\\n${value}\\r\\n`);\n            }\n        },\n    });\n};\n", "export async function headStream(stream, bytes) {\n    let byteLengthCounter = 0;\n    const chunks = [];\n    const reader = stream.getReader();\n    let isDone = false;\n    while (!isDone) {\n        const { done, value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            byteLengthCounter += value?.byteLength ?? 0;\n        }\n        if (byteLengthCounter >= bytes) {\n            break;\n        }\n        isDone = done;\n    }\n    reader.releaseLock();\n    const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));\n    let offset = 0;\n    for (const chunk of chunks) {\n        if (chunk.byteLength > collected.byteLength - offset) {\n            collected.set(chunk.subarray(0, collected.byteLength - offset), offset);\n            break;\n        }\n        else {\n            collected.set(chunk, offset);\n        }\n        offset += chunk.length;\n    }\n    return collected;\n}\n", "import { streamCollector } from \"@smithy/fetch-http-handler\";\nimport { toBase64 } from \"@smithy/util-base64\";\nimport { toHex } from \"@smithy/util-hex-encoding\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { isReadableStream } from \"./stream-type-check\";\nconst ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = \"The stream has already been transformed.\";\nexport const sdkStreamMixin = (stream) => {\n    if (!isBlobInstance(stream) && !isReadableStream(stream)) {\n        const name = stream?.__proto__?.constructor?.name || stream;\n        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);\n    }\n    let transformed = false;\n    const transformToByteArray = async () => {\n        if (transformed) {\n            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);\n        }\n        transformed = true;\n        return await streamCollector(stream);\n    };\n    const blobToWebStream = (blob) => {\n        if (typeof blob.stream !== \"function\") {\n            throw new Error(\"Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\\n\" +\n                \"If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body\");\n        }\n        return blob.stream();\n    };\n    return Object.assign(stream, {\n        transformToByteArray: transformToByteArray,\n        transformToString: async (encoding) => {\n            const buf = await transformToByteArray();\n            if (encoding === \"base64\") {\n                return toBase64(buf);\n            }\n            else if (encoding === \"hex\") {\n                return toHex(buf);\n            }\n            else if (encoding === undefined || encoding === \"utf8\" || encoding === \"utf-8\") {\n                return toUtf8(buf);\n            }\n            else if (typeof TextDecoder === \"function\") {\n                return new TextDecoder(encoding).decode(buf);\n            }\n            else {\n                throw new Error(\"TextDecoder is not available, please make sure polyfill is provided.\");\n            }\n        },\n        transformToWebStream: () => {\n            if (transformed) {\n                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);\n            }\n            transformed = true;\n            if (isBlobInstance(stream)) {\n                return blobToWebStream(stream);\n            }\n            else if (isReadableStream(stream)) {\n                return stream;\n            }\n            else {\n                throw new Error(`Cannot transform payload to web stream, got ${stream}`);\n            }\n        },\n    });\n};\nconst isBlobInstance = (stream) => typeof Blob === \"function\" && stream instanceof Blob;\n", "export * from \"./fetch-http-handler\";\nexport * from \"./stream-collector\";\n", "import { HttpResponse } from \"@smithy/protocol-http\";\nimport { buildQueryString } from \"@smithy/querystring-builder\";\nimport { createRequest } from \"./create-request\";\nimport { requestTimeout } from \"./request-timeout\";\nexport const keepAliveSupport = {\n    supported: undefined,\n};\nexport class FetchHttpHandler {\n    static create(instanceOrOptions) {\n        if (typeof instanceOrOptions?.handle === \"function\") {\n            return instanceOrOptions;\n        }\n        return new FetchHttpHandler(instanceOrOptions);\n    }\n    constructor(options) {\n        if (typeof options === \"function\") {\n            this.configProvider = options().then((opts) => opts || {});\n        }\n        else {\n            this.config = options ?? {};\n            this.configProvider = Promise.resolve(this.config);\n        }\n        if (keepAliveSupport.supported === undefined) {\n            keepAliveSupport.supported = Boolean(typeof Request !== \"undefined\" && \"keepalive\" in createRequest(\"https://[::1]\"));\n        }\n    }\n    destroy() {\n    }\n    async handle(request, { abortSignal } = {}) {\n        if (!this.config) {\n            this.config = await this.configProvider;\n        }\n        const requestTimeoutInMs = this.config.requestTimeout;\n        const keepAlive = this.config.keepAlive === true;\n        const credentials = this.config.credentials;\n        if (abortSignal?.aborted) {\n            const abortError = new Error(\"Request aborted\");\n            abortError.name = \"AbortError\";\n            return Promise.reject(abortError);\n        }\n        let path = request.path;\n        const queryString = buildQueryString(request.query || {});\n        if (queryString) {\n            path += `?${queryString}`;\n        }\n        if (request.fragment) {\n            path += `#${request.fragment}`;\n        }\n        let auth = \"\";\n        if (request.username != null || request.password != null) {\n            const username = request.username ?? \"\";\n            const password = request.password ?? \"\";\n            auth = `${username}:${password}@`;\n        }\n        const { port, method } = request;\n        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : \"\"}${path}`;\n        const body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n        const requestOptions = {\n            body,\n            headers: new Headers(request.headers),\n            method: method,\n            credentials,\n        };\n        if (this.config?.cache) {\n            requestOptions.cache = this.config.cache;\n        }\n        if (body) {\n            requestOptions.duplex = \"half\";\n        }\n        if (typeof AbortController !== \"undefined\") {\n            requestOptions.signal = abortSignal;\n        }\n        if (keepAliveSupport.supported) {\n            requestOptions.keepalive = keepAlive;\n        }\n        if (typeof this.config.requestInit === \"function\") {\n            Object.assign(requestOptions, this.config.requestInit(request));\n        }\n        let removeSignalEventListener = () => { };\n        const fetchRequest = createRequest(url, requestOptions);\n        const raceOfPromises = [\n            fetch(fetchRequest).then((response) => {\n                const fetchHeaders = response.headers;\n                const transformedHeaders = {};\n                for (const pair of fetchHeaders.entries()) {\n                    transformedHeaders[pair[0]] = pair[1];\n                }\n                const hasReadableStream = response.body != undefined;\n                if (!hasReadableStream) {\n                    return response.blob().then((body) => ({\n                        response: new HttpResponse({\n                            headers: transformedHeaders,\n                            reason: response.statusText,\n                            statusCode: response.status,\n                            body,\n                        }),\n                    }));\n                }\n                return {\n                    response: new HttpResponse({\n                        headers: transformedHeaders,\n                        reason: response.statusText,\n                        statusCode: response.status,\n                        body: response.body,\n                    }),\n                };\n            }),\n            requestTimeout(requestTimeoutInMs),\n        ];\n        if (abortSignal) {\n            raceOfPromises.push(new Promise((resolve, reject) => {\n                const onAbort = () => {\n                    const abortError = new Error(\"Request aborted\");\n                    abortError.name = \"AbortError\";\n                    reject(abortError);\n                };\n                if (typeof abortSignal.addEventListener === \"function\") {\n                    const signal = abortSignal;\n                    signal.addEventListener(\"abort\", onAbort, { once: true });\n                    removeSignalEventListener = () => signal.removeEventListener(\"abort\", onAbort);\n                }\n                else {\n                    abortSignal.onabort = onAbort;\n                }\n            }));\n        }\n        return Promise.race(raceOfPromises).finally(removeSignalEventListener);\n    }\n    updateHttpClientConfig(key, value) {\n        this.config = undefined;\n        this.configProvider = this.configProvider.then((config) => {\n            config[key] = value;\n            return config;\n        });\n    }\n    httpHandlerConfigs() {\n        return this.config ?? {};\n    }\n}\n", "import { escapeUri } from \"@smithy/util-uri-escape\";\nexport function buildQueryString(query) {\n    const parts = [];\n    for (let key of Object.keys(query).sort()) {\n        const value = query[key];\n        key = escapeUri(key);\n        if (Array.isArray(value)) {\n            for (let i = 0, iLen = value.length; i < iLen; i++) {\n                parts.push(`${key}=${escapeUri(value[i])}`);\n            }\n        }\n        else {\n            let qsEntry = key;\n            if (value || typeof value === \"string\") {\n                qsEntry += `=${escapeUri(value)}`;\n            }\n            parts.push(qsEntry);\n        }\n    }\n    return parts.join(\"&\");\n}\n", "export * from \"./escape-uri\";\nexport * from \"./escape-uri-path\";\n", "export const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);\nconst hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;\n", "import { escapeUri } from \"./escape-uri\";\nexport const escapeUriPath = (uri) => uri.split(\"/\").map(escapeUri).join(\"/\");\n", "export function createRequest(url, requestOptions) {\n    return new Request(url, requestOptions);\n}\n", "export function requestTimeout(timeoutInMs = 0) {\n    return new Promise((resolve, reject) => {\n        if (timeoutInMs) {\n            setTimeout(() => {\n                const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);\n                timeoutError.name = \"TimeoutError\";\n                reject(timeoutError);\n            }, timeoutInMs);\n        }\n    });\n}\n", "import { fromBase64 } from \"@smithy/util-base64\";\nexport const streamCollector = async (stream) => {\n    if ((typeof Blob === \"function\" && stream instanceof Blob) || stream.constructor?.name === \"Blob\") {\n        if (Blob.prototype.arrayBuffer !== undefined) {\n            return new Uint8Array(await stream.arrayBuffer());\n        }\n        return collectBlob(stream);\n    }\n    return collectStream(stream);\n};\nasync function collectBlob(blob) {\n    const base64 = await readToBase64(blob);\n    const arrayBuffer = fromBase64(base64);\n    return new Uint8Array(arrayBuffer);\n}\nasync function collectStream(stream) {\n    const chunks = [];\n    const reader = stream.getReader();\n    let isDone = false;\n    let length = 0;\n    while (!isDone) {\n        const { done, value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            length += value.length;\n        }\n        isDone = done;\n    }\n    const collected = new Uint8Array(length);\n    let offset = 0;\n    for (const chunk of chunks) {\n        collected.set(chunk, offset);\n        offset += chunk.length;\n    }\n    return collected;\n}\nfunction readToBase64(blob) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n            if (reader.readyState !== 2) {\n                return reject(new Error(\"Reader aborted too early\"));\n            }\n            const result = (reader.result ?? \"\");\n            const commaIndex = result.indexOf(\",\");\n            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;\n            resolve(result.substring(dataOffset));\n        };\n        reader.onabort = () => reject(new Error(\"Read aborted\"));\n        reader.onerror = () => reject(reader.error);\n        reader.readAsDataURL(blob);\n    });\n}\n", "const SHORT_TO_HEX = {};\nconst HEX_TO_SHORT = {};\nfor (let i = 0; i < 256; i++) {\n    let encodedByte = i.toString(16).toLowerCase();\n    if (encodedByte.length === 1) {\n        encodedByte = `0${encodedByte}`;\n    }\n    SHORT_TO_HEX[i] = encodedByte;\n    HEX_TO_SHORT[encodedByte] = i;\n}\nexport function fromHex(encoded) {\n    if (encoded.length % 2 !== 0) {\n        throw new Error(\"Hex encoded strings must have an even number length\");\n    }\n    const out = new Uint8Array(encoded.length / 2);\n    for (let i = 0; i < encoded.length; i += 2) {\n        const encodedByte = encoded.slice(i, i + 2).toLowerCase();\n        if (encodedByte in HEX_TO_SHORT) {\n            out[i / 2] = HEX_TO_SHORT[encodedByte];\n        }\n        else {\n            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);\n        }\n    }\n    return out;\n}\nexport function toHex(bytes) {\n    let out = \"\";\n    for (let i = 0; i < bytes.byteLength; i++) {\n        out += SHORT_TO_HEX[bytes[i]];\n    }\n    return out;\n}\n", "export async function splitStream(stream) {\n    if (typeof stream.stream === \"function\") {\n        stream = stream.stream();\n    }\n    const readableStream = stream;\n    return readableStream.tee();\n}\n", "export function extendedEncodeURIComponent(str) {\n    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n        return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n}\n", "import { HttpRequest } from \"@smithy/protocol-http\";\nimport { resolvedPath } from \"./resolve-path\";\nexport function requestBuilder(input, context) {\n    return new RequestBuilder(input, context);\n}\nexport class RequestBuilder {\n    constructor(input, context) {\n        this.input = input;\n        this.context = context;\n        this.query = {};\n        this.method = \"\";\n        this.headers = {};\n        this.path = \"\";\n        this.body = null;\n        this.hostname = \"\";\n        this.resolvePathStack = [];\n    }\n    async build() {\n        const { hostname, protocol = \"https\", port, path: basePath } = await this.context.endpoint();\n        this.path = basePath;\n        for (const resolvePath of this.resolvePathStack) {\n            resolvePath(this.path);\n        }\n        return new HttpRequest({\n            protocol,\n            hostname: this.hostname || hostname,\n            port,\n            method: this.method,\n            path: this.path,\n            query: this.query,\n            body: this.body,\n            headers: this.headers,\n        });\n    }\n    hn(hostname) {\n        this.hostname = hostname;\n        return this;\n    }\n    bp(uriLabel) {\n        this.resolvePathStack.push((basePath) => {\n            this.path = `${basePath?.endsWith(\"/\") ? basePath.slice(0, -1) : basePath || \"\"}` + uriLabel;\n        });\n        return this;\n    }\n    p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {\n        this.resolvePathStack.push((path) => {\n            this.path = resolvedPath(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);\n        });\n        return this;\n    }\n    h(headers) {\n        this.headers = headers;\n        return this;\n    }\n    q(query) {\n        this.query = query;\n        return this;\n    }\n    b(body) {\n        this.body = body;\n        return this;\n    }\n    m(method) {\n        this.method = method;\n        return this;\n    }\n}\n", "import { extendedEncodeURIComponent } from \"./extended-encode-uri-component\";\nexport const resolvedPath = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {\n    if (input != null && input[memberName] !== undefined) {\n        const labelValue = labelValueProvider();\n        if (labelValue.length <= 0) {\n            throw new Error(\"Empty value provided for input HTTP label: \" + memberName + \".\");\n        }\n        resolvedPath = resolvedPath.replace(uriLabel, isGreedyLabel\n            ? labelValue\n                .split(\"/\")\n                .map((segment) => extendedEncodeURIComponent(segment))\n                .join(\"/\")\n            : extendedEncodeURIComponent(labelValue));\n    }\n    else {\n        throw new Error(\"No value provided for input HTTP label: \" + memberName + \".\");\n    }\n    return resolvedPath;\n};\n", "export function setFeature(context, feature, value) {\n    if (!context.__smithy_context) {\n        context.__smithy_context = {\n            features: {},\n        };\n    }\n    else if (!context.__smithy_context.features) {\n        context.__smithy_context.features = {};\n    }\n    context.__smithy_context.features[feature] = value;\n}\n", "export * from \"./DefaultIdentityProviderConfig\";\nexport * from \"./httpAuthSchemes\";\nexport * from \"./memoizeIdentityProvider\";\n", "export class DefaultIdentityProviderConfig {\n    constructor(config) {\n        this.authSchemes = new Map();\n        for (const [key, value] of Object.entries(config)) {\n            if (value !== undefined) {\n                this.authSchemes.set(key, value);\n            }\n        }\n    }\n    getIdentityProvider(schemeId) {\n        return this.authSchemes.get(schemeId);\n    }\n}\n", "export * from \"./httpApiKeyAuth\";\nexport * from \"./httpBearerAuth\";\nexport * from \"./noAuth\";\n", "import { HttpRequest } from \"@smithy/protocol-http\";\nimport { HttpApiKeyAuthLocation } from \"@smithy/types\";\nexport class HttpApiKeyAuthSigner {\n    async sign(httpRequest, identity, signingProperties) {\n        if (!signingProperties) {\n            throw new Error(\"request could not be signed with `apiKey` since the `name` and `in` signer properties are missing\");\n        }\n        if (!signingProperties.name) {\n            throw new Error(\"request could not be signed with `apiKey` since the `name` signer property is missing\");\n        }\n        if (!signingProperties.in) {\n            throw new Error(\"request could not be signed with `apiKey` since the `in` signer property is missing\");\n        }\n        if (!identity.apiKey) {\n            throw new Error(\"request could not be signed with `apiKey` since the `apiKey` is not defined\");\n        }\n        const clonedRequest = HttpRequest.clone(httpRequest);\n        if (signingProperties.in === HttpApiKeyAuthLocation.QUERY) {\n            clonedRequest.query[signingProperties.name] = identity.apiKey;\n        }\n        else if (signingProperties.in === HttpApiKeyAuthLocation.HEADER) {\n            clonedRequest.headers[signingProperties.name] = signingProperties.scheme\n                ? `${signingProperties.scheme} ${identity.apiKey}`\n                : identity.apiKey;\n        }\n        else {\n            throw new Error(\"request can only be signed with `apiKey` locations `query` or `header`, \" +\n                \"but found: `\" +\n                signingProperties.in +\n                \"`\");\n        }\n        return clonedRequest;\n    }\n}\n", "import { HttpRequest } from \"@smithy/protocol-http\";\nexport class HttpBearerAuthSigner {\n    async sign(httpRequest, identity, signingProperties) {\n        const clonedRequest = HttpRequest.clone(httpRequest);\n        if (!identity.token) {\n            throw new Error(\"request could not be signed with `token` since the `token` is not defined\");\n        }\n        clonedRequest.headers[\"Authorization\"] = `Bearer ${identity.token}`;\n        return clonedRequest;\n    }\n}\n", "export class NoAuthSigner {\n    async sign(httpRequest, identity, signingProperties) {\n        return httpRequest;\n    }\n}\n", "export const createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;\nexport const EXPIRATION_MS = 300000;\nexport const isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);\nexport const doesIdentityRequireRefresh = (identity) => identity.expiration !== undefined;\nexport const memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {\n    if (provider === undefined) {\n        return undefined;\n    }\n    const normalizedProvider = typeof provider !== \"function\" ? async () => Promise.resolve(provider) : provider;\n    let resolved;\n    let pending;\n    let hasResult;\n    let isConstant = false;\n    const coalesceProvider = async (options) => {\n        if (!pending) {\n            pending = normalizedProvider(options);\n        }\n        try {\n            resolved = await pending;\n            hasResult = true;\n            isConstant = false;\n        }\n        finally {\n            pending = undefined;\n        }\n        return resolved;\n    };\n    if (isExpired === undefined) {\n        return async (options) => {\n            if (!hasResult || options?.forceRefresh) {\n                resolved = await coalesceProvider(options);\n            }\n            return resolved;\n        };\n    }\n    return async (options) => {\n        if (!hasResult || options?.forceRefresh) {\n            resolved = await coalesceProvider(options);\n        }\n        if (isConstant) {\n            return resolved;\n        }\n        if (!requiresRefresh(resolved)) {\n            isConstant = true;\n            return resolved;\n        }\n        if (isExpired(resolved)) {\n            await coalesceProvider(options);\n            return resolved;\n        }\n        return resolved;\n    };\n};\n", "import { getUserAgentPrefix } from \"@aws-sdk/util-endpoints\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { checkFeatures } from \"./check-features\";\nimport { SPACE, UA_ESCAPE_CHAR, UA_NAME_ESCAPE_REGEX, UA_NAME_SEPARATOR, UA_VALUE_ESCAPE_REGEX, USER_AGENT, X_AMZ_USER_AGENT, } from \"./constants\";\nimport { encodeFeatures } from \"./encode-features\";\nexport const userAgentMiddleware = (options) => (next, context) => async (args) => {\n    const { request } = args;\n    if (!HttpRequest.isInstance(request)) {\n        return next(args);\n    }\n    const { headers } = request;\n    const userAgent = context?.userAgent?.map(escapeUserAgent) || [];\n    const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);\n    await checkFeatures(context, options, args);\n    const awsContext = context;\n    defaultUserAgent.push(`m/${encodeFeatures(Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);\n    const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];\n    const appId = await options.userAgentAppId();\n    if (appId) {\n        defaultUserAgent.push(escapeUserAgent([`app/${appId}`]));\n    }\n    const prefix = getUserAgentPrefix();\n    const sdkUserAgentValue = (prefix ? [prefix] : [])\n        .concat([...defaultUserAgent, ...userAgent, ...customUserAgent])\n        .join(SPACE);\n    const normalUAValue = [\n        ...defaultUserAgent.filter((section) => section.startsWith(\"aws-sdk-\")),\n        ...customUserAgent,\n    ].join(SPACE);\n    if (options.runtime !== \"browser\") {\n        if (normalUAValue) {\n            headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT]\n                ? `${headers[USER_AGENT]} ${normalUAValue}`\n                : normalUAValue;\n        }\n        headers[USER_AGENT] = sdkUserAgentValue;\n    }\n    else {\n        headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;\n    }\n    return next({\n        ...args,\n        request,\n    });\n};\nconst escapeUserAgent = (userAgentPair) => {\n    const name = userAgentPair[0]\n        .split(UA_NAME_SEPARATOR)\n        .map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR))\n        .join(UA_NAME_SEPARATOR);\n    const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);\n    const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);\n    const prefix = name.substring(0, prefixSeparatorIndex);\n    let uaName = name.substring(prefixSeparatorIndex + 1);\n    if (prefix === \"api\") {\n        uaName = uaName.toLowerCase();\n    }\n    return [prefix, uaName, version]\n        .filter((item) => item && item.length > 0)\n        .reduce((acc, item, index) => {\n        switch (index) {\n            case 0:\n                return item;\n            case 1:\n                return `${acc}/${item}`;\n            default:\n                return `${acc}#${item}`;\n        }\n    }, \"\");\n};\nexport const getUserAgentMiddlewareOptions = {\n    name: \"getUserAgentMiddleware\",\n    step: \"build\",\n    priority: \"low\",\n    tags: [\"SET_USER_AGENT\", \"USER_AGENT\"],\n    override: true,\n};\nexport const getUserAgentPlugin = (config) => ({\n    applyToStack: (clientStack) => {\n        clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);\n    },\n});\n", "export * from \"./aws\";\nexport * from \"./lib/aws/partition\";\nexport * from \"./lib/isIpAddress\";\nexport * from \"./resolveEndpoint\";\nexport * from \"./types\";\n", "import { customEndpointFunctions } from \"@smithy/util-endpoints\";\nimport { isVirtualHostableS3Bucket } from \"./lib/aws/isVirtualHostableS3Bucket\";\nimport { parseArn } from \"./lib/aws/parseArn\";\nimport { partition } from \"./lib/aws/partition\";\nexport const awsEndpointFunctions = {\n    isVirtualHostableS3Bucket: isVirtualHostableS3Bucket,\n    parseArn: parseArn,\n    partition: partition,\n};\ncustomEndpointFunctions.aws = awsEndpointFunctions;\n", "export * from \"./cache/EndpointCache\";\nexport * from \"./lib/isIpAddress\";\nexport * from \"./lib/isValidHostLabel\";\nexport * from \"./utils/customEndpointFunctions\";\nexport * from \"./resolveEndpoint\";\nexport * from \"./types\";\n", "export class EndpointCache {\n    constructor({ size, params }) {\n        this.data = new Map();\n        this.parameters = [];\n        this.capacity = size ?? 50;\n        if (params) {\n            this.parameters = params;\n        }\n    }\n    get(endpointParams, resolver) {\n        const key = this.hash(endpointParams);\n        if (key === false) {\n            return resolver();\n        }\n        if (!this.data.has(key)) {\n            if (this.data.size > this.capacity + 10) {\n                const keys = this.data.keys();\n                let i = 0;\n                while (true) {\n                    const { value, done } = keys.next();\n                    this.data.delete(value);\n                    if (done || ++i > 10) {\n                        break;\n                    }\n                }\n            }\n            this.data.set(key, resolver());\n        }\n        return this.data.get(key);\n    }\n    size() {\n        return this.data.size;\n    }\n    hash(endpointParams) {\n        let buffer = \"\";\n        const { parameters } = this;\n        if (parameters.length === 0) {\n            return false;\n        }\n        for (const param of parameters) {\n            const val = String(endpointParams[param] ?? \"\");\n            if (val.includes(\"|;\")) {\n                return false;\n            }\n            buffer += val + \"|;\";\n        }\n        return buffer;\n    }\n}\n", "const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}$`);\nexport const isIpAddress = (value) => IP_V4_REGEX.test(value) || (value.startsWith(\"[\") && value.endsWith(\"]\"));\n", "const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);\nexport const isValidHostLabel = (value, allowSubDomains = false) => {\n    if (!allowSubDomains) {\n        return VALID_HOST_LABEL_REGEX.test(value);\n    }\n    const labels = value.split(\".\");\n    for (const label of labels) {\n        if (!isValidHostLabel(label)) {\n            return false;\n        }\n    }\n    return true;\n};\n", "export const customEndpointFunctions = {};\n", "import { debugId, toDebugString } from \"./debug\";\nimport { EndpointError } from \"./types\";\nimport { evaluateRules } from \"./utils\";\nexport const resolveEndpoint = (ruleSetObject, options) => {\n    const { endpointParams, logger } = options;\n    const { parameters, rules } = ruleSetObject;\n    options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);\n    const paramsWithDefault = Object.entries(parameters)\n        .filter(([, v]) => v.default != null)\n        .map(([k, v]) => [k, v.default]);\n    if (paramsWithDefault.length > 0) {\n        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {\n            endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;\n        }\n    }\n    const requiredParams = Object.entries(parameters)\n        .filter(([, v]) => v.required)\n        .map(([k]) => k);\n    for (const requiredParam of requiredParams) {\n        if (endpointParams[requiredParam] == null) {\n            throw new EndpointError(`Missing required parameter: '${requiredParam}'`);\n        }\n    }\n    const endpoint = evaluateRules(rules, { endpointParams, logger, referenceRecord: {} });\n    options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);\n    return endpoint;\n};\n", "export * from \"./debugId\";\nexport * from \"./toDebugString\";\n", "export const debugId = \"endpoints\";\n", "export function toDebugString(input) {\n    if (typeof input !== \"object\" || input == null) {\n        return input;\n    }\n    if (\"ref\" in input) {\n        return `$${toDebugString(input.ref)}`;\n    }\n    if (\"fn\" in input) {\n        return `${input.fn}(${(input.argv || []).map(toDebugString).join(\", \")})`;\n    }\n    return JSON.stringify(input, null, 2);\n}\n", "export * from \"./EndpointError\";\nexport * from \"./EndpointFunctions\";\nexport * from \"./EndpointRuleObject\";\nexport * from \"./ErrorRuleObject\";\nexport * from \"./RuleSetObject\";\nexport * from \"./TreeRuleObject\";\nexport * from \"./shared\";\n", "export class EndpointError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"EndpointError\";\n    }\n}\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export * from \"./customEndpointFunctions\";\nexport * from \"./evaluateRules\";\n", "import { EndpointError } from \"../types\";\nimport { evaluateEndpointRule } from \"./evaluateEndpointRule\";\nimport { evaluateErrorRule } from \"./evaluateErrorRule\";\nimport { evaluateTreeRule } from \"./evaluateTreeRule\";\nexport const evaluateRules = (rules, options) => {\n    for (const rule of rules) {\n        if (rule.type === \"endpoint\") {\n            const endpointOrUndefined = evaluateEndpointRule(rule, options);\n            if (endpointOrUndefined) {\n                return endpointOrUndefined;\n            }\n        }\n        else if (rule.type === \"error\") {\n            evaluateErrorRule(rule, options);\n        }\n        else if (rule.type === \"tree\") {\n            const endpointOrUndefined = evaluateTreeRule(rule, options);\n            if (endpointOrUndefined) {\n                return endpointOrUndefined;\n            }\n        }\n        else {\n            throw new EndpointError(`Unknown endpoint rule: ${rule}`);\n        }\n    }\n    throw new EndpointError(`Rules evaluation failed`);\n};\n", "import { debugId, toDebugString } from \"../debug\";\nimport { evaluateConditions } from \"./evaluateConditions\";\nimport { getEndpointHeaders } from \"./getEndpointHeaders\";\nimport { getEndpointProperties } from \"./getEndpointProperties\";\nimport { getEndpointUrl } from \"./getEndpointUrl\";\nexport const evaluateEndpointRule = (endpointRule, options) => {\n    const { conditions, endpoint } = endpointRule;\n    const { result, referenceRecord } = evaluateConditions(conditions, options);\n    if (!result) {\n        return;\n    }\n    const endpointRuleOptions = {\n        ...options,\n        referenceRecord: { ...options.referenceRecord, ...referenceRecord },\n    };\n    const { url, properties, headers } = endpoint;\n    options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);\n    return {\n        ...(headers != undefined && {\n            headers: getEndpointHeaders(headers, endpointRuleOptions),\n        }),\n        ...(properties != undefined && {\n            properties: getEndpointProperties(properties, endpointRuleOptions),\n        }),\n        url: getEndpointUrl(url, endpointRuleOptions),\n    };\n};\n", "import { debugId, toDebugString } from \"../debug\";\nimport { evaluateCondition } from \"./evaluateCondition\";\nexport const evaluateConditions = (conditions = [], options) => {\n    const conditionsReferenceRecord = {};\n    for (const condition of conditions) {\n        const { result, toAssign } = evaluateCondition(condition, {\n            ...options,\n            referenceRecord: {\n                ...options.referenceRecord,\n                ...conditionsReferenceRecord,\n            },\n        });\n        if (!result) {\n            return { result };\n        }\n        if (toAssign) {\n            conditionsReferenceRecord[toAssign.name] = toAssign.value;\n            options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);\n        }\n    }\n    return { result: true, referenceRecord: conditionsReferenceRecord };\n};\n", "import { debugId, toDebugString } from \"../debug\";\nimport { EndpointError } from \"../types\";\nimport { callFunction } from \"./callFunction\";\nexport const evaluateCondition = ({ assign, ...fnArgs }, options) => {\n    if (assign && assign in options.referenceRecord) {\n        throw new EndpointError(`'${assign}' is already defined in Reference Record.`);\n    }\n    const value = callFunction(fnArgs, options);\n    options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);\n    return {\n        result: value === \"\" ? true : !!value,\n        ...(assign != null && { toAssign: { name: assign, value } }),\n    };\n};\n", "import { customEndpointFunctions } from \"./customEndpointFunctions\";\nimport { endpointFunctions } from \"./endpointFunctions\";\nimport { evaluateExpression } from \"./evaluateExpression\";\nexport const callFunction = ({ fn, argv }, options) => {\n    const evaluatedArgs = argv.map((arg) => [\"boolean\", \"number\"].includes(typeof arg) ? arg : evaluateExpression(arg, \"arg\", options));\n    const fnSegments = fn.split(\".\");\n    if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {\n        return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);\n    }\n    return endpointFunctions[fn](...evaluatedArgs);\n};\n", "import { booleanEquals, getAttr, isSet, isValidHostLabel, not, parseURL, stringEquals, substring, uriEncode, } from \"../lib\";\nexport const endpointFunctions = {\n    booleanEquals,\n    getAttr,\n    isSet,\n    isValidHostLabel,\n    not,\n    parseURL,\n    stringEquals,\n    substring,\n    uriEncode,\n};\n", "export * from \"./booleanEquals\";\nexport * from \"./getAttr\";\nexport * from \"./isSet\";\nexport * from \"./isValidHostLabel\";\nexport * from \"./not\";\nexport * from \"./parseURL\";\nexport * from \"./stringEquals\";\nexport * from \"./substring\";\nexport * from \"./uriEncode\";\n", "export const booleanEquals = (value1, value2) => value1 === value2;\n", "import { EndpointError } from \"../types\";\nimport { getAttrPathList } from \"./getAttrPathList\";\nexport const getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {\n    if (typeof acc !== \"object\") {\n        throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);\n    }\n    else if (Array.isArray(acc)) {\n        return acc[parseInt(index)];\n    }\n    return acc[index];\n}, value);\n", "import { EndpointError } from \"../types\";\nexport const getAttrPathList = (path) => {\n    const parts = path.split(\".\");\n    const pathList = [];\n    for (const part of parts) {\n        const squareBracketIndex = part.indexOf(\"[\");\n        if (squareBracketIndex !== -1) {\n            if (part.indexOf(\"]\") !== part.length - 1) {\n                throw new EndpointError(`Path: '${path}' does not end with ']'`);\n            }\n            const arrayIndex = part.slice(squareBracketIndex + 1, -1);\n            if (Number.isNaN(parseInt(arrayIndex))) {\n                throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);\n            }\n            if (squareBracketIndex !== 0) {\n                pathList.push(part.slice(0, squareBracketIndex));\n            }\n            pathList.push(arrayIndex);\n        }\n        else {\n            pathList.push(part);\n        }\n    }\n    return pathList;\n};\n", "export const isSet = (value) => value != null;\n", "export const not = (value) => !value;\n", "import { EndpointURLScheme } from \"@smithy/types\";\nimport { isIpAddress } from \"./isIpAddress\";\nconst DEFAULT_PORTS = {\n    [EndpointURLScheme.HTTP]: 80,\n    [EndpointURLScheme.HTTPS]: 443,\n};\nexport const parseURL = (value) => {\n    const whatwgURL = (() => {\n        try {\n            if (value instanceof URL) {\n                return value;\n            }\n            if (typeof value === \"object\" && \"hostname\" in value) {\n                const { hostname, port, protocol = \"\", path = \"\", query = {} } = value;\n                const url = new URL(`${protocol}//${hostname}${port ? `:${port}` : \"\"}${path}`);\n                url.search = Object.entries(query)\n                    .map(([k, v]) => `${k}=${v}`)\n                    .join(\"&\");\n                return url;\n            }\n            return new URL(value);\n        }\n        catch (error) {\n            return null;\n        }\n    })();\n    if (!whatwgURL) {\n        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);\n        return null;\n    }\n    const urlString = whatwgURL.href;\n    const { host, hostname, pathname, protocol, search } = whatwgURL;\n    if (search) {\n        return null;\n    }\n    const scheme = protocol.slice(0, -1);\n    if (!Object.values(EndpointURLScheme).includes(scheme)) {\n        return null;\n    }\n    const isIp = isIpAddress(hostname);\n    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) ||\n        (typeof value === \"string\" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`));\n    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;\n    return {\n        scheme,\n        authority,\n        path: pathname,\n        normalizedPath: pathname.endsWith(\"/\") ? pathname : `${pathname}/`,\n        isIp,\n    };\n};\n", "export const stringEquals = (value1, value2) => value1 === value2;\n", "export const substring = (input, start, stop, reverse) => {\n    if (start >= stop || input.length < stop) {\n        return null;\n    }\n    if (!reverse) {\n        return input.substring(start, stop);\n    }\n    return input.substring(input.length - stop, input.length - start);\n};\n", "export const uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);\n", "import { EndpointError } from \"../types\";\nimport { callFunction } from \"./callFunction\";\nimport { evaluateTemplate } from \"./evaluateTemplate\";\nimport { getReferenceValue } from \"./getReferenceValue\";\nexport const evaluateExpression = (obj, keyName, options) => {\n    if (typeof obj === \"string\") {\n        return evaluateTemplate(obj, options);\n    }\n    else if (obj[\"fn\"]) {\n        return callFunction(obj, options);\n    }\n    else if (obj[\"ref\"]) {\n        return getReferenceValue(obj, options);\n    }\n    throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);\n};\n", "import { getAttr } from \"../lib\";\nexport const evaluateTemplate = (template, options) => {\n    const evaluatedTemplateArr = [];\n    const templateContext = {\n        ...options.endpointParams,\n        ...options.referenceRecord,\n    };\n    let currentIndex = 0;\n    while (currentIndex < template.length) {\n        const openingBraceIndex = template.indexOf(\"{\", currentIndex);\n        if (openingBraceIndex === -1) {\n            evaluatedTemplateArr.push(template.slice(currentIndex));\n            break;\n        }\n        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));\n        const closingBraceIndex = template.indexOf(\"}\", openingBraceIndex);\n        if (closingBraceIndex === -1) {\n            evaluatedTemplateArr.push(template.slice(openingBraceIndex));\n            break;\n        }\n        if (template[openingBraceIndex + 1] === \"{\" && template[closingBraceIndex + 1] === \"}\") {\n            evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));\n            currentIndex = closingBraceIndex + 2;\n        }\n        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);\n        if (parameterName.includes(\"#\")) {\n            const [refName, attrName] = parameterName.split(\"#\");\n            evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));\n        }\n        else {\n            evaluatedTemplateArr.push(templateContext[parameterName]);\n        }\n        currentIndex = closingBraceIndex + 1;\n    }\n    return evaluatedTemplateArr.join(\"\");\n};\n", "export const getReferenceValue = ({ ref }, options) => {\n    const referenceRecord = {\n        ...options.endpointParams,\n        ...options.referenceRecord,\n    };\n    return referenceRecord[ref];\n};\n", "import { EndpointError } from \"../types\";\nimport { evaluateExpression } from \"./evaluateExpression\";\nexport const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({\n    ...acc,\n    [headerKey]: headerVal.map((headerValEntry) => {\n        const processedExpr = evaluateExpression(headerValEntry, \"Header value entry\", options);\n        if (typeof processedExpr !== \"string\") {\n            throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);\n        }\n        return processedExpr;\n    }),\n}), {});\n", "import { getEndpointProperty } from \"./getEndpointProperty\";\nexport const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({\n    ...acc,\n    [propertyKey]: getEndpointProperty(propertyVal, options),\n}), {});\n", "import { EndpointError } from \"../types\";\nimport { evaluateTemplate } from \"./evaluateTemplate\";\nimport { getEndpointProperties } from \"./getEndpointProperties\";\nexport const getEndpointProperty = (property, options) => {\n    if (Array.isArray(property)) {\n        return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));\n    }\n    switch (typeof property) {\n        case \"string\":\n            return evaluateTemplate(property, options);\n        case \"object\":\n            if (property === null) {\n                throw new EndpointError(`Unexpected endpoint property: ${property}`);\n            }\n            return getEndpointProperties(property, options);\n        case \"boolean\":\n            return property;\n        default:\n            throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);\n    }\n};\n", "import { EndpointError } from \"../types\";\nimport { evaluateExpression } from \"./evaluateExpression\";\nexport const getEndpointUrl = (endpointUrl, options) => {\n    const expression = evaluateExpression(endpointUrl, \"Endpoint URL\", options);\n    if (typeof expression === \"string\") {\n        try {\n            return new URL(expression);\n        }\n        catch (error) {\n            console.error(`Failed to construct URL with ${expression}`, error);\n            throw error;\n        }\n    }\n    throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);\n};\n", "import { EndpointError } from \"../types\";\nimport { evaluateConditions } from \"./evaluateConditions\";\nimport { evaluateExpression } from \"./evaluateExpression\";\nexport const evaluateErrorRule = (errorRule, options) => {\n    const { conditions, error } = errorRule;\n    const { result, referenceRecord } = evaluateConditions(conditions, options);\n    if (!result) {\n        return;\n    }\n    throw new EndpointError(evaluateExpression(error, \"Error\", {\n        ...options,\n        referenceRecord: { ...options.referenceRecord, ...referenceRecord },\n    }));\n};\n", "import { evaluateConditions } from \"./evaluateConditions\";\nimport { evaluateRules } from \"./evaluateRules\";\nexport const evaluateTreeRule = (treeRule, options) => {\n    const { conditions, rules } = treeRule;\n    const { result, referenceRecord } = evaluateConditions(conditions, options);\n    if (!result) {\n        return;\n    }\n    return evaluateRules(rules, {\n        ...options,\n        referenceRecord: { ...options.referenceRecord, ...referenceRecord },\n    });\n};\n", "import { isValidHostLabel } from \"@smithy/util-endpoints\";\nimport { isIpAddress } from \"../isIpAddress\";\nexport const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {\n    if (allowSubDomains) {\n        for (const label of value.split(\".\")) {\n            if (!isVirtualHostableS3Bucket(label)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (!isValidHostLabel(value)) {\n        return false;\n    }\n    if (value.length < 3 || value.length > 63) {\n        return false;\n    }\n    if (value !== value.toLowerCase()) {\n        return false;\n    }\n    if (isIpAddress(value)) {\n        return false;\n    }\n    return true;\n};\n", "export { isIpAddress } from \"@smithy/util-endpoints\";\n", "const ARN_DELIMITER = \":\";\nconst RESOURCE_DELIMITER = \"/\";\nexport const parseArn = (value) => {\n    const segments = value.split(ARN_DELIMITER);\n    if (segments.length < 6)\n        return null;\n    const [arn, partition, service, region, accountId, ...resourcePath] = segments;\n    if (arn !== \"arn\" || partition === \"\" || service === \"\" || resourcePath.join(ARN_DELIMITER) === \"\")\n        return null;\n    const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();\n    return {\n        partition,\n        service,\n        region,\n        accountId,\n        resourceId,\n    };\n};\n", "import partitionsInfo from \"./partitions.json\";\nlet selectedPartitionsInfo = partitionsInfo;\nlet selectedUserAgentPrefix = \"\";\nexport const partition = (value) => {\n    const { partitions } = selectedPartitionsInfo;\n    for (const partition of partitions) {\n        const { regions, outputs } = partition;\n        for (const [region, regionData] of Object.entries(regions)) {\n            if (region === value) {\n                return {\n                    ...outputs,\n                    ...regionData,\n                };\n            }\n        }\n    }\n    for (const partition of partitions) {\n        const { regionRegex, outputs } = partition;\n        if (new RegExp(regionRegex).test(value)) {\n            return {\n                ...outputs,\n            };\n        }\n    }\n    const DEFAULT_PARTITION = partitions.find((partition) => partition.id === \"aws\");\n    if (!DEFAULT_PARTITION) {\n        throw new Error(\"Provided region was not found in the partition array or regex,\" +\n            \" and default partition with id 'aws' doesn't exist.\");\n    }\n    return {\n        ...DEFAULT_PARTITION.outputs,\n    };\n};\nexport const setPartitionInfo = (partitionsInfo, userAgentPrefix = \"\") => {\n    selectedPartitionsInfo = partitionsInfo;\n    selectedUserAgentPrefix = userAgentPrefix;\n};\nexport const useDefaultPartitionInfo = () => {\n    setPartitionInfo(partitionsInfo, \"\");\n};\nexport const getUserAgentPrefix = () => selectedUserAgentPrefix;\n", "{\n    \"partitions\": [{\n            \"id\": \"aws\",\n            \"outputs\": {\n                \"dnsSuffix\": \"amazonaws.com\",\n                \"dualStackDnsSuffix\": \"api.aws\",\n                \"implicitGlobalRegion\": \"us-east-1\",\n                \"name\": \"aws\",\n                \"supportsDualStack\": true,\n                \"supportsFIPS\": true\n            },\n            \"regionRegex\": \"^(us|eu|ap|sa|ca|me|af|il|mx)\\\\-\\\\w+\\\\-\\\\d+$\",\n            \"regions\": {\n                \"af-south-1\": {\n                    \"description\": \"Africa (Cape Town)\"\n                },\n                \"ap-east-1\": {\n                    \"description\": \"Asia Pacific (Hong Kong)\"\n                },\n                \"ap-northeast-1\": {\n                    \"description\": \"Asia Pacific (Tokyo)\"\n                },\n                \"ap-northeast-2\": {\n                    \"description\": \"Asia Pacific (Seoul)\"\n                },\n                \"ap-northeast-3\": {\n                    \"description\": \"Asia Pacific (Osaka)\"\n                },\n                \"ap-south-1\": {\n                    \"description\": \"Asia Pacific (Mumbai)\"\n                },\n                \"ap-south-2\": {\n                    \"description\": \"Asia Pacific (Hyderabad)\"\n                },\n                \"ap-southeast-1\": {\n                    \"description\": \"Asia Pacific (Singapore)\"\n                },\n                \"ap-southeast-2\": {\n                    \"description\": \"Asia Pacific (Sydney)\"\n                },\n                \"ap-southeast-3\": {\n                    \"description\": \"Asia Pacific (Jakarta)\"\n                },\n                \"ap-southeast-4\": {\n                    \"description\": \"Asia Pacific (Melbourne)\"\n                },\n                \"ap-southeast-5\": {\n                    \"description\": \"Asia Pacific (Malaysia)\"\n                },\n                \"ap-southeast-7\": {\n                    \"description\": \"Asia Pacific (Thailand)\"\n                },\n                \"aws-global\": {\n                    \"description\": \"AWS Standard global region\"\n                },\n                \"ca-central-1\": {\n                    \"description\": \"Canada (Central)\"\n                },\n                \"ca-west-1\": {\n                    \"description\": \"Canada West (Calgary)\"\n                },\n                \"eu-central-1\": {\n                    \"description\": \"Europe (Frankfurt)\"\n                },\n                \"eu-central-2\": {\n                    \"description\": \"Europe (Zurich)\"\n                },\n                \"eu-north-1\": {\n                    \"description\": \"Europe (Stockholm)\"\n                },\n                \"eu-south-1\": {\n                    \"description\": \"Europe (Milan)\"\n                },\n                \"eu-south-2\": {\n                    \"description\": \"Europe (Spain)\"\n                },\n                \"eu-west-1\": {\n                    \"description\": \"Europe (Ireland)\"\n                },\n                \"eu-west-2\": {\n                    \"description\": \"Europe (London)\"\n                },\n                \"eu-west-3\": {\n                    \"description\": \"Europe (Paris)\"\n                },\n                \"il-central-1\": {\n                    \"description\": \"Israel (Tel Aviv)\"\n                },\n                \"me-central-1\": {\n                    \"description\": \"Middle East (UAE)\"\n                },\n                \"me-south-1\": {\n                    \"description\": \"Middle East (Bahrain)\"\n                },\n                \"mx-central-1\": {\n                    \"description\": \"Mexico (Central)\"\n                },\n                \"sa-east-1\": {\n                    \"description\": \"South America (Sao Paulo)\"\n                },\n                \"us-east-1\": {\n                    \"description\": \"US East (N. Virginia)\"\n                },\n                \"us-east-2\": {\n                    \"description\": \"US East (Ohio)\"\n                },\n                \"us-west-1\": {\n                    \"description\": \"US West (N. California)\"\n                },\n                \"us-west-2\": {\n                    \"description\": \"US West (Oregon)\"\n                }\n            }\n        }, {\n            \"id\": \"aws-cn\",\n            \"outputs\": {\n                \"dnsSuffix\": \"amazonaws.com.cn\",\n                \"dualStackDnsSuffix\": \"api.amazonwebservices.com.cn\",\n                \"implicitGlobalRegion\": \"cn-northwest-1\",\n                \"name\": \"aws-cn\",\n                \"supportsDualStack\": true,\n                \"supportsFIPS\": true\n            },\n            \"regionRegex\": \"^cn\\\\-\\\\w+\\\\-\\\\d+$\",\n            \"regions\": {\n                \"aws-cn-global\": {\n                    \"description\": \"AWS China global region\"\n                },\n                \"cn-north-1\": {\n                    \"description\": \"China (Beijing)\"\n                },\n                \"cn-northwest-1\": {\n                    \"description\": \"China (Ningxia)\"\n                }\n            }\n        }, {\n            \"id\": \"aws-us-gov\",\n            \"outputs\": {\n                \"dnsSuffix\": \"amazonaws.com\",\n                \"dualStackDnsSuffix\": \"api.aws\",\n                \"implicitGlobalRegion\": \"us-gov-west-1\",\n                \"name\": \"aws-us-gov\",\n                \"supportsDualStack\": true,\n                \"supportsFIPS\": true\n            },\n            \"regionRegex\": \"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$\",\n            \"regions\": {\n                \"aws-us-gov-global\": {\n                    \"description\": \"AWS GovCloud (US) global region\"\n                },\n                \"us-gov-east-1\": {\n                    \"description\": \"AWS GovCloud (US-East)\"\n                },\n                \"us-gov-west-1\": {\n                    \"description\": \"AWS GovCloud (US-West)\"\n                }\n            }\n        }, {\n            \"id\": \"aws-iso\",\n            \"outputs\": {\n                \"dnsSuffix\": \"c2s.ic.gov\",\n                \"dualStackDnsSuffix\": \"c2s.ic.gov\",\n                \"implicitGlobalRegion\": \"us-iso-east-1\",\n                \"name\": \"aws-iso\",\n                \"supportsDualStack\": false,\n                \"supportsFIPS\": true\n            },\n            \"regionRegex\": \"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$\",\n            \"regions\": {\n                \"aws-iso-global\": {\n                    \"description\": \"AWS ISO (US) global region\"\n                },\n                \"us-iso-east-1\": {\n                    \"description\": \"US ISO East\"\n                },\n                \"us-iso-west-1\": {\n                    \"description\": \"US ISO WEST\"\n                }\n            }\n        }, {\n            \"id\": \"aws-iso-b\",\n            \"outputs\": {\n                \"dnsSuffix\": \"sc2s.sgov.gov\",\n                \"dualStackDnsSuffix\": \"sc2s.sgov.gov\",\n                \"implicitGlobalRegion\": \"us-isob-east-1\",\n                \"name\": \"aws-iso-b\",\n                \"supportsDualStack\": false,\n                \"supportsFIPS\": true\n            },\n            \"regionRegex\": \"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$\",\n            \"regions\": {\n                \"aws-iso-b-global\": {\n                    \"description\": \"AWS ISOB (US) global region\"\n                },\n                \"us-isob-east-1\": {\n                    \"description\": \"US ISOB East (Ohio)\"\n                }\n            }\n        }, {\n            \"id\": \"aws-iso-e\",\n            \"outputs\": {\n                \"dnsSuffix\": \"cloud.adc-e.uk\",\n                \"dualStackDnsSuffix\": \"cloud.adc-e.uk\",\n                \"implicitGlobalRegion\": \"eu-isoe-west-1\",\n                \"name\": \"aws-iso-e\",\n                \"supportsDualStack\": false,\n                \"supportsFIPS\": true\n            },\n            \"regionRegex\": \"^eu\\\\-isoe\\\\-\\\\w+\\\\-\\\\d+$\",\n            \"regions\": {\n                \"aws-iso-e-global\": {\n                    \"description\": \"AWS ISOE (Europe) global region\"\n                },\n                \"eu-isoe-west-1\": {\n                    \"description\": \"EU ISOE West\"\n                }\n            }\n        }, {\n            \"id\": \"aws-iso-f\",\n            \"outputs\": {\n                \"dnsSuffix\": \"csp.hci.ic.gov\",\n                \"dualStackDnsSuffix\": \"csp.hci.ic.gov\",\n                \"implicitGlobalRegion\": \"us-isof-south-1\",\n                \"name\": \"aws-iso-f\",\n                \"supportsDualStack\": false,\n                \"supportsFIPS\": true\n            },\n            \"regionRegex\": \"^us\\\\-isof\\\\-\\\\w+\\\\-\\\\d+$\",\n            \"regions\": {\n                \"aws-iso-f-global\": {\n                    \"description\": \"AWS ISOF global region\"\n                },\n                \"us-isof-east-1\": {\n                    \"description\": \"US ISOF EAST\"\n                },\n                \"us-isof-south-1\": {\n                    \"description\": \"US ISOF SOUTH\"\n                }\n            }\n        }, {\n            \"id\": \"aws-eusc\",\n            \"outputs\": {\n                \"dnsSuffix\": \"amazonaws.eu\",\n                \"dualStackDnsSuffix\": \"amazonaws.eu\",\n                \"implicitGlobalRegion\": \"eusc-de-east-1\",\n                \"name\": \"aws-eusc\",\n                \"supportsDualStack\": false,\n                \"supportsFIPS\": true\n            },\n            \"regionRegex\": \"^eusc\\\\-(de)\\\\-\\\\w+\\\\-\\\\d+$\",\n            \"regions\": {\n                \"eusc-de-east-1\": {\n                    \"description\": \"EU (Germany)\"\n                }\n            }\n        }],\n    \"version\": \"1.1\"\n}\n", "export { resolveEndpoint } from \"@smithy/util-endpoints\";\n", "export * from \"./EndpointError\";\nexport * from \"./EndpointRuleObject\";\nexport * from \"./ErrorRuleObject\";\nexport * from \"./RuleSetObject\";\nexport * from \"./TreeRuleObject\";\nexport * from \"./shared\";\n", "export { EndpointError } from \"@smithy/util-endpoints\";\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "import { setFeature } from \"@aws-sdk/core\";\nconst ACCOUNT_ID_ENDPOINT_REGEX = /\\d{12}\\.ddb/;\nexport async function checkFeatures(context, config, args) {\n    const request = args.request;\n    if (request?.headers?.[\"smithy-protocol\"] === \"rpc-v2-cbor\") {\n        setFeature(context, \"PROTOCOL_RPC_V2_CBOR\", \"M\");\n    }\n    if (typeof config.retryStrategy === \"function\") {\n        const retryStrategy = await config.retryStrategy();\n        if (typeof retryStrategy.acquireInitialRetryToken === \"function\") {\n            if (retryStrategy.constructor?.name?.includes(\"Adaptive\")) {\n                setFeature(context, \"RETRY_MODE_ADAPTIVE\", \"F\");\n            }\n            else {\n                setFeature(context, \"RETRY_MODE_STANDARD\", \"E\");\n            }\n        }\n        else {\n            setFeature(context, \"RETRY_MODE_LEGACY\", \"D\");\n        }\n    }\n    if (typeof config.accountIdEndpointMode === \"function\") {\n        const endpointV2 = context.endpointV2;\n        if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) {\n            setFeature(context, \"ACCOUNT_ID_ENDPOINT\", \"O\");\n        }\n        switch (await config.accountIdEndpointMode?.()) {\n            case \"disabled\":\n                setFeature(context, \"ACCOUNT_ID_MODE_DISABLED\", \"Q\");\n                break;\n            case \"preferred\":\n                setFeature(context, \"ACCOUNT_ID_MODE_PREFERRED\", \"P\");\n                break;\n            case \"required\":\n                setFeature(context, \"ACCOUNT_ID_MODE_REQUIRED\", \"R\");\n                break;\n        }\n    }\n    const identity = context.__smithy_context?.selectedHttpAuthScheme?.identity;\n    if (identity?.$source) {\n        const credentials = identity;\n        if (credentials.accountId) {\n            setFeature(context, \"RESOLVED_ACCOUNT_ID\", \"T\");\n        }\n        for (const [key, value] of Object.entries(credentials.$source ?? {})) {\n            setFeature(context, key, value);\n        }\n    }\n}\n", "export function setCredentialFeature(credentials, feature, value) {\n    if (!credentials.$source) {\n        credentials.$source = {};\n    }\n    credentials.$source[feature] = value;\n    return credentials;\n}\n", "export function setFeature(context, feature, value) {\n    if (!context.__aws_sdk_context) {\n        context.__aws_sdk_context = {\n            features: {},\n        };\n    }\n    else if (!context.__aws_sdk_context.features) {\n        context.__aws_sdk_context.features = {};\n    }\n    context.__aws_sdk_context.features[feature] = value;\n}\n", "export { AwsSdkSigV4Signer, AWSSDKSigV4Signer, validateSigningProperties } from \"./AwsSdkSigV4Signer\";\nexport { AwsSdkSigV4ASigner } from \"./AwsSdkSigV4ASigner\";\nexport * from \"./NODE_AUTH_SCHEME_PREFERENCE_OPTIONS\";\nexport * from \"./resolveAwsSdkSigV4AConfig\";\nexport * from \"./resolveAwsSdkSigV4Config\";\n", "import { HttpRequest } from \"@smithy/protocol-http\";\nimport { getDateHeader, getSkewCorrectedDate, getUpdatedSystemClockOffset } from \"../utils\";\nconst throwSigningPropertyError = (name, property) => {\n    if (!property) {\n        throw new Error(`Property \\`${name}\\` is not resolved for AWS SDK SigV4Auth`);\n    }\n    return property;\n};\nexport const validateSigningProperties = async (signingProperties) => {\n    const context = throwSigningPropertyError(\"context\", signingProperties.context);\n    const config = throwSigningPropertyError(\"config\", signingProperties.config);\n    const authScheme = context.endpointV2?.properties?.authSchemes?.[0];\n    const signerFunction = throwSigningPropertyError(\"signer\", config.signer);\n    const signer = await signerFunction(authScheme);\n    const signingRegion = signingProperties?.signingRegion;\n    const signingRegionSet = signingProperties?.signingRegionSet;\n    const signingName = signingProperties?.signingName;\n    return {\n        config,\n        signer,\n        signingRegion,\n        signingRegionSet,\n        signingName,\n    };\n};\nexport class AwsSdkSigV4Signer {\n    async sign(httpRequest, identity, signingProperties) {\n        if (!HttpRequest.isInstance(httpRequest)) {\n            throw new Error(\"The request is not an instance of `HttpRequest` and cannot be signed\");\n        }\n        const validatedProps = await validateSigningProperties(signingProperties);\n        const { config, signer } = validatedProps;\n        let { signingRegion, signingName } = validatedProps;\n        const handlerExecutionContext = signingProperties.context;\n        if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {\n            const [first, second] = handlerExecutionContext.authSchemes;\n            if (first?.name === \"sigv4a\" && second?.name === \"sigv4\") {\n                signingRegion = second?.signingRegion ?? signingRegion;\n                signingName = second?.signingName ?? signingName;\n            }\n        }\n        const signedRequest = await signer.sign(httpRequest, {\n            signingDate: getSkewCorrectedDate(config.systemClockOffset),\n            signingRegion: signingRegion,\n            signingService: signingName,\n        });\n        return signedRequest;\n    }\n    errorHandler(signingProperties) {\n        return (error) => {\n            const serverTime = error.ServerTime ?? getDateHeader(error.$response);\n            if (serverTime) {\n                const config = throwSigningPropertyError(\"config\", signingProperties.config);\n                const initialSystemClockOffset = config.systemClockOffset;\n                config.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config.systemClockOffset);\n                const clockSkewCorrected = config.systemClockOffset !== initialSystemClockOffset;\n                if (clockSkewCorrected && error.$metadata) {\n                    error.$metadata.clockSkewCorrected = true;\n                }\n            }\n            throw error;\n        };\n    }\n    successHandler(httpResponse, signingProperties) {\n        const dateHeader = getDateHeader(httpResponse);\n        if (dateHeader) {\n            const config = throwSigningPropertyError(\"config\", signingProperties.config);\n            config.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config.systemClockOffset);\n        }\n    }\n}\nexport const AWSSDKSigV4Signer = AwsSdkSigV4Signer;\n", "import { HttpResponse } from \"@smithy/protocol-http\";\nexport const getDateHeader = (response) => HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : undefined;\n", "export const getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);\n", "import { isClockSkewed } from \"./isClockSkewed\";\nexport const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {\n    const clockTimeInMs = Date.parse(clockTime);\n    if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {\n        return clockTimeInMs - Date.now();\n    }\n    return currentSystemClockOffset;\n};\n", "import { getSkewCorrectedDate } from \"./getSkewCorrectedDate\";\nexport const isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 300000;\n", "export * from \"./CredentialsProviderError\";\nexport * from \"./ProviderError\";\nexport * from \"./TokenProviderError\";\nexport * from \"./chain\";\nexport * from \"./fromStatic\";\nexport * from \"./memoize\";\n", "import { ProviderError } from \"./ProviderError\";\nexport class CredentialsProviderError extends ProviderError {\n    constructor(message, options = true) {\n        super(message, options);\n        this.name = \"CredentialsProviderError\";\n        Object.setPrototypeOf(this, CredentialsProviderError.prototype);\n    }\n}\n", "export class ProviderError extends Error {\n    constructor(message, options = true) {\n        let logger;\n        let tryNextLink = true;\n        if (typeof options === \"boolean\") {\n            logger = undefined;\n            tryNextLink = options;\n        }\n        else if (options != null && typeof options === \"object\") {\n            logger = options.logger;\n            tryNextLink = options.tryNextLink ?? true;\n        }\n        super(message);\n        this.name = \"ProviderError\";\n        this.tryNextLink = tryNextLink;\n        Object.setPrototypeOf(this, ProviderError.prototype);\n        logger?.debug?.(`@smithy/property-provider ${tryNextLink ? \"->\" : \"(!)\"} ${message}`);\n    }\n    static from(error, options = true) {\n        return Object.assign(new this(error.message, options), error);\n    }\n}\n", "import { ProviderError } from \"./ProviderError\";\nexport class TokenProviderError extends ProviderError {\n    constructor(message, options = true) {\n        super(message, options);\n        this.name = \"TokenProviderError\";\n        Object.setPrototypeOf(this, TokenProviderError.prototype);\n    }\n}\n", "import { ProviderError } from \"./ProviderError\";\nexport const chain = (...providers) => async () => {\n    if (providers.length === 0) {\n        throw new ProviderError(\"No providers in chain\");\n    }\n    let lastProviderError;\n    for (const provider of providers) {\n        try {\n            const credentials = await provider();\n            return credentials;\n        }\n        catch (err) {\n            lastProviderError = err;\n            if (err?.tryNextLink) {\n                continue;\n            }\n            throw err;\n        }\n    }\n    throw lastProviderError;\n};\n", "export const fromStatic = (staticValue) => () => Promise.resolve(staticValue);\n", "export const memoize = (provider, isExpired, requiresRefresh) => {\n    let resolved;\n    let pending;\n    let hasResult;\n    let isConstant = false;\n    const coalesceProvider = async () => {\n        if (!pending) {\n            pending = provider();\n        }\n        try {\n            resolved = await pending;\n            hasResult = true;\n            isConstant = false;\n        }\n        finally {\n            pending = undefined;\n        }\n        return resolved;\n    };\n    if (isExpired === undefined) {\n        return async (options) => {\n            if (!hasResult || options?.forceRefresh) {\n                resolved = await coalesceProvider();\n            }\n            return resolved;\n        };\n    }\n    return async (options) => {\n        if (!hasResult || options?.forceRefresh) {\n            resolved = await coalesceProvider();\n        }\n        if (isConstant) {\n            return resolved;\n        }\n        if (requiresRefresh && !requiresRefresh(resolved)) {\n            isConstant = true;\n            return resolved;\n        }\n        if (isExpired(resolved)) {\n            await coalesceProvider();\n            return resolved;\n        }\n        return resolved;\n    };\n};\n", "import { setCredentialFeature } from \"@aws-sdk/core/client\";\nimport { doesIdentityRequireRefresh, isIdentityExpired, memoizeIdentityProvider, normalizeProvider, } from \"@smithy/core\";\nimport { SignatureV4 } from \"@smithy/signature-v4\";\nexport const resolveAwsSdkSigV4Config = (config) => {\n    let inputCredentials = config.credentials;\n    let isUserSupplied = !!config.credentials;\n    let resolvedCredentials = undefined;\n    Object.defineProperty(config, \"credentials\", {\n        set(credentials) {\n            if (credentials && credentials !== inputCredentials && credentials !== resolvedCredentials) {\n                isUserSupplied = true;\n            }\n            inputCredentials = credentials;\n            const memoizedProvider = normalizeCredentialProvider(config, {\n                credentials: inputCredentials,\n                credentialDefaultProvider: config.credentialDefaultProvider,\n            });\n            const boundProvider = bindCallerConfig(config, memoizedProvider);\n            if (isUserSupplied && !boundProvider.attributed) {\n                resolvedCredentials = async (options) => boundProvider(options).then((creds) => setCredentialFeature(creds, \"CREDENTIALS_CODE\", \"e\"));\n                resolvedCredentials.memoized = boundProvider.memoized;\n                resolvedCredentials.configBound = boundProvider.configBound;\n                resolvedCredentials.attributed = true;\n            }\n            else {\n                resolvedCredentials = boundProvider;\n            }\n        },\n        get() {\n            return resolvedCredentials;\n        },\n        enumerable: true,\n        configurable: true,\n    });\n    config.credentials = inputCredentials;\n    const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256, } = config;\n    let signer;\n    if (config.signer) {\n        signer = normalizeProvider(config.signer);\n    }\n    else if (config.regionInfoProvider) {\n        signer = () => normalizeProvider(config.region)()\n            .then(async (region) => [\n            (await config.regionInfoProvider(region, {\n                useFipsEndpoint: await config.useFipsEndpoint(),\n                useDualstackEndpoint: await config.useDualstackEndpoint(),\n            })) || {},\n            region,\n        ])\n            .then(([regionInfo, region]) => {\n            const { signingRegion, signingService } = regionInfo;\n            config.signingRegion = config.signingRegion || signingRegion || region;\n            config.signingName = config.signingName || signingService || config.serviceId;\n            const params = {\n                ...config,\n                credentials: config.credentials,\n                region: config.signingRegion,\n                service: config.signingName,\n                sha256,\n                uriEscapePath: signingEscapePath,\n            };\n            const SignerCtor = config.signerConstructor || SignatureV4;\n            return new SignerCtor(params);\n        });\n    }\n    else {\n        signer = async (authScheme) => {\n            authScheme = Object.assign({}, {\n                name: \"sigv4\",\n                signingName: config.signingName || config.defaultSigningName,\n                signingRegion: await normalizeProvider(config.region)(),\n                properties: {},\n            }, authScheme);\n            const signingRegion = authScheme.signingRegion;\n            const signingService = authScheme.signingName;\n            config.signingRegion = config.signingRegion || signingRegion;\n            config.signingName = config.signingName || signingService || config.serviceId;\n            const params = {\n                ...config,\n                credentials: config.credentials,\n                region: config.signingRegion,\n                service: config.signingName,\n                sha256,\n                uriEscapePath: signingEscapePath,\n            };\n            const SignerCtor = config.signerConstructor || SignatureV4;\n            return new SignerCtor(params);\n        };\n    }\n    const resolvedConfig = Object.assign(config, {\n        systemClockOffset,\n        signingEscapePath,\n        signer,\n    });\n    return resolvedConfig;\n};\nexport const resolveAWSSDKSigV4Config = resolveAwsSdkSigV4Config;\nfunction normalizeCredentialProvider(config, { credentials, credentialDefaultProvider, }) {\n    let credentialsProvider;\n    if (credentials) {\n        if (!credentials?.memoized) {\n            credentialsProvider = memoizeIdentityProvider(credentials, isIdentityExpired, doesIdentityRequireRefresh);\n        }\n        else {\n            credentialsProvider = credentials;\n        }\n    }\n    else {\n        if (credentialDefaultProvider) {\n            credentialsProvider = normalizeProvider(credentialDefaultProvider(Object.assign({}, config, {\n                parentClientConfig: config,\n            })));\n        }\n        else {\n            credentialsProvider = async () => {\n                throw new Error(\"@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.\");\n            };\n        }\n    }\n    credentialsProvider.memoized = true;\n    return credentialsProvider;\n}\nfunction bindCallerConfig(config, credentialsProvider) {\n    if (credentialsProvider.configBound) {\n        return credentialsProvider;\n    }\n    const fn = async (options) => credentialsProvider({ ...options, callerClientConfig: config });\n    fn.memoized = credentialsProvider.memoized;\n    fn.configBound = true;\n    return fn;\n}\n", "export * from \"./SignatureV4\";\nexport * from \"./constants\";\nexport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nexport { getCanonicalQuery } from \"./getCanonicalQuery\";\nexport { getPayloadHash } from \"./getPayloadHash\";\nexport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nexport { prepareRequest } from \"./prepareRequest\";\nexport * from \"./credentialDerivation\";\nexport { SignatureV4Base } from \"./SignatureV4Base\";\nexport { hasHeader } from \"./headerUtil\";\nexport * from \"./signature-v4a-container\";\n", "import { toHex } from \"@smithy/util-hex-encoding\";\nimport { toUint8Array } from \"@smithy/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM, } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { HeaderFormatter } from \"./HeaderFormatter\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { SignatureV4Base } from \"./SignatureV4Base\";\nexport class SignatureV4 extends SignatureV4Base {\n    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {\n        super({\n            applyChecksum,\n            credentials,\n            region,\n            service,\n            sha256,\n            uriEscapePath,\n        });\n        this.headerFormatter = new HeaderFormatter();\n    }\n    async presign(originalRequest, options = {}) {\n        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, hoistableHeaders, signingRegion, signingService, } = options;\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { longDate, shortDate } = this.formatDate(signingDate);\n        if (expiresIn > MAX_PRESIGNED_TTL) {\n            return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n        }\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });\n        if (credentials.sessionToken) {\n            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n        }\n        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n        request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        request.query[SIGNED_HEADERS_QUERY_PARAM] = this.getCanonicalHeaderList(canonicalHeaders);\n        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));\n        return request;\n    }\n    async sign(toSign, options) {\n        if (typeof toSign === \"string\") {\n            return this.signString(toSign, options);\n        }\n        else if (toSign.headers && toSign.payload) {\n            return this.signEvent(toSign, options);\n        }\n        else if (toSign.message) {\n            return this.signMessage(toSign, options);\n        }\n        else {\n            return this.signRequest(toSign, options);\n        }\n    }\n    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate, longDate } = this.formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);\n        const hash = new this.sha256();\n        hash.update(headers);\n        const hashedHeaders = toHex(await hash.digest());\n        const stringToSign = [\n            EVENT_ALGORITHM_IDENTIFIER,\n            longDate,\n            scope,\n            priorSignature,\n            hashedHeaders,\n            hashedPayload,\n        ].join(\"\\n\");\n        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });\n    }\n    async signMessage(signableMessage, { signingDate = new Date(), signingRegion, signingService }) {\n        const promise = this.signEvent({\n            headers: this.headerFormatter.format(signableMessage.message.headers),\n            payload: signableMessage.message.body,\n        }, {\n            signingDate,\n            signingRegion,\n            signingService,\n            priorSignature: signableMessage.priorSignature,\n        });\n        return promise.then((signature) => {\n            return { message: signableMessage.message, signature };\n        });\n    }\n    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate } = this.formatDate(signingDate);\n        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const request = prepareRequest(requestToSign);\n        const { longDate, shortDate } = this.formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        request.headers[AMZ_DATE_HEADER] = longDate;\n        if (credentials.sessionToken) {\n            request.headers[TOKEN_HEADER] = credentials.sessionToken;\n        }\n        const payloadHash = await getPayloadHash(request, this.sha256);\n        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n            request.headers[SHA256_HEADER] = payloadHash;\n        }\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n        request.headers[AUTH_HEADER] =\n            `${ALGORITHM_IDENTIFIER} ` +\n                `Credential=${credentials.accessKeyId}/${scope}, ` +\n                `SignedHeaders=${this.getCanonicalHeaderList(canonicalHeaders)}, ` +\n                `Signature=${signature}`;\n        return request;\n    }\n    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest, ALGORITHM_IDENTIFIER);\n        const hash = new this.sha256(await keyPromise);\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    getSigningKey(credentials, region, shortDate, service) {\n        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n    }\n}\n", "export const ALGORITHM_QUERY_PARAM = \"X-Amz-Algorithm\";\nexport const CREDENTIAL_QUERY_PARAM = \"X-Amz-Credential\";\nexport const AMZ_DATE_QUERY_PARAM = \"X-Amz-Date\";\nexport const SIGNED_HEADERS_QUERY_PARAM = \"X-Amz-SignedHeaders\";\nexport const EXPIRES_QUERY_PARAM = \"X-Amz-Expires\";\nexport const SIGNATURE_QUERY_PARAM = \"X-Amz-Signature\";\nexport const TOKEN_QUERY_PARAM = \"X-Amz-Security-Token\";\nexport const REGION_SET_PARAM = \"X-Amz-Region-Set\";\nexport const AUTH_HEADER = \"authorization\";\nexport const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();\nexport const DATE_HEADER = \"date\";\nexport const GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];\nexport const SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();\nexport const SHA256_HEADER = \"x-amz-content-sha256\";\nexport const TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();\nexport const HOST_HEADER = \"host\";\nexport const ALWAYS_UNSIGNABLE_HEADERS = {\n    authorization: true,\n    \"cache-control\": true,\n    connection: true,\n    expect: true,\n    from: true,\n    \"keep-alive\": true,\n    \"max-forwards\": true,\n    pragma: true,\n    referer: true,\n    te: true,\n    trailer: true,\n    \"transfer-encoding\": true,\n    upgrade: true,\n    \"user-agent\": true,\n    \"x-amzn-trace-id\": true,\n};\nexport const PROXY_HEADER_PATTERN = /^proxy-/;\nexport const SEC_HEADER_PATTERN = /^sec-/;\nexport const UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i];\nexport const ALGORITHM_IDENTIFIER = \"AWS4-HMAC-SHA256\";\nexport const ALGORITHM_IDENTIFIER_V4A = \"AWS4-ECDSA-P256-SHA256\";\nexport const EVENT_ALGORITHM_IDENTIFIER = \"AWS4-HMAC-SHA256-PAYLOAD\";\nexport const UNSIGNED_PAYLOAD = \"UNSIGNED-PAYLOAD\";\nexport const MAX_CACHE_SIZE = 50;\nexport const KEY_TYPE_IDENTIFIER = \"aws4_request\";\nexport const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;\n", "import { toHex } from \"@smithy/util-hex-encoding\";\nimport { toUint8Array } from \"@smithy/util-utf8\";\nimport { KEY_TYPE_IDENTIFIER, MAX_CACHE_SIZE } from \"./constants\";\nconst signingKeyCache = {};\nconst cacheQueue = [];\nexport const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;\nexport const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {\n    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);\n    const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;\n    if (cacheKey in signingKeyCache) {\n        return signingKeyCache[cacheKey];\n    }\n    cacheQueue.push(cacheKey);\n    while (cacheQueue.length > MAX_CACHE_SIZE) {\n        delete signingKeyCache[cacheQueue.shift()];\n    }\n    let key = `AWS4${credentials.secretAccessKey}`;\n    for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {\n        key = await hmac(sha256Constructor, key, signable);\n    }\n    return (signingKeyCache[cacheKey] = key);\n};\nexport const clearCredentialCache = () => {\n    cacheQueue.length = 0;\n    Object.keys(signingKeyCache).forEach((cacheKey) => {\n        delete signingKeyCache[cacheKey];\n    });\n};\nconst hmac = (ctor, secret, data) => {\n    const hash = new ctor(secret);\n    hash.update(toUint8Array(data));\n    return hash.digest();\n};\n", "import { ALWAYS_UNSIGNABLE_HEADERS, PROXY_HEADER_PATTERN, SEC_HEADER_PATTERN } from \"./constants\";\nexport const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {\n    const canonical = {};\n    for (const headerName of Object.keys(headers).sort()) {\n        if (headers[headerName] == undefined) {\n            continue;\n        }\n        const canonicalHeaderName = headerName.toLowerCase();\n        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS ||\n            unsignableHeaders?.has(canonicalHeaderName) ||\n            PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||\n            SEC_HEADER_PATTERN.test(canonicalHeaderName)) {\n            if (!signableHeaders || (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {\n                continue;\n            }\n        }\n        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\\s+/g, \" \");\n    }\n    return canonical;\n};\n", "import { isArrayBuffer } from \"@smithy/is-array-buffer\";\nimport { toHex } from \"@smithy/util-hex-encoding\";\nimport { toUint8Array } from \"@smithy/util-utf8\";\nimport { SHA256_HEADER, UNSIGNED_PAYLOAD } from \"./constants\";\nexport const getPayloadHash = async ({ headers, body }, hashConstructor) => {\n    for (const headerName of Object.keys(headers)) {\n        if (headerName.toLowerCase() === SHA256_HEADER) {\n            return headers[headerName];\n        }\n    }\n    if (body == undefined) {\n        return \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\";\n    }\n    else if (typeof body === \"string\" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {\n        const hashCtor = new hashConstructor();\n        hashCtor.update(toUint8Array(body));\n        return toHex(await hashCtor.digest());\n    }\n    return UNSIGNED_PAYLOAD;\n};\n", "export const isArrayBuffer = (arg) => (typeof ArrayBuffer === \"function\" && arg instanceof ArrayBuffer) ||\n    Object.prototype.toString.call(arg) === \"[object ArrayBuffer]\";\n", "import { fromHex, toHex } from \"@smithy/util-hex-encoding\";\nimport { fromUtf8 } from \"@smithy/util-utf8\";\nexport class HeaderFormatter {\n    format(headers) {\n        const chunks = [];\n        for (const headerName of Object.keys(headers)) {\n            const bytes = fromUtf8(headerName);\n            chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));\n        }\n        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));\n        let position = 0;\n        for (const chunk of chunks) {\n            out.set(chunk, position);\n            position += chunk.byteLength;\n        }\n        return out;\n    }\n    formatHeaderValue(header) {\n        switch (header.type) {\n            case \"boolean\":\n                return Uint8Array.from([header.value ? 0 : 1]);\n            case \"byte\":\n                return Uint8Array.from([2, header.value]);\n            case \"short\":\n                const shortView = new DataView(new ArrayBuffer(3));\n                shortView.setUint8(0, 3);\n                shortView.setInt16(1, header.value, false);\n                return new Uint8Array(shortView.buffer);\n            case \"integer\":\n                const intView = new DataView(new ArrayBuffer(5));\n                intView.setUint8(0, 4);\n                intView.setInt32(1, header.value, false);\n                return new Uint8Array(intView.buffer);\n            case \"long\":\n                const longBytes = new Uint8Array(9);\n                longBytes[0] = 5;\n                longBytes.set(header.value.bytes, 1);\n                return longBytes;\n            case \"binary\":\n                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));\n                binView.setUint8(0, 6);\n                binView.setUint16(1, header.value.byteLength, false);\n                const binBytes = new Uint8Array(binView.buffer);\n                binBytes.set(header.value, 3);\n                return binBytes;\n            case \"string\":\n                const utf8Bytes = fromUtf8(header.value);\n                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));\n                strView.setUint8(0, 7);\n                strView.setUint16(1, utf8Bytes.byteLength, false);\n                const strBytes = new Uint8Array(strView.buffer);\n                strBytes.set(utf8Bytes, 3);\n                return strBytes;\n            case \"timestamp\":\n                const tsBytes = new Uint8Array(9);\n                tsBytes[0] = 8;\n                tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);\n                return tsBytes;\n            case \"uuid\":\n                if (!UUID_PATTERN.test(header.value)) {\n                    throw new Error(`Invalid UUID received: ${header.value}`);\n                }\n                const uuidBytes = new Uint8Array(17);\n                uuidBytes[0] = 9;\n                uuidBytes.set(fromHex(header.value.replace(/\\-/g, \"\")), 1);\n                return uuidBytes;\n        }\n    }\n}\nvar HEADER_VALUE_TYPE;\n(function (HEADER_VALUE_TYPE) {\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolTrue\"] = 0] = \"boolTrue\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolFalse\"] = 1] = \"boolFalse\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byte\"] = 2] = \"byte\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"short\"] = 3] = \"short\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"integer\"] = 4] = \"integer\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"long\"] = 5] = \"long\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byteArray\"] = 6] = \"byteArray\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"string\"] = 7] = \"string\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"timestamp\"] = 8] = \"timestamp\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"uuid\"] = 9] = \"uuid\";\n})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));\nconst UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;\nexport class Int64 {\n    constructor(bytes) {\n        this.bytes = bytes;\n        if (bytes.byteLength !== 8) {\n            throw new Error(\"Int64 buffers must be exactly 8 bytes\");\n        }\n    }\n    static fromNumber(number) {\n        if (number > 9223372036854776000 || number < -9223372036854776000) {\n            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);\n        }\n        const bytes = new Uint8Array(8);\n        for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n            bytes[i] = remaining;\n        }\n        if (number < 0) {\n            negate(bytes);\n        }\n        return new Int64(bytes);\n    }\n    valueOf() {\n        const bytes = this.bytes.slice(0);\n        const negative = bytes[0] & 0b10000000;\n        if (negative) {\n            negate(bytes);\n        }\n        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);\n    }\n    toString() {\n        return String(this.valueOf());\n    }\n}\nfunction negate(bytes) {\n    for (let i = 0; i < 8; i++) {\n        bytes[i] ^= 0xff;\n    }\n    for (let i = 7; i > -1; i--) {\n        bytes[i]++;\n        if (bytes[i] !== 0)\n            break;\n    }\n}\n", "export const hasHeader = (soughtHeader, headers) => {\n    soughtHeader = soughtHeader.toLowerCase();\n    for (const headerName of Object.keys(headers)) {\n        if (soughtHeader === headerName.toLowerCase()) {\n            return true;\n        }\n    }\n    return false;\n};\nexport const getHeaderValue = (soughtHeader, headers) => {\n    soughtHeader = soughtHeader.toLowerCase();\n    for (const headerName of Object.keys(headers)) {\n        if (soughtHeader === headerName.toLowerCase()) {\n            return headers[headerName];\n        }\n    }\n    return undefined;\n};\nexport const deleteHeader = (soughtHeader, headers) => {\n    soughtHeader = soughtHeader.toLowerCase();\n    for (const headerName of Object.keys(headers)) {\n        if (soughtHeader === headerName.toLowerCase()) {\n            delete headers[headerName];\n        }\n    }\n};\n", "import { HttpRequest } from \"@smithy/protocol-http\";\nexport const moveHeadersToQuery = (request, options = {}) => {\n    const { headers, query = {} } = HttpRequest.clone(request);\n    for (const name of Object.keys(headers)) {\n        const lname = name.toLowerCase();\n        if ((lname.slice(0, 6) === \"x-amz-\" && !options.unhoistableHeaders?.has(lname)) ||\n            options.hoistableHeaders?.has(lname)) {\n            query[name] = headers[name];\n            delete headers[name];\n        }\n    }\n    return {\n        ...request,\n        headers,\n        query,\n    };\n};\n", "import { HttpRequest } from \"@smithy/protocol-http\";\nimport { GENERATED_HEADERS } from \"./constants\";\nexport const prepareRequest = (request) => {\n    request = HttpRequest.clone(request);\n    for (const headerName of Object.keys(request.headers)) {\n        if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {\n            delete request.headers[headerName];\n        }\n    }\n    return request;\n};\n", "import { toHex } from \"@smithy/util-hex-encoding\";\nimport { normalizeProvider } from \"@smithy/util-middleware\";\nimport { escapeUri } from \"@smithy/util-uri-escape\";\nimport { toUint8Array } from \"@smithy/util-utf8\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4Base {\n    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {\n        this.service = service;\n        this.sha256 = sha256;\n        this.uriEscapePath = uriEscapePath;\n        this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n        this.regionProvider = normalizeProvider(region);\n        this.credentialProvider = normalizeProvider(credentials);\n    }\n    createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n        const sortedHeaders = Object.keys(canonicalHeaders).sort();\n        return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n    }\n    async createStringToSign(longDate, credentialScope, canonicalRequest, algorithmIdentifier) {\n        const hash = new this.sha256();\n        hash.update(toUint8Array(canonicalRequest));\n        const hashedRequest = await hash.digest();\n        return `${algorithmIdentifier}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n    }\n    getCanonicalPath({ path }) {\n        if (this.uriEscapePath) {\n            const normalizedPathSegments = [];\n            for (const pathSegment of path.split(\"/\")) {\n                if (pathSegment?.length === 0)\n                    continue;\n                if (pathSegment === \".\")\n                    continue;\n                if (pathSegment === \"..\") {\n                    normalizedPathSegments.pop();\n                }\n                else {\n                    normalizedPathSegments.push(pathSegment);\n                }\n            }\n            const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n            const doubleEncoded = escapeUri(normalizedPath);\n            return doubleEncoded.replace(/%2F/g, \"/\");\n        }\n        return path;\n    }\n    validateResolvedCredentials(credentials) {\n        if (typeof credentials !== \"object\" ||\n            typeof credentials.accessKeyId !== \"string\" ||\n            typeof credentials.secretAccessKey !== \"string\") {\n            throw new Error(\"Resolved credential object is not valid\");\n        }\n    }\n    formatDate(now) {\n        const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n        return {\n            longDate,\n            shortDate: longDate.slice(0, 8),\n        };\n    }\n    getCanonicalHeaderList(headers) {\n        return Object.keys(headers).sort().join(\";\");\n    }\n}\n", "import { escapeUri } from \"@smithy/util-uri-escape\";\nimport { SIGNATURE_HEADER } from \"./constants\";\nexport const getCanonicalQuery = ({ query = {} }) => {\n    const keys = [];\n    const serialized = {};\n    for (const key of Object.keys(query)) {\n        if (key.toLowerCase() === SIGNATURE_HEADER) {\n            continue;\n        }\n        const encodedKey = escapeUri(key);\n        keys.push(encodedKey);\n        const value = query[key];\n        if (typeof value === \"string\") {\n            serialized[encodedKey] = `${encodedKey}=${escapeUri(value)}`;\n        }\n        else if (Array.isArray(value)) {\n            serialized[encodedKey] = value\n                .slice(0)\n                .reduce((encoded, value) => encoded.concat([`${encodedKey}=${escapeUri(value)}`]), [])\n                .sort()\n                .join(\"&\");\n        }\n    }\n    return keys\n        .sort()\n        .map((key) => serialized[key])\n        .filter((serialized) => serialized)\n        .join(\"&\");\n};\n", "export const iso8601 = (time) => toDate(time)\n    .toISOString()\n    .replace(/\\.\\d{3}Z$/, \"Z\");\nexport const toDate = (time) => {\n    if (typeof time === \"number\") {\n        return new Date(time * 1000);\n    }\n    if (typeof time === \"string\") {\n        if (Number(time)) {\n            return new Date(Number(time) * 1000);\n        }\n        return new Date(time);\n    }\n    return time;\n};\n", "export const signatureV4aContainer = {\n    SignatureV4a: null,\n};\n", "export * from \"./client\";\nexport * from \"./collect-stream-body\";\nexport * from \"./command\";\nexport * from \"./constants\";\nexport * from \"./create-aggregated-client\";\nexport * from \"./default-error-handler\";\nexport * from \"./defaults-mode\";\nexport * from \"./emitWarningIfUnsupportedVersion\";\nexport * from \"./exceptions\";\nexport * from \"./extended-encode-uri-component\";\nexport * from \"./extensions\";\nexport * from \"./get-array-if-single-item\";\nexport * from \"./get-value-from-text-node\";\nexport * from \"./is-serializable-header-value\";\nexport * from \"./NoOpLogger\";\nexport * from \"./object-mapping\";\nexport * from \"./resolve-path\";\nexport * from \"./ser-utils\";\nexport * from \"./serde-json\";\nexport * from \"@smithy/core/serde\";\n", "import { constructStack } from \"@smithy/middleware-stack\";\nexport class Client {\n    constructor(config) {\n        this.config = config;\n        this.middlewareStack = constructStack();\n    }\n    send(command, optionsOrCb, cb) {\n        const options = typeof optionsOrCb !== \"function\" ? optionsOrCb : undefined;\n        const callback = typeof optionsOrCb === \"function\" ? optionsOrCb : cb;\n        const useHandlerCache = options === undefined && this.config.cacheMiddleware === true;\n        let handler;\n        if (useHandlerCache) {\n            if (!this.handlers) {\n                this.handlers = new WeakMap();\n            }\n            const handlers = this.handlers;\n            if (handlers.has(command.constructor)) {\n                handler = handlers.get(command.constructor);\n            }\n            else {\n                handler = command.resolveMiddleware(this.middlewareStack, this.config, options);\n                handlers.set(command.constructor, handler);\n            }\n        }\n        else {\n            delete this.handlers;\n            handler = command.resolveMiddleware(this.middlewareStack, this.config, options);\n        }\n        if (callback) {\n            handler(command)\n                .then((result) => callback(null, result.output), (err) => callback(err))\n                .catch(() => { });\n        }\n        else {\n            return handler(command).then((result) => result.output);\n        }\n    }\n    destroy() {\n        this.config?.requestHandler?.destroy?.();\n        delete this.handlers;\n    }\n}\n", "export * from \"./MiddlewareStack\";\n", "const getAllAliases = (name, aliases) => {\n    const _aliases = [];\n    if (name) {\n        _aliases.push(name);\n    }\n    if (aliases) {\n        for (const alias of aliases) {\n            _aliases.push(alias);\n        }\n    }\n    return _aliases;\n};\nconst getMiddlewareNameWithAliases = (name, aliases) => {\n    return `${name || \"anonymous\"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(\",\")})` : \"\"}`;\n};\nexport const constructStack = () => {\n    let absoluteEntries = [];\n    let relativeEntries = [];\n    let identifyOnResolve = false;\n    const entriesNameSet = new Set();\n    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||\n        priorityWeights[b.priority || \"normal\"] - priorityWeights[a.priority || \"normal\"]);\n    const removeByName = (toRemove) => {\n        let isRemoved = false;\n        const filterCb = (entry) => {\n            const aliases = getAllAliases(entry.name, entry.aliases);\n            if (aliases.includes(toRemove)) {\n                isRemoved = true;\n                for (const alias of aliases) {\n                    entriesNameSet.delete(alias);\n                }\n                return false;\n            }\n            return true;\n        };\n        absoluteEntries = absoluteEntries.filter(filterCb);\n        relativeEntries = relativeEntries.filter(filterCb);\n        return isRemoved;\n    };\n    const removeByReference = (toRemove) => {\n        let isRemoved = false;\n        const filterCb = (entry) => {\n            if (entry.middleware === toRemove) {\n                isRemoved = true;\n                for (const alias of getAllAliases(entry.name, entry.aliases)) {\n                    entriesNameSet.delete(alias);\n                }\n                return false;\n            }\n            return true;\n        };\n        absoluteEntries = absoluteEntries.filter(filterCb);\n        relativeEntries = relativeEntries.filter(filterCb);\n        return isRemoved;\n    };\n    const cloneTo = (toStack) => {\n        absoluteEntries.forEach((entry) => {\n            toStack.add(entry.middleware, { ...entry });\n        });\n        relativeEntries.forEach((entry) => {\n            toStack.addRelativeTo(entry.middleware, { ...entry });\n        });\n        toStack.identifyOnResolve?.(stack.identifyOnResolve());\n        return toStack;\n    };\n    const expandRelativeMiddlewareList = (from) => {\n        const expandedMiddlewareList = [];\n        from.before.forEach((entry) => {\n            if (entry.before.length === 0 && entry.after.length === 0) {\n                expandedMiddlewareList.push(entry);\n            }\n            else {\n                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));\n            }\n        });\n        expandedMiddlewareList.push(from);\n        from.after.reverse().forEach((entry) => {\n            if (entry.before.length === 0 && entry.after.length === 0) {\n                expandedMiddlewareList.push(entry);\n            }\n            else {\n                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));\n            }\n        });\n        return expandedMiddlewareList;\n    };\n    const getMiddlewareList = (debug = false) => {\n        const normalizedAbsoluteEntries = [];\n        const normalizedRelativeEntries = [];\n        const normalizedEntriesNameMap = {};\n        absoluteEntries.forEach((entry) => {\n            const normalizedEntry = {\n                ...entry,\n                before: [],\n                after: [],\n            };\n            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {\n                normalizedEntriesNameMap[alias] = normalizedEntry;\n            }\n            normalizedAbsoluteEntries.push(normalizedEntry);\n        });\n        relativeEntries.forEach((entry) => {\n            const normalizedEntry = {\n                ...entry,\n                before: [],\n                after: [],\n            };\n            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {\n                normalizedEntriesNameMap[alias] = normalizedEntry;\n            }\n            normalizedRelativeEntries.push(normalizedEntry);\n        });\n        normalizedRelativeEntries.forEach((entry) => {\n            if (entry.toMiddleware) {\n                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];\n                if (toMiddleware === undefined) {\n                    if (debug) {\n                        return;\n                    }\n                    throw new Error(`${entry.toMiddleware} is not found when adding ` +\n                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +\n                        `middleware ${entry.relation} ${entry.toMiddleware}`);\n                }\n                if (entry.relation === \"after\") {\n                    toMiddleware.after.push(entry);\n                }\n                if (entry.relation === \"before\") {\n                    toMiddleware.before.push(entry);\n                }\n            }\n        });\n        const mainChain = sort(normalizedAbsoluteEntries)\n            .map(expandRelativeMiddlewareList)\n            .reduce((wholeList, expandedMiddlewareList) => {\n            wholeList.push(...expandedMiddlewareList);\n            return wholeList;\n        }, []);\n        return mainChain;\n    };\n    const stack = {\n        add: (middleware, options = {}) => {\n            const { name, override, aliases: _aliases } = options;\n            const entry = {\n                step: \"initialize\",\n                priority: \"normal\",\n                middleware,\n                ...options,\n            };\n            const aliases = getAllAliases(name, _aliases);\n            if (aliases.length > 0) {\n                if (aliases.some((alias) => entriesNameSet.has(alias))) {\n                    if (!override)\n                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);\n                    for (const alias of aliases) {\n                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));\n                        if (toOverrideIndex === -1) {\n                            continue;\n                        }\n                        const toOverride = absoluteEntries[toOverrideIndex];\n                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {\n                            throw new Error(`\"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}\" middleware with ` +\n                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +\n                                `be overridden by \"${getMiddlewareNameWithAliases(name, _aliases)}\" middleware with ` +\n                                `${entry.priority} priority in ${entry.step} step.`);\n                        }\n                        absoluteEntries.splice(toOverrideIndex, 1);\n                    }\n                }\n                for (const alias of aliases) {\n                    entriesNameSet.add(alias);\n                }\n            }\n            absoluteEntries.push(entry);\n        },\n        addRelativeTo: (middleware, options) => {\n            const { name, override, aliases: _aliases } = options;\n            const entry = {\n                middleware,\n                ...options,\n            };\n            const aliases = getAllAliases(name, _aliases);\n            if (aliases.length > 0) {\n                if (aliases.some((alias) => entriesNameSet.has(alias))) {\n                    if (!override)\n                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);\n                    for (const alias of aliases) {\n                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));\n                        if (toOverrideIndex === -1) {\n                            continue;\n                        }\n                        const toOverride = relativeEntries[toOverrideIndex];\n                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {\n                            throw new Error(`\"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}\" middleware ` +\n                                `${toOverride.relation} \"${toOverride.toMiddleware}\" middleware cannot be overridden ` +\n                                `by \"${getMiddlewareNameWithAliases(name, _aliases)}\" middleware ${entry.relation} ` +\n                                `\"${entry.toMiddleware}\" middleware.`);\n                        }\n                        relativeEntries.splice(toOverrideIndex, 1);\n                    }\n                }\n                for (const alias of aliases) {\n                    entriesNameSet.add(alias);\n                }\n            }\n            relativeEntries.push(entry);\n        },\n        clone: () => cloneTo(constructStack()),\n        use: (plugin) => {\n            plugin.applyToStack(stack);\n        },\n        remove: (toRemove) => {\n            if (typeof toRemove === \"string\")\n                return removeByName(toRemove);\n            else\n                return removeByReference(toRemove);\n        },\n        removeByTag: (toRemove) => {\n            let isRemoved = false;\n            const filterCb = (entry) => {\n                const { tags, name, aliases: _aliases } = entry;\n                if (tags && tags.includes(toRemove)) {\n                    const aliases = getAllAliases(name, _aliases);\n                    for (const alias of aliases) {\n                        entriesNameSet.delete(alias);\n                    }\n                    isRemoved = true;\n                    return false;\n                }\n                return true;\n            };\n            absoluteEntries = absoluteEntries.filter(filterCb);\n            relativeEntries = relativeEntries.filter(filterCb);\n            return isRemoved;\n        },\n        concat: (from) => {\n            const cloned = cloneTo(constructStack());\n            cloned.use(from);\n            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));\n            return cloned;\n        },\n        applyToStack: cloneTo,\n        identify: () => {\n            return getMiddlewareList(true).map((mw) => {\n                const step = mw.step ??\n                    mw.relation +\n                        \" \" +\n                        mw.toMiddleware;\n                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + \" - \" + step;\n            });\n        },\n        identifyOnResolve(toggle) {\n            if (typeof toggle === \"boolean\")\n                identifyOnResolve = toggle;\n            return identifyOnResolve;\n        },\n        resolve: (handler, context) => {\n            for (const middleware of getMiddlewareList()\n                .map((entry) => entry.middleware)\n                .reverse()) {\n                handler = middleware(handler, context);\n            }\n            if (identifyOnResolve) {\n                console.log(stack.identify());\n            }\n            return handler;\n        },\n    };\n    return stack;\n};\nconst stepWeights = {\n    initialize: 5,\n    serialize: 4,\n    build: 3,\n    finalizeRequest: 2,\n    deserialize: 1,\n};\nconst priorityWeights = {\n    high: 3,\n    normal: 2,\n    low: 1,\n};\n", "export { collectBody } from \"@smithy/core/protocols\";\n", "import { constructStack } from \"@smithy/middleware-stack\";\nimport { SMITHY_CONTEXT_KEY } from \"@smithy/types\";\nexport class Command {\n    constructor() {\n        this.middlewareStack = constructStack();\n    }\n    static classBuilder() {\n        return new ClassBuilder();\n    }\n    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {\n        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {\n            this.middlewareStack.use(mw);\n        }\n        const stack = clientStack.concat(this.middlewareStack);\n        const { logger } = configuration;\n        const handlerExecutionContext = {\n            logger,\n            clientName,\n            commandName,\n            inputFilterSensitiveLog,\n            outputFilterSensitiveLog,\n            [SMITHY_CONTEXT_KEY]: {\n                commandInstance: this,\n                ...smithyContext,\n            },\n            ...additionalContext,\n        };\n        const { requestHandler } = configuration;\n        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);\n    }\n}\nclass ClassBuilder {\n    constructor() {\n        this._init = () => { };\n        this._ep = {};\n        this._middlewareFn = () => [];\n        this._commandName = \"\";\n        this._clientName = \"\";\n        this._additionalContext = {};\n        this._smithyContext = {};\n        this._inputFilterSensitiveLog = (_) => _;\n        this._outputFilterSensitiveLog = (_) => _;\n        this._serializer = null;\n        this._deserializer = null;\n    }\n    init(cb) {\n        this._init = cb;\n    }\n    ep(endpointParameterInstructions) {\n        this._ep = endpointParameterInstructions;\n        return this;\n    }\n    m(middlewareSupplier) {\n        this._middlewareFn = middlewareSupplier;\n        return this;\n    }\n    s(service, operation, smithyContext = {}) {\n        this._smithyContext = {\n            service,\n            operation,\n            ...smithyContext,\n        };\n        return this;\n    }\n    c(additionalContext = {}) {\n        this._additionalContext = additionalContext;\n        return this;\n    }\n    n(clientName, commandName) {\n        this._clientName = clientName;\n        this._commandName = commandName;\n        return this;\n    }\n    f(inputFilter = (_) => _, outputFilter = (_) => _) {\n        this._inputFilterSensitiveLog = inputFilter;\n        this._outputFilterSensitiveLog = outputFilter;\n        return this;\n    }\n    ser(serializer) {\n        this._serializer = serializer;\n        return this;\n    }\n    de(deserializer) {\n        this._deserializer = deserializer;\n        return this;\n    }\n    build() {\n        const closure = this;\n        let CommandRef;\n        return (CommandRef = class extends Command {\n            static getEndpointParameterInstructions() {\n                return closure._ep;\n            }\n            constructor(...[input]) {\n                super();\n                this.serialize = closure._serializer;\n                this.deserialize = closure._deserializer;\n                this.input = input ?? {};\n                closure._init(this);\n            }\n            resolveMiddleware(stack, configuration, options) {\n                return this.resolveMiddlewareWithContext(stack, configuration, options, {\n                    CommandCtor: CommandRef,\n                    middlewareFn: closure._middlewareFn,\n                    clientName: closure._clientName,\n                    commandName: closure._commandName,\n                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,\n                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,\n                    smithyContext: closure._smithyContext,\n                    additionalContext: closure._additionalContext,\n                });\n            }\n        });\n    }\n}\n", "export const SENSITIVE_STRING = \"***SensitiveInformation***\";\n", "export const createAggregatedClient = (commands, Client) => {\n    for (const command of Object.keys(commands)) {\n        const CommandCtor = commands[command];\n        const methodImpl = async function (args, optionsOrCb, cb) {\n            const command = new CommandCtor(args);\n            if (typeof optionsOrCb === \"function\") {\n                this.send(command, optionsOrCb);\n            }\n            else if (typeof cb === \"function\") {\n                if (typeof optionsOrCb !== \"object\")\n                    throw new Error(`Expected http options but got ${typeof optionsOrCb}`);\n                this.send(command, optionsOrCb || {}, cb);\n            }\n            else {\n                return this.send(command, optionsOrCb);\n            }\n        };\n        const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, \"\");\n        Client.prototype[methodName] = methodImpl;\n    }\n};\n", "import { decorateServiceException } from \"./exceptions\";\nexport const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {\n    const $metadata = deserializeMetadata(output);\n    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + \"\" : undefined;\n    const response = new exceptionCtor({\n        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || \"UnknownError\",\n        $fault: \"client\",\n        $metadata,\n    });\n    throw decorateServiceException(response, parsedBody);\n};\nexport const withBaseException = (ExceptionCtor) => {\n    return ({ output, parsedBody, errorCode }) => {\n        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });\n    };\n};\nconst deserializeMetadata = (output) => ({\n    httpStatusCode: output.statusCode,\n    requestId: output.headers[\"x-amzn-requestid\"] ?? output.headers[\"x-amzn-request-id\"] ?? output.headers[\"x-amz-request-id\"],\n    extendedRequestId: output.headers[\"x-amz-id-2\"],\n    cfId: output.headers[\"x-amz-cf-id\"],\n});\n", "export class ServiceException extends Error {\n    constructor(options) {\n        super(options.message);\n        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype);\n        this.name = options.name;\n        this.$fault = options.$fault;\n        this.$metadata = options.$metadata;\n    }\n    static isInstance(value) {\n        if (!value)\n            return false;\n        const candidate = value;\n        return (ServiceException.prototype.isPrototypeOf(candidate) ||\n            (Boolean(candidate.$fault) &&\n                Boolean(candidate.$metadata) &&\n                (candidate.$fault === \"client\" || candidate.$fault === \"server\")));\n    }\n    static [Symbol.hasInstance](instance) {\n        if (!instance)\n            return false;\n        const candidate = instance;\n        if (this === ServiceException) {\n            return ServiceException.isInstance(instance);\n        }\n        if (ServiceException.isInstance(instance)) {\n            if (candidate.name && this.name) {\n                return this.prototype.isPrototypeOf(instance) || candidate.name === this.name;\n            }\n            return this.prototype.isPrototypeOf(instance);\n        }\n        return false;\n    }\n}\nexport const decorateServiceException = (exception, additions = {}) => {\n    Object.entries(additions)\n        .filter(([, v]) => v !== undefined)\n        .forEach(([k, v]) => {\n        if (exception[k] == undefined || exception[k] === \"\") {\n            exception[k] = v;\n        }\n    });\n    const message = exception.message || exception.Message || \"UnknownError\";\n    exception.message = message;\n    delete exception.Message;\n    return exception;\n};\n", "export const loadConfigsForDefaultMode = (mode) => {\n    switch (mode) {\n        case \"standard\":\n            return {\n                retryMode: \"standard\",\n                connectionTimeout: 3100,\n            };\n        case \"in-region\":\n            return {\n                retryMode: \"standard\",\n                connectionTimeout: 1100,\n            };\n        case \"cross-region\":\n            return {\n                retryMode: \"standard\",\n                connectionTimeout: 3100,\n            };\n        case \"mobile\":\n            return {\n                retryMode: \"standard\",\n                connectionTimeout: 30000,\n            };\n        default:\n            return {};\n    }\n};\n", "let warningEmitted = false;\nexport const emitWarningIfUnsupportedVersion = (version) => {\n    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf(\".\"))) < 16) {\n        warningEmitted = true;\n    }\n};\n", "export { extendedEncodeURIComponent } from \"@smithy/core/protocols\";\n", "export * from \"./defaultExtensionConfiguration\";\n", "import { getChecksumConfiguration, resolveChecksumRuntimeConfig } from \"./checksum\";\nimport { getRetryConfiguration, resolveRetryRuntimeConfig } from \"./retry\";\nexport const getDefaultExtensionConfiguration = (runtimeConfig) => {\n    return Object.assign(getChecksumConfiguration(runtimeConfig), getRetryConfiguration(runtimeConfig));\n};\nexport const getDefaultClientConfiguration = getDefaultExtensionConfiguration;\nexport const resolveDefaultRuntimeConfig = (config) => {\n    return Object.assign(resolveChecksumRuntimeConfig(config), resolveRetryRuntimeConfig(config));\n};\n", "import { AlgorithmId } from \"@smithy/types\";\nexport { AlgorithmId };\nexport const getChecksumConfiguration = (runtimeConfig) => {\n    const checksumAlgorithms = [];\n    for (const id in AlgorithmId) {\n        const algorithmId = AlgorithmId[id];\n        if (runtimeConfig[algorithmId] === undefined) {\n            continue;\n        }\n        checksumAlgorithms.push({\n            algorithmId: () => algorithmId,\n            checksumConstructor: () => runtimeConfig[algorithmId],\n        });\n    }\n    return {\n        addChecksumAlgorithm(algo) {\n            checksumAlgorithms.push(algo);\n        },\n        checksumAlgorithms() {\n            return checksumAlgorithms;\n        },\n    };\n};\nexport const resolveChecksumRuntimeConfig = (clientConfig) => {\n    const runtimeConfig = {};\n    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {\n        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();\n    });\n    return runtimeConfig;\n};\n", "export const getRetryConfiguration = (runtimeConfig) => {\n    return {\n        setRetryStrategy(retryStrategy) {\n            runtimeConfig.retryStrategy = retryStrategy;\n        },\n        retryStrategy() {\n            return runtimeConfig.retryStrategy;\n        },\n    };\n};\nexport const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {\n    const runtimeConfig = {};\n    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();\n    return runtimeConfig;\n};\n", "export const getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];\n", "export const getValueFromTextNode = (obj) => {\n    const textNodeName = \"#text\";\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {\n            obj[key] = obj[key][textNodeName];\n        }\n        else if (typeof obj[key] === \"object\" && obj[key] !== null) {\n            obj[key] = getValueFromTextNode(obj[key]);\n        }\n    }\n    return obj;\n};\n", "export const isSerializableHeaderValue = (value) => {\n    return value != null;\n};\n", "export class NoOpLogger {\n    trace() { }\n    debug() { }\n    info() { }\n    warn() { }\n    error() { }\n}\n", "export function map(arg0, arg1, arg2) {\n    let target;\n    let filter;\n    let instructions;\n    if (typeof arg1 === \"undefined\" && typeof arg2 === \"undefined\") {\n        target = {};\n        instructions = arg0;\n    }\n    else {\n        target = arg0;\n        if (typeof arg1 === \"function\") {\n            filter = arg1;\n            instructions = arg2;\n            return mapWithFilter(target, filter, instructions);\n        }\n        else {\n            instructions = arg1;\n        }\n    }\n    for (const key of Object.keys(instructions)) {\n        if (!Array.isArray(instructions[key])) {\n            target[key] = instructions[key];\n            continue;\n        }\n        applyInstruction(target, null, instructions, key);\n    }\n    return target;\n}\nexport const convertMap = (target) => {\n    const output = {};\n    for (const [k, v] of Object.entries(target || {})) {\n        output[k] = [, v];\n    }\n    return output;\n};\nexport const take = (source, instructions) => {\n    const out = {};\n    for (const key in instructions) {\n        applyInstruction(out, source, instructions, key);\n    }\n    return out;\n};\nconst mapWithFilter = (target, filter, instructions) => {\n    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {\n        if (Array.isArray(value)) {\n            _instructions[key] = value;\n        }\n        else {\n            if (typeof value === \"function\") {\n                _instructions[key] = [filter, value()];\n            }\n            else {\n                _instructions[key] = [filter, value];\n            }\n        }\n        return _instructions;\n    }, {}));\n};\nconst applyInstruction = (target, source, instructions, targetKey) => {\n    if (source !== null) {\n        let instruction = instructions[targetKey];\n        if (typeof instruction === \"function\") {\n            instruction = [, instruction];\n        }\n        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;\n        if ((typeof filter === \"function\" && filter(source[sourceKey])) || (typeof filter !== \"function\" && !!filter)) {\n            target[targetKey] = valueFn(source[sourceKey]);\n        }\n        return;\n    }\n    let [filter, value] = instructions[targetKey];\n    if (typeof value === \"function\") {\n        let _value;\n        const defaultFilterPassed = filter === undefined && (_value = value()) != null;\n        const customFilterPassed = (typeof filter === \"function\" && !!filter(void 0)) || (typeof filter !== \"function\" && !!filter);\n        if (defaultFilterPassed) {\n            target[targetKey] = _value;\n        }\n        else if (customFilterPassed) {\n            target[targetKey] = value();\n        }\n    }\n    else {\n        const defaultFilterPassed = filter === undefined && value != null;\n        const customFilterPassed = (typeof filter === \"function\" && !!filter(value)) || (typeof filter !== \"function\" && !!filter);\n        if (defaultFilterPassed || customFilterPassed) {\n            target[targetKey] = value;\n        }\n    }\n};\nconst nonNullish = (_) => _ != null;\nconst pass = (_) => _;\n", "export { resolvedPath } from \"@smithy/core/protocols\";\n", "export const serializeFloat = (value) => {\n    if (value !== value) {\n        return \"NaN\";\n    }\n    switch (value) {\n        case Infinity:\n            return \"Infinity\";\n        case -Infinity:\n            return \"-Infinity\";\n        default:\n            return value;\n    }\n};\nexport const serializeDateTime = (date) => date.toISOString().replace(\".000Z\", \"Z\");\n", "export const _json = (obj) => {\n    if (obj == null) {\n        return {};\n    }\n    if (Array.isArray(obj)) {\n        return obj.filter((_) => _ != null).map(_json);\n    }\n    if (typeof obj === \"object\") {\n        const target = {};\n        for (const key of Object.keys(obj)) {\n            if (obj[key] == null) {\n                continue;\n            }\n            target[key] = _json(obj[key]);\n        }\n        return target;\n    }\n    return obj;\n};\n", "export * from \"./parse-utils\";\nexport * from \"./date-utils\";\nexport * from \"./quote-header\";\nexport * from \"./split-header\";\nexport * from \"./value/NumericValue\";\nexport * from \"./lazy-json\";\nexport * from \"./split-every\";\n", "export const parseBoolean = (value) => {\n    switch (value) {\n        case \"true\":\n            return true;\n        case \"false\":\n            return false;\n        default:\n            throw new Error(`Unable to parse boolean value \"${value}\"`);\n    }\n};\nexport const expectBoolean = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (typeof value === \"number\") {\n        if (value === 0 || value === 1) {\n            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));\n        }\n        if (value === 0) {\n            return false;\n        }\n        if (value === 1) {\n            return true;\n        }\n    }\n    if (typeof value === \"string\") {\n        const lower = value.toLowerCase();\n        if (lower === \"false\" || lower === \"true\") {\n            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));\n        }\n        if (lower === \"false\") {\n            return false;\n        }\n        if (lower === \"true\") {\n            return true;\n        }\n    }\n    if (typeof value === \"boolean\") {\n        return value;\n    }\n    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);\n};\nexport const expectNumber = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (typeof value === \"string\") {\n        const parsed = parseFloat(value);\n        if (!Number.isNaN(parsed)) {\n            if (String(parsed) !== String(value)) {\n                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));\n            }\n            return parsed;\n        }\n    }\n    if (typeof value === \"number\") {\n        return value;\n    }\n    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);\n};\nconst MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));\nexport const expectFloat32 = (value) => {\n    const expected = expectNumber(value);\n    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {\n        if (Math.abs(expected) > MAX_FLOAT) {\n            throw new TypeError(`Expected 32-bit float, got ${value}`);\n        }\n    }\n    return expected;\n};\nexport const expectLong = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (Number.isInteger(value) && !Number.isNaN(value)) {\n        return value;\n    }\n    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);\n};\nexport const expectInt = expectLong;\nexport const expectInt32 = (value) => expectSizedInt(value, 32);\nexport const expectShort = (value) => expectSizedInt(value, 16);\nexport const expectByte = (value) => expectSizedInt(value, 8);\nconst expectSizedInt = (value, size) => {\n    const expected = expectLong(value);\n    if (expected !== undefined && castInt(expected, size) !== expected) {\n        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);\n    }\n    return expected;\n};\nconst castInt = (value, size) => {\n    switch (size) {\n        case 32:\n            return Int32Array.of(value)[0];\n        case 16:\n            return Int16Array.of(value)[0];\n        case 8:\n            return Int8Array.of(value)[0];\n    }\n};\nexport const expectNonNull = (value, location) => {\n    if (value === null || value === undefined) {\n        if (location) {\n            throw new TypeError(`Expected a non-null value for ${location}`);\n        }\n        throw new TypeError(\"Expected a non-null value\");\n    }\n    return value;\n};\nexport const expectObject = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (typeof value === \"object\" && !Array.isArray(value)) {\n        return value;\n    }\n    const receivedType = Array.isArray(value) ? \"array\" : typeof value;\n    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);\n};\nexport const expectString = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if ([\"boolean\", \"number\", \"bigint\"].includes(typeof value)) {\n        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));\n        return String(value);\n    }\n    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);\n};\nexport const expectUnion = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    const asObject = expectObject(value);\n    const setKeys = Object.entries(asObject)\n        .filter(([, v]) => v != null)\n        .map(([k]) => k);\n    if (setKeys.length === 0) {\n        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);\n    }\n    if (setKeys.length > 1) {\n        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);\n    }\n    return asObject;\n};\nexport const strictParseDouble = (value) => {\n    if (typeof value == \"string\") {\n        return expectNumber(parseNumber(value));\n    }\n    return expectNumber(value);\n};\nexport const strictParseFloat = strictParseDouble;\nexport const strictParseFloat32 = (value) => {\n    if (typeof value == \"string\") {\n        return expectFloat32(parseNumber(value));\n    }\n    return expectFloat32(value);\n};\nconst NUMBER_REGEX = /(-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)|(-?Infinity)|(NaN)/g;\nconst parseNumber = (value) => {\n    const matches = value.match(NUMBER_REGEX);\n    if (matches === null || matches[0].length !== value.length) {\n        throw new TypeError(`Expected real number, got implicit NaN`);\n    }\n    return parseFloat(value);\n};\nexport const limitedParseDouble = (value) => {\n    if (typeof value == \"string\") {\n        return parseFloatString(value);\n    }\n    return expectNumber(value);\n};\nexport const handleFloat = limitedParseDouble;\nexport const limitedParseFloat = limitedParseDouble;\nexport const limitedParseFloat32 = (value) => {\n    if (typeof value == \"string\") {\n        return parseFloatString(value);\n    }\n    return expectFloat32(value);\n};\nconst parseFloatString = (value) => {\n    switch (value) {\n        case \"NaN\":\n            return NaN;\n        case \"Infinity\":\n            return Infinity;\n        case \"-Infinity\":\n            return -Infinity;\n        default:\n            throw new Error(`Unable to parse float value: ${value}`);\n    }\n};\nexport const strictParseLong = (value) => {\n    if (typeof value === \"string\") {\n        return expectLong(parseNumber(value));\n    }\n    return expectLong(value);\n};\nexport const strictParseInt = strictParseLong;\nexport const strictParseInt32 = (value) => {\n    if (typeof value === \"string\") {\n        return expectInt32(parseNumber(value));\n    }\n    return expectInt32(value);\n};\nexport const strictParseShort = (value) => {\n    if (typeof value === \"string\") {\n        return expectShort(parseNumber(value));\n    }\n    return expectShort(value);\n};\nexport const strictParseByte = (value) => {\n    if (typeof value === \"string\") {\n        return expectByte(parseNumber(value));\n    }\n    return expectByte(value);\n};\nconst stackTraceWarning = (message) => {\n    return String(new TypeError(message).stack || message)\n        .split(\"\\n\")\n        .slice(0, 5)\n        .filter((s) => !s.includes(\"stackTraceWarning\"))\n        .join(\"\\n\");\n};\nexport const logger = {\n    warn: console.warn,\n};\n", "import { strictParseByte, strictParseDouble, strictParseFloat32, strictParseShort } from \"./parse-utils\";\nconst DAYS = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\nconst MONTHS = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\nexport function dateToUtcString(date) {\n    const year = date.getUTCFullYear();\n    const month = date.getUTCMonth();\n    const dayOfWeek = date.getUTCDay();\n    const dayOfMonthInt = date.getUTCDate();\n    const hoursInt = date.getUTCHours();\n    const minutesInt = date.getUTCMinutes();\n    const secondsInt = date.getUTCSeconds();\n    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;\n    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;\n    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;\n    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;\n    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;\n}\nconst RFC3339 = new RegExp(/^(\\d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?[zZ]$/);\nexport const parseRfc3339DateTime = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (typeof value !== \"string\") {\n        throw new TypeError(\"RFC-3339 date-times must be expressed as strings\");\n    }\n    const match = RFC3339.exec(value);\n    if (!match) {\n        throw new TypeError(\"Invalid RFC-3339 date-time value\");\n    }\n    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;\n    const year = strictParseShort(stripLeadingZeroes(yearStr));\n    const month = parseDateValue(monthStr, \"month\", 1, 12);\n    const day = parseDateValue(dayStr, \"day\", 1, 31);\n    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });\n};\nconst RFC3339_WITH_OFFSET = new RegExp(/^(\\d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(([-+]\\d{2}\\:\\d{2})|[zZ])$/);\nexport const parseRfc3339DateTimeWithOffset = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (typeof value !== \"string\") {\n        throw new TypeError(\"RFC-3339 date-times must be expressed as strings\");\n    }\n    const match = RFC3339_WITH_OFFSET.exec(value);\n    if (!match) {\n        throw new TypeError(\"Invalid RFC-3339 date-time value\");\n    }\n    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;\n    const year = strictParseShort(stripLeadingZeroes(yearStr));\n    const month = parseDateValue(monthStr, \"month\", 1, 12);\n    const day = parseDateValue(dayStr, \"day\", 1, 31);\n    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });\n    if (offsetStr.toUpperCase() != \"Z\") {\n        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));\n    }\n    return date;\n};\nconst IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nconst RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d{2}) (\\d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nconst ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\\d{2}) (\\d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? (\\d{4})$/);\nexport const parseRfc7231DateTime = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (typeof value !== \"string\") {\n        throw new TypeError(\"RFC-7231 date-times must be expressed as strings\");\n    }\n    let match = IMF_FIXDATE.exec(value);\n    if (match) {\n        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;\n        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, \"day\", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });\n    }\n    match = RFC_850_DATE.exec(value);\n    if (match) {\n        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;\n        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, \"day\", 1, 31), {\n            hours,\n            minutes,\n            seconds,\n            fractionalMilliseconds,\n        }));\n    }\n    match = ASC_TIME.exec(value);\n    if (match) {\n        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;\n        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), \"day\", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });\n    }\n    throw new TypeError(\"Invalid RFC-7231 date-time value\");\n};\nexport const parseEpochTimestamp = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    let valueAsDouble;\n    if (typeof value === \"number\") {\n        valueAsDouble = value;\n    }\n    else if (typeof value === \"string\") {\n        valueAsDouble = strictParseDouble(value);\n    }\n    else if (typeof value === \"object\" && value.tag === 1) {\n        valueAsDouble = value.value;\n    }\n    else {\n        throw new TypeError(\"Epoch timestamps must be expressed as floating point numbers or their string representation\");\n    }\n    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {\n        throw new TypeError(\"Epoch timestamps must be valid, non-Infinite, non-NaN numerics\");\n    }\n    return new Date(Math.round(valueAsDouble * 1000));\n};\nconst buildDate = (year, month, day, time) => {\n    const adjustedMonth = month - 1;\n    validateDayOfMonth(year, adjustedMonth, day);\n    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, \"hour\", 0, 23), parseDateValue(time.minutes, \"minute\", 0, 59), parseDateValue(time.seconds, \"seconds\", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));\n};\nconst parseTwoDigitYear = (value) => {\n    const thisYear = new Date().getUTCFullYear();\n    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));\n    if (valueInThisCentury < thisYear) {\n        return valueInThisCentury + 100;\n    }\n    return valueInThisCentury;\n};\nconst FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;\nconst adjustRfc850Year = (input) => {\n    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {\n        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));\n    }\n    return input;\n};\nconst parseMonthByShortName = (value) => {\n    const monthIdx = MONTHS.indexOf(value);\n    if (monthIdx < 0) {\n        throw new TypeError(`Invalid month: ${value}`);\n    }\n    return monthIdx + 1;\n};\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst validateDayOfMonth = (year, month, day) => {\n    let maxDays = DAYS_IN_MONTH[month];\n    if (month === 1 && isLeapYear(year)) {\n        maxDays = 29;\n    }\n    if (day > maxDays) {\n        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);\n    }\n};\nconst isLeapYear = (year) => {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n};\nconst parseDateValue = (value, type, lower, upper) => {\n    const dateVal = strictParseByte(stripLeadingZeroes(value));\n    if (dateVal < lower || dateVal > upper) {\n        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);\n    }\n    return dateVal;\n};\nconst parseMilliseconds = (value) => {\n    if (value === null || value === undefined) {\n        return 0;\n    }\n    return strictParseFloat32(\"0.\" + value) * 1000;\n};\nconst parseOffsetToMilliseconds = (value) => {\n    const directionStr = value[0];\n    let direction = 1;\n    if (directionStr == \"+\") {\n        direction = 1;\n    }\n    else if (directionStr == \"-\") {\n        direction = -1;\n    }\n    else {\n        throw new TypeError(`Offset direction, ${directionStr}, must be \"+\" or \"-\"`);\n    }\n    const hour = Number(value.substring(1, 3));\n    const minute = Number(value.substring(4, 6));\n    return direction * (hour * 60 + minute) * 60 * 1000;\n};\nconst stripLeadingZeroes = (value) => {\n    let idx = 0;\n    while (idx < value.length - 1 && value.charAt(idx) === \"0\") {\n        idx++;\n    }\n    if (idx === 0) {\n        return value;\n    }\n    return value.slice(idx);\n};\n", "export function quoteHeader(part) {\n    if (part.includes(\",\") || part.includes('\"')) {\n        part = `\"${part.replace(/\"/g, '\\\\\"')}\"`;\n    }\n    return part;\n}\n", "export const splitHeader = (value) => {\n    const z = value.length;\n    const values = [];\n    let withinQuotes = false;\n    let prevChar = undefined;\n    let anchor = 0;\n    for (let i = 0; i < z; ++i) {\n        const char = value[i];\n        switch (char) {\n            case `\"`:\n                if (prevChar !== \"\\\\\") {\n                    withinQuotes = !withinQuotes;\n                }\n                break;\n            case \",\":\n                if (!withinQuotes) {\n                    values.push(value.slice(anchor, i));\n                    anchor = i + 1;\n                }\n                break;\n            default:\n        }\n        prevChar = char;\n    }\n    values.push(value.slice(anchor));\n    return values.map((v) => {\n        v = v.trim();\n        const z = v.length;\n        if (z < 2) {\n            return v;\n        }\n        if (v[0] === `\"` && v[z - 1] === `\"`) {\n            v = v.slice(1, z - 1);\n        }\n        return v.replace(/\\\\\"/g, '\"');\n    });\n};\n", "export class NumericValue {\n    constructor(string, type) {\n        this.string = string;\n        this.type = type;\n    }\n}\nexport function nv(string) {\n    return new NumericValue(string, \"bigDecimal\");\n}\n", "export const LazyJsonString = function LazyJsonString(val) {\n    const str = Object.assign(new String(val), {\n        deserializeJSON() {\n            return JSON.parse(String(val));\n        },\n        toString() {\n            return String(val);\n        },\n        toJSON() {\n            return String(val);\n        },\n    });\n    return str;\n};\nLazyJsonString.from = (object) => {\n    if (object && typeof object === \"object\" && (object instanceof LazyJsonString || \"deserializeJSON\" in object)) {\n        return object;\n    }\n    else if (typeof object === \"string\" || Object.getPrototypeOf(object) === String.prototype) {\n        return LazyJsonString(String(object));\n    }\n    return LazyJsonString(JSON.stringify(object));\n};\nLazyJsonString.fromObject = LazyJsonString.from;\n", "export function splitEvery(value, delimiter, numDelimiters) {\n    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {\n        throw new Error(\"Invalid number of delimiters (\" + numDelimiters + \") for splitEvery.\");\n    }\n    const segments = value.split(delimiter);\n    if (numDelimiters === 1) {\n        return segments;\n    }\n    const compoundSegments = [];\n    let currentSegment = \"\";\n    for (let i = 0; i < segments.length; i++) {\n        if (currentSegment === \"\") {\n            currentSegment = segments[i];\n        }\n        else {\n            currentSegment += delimiter + segments[i];\n        }\n        if ((i + 1) % numDelimiters === 0) {\n            compoundSegments.push(currentSegment);\n            currentSegment = \"\";\n        }\n    }\n    if (currentSegment !== \"\") {\n        compoundSegments.push(currentSegment);\n    }\n    return compoundSegments;\n}\n", "import { collectBody } from \"@smithy/smithy-client\";\nexport const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));\n", "import { getValueFromTextNode } from \"@smithy/smithy-client\";\nimport { XMLParser } from \"fast-xml-parser\";\nimport { collectBodyString } from \"../common\";\nexport const parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {\n    if (encoded.length) {\n        const parser = new XMLParser({\n            attributeNamePrefix: \"\",\n            htmlEntities: true,\n            ignoreAttributes: false,\n            ignoreDeclaration: true,\n            parseTagValue: false,\n            trimValues: false,\n            tagValueProcessor: (_, val) => (val.trim() === \"\" && val.includes(\"\\n\") ? \"\" : undefined),\n        });\n        parser.addEntity(\"#xD\", \"\\r\");\n        parser.addEntity(\"#10\", \"\\n\");\n        let parsedObj;\n        try {\n            parsedObj = parser.parse(encoded, true);\n        }\n        catch (e) {\n            if (e && typeof e === \"object\") {\n                Object.defineProperty(e, \"$responseBodyText\", {\n                    value: encoded,\n                });\n            }\n            throw e;\n        }\n        const textNodeName = \"#text\";\n        const key = Object.keys(parsedObj)[0];\n        const parsedObjToReturn = parsedObj[key];\n        if (parsedObjToReturn[textNodeName]) {\n            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\n            delete parsedObjToReturn[textNodeName];\n        }\n        return getValueFromTextNode(parsedObjToReturn);\n    }\n    return {};\n});\nexport const parseXmlErrorBody = async (errorBody, context) => {\n    const value = await parseXmlBody(errorBody, context);\n    if (value.Error) {\n        value.Error.message = value.Error.message ?? value.Error.Message;\n    }\n    return value;\n};\nexport const loadRestXmlErrorCode = (output, data) => {\n    if (data?.Error?.Code !== undefined) {\n        return data.Error.Code;\n    }\n    if (data?.Code !== undefined) {\n        return data.Code;\n    }\n    if (output.statusCode == 404) {\n        return \"NotFound\";\n    }\n};\n", "export const USER_AGENT = \"user-agent\";\nexport const X_AMZ_USER_AGENT = \"x-amz-user-agent\";\nexport const SPACE = \" \";\nexport const UA_NAME_SEPARATOR = \"/\";\nexport const UA_NAME_ESCAPE_REGEX = /[^\\!\\$\\%\\&\\'\\*\\+\\-\\.\\^\\_\\`\\|\\~\\d\\w]/g;\nexport const UA_VALUE_ESCAPE_REGEX = /[^\\!\\$\\%\\&\\'\\*\\+\\-\\.\\^\\_\\`\\|\\~\\d\\w\\#]/g;\nexport const UA_ESCAPE_CHAR = \"-\";\n", "const BYTE_LIMIT = 1024;\nexport function encodeFeatures(features) {\n    let buffer = \"\";\n    for (const key in features) {\n        const val = features[key];\n        if (buffer.length + val.length + 1 <= BYTE_LIMIT) {\n            if (buffer.length) {\n                buffer += \",\" + val;\n            }\n            else {\n                buffer += val;\n            }\n            continue;\n        }\n        break;\n    }\n    return buffer;\n}\n", "export * from \"./endpointsConfig\";\nexport * from \"./regionConfig\";\nexport * from \"./regionInfo\";\n", "export * from \"./NodeUseDualstackEndpointConfigOptions\";\nexport * from \"./NodeUseFipsEndpointConfigOptions\";\nexport * from \"./resolveCustomEndpointsConfig\";\nexport * from \"./resolveEndpointsConfig\";\n", "import { booleanSelector, SelectorType } from \"@smithy/util-config-provider\";\nexport const ENV_USE_DUALSTACK_ENDPOINT = \"AWS_USE_DUALSTACK_ENDPOINT\";\nexport const CONFIG_USE_DUALSTACK_ENDPOINT = \"use_dualstack_endpoint\";\nexport const DEFAULT_USE_DUALSTACK_ENDPOINT = false;\nexport const NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {\n    environmentVariableSelector: (env) => booleanSelector(env, ENV_USE_DUALSTACK_ENDPOINT, SelectorType.ENV),\n    configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, SelectorType.CONFIG),\n    default: false,\n};\n", "export * from \"./booleanSelector\";\nexport * from \"./numberSelector\";\nexport * from \"./types\";\n", "export const booleanSelector = (obj, key, type) => {\n    if (!(key in obj))\n        return undefined;\n    if (obj[key] === \"true\")\n        return true;\n    if (obj[key] === \"false\")\n        return false;\n    throw new Error(`Cannot load ${type} \"${key}\". Expected \"true\" or \"false\", got ${obj[key]}.`);\n};\n", "export const numberSelector = (obj, key, type) => {\n    if (!(key in obj))\n        return undefined;\n    const numberValue = parseInt(obj[key], 10);\n    if (Number.isNaN(numberValue)) {\n        throw new TypeError(`Cannot load ${type} '${key}'. Expected number, got '${obj[key]}'.`);\n    }\n    return numberValue;\n};\n", "export var SelectorType;\n(function (SelectorType) {\n    SelectorType[\"ENV\"] = \"env\";\n    SelectorType[\"CONFIG\"] = \"shared config entry\";\n})(SelectorType || (SelectorType = {}));\n", "import { booleanSelector, SelectorType } from \"@smithy/util-config-provider\";\nexport const ENV_USE_FIPS_ENDPOINT = \"AWS_USE_FIPS_ENDPOINT\";\nexport const CONFIG_USE_FIPS_ENDPOINT = \"use_fips_endpoint\";\nexport const DEFAULT_USE_FIPS_ENDPOINT = false;\nexport const NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {\n    environmentVariableSelector: (env) => booleanSelector(env, ENV_USE_FIPS_ENDPOINT, SelectorType.ENV),\n    configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, SelectorType.CONFIG),\n    default: false,\n};\n", "import { normalizeProvider } from \"@smithy/util-middleware\";\nexport const resolveCustomEndpointsConfig = (input) => {\n    const { tls, endpoint, urlParser, useDualstackEndpoint } = input;\n    return Object.assign(input, {\n        tls: tls ?? true,\n        endpoint: normalizeProvider(typeof endpoint === \"string\" ? urlParser(endpoint) : endpoint),\n        isCustomEndpoint: true,\n        useDualstackEndpoint: normalizeProvider(useDualstackEndpoint ?? false),\n    });\n};\n", "import { normalizeProvider } from \"@smithy/util-middleware\";\nimport { getEndpointFromRegion } from \"./utils/getEndpointFromRegion\";\nexport const resolveEndpointsConfig = (input) => {\n    const useDualstackEndpoint = normalizeProvider(input.useDualstackEndpoint ?? false);\n    const { endpoint, useFipsEndpoint, urlParser, tls } = input;\n    return Object.assign(input, {\n        tls: tls ?? true,\n        endpoint: endpoint\n            ? normalizeProvider(typeof endpoint === \"string\" ? urlParser(endpoint) : endpoint)\n            : () => getEndpointFromRegion({ ...input, useDualstackEndpoint, useFipsEndpoint }),\n        isCustomEndpoint: !!endpoint,\n        useDualstackEndpoint,\n    });\n};\n", "export const getEndpointFromRegion = async (input) => {\n    const { tls = true } = input;\n    const region = await input.region();\n    const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);\n    if (!dnsHostRegex.test(region)) {\n        throw new Error(\"Invalid region in client config\");\n    }\n    const useDualstackEndpoint = await input.useDualstackEndpoint();\n    const useFipsEndpoint = await input.useFipsEndpoint();\n    const { hostname } = (await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint })) ?? {};\n    if (!hostname) {\n        throw new Error(\"Cannot resolve hostname from client config\");\n    }\n    return input.urlParser(`${tls ? \"https:\" : \"http:\"}//${hostname}`);\n};\n", "export * from \"./config\";\nexport * from \"./resolveRegionConfig\";\n", "export const REGION_ENV_NAME = \"AWS_REGION\";\nexport const REGION_INI_NAME = \"region\";\nexport const NODE_REGION_CONFIG_OPTIONS = {\n    environmentVariableSelector: (env) => env[REGION_ENV_NAME],\n    configFileSelector: (profile) => profile[REGION_INI_NAME],\n    default: () => {\n        throw new Error(\"Region is missing\");\n    },\n};\nexport const NODE_REGION_CONFIG_FILE_OPTIONS = {\n    preferredFile: \"credentials\",\n};\n", "import { getRealRegion } from \"./getRealRegion\";\nimport { isFipsRegion } from \"./isFipsRegion\";\nexport const resolveRegionConfig = (input) => {\n    const { region, useFipsEndpoint } = input;\n    if (!region) {\n        throw new Error(\"Region is missing\");\n    }\n    return Object.assign(input, {\n        region: async () => {\n            if (typeof region === \"string\") {\n                return getRealRegion(region);\n            }\n            const providedRegion = await region();\n            return getRealRegion(providedRegion);\n        },\n        useFipsEndpoint: async () => {\n            const providedRegion = typeof region === \"string\" ? region : await region();\n            if (isFipsRegion(providedRegion)) {\n                return true;\n            }\n            return typeof useFipsEndpoint !== \"function\" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();\n        },\n    });\n};\n", "import { isFipsRegion } from \"./isFipsRegion\";\nexport const getRealRegion = (region) => isFipsRegion(region)\n    ? [\"fips-aws-global\", \"aws-fips\"].includes(region)\n        ? \"us-east-1\"\n        : region.replace(/fips-(dkr-|prod-)?|-fips/, \"\")\n    : region;\n", "export const isFipsRegion = (region) => typeof region === \"string\" && (region.startsWith(\"fips-\") || region.endsWith(\"-fips\"));\n", "export * from \"./PartitionHash\";\nexport * from \"./RegionHash\";\nexport * from \"./getRegionInfo\";\n", "export {};\n", "export {};\n", "import { getHostnameFromVariants } from \"./getHostnameFromVariants\";\nimport { getResolvedHostname } from \"./getResolvedHostname\";\nimport { getResolvedPartition } from \"./getResolvedPartition\";\nimport { getResolvedSigningRegion } from \"./getResolvedSigningRegion\";\nexport const getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash, }) => {\n    const partition = getResolvedPartition(region, { partitionHash });\n    const resolvedRegion = region in regionHash ? region : partitionHash[partition]?.endpoint ?? region;\n    const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };\n    const regionHostname = getHostnameFromVariants(regionHash[resolvedRegion]?.variants, hostnameOptions);\n    const partitionHostname = getHostnameFromVariants(partitionHash[partition]?.variants, hostnameOptions);\n    const hostname = getResolvedHostname(resolvedRegion, { regionHostname, partitionHostname });\n    if (hostname === undefined) {\n        throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);\n    }\n    const signingRegion = getResolvedSigningRegion(hostname, {\n        signingRegion: regionHash[resolvedRegion]?.signingRegion,\n        regionRegex: partitionHash[partition].regionRegex,\n        useFipsEndpoint,\n    });\n    return {\n        partition,\n        signingService,\n        hostname,\n        ...(signingRegion && { signingRegion }),\n        ...(regionHash[resolvedRegion]?.signingService && {\n            signingService: regionHash[resolvedRegion].signingService,\n        }),\n    };\n};\n", "export const getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => variants.find(({ tags }) => useFipsEndpoint === tags.includes(\"fips\") && useDualstackEndpoint === tags.includes(\"dualstack\"))?.hostname;\n", "export const getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname\n    ? regionHostname\n    : partitionHostname\n        ? partitionHostname.replace(\"{region}\", resolvedRegion)\n        : undefined;\n", "export const getResolvedPartition = (region, { partitionHash }) => Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region)) ?? \"aws\";\n", "export const getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {\n    if (signingRegion) {\n        return signingRegion;\n    }\n    else if (useFipsEndpoint) {\n        const regionRegexJs = regionRegex.replace(\"\\\\\\\\\", \"\\\\\").replace(/^\\^/g, \"\\\\.\").replace(/\\$$/g, \"\\\\.\");\n        const regionRegexmatchArray = hostname.match(regionRegexJs);\n        if (regionRegexmatchArray) {\n            return regionRegexmatchArray[0].slice(1, -1);\n        }\n    }\n};\n", "import { HttpRequest } from \"@smithy/protocol-http\";\nconst CONTENT_LENGTH_HEADER = \"content-length\";\nexport function contentLengthMiddleware(bodyLengthChecker) {\n    return (next) => async (args) => {\n        const request = args.request;\n        if (HttpRequest.isInstance(request)) {\n            const { body, headers } = request;\n            if (body &&\n                Object.keys(headers)\n                    .map((str) => str.toLowerCase())\n                    .indexOf(CONTENT_LENGTH_HEADER) === -1) {\n                try {\n                    const length = bodyLengthChecker(body);\n                    request.headers = {\n                        ...request.headers,\n                        [CONTENT_LENGTH_HEADER]: String(length),\n                    };\n                }\n                catch (error) {\n                }\n            }\n        }\n        return next({\n            ...args,\n            request,\n        });\n    };\n}\nexport const contentLengthMiddlewareOptions = {\n    step: \"build\",\n    tags: [\"SET_CONTENT_LENGTH\", \"CONTENT_LENGTH\"],\n    name: \"contentLengthMiddleware\",\n    override: true,\n};\nexport const getContentLengthPlugin = (options) => ({\n    applyToStack: (clientStack) => {\n        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);\n    },\n});\n", "export * from \"./adaptors\";\nexport * from \"./endpointMiddleware\";\nexport * from \"./getEndpointPlugin\";\nexport * from \"./resolveEndpointConfig\";\nexport * from \"./types\";\n", "export * from \"./getEndpointFromInstructions\";\nexport * from \"./toEndpointV1\";\n", "import { resolveParamsForS3 } from \"../service-customizations\";\nimport { createConfigValueProvider } from \"./createConfigValueProvider\";\nimport { getEndpointFromConfig } from \"./getEndpointFromConfig\";\nimport { toEndpointV1 } from \"./toEndpointV1\";\nexport const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {\n    if (!clientConfig.endpoint) {\n        let endpointFromConfig;\n        if (clientConfig.serviceConfiguredEndpoint) {\n            endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();\n        }\n        else {\n            endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId);\n        }\n        if (endpointFromConfig) {\n            clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));\n        }\n    }\n    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);\n    if (typeof clientConfig.endpointProvider !== \"function\") {\n        throw new Error(\"config.endpointProvider is not set.\");\n    }\n    const endpoint = clientConfig.endpointProvider(endpointParams, context);\n    return endpoint;\n};\nexport const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {\n    const endpointParams = {};\n    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};\n    for (const [name, instruction] of Object.entries(instructions)) {\n        switch (instruction.type) {\n            case \"staticContextParams\":\n                endpointParams[name] = instruction.value;\n                break;\n            case \"contextParams\":\n                endpointParams[name] = commandInput[instruction.name];\n                break;\n            case \"clientContextParams\":\n            case \"builtInParams\":\n                endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();\n                break;\n            case \"operationContextParams\":\n                endpointParams[name] = instruction.get(commandInput);\n                break;\n            default:\n                throw new Error(\"Unrecognized endpoint parameter instruction: \" + JSON.stringify(instruction));\n        }\n    }\n    if (Object.keys(instructions).length === 0) {\n        Object.assign(endpointParams, clientConfig);\n    }\n    if (String(clientConfig.serviceId).toLowerCase() === \"s3\") {\n        await resolveParamsForS3(endpointParams);\n    }\n    return endpointParams;\n};\n", "export * from \"./s3\";\n", "export const resolveParamsForS3 = async (endpointParams) => {\n    const bucket = endpointParams?.Bucket || \"\";\n    if (typeof endpointParams.Bucket === \"string\") {\n        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent(\"#\")).replace(/\\?/g, encodeURIComponent(\"?\"));\n    }\n    if (isArnBucketName(bucket)) {\n        if (endpointParams.ForcePathStyle === true) {\n            throw new Error(\"Path-style addressing cannot be used with ARN buckets\");\n        }\n    }\n    else if (!isDnsCompatibleBucketName(bucket) ||\n        (bucket.indexOf(\".\") !== -1 && !String(endpointParams.Endpoint).startsWith(\"http:\")) ||\n        bucket.toLowerCase() !== bucket ||\n        bucket.length < 3) {\n        endpointParams.ForcePathStyle = true;\n    }\n    if (endpointParams.DisableMultiRegionAccessPoints) {\n        endpointParams.disableMultiRegionAccessPoints = true;\n        endpointParams.DisableMRAP = true;\n    }\n    return endpointParams;\n};\nconst DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\\.\\-]{1,61}[a-z0-9]$/;\nconst IP_ADDRESS_PATTERN = /(\\d+\\.){3}\\d+/;\nconst DOTS_PATTERN = /\\.\\./;\nexport const DOT_PATTERN = /\\./;\nexport const S3_HOSTNAME_PATTERN = /^(.+\\.)?s3(-fips)?(\\.dualstack)?[.-]([a-z0-9-]+)\\./;\nexport const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);\nexport const isArnBucketName = (bucketName) => {\n    const [arn, partition, service, , , bucket] = bucketName.split(\":\");\n    const isArn = arn === \"arn\" && bucketName.split(\":\").length >= 6;\n    const isValidArn = Boolean(isArn && partition && service && bucket);\n    if (isArn && !isValidArn) {\n        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);\n    }\n    return isValidArn;\n};\n", "export const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {\n    const configProvider = async () => {\n        const configValue = config[configKey] ?? config[canonicalEndpointParamKey];\n        if (typeof configValue === \"function\") {\n            return configValue();\n        }\n        return configValue;\n    };\n    if (configKey === \"credentialScope\" || canonicalEndpointParamKey === \"CredentialScope\") {\n        return async () => {\n            const credentials = typeof config.credentials === \"function\" ? await config.credentials() : config.credentials;\n            const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;\n            return configValue;\n        };\n    }\n    if (configKey === \"accountId\" || canonicalEndpointParamKey === \"AccountId\") {\n        return async () => {\n            const credentials = typeof config.credentials === \"function\" ? await config.credentials() : config.credentials;\n            const configValue = credentials?.accountId ?? credentials?.AccountId;\n            return configValue;\n        };\n    }\n    if (configKey === \"endpoint\" || canonicalEndpointParamKey === \"endpoint\") {\n        return async () => {\n            const endpoint = await configProvider();\n            if (endpoint && typeof endpoint === \"object\") {\n                if (\"url\" in endpoint) {\n                    return endpoint.url.href;\n                }\n                if (\"hostname\" in endpoint) {\n                    const { protocol, hostname, port, path } = endpoint;\n                    return `${protocol}//${hostname}${port ? \":\" + port : \"\"}${path}`;\n                }\n            }\n            return endpoint;\n        };\n    }\n    return configProvider;\n};\n", "export const getEndpointFromConfig = async (serviceId) => undefined;\n", "import { parseUrl } from \"@smithy/url-parser\";\nexport const toEndpointV1 = (endpoint) => {\n    if (typeof endpoint === \"object\") {\n        if (\"url\" in endpoint) {\n            return parseUrl(endpoint.url);\n        }\n        return endpoint;\n    }\n    return parseUrl(endpoint);\n};\n", "import { parseQueryString } from \"@smithy/querystring-parser\";\nexport const parseUrl = (url) => {\n    if (typeof url === \"string\") {\n        return parseUrl(new URL(url));\n    }\n    const { hostname, pathname, port, protocol, search } = url;\n    let query;\n    if (search) {\n        query = parseQueryString(search);\n    }\n    return {\n        hostname,\n        port: port ? parseInt(port) : undefined,\n        protocol,\n        path: pathname,\n        query,\n    };\n};\n", "export function parseQueryString(querystring) {\n    const query = {};\n    querystring = querystring.replace(/^\\?/, \"\");\n    if (querystring) {\n        for (const pair of querystring.split(\"&\")) {\n            let [key, value = null] = pair.split(\"=\");\n            key = decodeURIComponent(key);\n            if (value) {\n                value = decodeURIComponent(value);\n            }\n            if (!(key in query)) {\n                query[key] = value;\n            }\n            else if (Array.isArray(query[key])) {\n                query[key].push(value);\n            }\n            else {\n                query[key] = [query[key], value];\n            }\n        }\n    }\n    return query;\n}\n", "import { setFeature } from \"@smithy/core\";\nimport { getSmithyContext } from \"@smithy/util-middleware\";\nimport { getEndpointFromInstructions } from \"./adaptors/getEndpointFromInstructions\";\nexport const endpointMiddleware = ({ config, instructions, }) => {\n    return (next, context) => async (args) => {\n        if (config.endpoint) {\n            setFeature(context, \"ENDPOINT_OVERRIDE\", \"N\");\n        }\n        const endpoint = await getEndpointFromInstructions(args.input, {\n            getEndpointParameterInstructions() {\n                return instructions;\n            },\n        }, { ...config }, context);\n        context.endpointV2 = endpoint;\n        context.authSchemes = endpoint.properties?.authSchemes;\n        const authScheme = context.authSchemes?.[0];\n        if (authScheme) {\n            context[\"signing_region\"] = authScheme.signingRegion;\n            context[\"signing_service\"] = authScheme.signingName;\n            const smithyContext = getSmithyContext(context);\n            const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;\n            if (httpAuthOption) {\n                httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {\n                    signing_region: authScheme.signingRegion,\n                    signingRegion: authScheme.signingRegion,\n                    signing_service: authScheme.signingName,\n                    signingName: authScheme.signingName,\n                    signingRegionSet: authScheme.signingRegionSet,\n                }, authScheme.properties);\n            }\n        }\n        return next({\n            ...args,\n        });\n    };\n};\n", "import { serializerMiddlewareOption } from \"@smithy/middleware-serde\";\nimport { endpointMiddleware } from \"./endpointMiddleware\";\nexport const endpointMiddlewareOptions = {\n    step: \"serialize\",\n    tags: [\"ENDPOINT_PARAMETERS\", \"ENDPOINT_V2\", \"ENDPOINT\"],\n    name: \"endpointV2Middleware\",\n    override: true,\n    relation: \"before\",\n    toMiddleware: serializerMiddlewareOption.name,\n};\nexport const getEndpointPlugin = (config, instructions) => ({\n    applyToStack: (clientStack) => {\n        clientStack.addRelativeTo(endpointMiddleware({\n            config,\n            instructions,\n        }), endpointMiddlewareOptions);\n    },\n});\n", "import { normalizeProvider } from \"@smithy/util-middleware\";\nimport { getEndpointFromConfig } from \"./adaptors/getEndpointFromConfig\";\nimport { toEndpointV1 } from \"./adaptors/toEndpointV1\";\nexport const resolveEndpointConfig = (input) => {\n    const tls = input.tls ?? true;\n    const { endpoint, useDualstackEndpoint, useFipsEndpoint } = input;\n    const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : undefined;\n    const isCustomEndpoint = !!endpoint;\n    const resolvedConfig = Object.assign(input, {\n        endpoint: customEndpointProvider,\n        tls,\n        isCustomEndpoint,\n        useDualstackEndpoint: normalizeProvider(useDualstackEndpoint ?? false),\n        useFipsEndpoint: normalizeProvider(useFipsEndpoint ?? false),\n    });\n    let configuredEndpointPromise = undefined;\n    resolvedConfig.serviceConfiguredEndpoint = async () => {\n        if (input.serviceId && !configuredEndpointPromise) {\n            configuredEndpointPromise = getEndpointFromConfig(input.serviceId);\n        }\n        return configuredEndpointPromise;\n    };\n    return resolvedConfig;\n};\n", "export {};\n", "export * from \"./AdaptiveRetryStrategy\";\nexport * from \"./StandardRetryStrategy\";\nexport * from \"./configurations\";\nexport * from \"./delayDecider\";\nexport * from \"./omitRetryHeadersMiddleware\";\nexport * from \"./retryDecider\";\nexport * from \"./retryMiddleware\";\n", "import { DefaultRateLimiter, RETRY_MODES } from \"@smithy/util-retry\";\nimport { StandardRetryStrategy } from \"./StandardRetryStrategy\";\nexport class AdaptiveRetryStrategy extends StandardRetryStrategy {\n    constructor(maxAttemptsProvider, options) {\n        const { rateLimiter, ...superOptions } = options ?? {};\n        super(maxAttemptsProvider, superOptions);\n        this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();\n        this.mode = RETRY_MODES.ADAPTIVE;\n    }\n    async retry(next, args) {\n        return super.retry(next, args, {\n            beforeRequest: async () => {\n                return this.rateLimiter.getSendToken();\n            },\n            afterRequest: (response) => {\n                this.rateLimiter.updateClientSendingRate(response);\n            },\n        });\n    }\n}\n", "export * from \"./AdaptiveRetryStrategy\";\nexport * from \"./ConfiguredRetryStrategy\";\nexport * from \"./DefaultRateLimiter\";\nexport * from \"./StandardRetryStrategy\";\nexport * from \"./config\";\nexport * from \"./constants\";\nexport * from \"./types\";\n", "import { RETRY_MODES } from \"./config\";\nimport { DefaultRateLimiter } from \"./DefaultRateLimiter\";\nimport { StandardRetryStrategy } from \"./StandardRetryStrategy\";\nexport class AdaptiveRetryStrategy {\n    constructor(maxAttemptsProvider, options) {\n        this.maxAttemptsProvider = maxAttemptsProvider;\n        this.mode = RETRY_MODES.ADAPTIVE;\n        const { rateLimiter } = options ?? {};\n        this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();\n        this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);\n    }\n    async acquireInitialRetryToken(retryTokenScope) {\n        await this.rateLimiter.getSendToken();\n        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);\n    }\n    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {\n        this.rateLimiter.updateClientSendingRate(errorInfo);\n        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);\n    }\n    recordSuccess(token) {\n        this.rateLimiter.updateClientSendingRate({});\n        this.standardRetryStrategy.recordSuccess(token);\n    }\n}\n", "export var RETRY_MODES;\n(function (RETRY_MODES) {\n    RETRY_MODES[\"STANDARD\"] = \"standard\";\n    RETRY_MODES[\"ADAPTIVE\"] = \"adaptive\";\n})(RETRY_MODES || (RETRY_MODES = {}));\nexport const DEFAULT_MAX_ATTEMPTS = 3;\nexport const DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;\n", "import { isThrottlingError } from \"@smithy/service-error-classification\";\nexport class DefaultRateLimiter {\n    constructor(options) {\n        this.currentCapacity = 0;\n        this.enabled = false;\n        this.lastMaxRate = 0;\n        this.measuredTxRate = 0;\n        this.requestCount = 0;\n        this.lastTimestamp = 0;\n        this.timeWindow = 0;\n        this.beta = options?.beta ?? 0.7;\n        this.minCapacity = options?.minCapacity ?? 1;\n        this.minFillRate = options?.minFillRate ?? 0.5;\n        this.scaleConstant = options?.scaleConstant ?? 0.4;\n        this.smooth = options?.smooth ?? 0.8;\n        const currentTimeInSeconds = this.getCurrentTimeInSeconds();\n        this.lastThrottleTime = currentTimeInSeconds;\n        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n        this.fillRate = this.minFillRate;\n        this.maxCapacity = this.minCapacity;\n    }\n    getCurrentTimeInSeconds() {\n        return Date.now() / 1000;\n    }\n    async getSendToken() {\n        return this.acquireTokenBucket(1);\n    }\n    async acquireTokenBucket(amount) {\n        if (!this.enabled) {\n            return;\n        }\n        this.refillTokenBucket();\n        if (amount > this.currentCapacity) {\n            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;\n            await new Promise((resolve) => DefaultRateLimiter.setTimeoutFn(resolve, delay));\n        }\n        this.currentCapacity = this.currentCapacity - amount;\n    }\n    refillTokenBucket() {\n        const timestamp = this.getCurrentTimeInSeconds();\n        if (!this.lastTimestamp) {\n            this.lastTimestamp = timestamp;\n            return;\n        }\n        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n        this.lastTimestamp = timestamp;\n    }\n    updateClientSendingRate(response) {\n        let calculatedRate;\n        this.updateMeasuredRate();\n        if (isThrottlingError(response)) {\n            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n            this.lastMaxRate = rateToUse;\n            this.calculateTimeWindow();\n            this.lastThrottleTime = this.getCurrentTimeInSeconds();\n            calculatedRate = this.cubicThrottle(rateToUse);\n            this.enableTokenBucket();\n        }\n        else {\n            this.calculateTimeWindow();\n            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n        }\n        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n        this.updateTokenBucketRate(newRate);\n    }\n    calculateTimeWindow() {\n        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));\n    }\n    cubicThrottle(rateToUse) {\n        return this.getPrecise(rateToUse * this.beta);\n    }\n    cubicSuccess(timestamp) {\n        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n    }\n    enableTokenBucket() {\n        this.enabled = true;\n    }\n    updateTokenBucketRate(newRate) {\n        this.refillTokenBucket();\n        this.fillRate = Math.max(newRate, this.minFillRate);\n        this.maxCapacity = Math.max(newRate, this.minCapacity);\n        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n    }\n    updateMeasuredRate() {\n        const t = this.getCurrentTimeInSeconds();\n        const timeBucket = Math.floor(t * 2) / 2;\n        this.requestCount++;\n        if (timeBucket > this.lastTxRateBucket) {\n            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n            this.requestCount = 0;\n            this.lastTxRateBucket = timeBucket;\n        }\n    }\n    getPrecise(num) {\n        return parseFloat(num.toFixed(8));\n    }\n}\nDefaultRateLimiter.setTimeoutFn = setTimeout;\n", "import { CLOCK_SKEW_ERROR_CODES, NODEJS_TIMEOUT_ERROR_CODES, THROTTLING_ERROR_CODES, TRANSIENT_ERROR_CODES, TRANSIENT_ERROR_STATUS_CODES, } from \"./constants\";\nexport const isRetryableByTrait = (error) => error.$retryable !== undefined;\nexport const isClockSkewError = (error) => CLOCK_SKEW_ERROR_CODES.includes(error.name);\nexport const isClockSkewCorrectedError = (error) => error.$metadata?.clockSkewCorrected;\nexport const isBrowserNetworkError = (error) => {\n    const errorMessages = new Set([\n        \"Failed to fetch\",\n        \"NetworkError when attempting to fetch resource\",\n        \"The Internet connection appears to be offline\",\n        \"Load failed\",\n        \"Network request failed\",\n    ]);\n    const isValid = error && error instanceof TypeError;\n    if (!isValid) {\n        return false;\n    }\n    return errorMessages.has(error.message);\n};\nexport const isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 ||\n    THROTTLING_ERROR_CODES.includes(error.name) ||\n    error.$retryable?.throttling == true;\nexport const isTransientError = (error, depth = 0) => isClockSkewCorrectedError(error) ||\n    TRANSIENT_ERROR_CODES.includes(error.name) ||\n    NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || \"\") ||\n    TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0) ||\n    isBrowserNetworkError(error) ||\n    (error.cause !== undefined && depth <= 10 && isTransientError(error.cause, depth + 1));\nexport const isServerError = (error) => {\n    if (error.$metadata?.httpStatusCode !== undefined) {\n        const statusCode = error.$metadata.httpStatusCode;\n        if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {\n            return true;\n        }\n        return false;\n    }\n    return false;\n};\n", "export const CLOCK_SKEW_ERROR_CODES = [\n    \"AuthFailure\",\n    \"InvalidSignatureException\",\n    \"RequestExpired\",\n    \"RequestInTheFuture\",\n    \"RequestTimeTooSkewed\",\n    \"SignatureDoesNotMatch\",\n];\nexport const THROTTLING_ERROR_CODES = [\n    \"BandwidthLimitExceeded\",\n    \"EC2ThrottledException\",\n    \"LimitExceededException\",\n    \"PriorRequestNotComplete\",\n    \"ProvisionedThroughputExceededException\",\n    \"RequestLimitExceeded\",\n    \"RequestThrottled\",\n    \"RequestThrottledException\",\n    \"SlowDown\",\n    \"ThrottledException\",\n    \"Throttling\",\n    \"ThrottlingException\",\n    \"TooManyRequestsException\",\n    \"TransactionInProgressException\",\n];\nexport const TRANSIENT_ERROR_CODES = [\"TimeoutError\", \"RequestTimeout\", \"RequestTimeoutException\"];\nexport const TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];\nexport const NODEJS_TIMEOUT_ERROR_CODES = [\"ECONNRESET\", \"ECONNREFUSED\", \"EPIPE\", \"ETIMEDOUT\"];\n", "import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST, } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nimport { createDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n    constructor(maxAttempts) {\n        this.maxAttempts = maxAttempts;\n        this.mode = RETRY_MODES.STANDARD;\n        this.capacity = INITIAL_RETRY_TOKENS;\n        this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();\n        this.maxAttemptsProvider = typeof maxAttempts === \"function\" ? maxAttempts : async () => maxAttempts;\n    }\n    async acquireInitialRetryToken(retryTokenScope) {\n        return createDefaultRetryToken({\n            retryDelay: DEFAULT_RETRY_DELAY_BASE,\n            retryCount: 0,\n        });\n    }\n    async refreshRetryTokenForRetry(token, errorInfo) {\n        const maxAttempts = await this.getMaxAttempts();\n        if (this.shouldRetry(token, errorInfo, maxAttempts)) {\n            const errorType = errorInfo.errorType;\n            this.retryBackoffStrategy.setDelayBase(errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);\n            const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());\n            const retryDelay = errorInfo.retryAfterHint\n                ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)\n                : delayFromErrorType;\n            const capacityCost = this.getCapacityCost(errorType);\n            this.capacity -= capacityCost;\n            return createDefaultRetryToken({\n                retryDelay,\n                retryCount: token.getRetryCount() + 1,\n                retryCost: capacityCost,\n            });\n        }\n        throw new Error(\"No retry token available\");\n    }\n    recordSuccess(token) {\n        this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));\n    }\n    getCapacity() {\n        return this.capacity;\n    }\n    async getMaxAttempts() {\n        try {\n            return await this.maxAttemptsProvider();\n        }\n        catch (error) {\n            console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n            return DEFAULT_MAX_ATTEMPTS;\n        }\n    }\n    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n        const attempts = tokenToRenew.getRetryCount() + 1;\n        return (attempts < maxAttempts &&\n            this.capacity >= this.getCapacityCost(errorInfo.errorType) &&\n            this.isRetryableError(errorInfo.errorType));\n    }\n    getCapacityCost(errorType) {\n        return errorType === \"TRANSIENT\" ? TIMEOUT_RETRY_COST : RETRY_COST;\n    }\n    isRetryableError(errorType) {\n        return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n    }\n}\n", "export const DEFAULT_RETRY_DELAY_BASE = 100;\nexport const MAXIMUM_RETRY_DELAY = 20 * 1000;\nexport const THROTTLING_RETRY_DELAY_BASE = 500;\nexport const INITIAL_RETRY_TOKENS = 500;\nexport const RETRY_COST = 5;\nexport const TIMEOUT_RETRY_COST = 10;\nexport const NO_RETRY_INCREMENT = 1;\nexport const INVOCATION_ID_HEADER = \"amz-sdk-invocation-id\";\nexport const REQUEST_HEADER = \"amz-sdk-request\";\n", "import { DEFAULT_RETRY_DELAY_BASE, MAXIMUM_RETRY_DELAY } from \"./constants\";\nexport const getDefaultRetryBackoffStrategy = () => {\n    let delayBase = DEFAULT_RETRY_DELAY_BASE;\n    const computeNextBackoffDelay = (attempts) => {\n        return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));\n    };\n    const setDelayBase = (delay) => {\n        delayBase = delay;\n    };\n    return {\n        computeNextBackoffDelay,\n        setDelayBase,\n    };\n};\n", "import { MAXIMUM_RETRY_DELAY } from \"./constants\";\nexport const createDefaultRetryToken = ({ retryDelay, retryCount, retryCost, }) => {\n    const getRetryCount = () => retryCount;\n    const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);\n    const getRetryCost = () => retryCost;\n    return {\n        getRetryCount,\n        getRetryDelay,\n        getRetryCost,\n    };\n};\n", "import { DEFAULT_RETRY_DELAY_BASE } from \"./constants\";\nimport { StandardRetryStrategy } from \"./StandardRetryStrategy\";\nexport class ConfiguredRetryStrategy extends StandardRetryStrategy {\n    constructor(maxAttempts, computeNextBackoffDelay = DEFAULT_RETRY_DELAY_BASE) {\n        super(typeof maxAttempts === \"function\" ? maxAttempts : async () => maxAttempts);\n        if (typeof computeNextBackoffDelay === \"number\") {\n            this.computeNextBackoffDelay = () => computeNextBackoffDelay;\n        }\n        else {\n            this.computeNextBackoffDelay = computeNextBackoffDelay;\n        }\n    }\n    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {\n        const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);\n        token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());\n        return token;\n    }\n}\n", "export {};\n", "import { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { isThrottlingError } from \"@smithy/service-error-classification\";\nimport { DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, INVOCATION_ID_HEADER, REQUEST_HEADER, RETRY_MODES, THROTTLING_RETRY_DELAY_BASE, } from \"@smithy/util-retry\";\nimport { v4 } from \"uuid\";\nimport { getDefaultRetryQuota } from \"./defaultRetryQuota\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\nimport { asSdkError } from \"./util\";\nexport class StandardRetryStrategy {\n    constructor(maxAttemptsProvider, options) {\n        this.maxAttemptsProvider = maxAttemptsProvider;\n        this.mode = RETRY_MODES.STANDARD;\n        this.retryDecider = options?.retryDecider ?? defaultRetryDecider;\n        this.delayDecider = options?.delayDecider ?? defaultDelayDecider;\n        this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(INITIAL_RETRY_TOKENS);\n    }\n    shouldRetry(error, attempts, maxAttempts) {\n        return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n    }\n    async getMaxAttempts() {\n        let maxAttempts;\n        try {\n            maxAttempts = await this.maxAttemptsProvider();\n        }\n        catch (error) {\n            maxAttempts = DEFAULT_MAX_ATTEMPTS;\n        }\n        return maxAttempts;\n    }\n    async retry(next, args, options) {\n        let retryTokenAmount;\n        let attempts = 0;\n        let totalDelay = 0;\n        const maxAttempts = await this.getMaxAttempts();\n        const { request } = args;\n        if (HttpRequest.isInstance(request)) {\n            request.headers[INVOCATION_ID_HEADER] = v4();\n        }\n        while (true) {\n            try {\n                if (HttpRequest.isInstance(request)) {\n                    request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n                }\n                if (options?.beforeRequest) {\n                    await options.beforeRequest();\n                }\n                const { response, output } = await next(args);\n                if (options?.afterRequest) {\n                    options.afterRequest(response);\n                }\n                this.retryQuota.releaseRetryTokens(retryTokenAmount);\n                output.$metadata.attempts = attempts + 1;\n                output.$metadata.totalRetryDelay = totalDelay;\n                return { response, output };\n            }\n            catch (e) {\n                const err = asSdkError(e);\n                attempts++;\n                if (this.shouldRetry(err, attempts, maxAttempts)) {\n                    retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);\n                    const delayFromDecider = this.delayDecider(isThrottlingError(err) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE, attempts);\n                    const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);\n                    const delay = Math.max(delayFromResponse || 0, delayFromDecider);\n                    totalDelay += delay;\n                    await new Promise((resolve) => setTimeout(resolve, delay));\n                    continue;\n                }\n                if (!err.$metadata) {\n                    err.$metadata = {};\n                }\n                err.$metadata.attempts = attempts;\n                err.$metadata.totalRetryDelay = totalDelay;\n                throw err;\n            }\n        }\n    }\n}\nconst getDelayFromRetryAfterHeader = (response) => {\n    if (!HttpResponse.isInstance(response))\n        return;\n    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === \"retry-after\");\n    if (!retryAfterHeaderName)\n        return;\n    const retryAfter = response.headers[retryAfterHeaderName];\n    const retryAfterSeconds = Number(retryAfter);\n    if (!Number.isNaN(retryAfterSeconds))\n        return retryAfterSeconds * 1000;\n    const retryAfterDate = new Date(retryAfter);\n    return retryAfterDate.getTime() - Date.now();\n};\n", "export { default as v1 } from './v1.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';\nexport { default as NIL } from './nil.js';\nexport { default as version } from './version.js';\nexport { default as validate } from './validate.js';\nexport { default as stringify } from './stringify.js';\nexport { default as parse } from './parse.js';", "// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};", "import { NO_RETRY_INCREMENT, RETRY_COST, TIMEOUT_RETRY_COST } from \"@smithy/util-retry\";\nexport const getDefaultRetryQuota = (initialRetryTokens, options) => {\n    const MAX_CAPACITY = initialRetryTokens;\n    const noRetryIncrement = options?.noRetryIncrement ?? NO_RETRY_INCREMENT;\n    const retryCost = options?.retryCost ?? RETRY_COST;\n    const timeoutRetryCost = options?.timeoutRetryCost ?? TIMEOUT_RETRY_COST;\n    let availableCapacity = initialRetryTokens;\n    const getCapacityAmount = (error) => (error.name === \"TimeoutError\" ? timeoutRetryCost : retryCost);\n    const hasRetryTokens = (error) => getCapacityAmount(error) <= availableCapacity;\n    const retrieveRetryTokens = (error) => {\n        if (!hasRetryTokens(error)) {\n            throw new Error(\"No retry token available\");\n        }\n        const capacityAmount = getCapacityAmount(error);\n        availableCapacity -= capacityAmount;\n        return capacityAmount;\n    };\n    const releaseRetryTokens = (capacityReleaseAmount) => {\n        availableCapacity += capacityReleaseAmount ?? noRetryIncrement;\n        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n    };\n    return Object.freeze({\n        hasRetryTokens,\n        retrieveRetryTokens,\n        releaseRetryTokens,\n    });\n};\n", "import { MAXIMUM_RETRY_DELAY } from \"@smithy/util-retry\";\nexport const defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));\n", "import { isClockSkewError, isRetryableByTrait, isThrottlingError, isTransientError, } from \"@smithy/service-error-classification\";\nexport const defaultRetryDecider = (error) => {\n    if (!error) {\n        return false;\n    }\n    return isRetryableByTrait(error) || isClockSkewError(error) || isThrottlingError(error) || isTransientError(error);\n};\n", "export const asSdkError = (error) => {\n    if (error instanceof Error)\n        return error;\n    if (error instanceof Object)\n        return Object.assign(new Error(), error);\n    if (typeof error === \"string\")\n        return new Error(error);\n    return new Error(`AWS SDK error wrapper for ${error}`);\n};\n", "import { normalizeProvider } from \"@smithy/util-middleware\";\nimport { AdaptiveRetryStrategy, DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_MODE, RETRY_MODES, StandardRetryStrategy, } from \"@smithy/util-retry\";\nexport const ENV_MAX_ATTEMPTS = \"AWS_MAX_ATTEMPTS\";\nexport const CONFIG_MAX_ATTEMPTS = \"max_attempts\";\nexport const NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {\n    environmentVariableSelector: (env) => {\n        const value = env[ENV_MAX_ATTEMPTS];\n        if (!value)\n            return undefined;\n        const maxAttempt = parseInt(value);\n        if (Number.isNaN(maxAttempt)) {\n            throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got \"${value}\"`);\n        }\n        return maxAttempt;\n    },\n    configFileSelector: (profile) => {\n        const value = profile[CONFIG_MAX_ATTEMPTS];\n        if (!value)\n            return undefined;\n        const maxAttempt = parseInt(value);\n        if (Number.isNaN(maxAttempt)) {\n            throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got \"${value}\"`);\n        }\n        return maxAttempt;\n    },\n    default: DEFAULT_MAX_ATTEMPTS,\n};\nexport const resolveRetryConfig = (input) => {\n    const { retryStrategy, retryMode: _retryMode, maxAttempts: _maxAttempts } = input;\n    const maxAttempts = normalizeProvider(_maxAttempts ?? DEFAULT_MAX_ATTEMPTS);\n    return Object.assign(input, {\n        maxAttempts,\n        retryStrategy: async () => {\n            if (retryStrategy) {\n                return retryStrategy;\n            }\n            const retryMode = await normalizeProvider(_retryMode)();\n            if (retryMode === RETRY_MODES.ADAPTIVE) {\n                return new AdaptiveRetryStrategy(maxAttempts);\n            }\n            return new StandardRetryStrategy(maxAttempts);\n        },\n    });\n};\nexport const ENV_RETRY_MODE = \"AWS_RETRY_MODE\";\nexport const CONFIG_RETRY_MODE = \"retry_mode\";\nexport const NODE_RETRY_MODE_CONFIG_OPTIONS = {\n    environmentVariableSelector: (env) => env[ENV_RETRY_MODE],\n    configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],\n    default: DEFAULT_RETRY_MODE,\n};\n", "import { HttpRequest } from \"@smithy/protocol-http\";\nimport { INVOCATION_ID_HEADER, REQUEST_HEADER } from \"@smithy/util-retry\";\nexport const omitRetryHeadersMiddleware = () => (next) => async (args) => {\n    const { request } = args;\n    if (HttpRequest.isInstance(request)) {\n        delete request.headers[INVOCATION_ID_HEADER];\n        delete request.headers[REQUEST_HEADER];\n    }\n    return next(args);\n};\nexport const omitRetryHeadersMiddlewareOptions = {\n    name: \"omitRetryHeadersMiddleware\",\n    tags: [\"RETRY\", \"HEADERS\", \"OMIT_RETRY_HEADERS\"],\n    relation: \"before\",\n    toMiddleware: \"awsAuthMiddleware\",\n    override: true,\n};\nexport const getOmitRetryHeadersPlugin = (options) => ({\n    applyToStack: (clientStack) => {\n        clientStack.addRelativeTo(omitRetryHeadersMiddleware(), omitRetryHeadersMiddlewareOptions);\n    },\n});\n", "import { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { isServerError, isThrottlingError, isTransientError } from \"@smithy/service-error-classification\";\nimport { NoOpLogger } from \"@smithy/smithy-client\";\nimport { INVOCATION_ID_HEADER, REQUEST_HEADER } from \"@smithy/util-retry\";\nimport { v4 } from \"uuid\";\nimport { isStreamingPayload } from \"./isStreamingPayload/isStreamingPayload\";\nimport { asSdkError } from \"./util\";\nexport const retryMiddleware = (options) => (next, context) => async (args) => {\n    let retryStrategy = await options.retryStrategy();\n    const maxAttempts = await options.maxAttempts();\n    if (isRetryStrategyV2(retryStrategy)) {\n        retryStrategy = retryStrategy;\n        let retryToken = await retryStrategy.acquireInitialRetryToken(context[\"partition_id\"]);\n        let lastError = new Error();\n        let attempts = 0;\n        let totalRetryDelay = 0;\n        const { request } = args;\n        const isRequest = HttpRequest.isInstance(request);\n        if (isRequest) {\n            request.headers[INVOCATION_ID_HEADER] = v4();\n        }\n        while (true) {\n            try {\n                if (isRequest) {\n                    request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n                }\n                const { response, output } = await next(args);\n                retryStrategy.recordSuccess(retryToken);\n                output.$metadata.attempts = attempts + 1;\n                output.$metadata.totalRetryDelay = totalRetryDelay;\n                return { response, output };\n            }\n            catch (e) {\n                const retryErrorInfo = getRetryErrorInfo(e);\n                lastError = asSdkError(e);\n                if (isRequest && isStreamingPayload(request)) {\n                    (context.logger instanceof NoOpLogger ? console : context.logger)?.warn(\"An error was encountered in a non-retryable streaming request.\");\n                    throw lastError;\n                }\n                try {\n                    retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);\n                }\n                catch (refreshError) {\n                    if (!lastError.$metadata) {\n                        lastError.$metadata = {};\n                    }\n                    lastError.$metadata.attempts = attempts + 1;\n                    lastError.$metadata.totalRetryDelay = totalRetryDelay;\n                    throw lastError;\n                }\n                attempts = retryToken.getRetryCount();\n                const delay = retryToken.getRetryDelay();\n                totalRetryDelay += delay;\n                await new Promise((resolve) => setTimeout(resolve, delay));\n            }\n        }\n    }\n    else {\n        retryStrategy = retryStrategy;\n        if (retryStrategy?.mode)\n            context.userAgent = [...(context.userAgent || []), [\"cfg/retry-mode\", retryStrategy.mode]];\n        return retryStrategy.retry(next, args);\n    }\n};\nconst isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== \"undefined\" &&\n    typeof retryStrategy.refreshRetryTokenForRetry !== \"undefined\" &&\n    typeof retryStrategy.recordSuccess !== \"undefined\";\nconst getRetryErrorInfo = (error) => {\n    const errorInfo = {\n        error,\n        errorType: getRetryErrorType(error),\n    };\n    const retryAfterHint = getRetryAfterHint(error.$response);\n    if (retryAfterHint) {\n        errorInfo.retryAfterHint = retryAfterHint;\n    }\n    return errorInfo;\n};\nconst getRetryErrorType = (error) => {\n    if (isThrottlingError(error))\n        return \"THROTTLING\";\n    if (isTransientError(error))\n        return \"TRANSIENT\";\n    if (isServerError(error))\n        return \"SERVER_ERROR\";\n    return \"CLIENT_ERROR\";\n};\nexport const retryMiddlewareOptions = {\n    name: \"retryMiddleware\",\n    tags: [\"RETRY\"],\n    step: \"finalizeRequest\",\n    priority: \"high\",\n    override: true,\n};\nexport const getRetryPlugin = (options) => ({\n    applyToStack: (clientStack) => {\n        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);\n    },\n});\nexport const getRetryAfterHint = (response) => {\n    if (!HttpResponse.isInstance(response))\n        return;\n    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === \"retry-after\");\n    if (!retryAfterHeaderName)\n        return;\n    const retryAfter = response.headers[retryAfterHeaderName];\n    const retryAfterSeconds = Number(retryAfter);\n    if (!Number.isNaN(retryAfterSeconds))\n        return new Date(retryAfterSeconds * 1000);\n    const retryAfterDate = new Date(retryAfter);\n    return retryAfterDate;\n};\n", "export const isStreamingPayload = (request) => request?.body instanceof ReadableStream;\n", "import { resolveAwsSdkSigV4Config, } from \"@aws-sdk/core\";\nimport { getSmithyContext, normalizeProvider } from \"@smithy/util-middleware\";\nexport const defaultEC2HttpAuthSchemeParametersProvider = async (config, context, input) => {\n    return {\n        operation: getSmithyContext(context).operation,\n        region: (await normalizeProvider(config.region)()) ||\n            (() => {\n                throw new Error(\"expected `region` to be configured for `aws.auth#sigv4`\");\n            })(),\n    };\n};\nfunction createAwsAuthSigv4HttpAuthOption(authParameters) {\n    return {\n        schemeId: \"aws.auth#sigv4\",\n        signingProperties: {\n            name: \"ec2\",\n            region: authParameters.region,\n        },\n        propertiesExtractor: (config, context) => ({\n            signingProperties: {\n                config,\n                context,\n            },\n        }),\n    };\n}\nexport const defaultEC2HttpAuthSchemeProvider = (authParameters) => {\n    const options = [];\n    switch (authParameters.operation) {\n        default: {\n            options.push(createAwsAuthSigv4HttpAuthOption(authParameters));\n        }\n    }\n    return options;\n};\nexport const resolveHttpAuthSchemeConfig = (config) => {\n    const config_0 = resolveAwsSdkSigV4Config(config);\n    return Object.assign(config_0, {\n        authSchemePreference: normalizeProvider(config.authSchemePreference ?? []),\n    });\n};\n", "export const resolveClientEndpointParameters = (options) => {\n    return Object.assign(options, {\n        useDualstackEndpoint: options.useDualstackEndpoint ?? false,\n        useFipsEndpoint: options.useFipsEndpoint ?? false,\n        defaultSigningName: \"ec2\",\n    });\n};\nexport const commonParams = {\n    UseFIPS: { type: \"builtInParams\", name: \"useFipsEndpoint\" },\n    Endpoint: { type: \"builtInParams\", name: \"endpoint\" },\n    Region: { type: \"builtInParams\", name: \"region\" },\n    UseDualStack: { type: \"builtInParams\", name: \"useDualstackEndpoint\" },\n};\n", "import packageInfo from \"../package.json\";\nimport { Sha256 } from \"@aws-crypto/sha256-browser\";\nimport { createDefaultUserAgentProvider } from \"@aws-sdk/util-user-agent-browser\";\nimport { DEFAULT_USE_DUALSTACK_ENDPOINT, DEFAULT_USE_FIPS_ENDPOINT } from \"@smithy/config-resolver\";\nimport { FetchHttpHandler as RequestHandler, streamCollector } from \"@smithy/fetch-http-handler\";\nimport { invalidProvider } from \"@smithy/invalid-dependency\";\nimport { calculateBodyLength } from \"@smithy/util-body-length-browser\";\nimport { DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_MODE } from \"@smithy/util-retry\";\nimport { getRuntimeConfig as getSharedRuntimeConfig } from \"./runtimeConfig.shared\";\nimport { loadConfigsForDefaultMode } from \"@smithy/smithy-client\";\nimport { resolveDefaultsModeConfig } from \"@smithy/util-defaults-mode-browser\";\nexport const getRuntimeConfig = (config) => {\n    const defaultsMode = resolveDefaultsModeConfig(config);\n    const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);\n    const clientSharedValues = getSharedRuntimeConfig(config);\n    return {\n        ...clientSharedValues,\n        ...config,\n        runtime: \"browser\",\n        defaultsMode,\n        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,\n        credentialDefaultProvider: config?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error(\"Credential is missing\"))),\n        defaultUserAgentProvider: config?.defaultUserAgentProvider ??\n            createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo.version }),\n        maxAttempts: config?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS,\n        region: config?.region ?? invalidProvider(\"Region is missing\"),\n        requestHandler: RequestHandler.create(config?.requestHandler ?? defaultConfigProvider),\n        retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),\n        sha256: config?.sha256 ?? Sha256,\n        streamCollector: config?.streamCollector ?? streamCollector,\n        useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),\n        useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT)),\n    };\n};\n", "{\n  \"name\": \"@aws-sdk/client-ec2\",\n  \"description\": \"AWS SDK for JavaScript Ec2 Client for Node.js, Browser and React Native\",\n  \"version\": \"3.819.0\",\n  \"scripts\": {\n    \"build\": \"concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'\",\n    \"build:cjs\": \"node ../../scripts/compilation/inline client-ec2\",\n    \"build:es\": \"tsc -p tsconfig.es.json\",\n    \"build:include:deps\": \"lerna run --scope $npm_package_name --include-dependencies build\",\n    \"build:types\": \"tsc -p tsconfig.types.json\",\n    \"build:types:downlevel\": \"downlevel-dts dist-types dist-types/ts3.4\",\n    \"clean\": \"rimraf ./dist-* && rimraf *.tsbuildinfo\",\n    \"extract:docs\": \"api-extractor run --local\",\n    \"generate:client\": \"node ../../scripts/generate-clients/single-service --solo ec2\"\n  },\n  \"main\": \"./dist-cjs/index.js\",\n  \"types\": \"./dist-types/index.d.ts\",\n  \"module\": \"./dist-es/index.js\",\n  \"sideEffects\": false,\n  \"dependencies\": {\n    \"@aws-crypto/sha256-browser\": \"5.2.0\",\n    \"@aws-crypto/sha256-js\": \"5.2.0\",\n    \"@aws-sdk/core\": \"3.816.0\",\n    \"@aws-sdk/credential-provider-node\": \"3.817.0\",\n    \"@aws-sdk/middleware-host-header\": \"3.804.0\",\n    \"@aws-sdk/middleware-logger\": \"3.804.0\",\n    \"@aws-sdk/middleware-recursion-detection\": \"3.804.0\",\n    \"@aws-sdk/middleware-sdk-ec2\": \"3.810.0\",\n    \"@aws-sdk/middleware-user-agent\": \"3.816.0\",\n    \"@aws-sdk/region-config-resolver\": \"3.808.0\",\n    \"@aws-sdk/types\": \"3.804.0\",\n    \"@aws-sdk/util-endpoints\": \"3.808.0\",\n    \"@aws-sdk/util-user-agent-browser\": \"3.804.0\",\n    \"@aws-sdk/util-user-agent-node\": \"3.816.0\",\n    \"@smithy/config-resolver\": \"^4.1.2\",\n    \"@smithy/core\": \"^3.3.3\",\n    \"@smithy/fetch-http-handler\": \"^5.0.2\",\n    \"@smithy/hash-node\": \"^4.0.2\",\n    \"@smithy/invalid-dependency\": \"^4.0.2\",\n    \"@smithy/middleware-content-length\": \"^4.0.2\",\n    \"@smithy/middleware-endpoint\": \"^4.1.6\",\n    \"@smithy/middleware-retry\": \"^4.1.7\",\n    \"@smithy/middleware-serde\": \"^4.0.5\",\n    \"@smithy/middleware-stack\": \"^4.0.2\",\n    \"@smithy/node-config-provider\": \"^4.1.1\",\n    \"@smithy/node-http-handler\": \"^4.0.4\",\n    \"@smithy/protocol-http\": \"^5.1.0\",\n    \"@smithy/smithy-client\": \"^4.2.6\",\n    \"@smithy/types\": \"^4.2.0\",\n    \"@smithy/url-parser\": \"^4.0.2\",\n    \"@smithy/util-base64\": \"^4.0.0\",\n    \"@smithy/util-body-length-browser\": \"^4.0.0\",\n    \"@smithy/util-body-length-node\": \"^4.0.0\",\n    \"@smithy/util-defaults-mode-browser\": \"^4.0.14\",\n    \"@smithy/util-defaults-mode-node\": \"^4.0.14\",\n    \"@smithy/util-endpoints\": \"^3.0.4\",\n    \"@smithy/util-middleware\": \"^4.0.2\",\n    \"@smithy/util-retry\": \"^4.0.3\",\n    \"@smithy/util-utf8\": \"^4.0.0\",\n    \"@smithy/util-waiter\": \"^4.0.3\",\n    \"@types/uuid\": \"^9.0.1\",\n    \"tslib\": \"^2.6.2\",\n    \"uuid\": \"^9.0.1\"\n  },\n  \"devDependencies\": {\n    \"@tsconfig/node18\": \"18.2.4\",\n    \"@types/node\": \"^18.19.69\",\n    \"concurrently\": \"7.0.0\",\n    \"downlevel-dts\": \"0.10.1\",\n    \"rimraf\": \"3.0.2\",\n    \"typescript\": \"~5.8.3\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"typesVersions\": {\n    \"<4.0\": {\n      \"dist-types/*\": [\n        \"dist-types/ts3.4/*\"\n      ]\n    }\n  },\n  \"files\": [\n    \"dist-*/**\"\n  ],\n  \"author\": {\n    \"name\": \"AWS SDK for JavaScript Team\",\n    \"url\": \"https://aws.amazon.com/javascript/\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"browser\": {\n    \"./dist-es/runtimeConfig\": \"./dist-es/runtimeConfig.browser\"\n  },\n  \"react-native\": {\n    \"./dist-es/runtimeConfig\": \"./dist-es/runtimeConfig.native\"\n  },\n  \"homepage\": \"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-ec2\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/aws/aws-sdk-js-v3.git\",\n    \"directory\": \"clients/client-ec2\"\n  }\n}\n", "export * from \"./crossPlatformSha256\";\nexport { Sha256 as WebCryptoSha256 } from \"./webCryptoSha256\";\n", "import { Sha256 as WebCryptoSha256 } from \"./webCryptoSha256\";\nimport { Sha256 as JsSha256 } from \"@aws-crypto/sha256-js\";\nimport { Checksum, SourceData } from \"@aws-sdk/types\";\nimport { supportsWebCrypto } from \"@aws-crypto/supports-web-crypto\";\nimport { locateWindow } from \"@aws-sdk/util-locate-window\";\nimport { convertToBuffer } from \"@aws-crypto/util\";\n\nexport class Sha256 implements Checksum {\n  private hash: Checksum;\n\n  constructor(secret?: SourceData) {\n    if (supportsWebCrypto(locateWindow())) {\n      this.hash = new WebCryptoSha256(secret);\n    } else {\n      this.hash = new JsSha256(secret);\n    }\n  }\n\n  update(data: SourceData, encoding?: \"utf8\" | \"ascii\" | \"latin1\"): void {\n    this.hash.update(convertToBuffer(data));\n  }\n\n  digest(): Promise<Uint8Array> {\n    return this.hash.digest();\n  }\n\n  reset(): void {\n    this.hash.reset();\n  }\n}\n", "import { Checksum, SourceData } from \"@aws-sdk/types\";\nimport { isEmptyData, convertToBuffer } from \"@aws-crypto/util\";\nimport {\n  EMPTY_DATA_SHA_256,\n  SHA_256_HASH,\n  SHA_256_HMAC_ALGO,\n} from \"./constants\";\nimport { locateWindow } from \"@aws-sdk/util-locate-window\";\n\nexport class Sha256 implements Checksum {\n  private readonly secret?: SourceData;\n  private key: Promise<CryptoKey> | undefined;\n  private toHash: Uint8Array = new Uint8Array(0);\n\n  constructor(secret?: SourceData) {\n    this.secret = secret;\n    this.reset();\n  }\n\n  update(data: SourceData): void {\n    if (isEmptyData(data)) {\n      return;\n    }\n\n    const update = convertToBuffer(data);\n    const typedArray = new Uint8Array(\n      this.toHash.byteLength + update.byteLength\n    );\n    typedArray.set(this.toHash, 0);\n    typedArray.set(update, this.toHash.byteLength);\n    this.toHash = typedArray;\n  }\n\n  digest(): Promise<Uint8Array> {\n    if (this.key) {\n      return this.key.then((key) =>\n        locateWindow()\n          .crypto.subtle.sign(SHA_256_HMAC_ALGO, key, this.toHash)\n          .then((data) => new Uint8Array(data))\n      );\n    }\n\n    if (isEmptyData(this.toHash)) {\n      return Promise.resolve(EMPTY_DATA_SHA_256);\n    }\n\n    return Promise.resolve()\n      .then(() =>\n        locateWindow().crypto.subtle.digest(SHA_256_HASH, this.toHash)\n      )\n      .then((data) => Promise.resolve(new Uint8Array(data)));\n  }\n\n  reset(): void {\n    this.toHash = new Uint8Array(0);\n    if (this.secret && this.secret !== void 0) {\n      this.key = new Promise((resolve, reject) => {\n        locateWindow()\n            .crypto.subtle.importKey(\n            \"raw\",\n            convertToBuffer(this.secret as SourceData),\n            SHA_256_HMAC_ALGO,\n            false,\n            [\"sign\"]\n        )\n            .then(resolve, reject);\n      });\n      this.key.catch(() => {});\n    }\n  }\n}\n", "// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nexport { convertToBuffer } from \"./convertToBuffer\";\nexport { isEmptyData } from \"./isEmptyData\";\nexport { numToUint8 } from \"./numToUint8\";\nexport {uint32ArrayFrom} from './uint32ArrayFrom';\n", "// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SourceData } from \"@aws-sdk/types\";\nimport { fromUtf8 as fromUtf8Browser } from \"@smithy/util-utf8\";\n\n// Quick polyfill\nconst fromUtf8 =\n  typeof Buffer !== \"undefined\" && Buffer.from\n    ? (input: string) => Buffer.from(input, \"utf8\")\n    : fromUtf8Browser;\n\nexport function convertToBuffer(data: SourceData): Uint8Array {\n  // Already a Uint8, do nothing\n  if (data instanceof Uint8Array) return data;\n\n  if (typeof data === \"string\") {\n    return fromUtf8(data);\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    return new Uint8Array(\n      data.buffer,\n      data.byteOffset,\n      data.byteLength / Uint8Array.BYTES_PER_ELEMENT\n    );\n  }\n\n  return new Uint8Array(data);\n}\n", "export * from \"./fromUtf8\";\nexport * from \"./toUint8Array\";\nexport * from \"./toUtf8\";\n", "export const fromUtf8 = (input) => new TextEncoder().encode(input);\n", "import { fromUtf8 } from \"./fromUtf8\";\nexport const toUint8Array = (data) => {\n    if (typeof data === \"string\") {\n        return fromUtf8(data);\n    }\n    if (ArrayBuffer.isView(data)) {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n    }\n    return new Uint8Array(data);\n};\n", "export const toUtf8 = (input) => {\n    if (typeof input === \"string\") {\n        return input;\n    }\n    if (typeof input !== \"object\" || typeof input.byteOffset !== \"number\" || typeof input.byteLength !== \"number\") {\n        throw new Error(\"@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.\");\n    }\n    return new TextDecoder(\"utf-8\").decode(input);\n};\n", "// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SourceData } from \"@aws-sdk/types\";\n\nexport function isEmptyData(data: SourceData): boolean {\n  if (typeof data === \"string\") {\n    return data.length === 0;\n  }\n\n  return data.byteLength === 0;\n}\n", "// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function numToUint8(num: number) {\n  return new Uint8Array([\n    (num & 0xff000000) >> 24,\n    (num & 0x00ff0000) >> 16,\n    (num & 0x0000ff00) >> 8,\n    num & 0x000000ff,\n  ]);\n}\n", "// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\n// IE 11 does not support Array.from, so we do it manually\nexport function uint32ArrayFrom(a_lookUpTable: Array<number>): Uint32Array {\n  if (!Uint32Array.from) {\n    const return_array = new Uint32Array(a_lookUpTable.length)\n    let a_index = 0\n    while (a_index < a_lookUpTable.length) {\n      return_array[a_index] = a_lookUpTable[a_index]\n      a_index += 1\n    }\n    return return_array\n  }\n  return Uint32Array.from(a_lookUpTable)\n}\n", "export const SHA_256_HASH: { name: \"SHA-256\" } = { name: \"SHA-256\" };\n\nexport const SHA_256_HMAC_ALGO: { name: \"HMAC\"; hash: { name: \"SHA-256\" } } = {\n  name: \"HMAC\",\n  hash: SHA_256_HASH\n};\n\nexport const EMPTY_DATA_SHA_256 = new Uint8Array([\n  227,\n  176,\n  196,\n  66,\n  152,\n  252,\n  28,\n  20,\n  154,\n  251,\n  244,\n  200,\n  153,\n  111,\n  185,\n  36,\n  39,\n  174,\n  65,\n  228,\n  100,\n  155,\n  147,\n  76,\n  164,\n  149,\n  153,\n  27,\n  120,\n  82,\n  184,\n  85\n]);\n", "const fallbackWindow = {};\nexport function locateWindow() {\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else if (typeof self !== \"undefined\") {\n        return self;\n    }\n    return fallbackWindow;\n}\n", "export * from \"./jsSha256\";\n", "/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n", "/**\n * @internal\n */\nexport const BLOCK_SIZE: number = 64;\n\n/**\n * @internal\n */\nexport const DIGEST_LENGTH: number = 32;\n\n/**\n * @internal\n */\nexport const KEY = new Uint32Array([\n  0x428a2f98,\n  0x71374491,\n  0xb5c0fbcf,\n  0xe9b5dba5,\n  0x3956c25b,\n  0x59f111f1,\n  0x923f82a4,\n  0xab1c5ed5,\n  0xd807aa98,\n  0x12835b01,\n  0x243185be,\n  0x550c7dc3,\n  0x72be5d74,\n  0x80deb1fe,\n  0x9bdc06a7,\n  0xc19bf174,\n  0xe49b69c1,\n  0xefbe4786,\n  0x0fc19dc6,\n  0x240ca1cc,\n  0x2de92c6f,\n  0x4a7484aa,\n  0x5cb0a9dc,\n  0x76f988da,\n  0x983e5152,\n  0xa831c66d,\n  0xb00327c8,\n  0xbf597fc7,\n  0xc6e00bf3,\n  0xd5a79147,\n  0x06ca6351,\n  0x14292967,\n  0x27b70a85,\n  0x2e1b2138,\n  0x4d2c6dfc,\n  0x53380d13,\n  0x650a7354,\n  0x766a0abb,\n  0x81c2c92e,\n  0x92722c85,\n  0xa2bfe8a1,\n  0xa81a664b,\n  0xc24b8b70,\n  0xc76c51a3,\n  0xd192e819,\n  0xd6990624,\n  0xf40e3585,\n  0x106aa070,\n  0x19a4c116,\n  0x1e376c08,\n  0x2748774c,\n  0x34b0bcb5,\n  0x391c0cb3,\n  0x4ed8aa4a,\n  0x5b9cca4f,\n  0x682e6ff3,\n  0x748f82ee,\n  0x78a5636f,\n  0x84c87814,\n  0x8cc70208,\n  0x90befffa,\n  0xa4506ceb,\n  0xbef9a3f7,\n  0xc67178f2\n]);\n\n/**\n * @internal\n */\nexport const INIT = [\n  0x6a09e667,\n  0xbb67ae85,\n  0x3c6ef372,\n  0xa54ff53a,\n  0x510e527f,\n  0x9b05688c,\n  0x1f83d9ab,\n  0x5be0cd19\n];\n\n/**\n * @internal\n */\nexport const MAX_HASHABLE_LENGTH = 2 ** 53 - 1;\n", "import {\n  BLOCK_SIZE,\n  DIGEST_LENGTH,\n  INIT,\n  KEY,\n  MAX_HASHABLE_LENGTH\n} from \"./constants\";\n\n/**\n * @internal\n */\nexport class RawSha256 {\n  private state: Int32Array = Int32Array.from(INIT);\n  private temp: Int32Array = new Int32Array(64);\n  private buffer: Uint8Array = new Uint8Array(64);\n  private bufferLength: number = 0;\n  private bytesHashed: number = 0;\n\n  /**\n   * @internal\n   */\n  finished: boolean = false;\n\n  update(data: Uint8Array): void {\n    if (this.finished) {\n      throw new Error(\"Attempted to update an already finished hash.\");\n    }\n\n    let position = 0;\n    let { byteLength } = data;\n    this.bytesHashed += byteLength;\n\n    if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {\n      throw new Error(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    while (byteLength > 0) {\n      this.buffer[this.bufferLength++] = data[position++];\n      byteLength--;\n\n      if (this.bufferLength === BLOCK_SIZE) {\n        this.hashBuffer();\n        this.bufferLength = 0;\n      }\n    }\n  }\n\n  digest(): Uint8Array {\n    if (!this.finished) {\n      const bitsHashed = this.bytesHashed * 8;\n      const bufferView = new DataView(\n        this.buffer.buffer,\n        this.buffer.byteOffset,\n        this.buffer.byteLength\n      );\n\n      const undecoratedLength = this.bufferLength;\n      bufferView.setUint8(this.bufferLength++, 0x80);\n\n      // Ensure the final block has enough room for the hashed length\n      if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {\n        for (let i = this.bufferLength; i < BLOCK_SIZE; i++) {\n          bufferView.setUint8(i, 0);\n        }\n        this.hashBuffer();\n        this.bufferLength = 0;\n      }\n\n      for (let i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {\n        bufferView.setUint8(i, 0);\n      }\n      bufferView.setUint32(\n        BLOCK_SIZE - 8,\n        Math.floor(bitsHashed / 0x100000000),\n        true\n      );\n      bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);\n\n      this.hashBuffer();\n\n      this.finished = true;\n    }\n\n    // The value in state is little-endian rather than big-endian, so flip\n    // each word into a new Uint8Array\n    const out = new Uint8Array(DIGEST_LENGTH);\n    for (let i = 0; i < 8; i++) {\n      out[i * 4] = (this.state[i] >>> 24) & 0xff;\n      out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n      out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n      out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n    }\n\n    return out;\n  }\n\n  private hashBuffer(): void {\n    const { buffer, state } = this;\n\n    let state0 = state[0],\n      state1 = state[1],\n      state2 = state[2],\n      state3 = state[3],\n      state4 = state[4],\n      state5 = state[5],\n      state6 = state[6],\n      state7 = state[7];\n\n    for (let i = 0; i < BLOCK_SIZE; i++) {\n      if (i < 16) {\n        this.temp[i] =\n          ((buffer[i * 4] & 0xff) << 24) |\n          ((buffer[i * 4 + 1] & 0xff) << 16) |\n          ((buffer[i * 4 + 2] & 0xff) << 8) |\n          (buffer[i * 4 + 3] & 0xff);\n      } else {\n        let u = this.temp[i - 2];\n        const t1 =\n          ((u >>> 17) | (u << 15)) ^ ((u >>> 19) | (u << 13)) ^ (u >>> 10);\n\n        u = this.temp[i - 15];\n        const t2 =\n          ((u >>> 7) | (u << 25)) ^ ((u >>> 18) | (u << 14)) ^ (u >>> 3);\n\n        this.temp[i] =\n          ((t1 + this.temp[i - 7]) | 0) + ((t2 + this.temp[i - 16]) | 0);\n      }\n\n      const t1 =\n        ((((((state4 >>> 6) | (state4 << 26)) ^\n          ((state4 >>> 11) | (state4 << 21)) ^\n          ((state4 >>> 25) | (state4 << 7))) +\n          ((state4 & state5) ^ (~state4 & state6))) |\n          0) +\n          ((state7 + ((KEY[i] + this.temp[i]) | 0)) | 0)) |\n        0;\n\n      const t2 =\n        ((((state0 >>> 2) | (state0 << 30)) ^\n          ((state0 >>> 13) | (state0 << 19)) ^\n          ((state0 >>> 22) | (state0 << 10))) +\n          ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) |\n        0;\n\n      state7 = state6;\n      state6 = state5;\n      state5 = state4;\n      state4 = (state3 + t1) | 0;\n      state3 = state2;\n      state2 = state1;\n      state1 = state0;\n      state0 = (t1 + t2) | 0;\n    }\n\n    state[0] += state0;\n    state[1] += state1;\n    state[2] += state2;\n    state[3] += state3;\n    state[4] += state4;\n    state[5] += state5;\n    state[6] += state6;\n    state[7] += state7;\n  }\n}\n", "import { BLOCK_SIZE } from \"./constants\";\nimport { RawSha256 } from \"./RawSha256\";\nimport { Checksum, SourceData } from \"@aws-sdk/types\";\nimport { isEmptyData, convertToBuffer } from \"@aws-crypto/util\";\n\nexport class Sha256 implements Checksum {\n  private readonly secret?: SourceData;\n  private hash: RawSha256;\n  private outer?: RawSha256;\n  private error: any;\n\n  constructor(secret?: SourceData) {\n    this.secret = secret;\n    this.hash = new RawSha256();\n    this.reset();\n  }\n\n  update(toHash: SourceData): void {\n    if (isEmptyData(toHash) || this.error) {\n      return;\n    }\n\n    try {\n      this.hash.update(convertToBuffer(toHash));\n    } catch (e) {\n      this.error = e;\n    }\n  }\n\n  /* This synchronous method keeps compatibility\n   * with the v2 aws-sdk.\n   */\n  digestSync(): Uint8Array {\n    if (this.error) {\n      throw this.error;\n    }\n\n    if (this.outer) {\n      if (!this.outer.finished) {\n        this.outer.update(this.hash.digest());\n      }\n\n      return this.outer.digest();\n    }\n\n    return this.hash.digest();\n  }\n\n  /* The underlying digest method here is synchronous.\n   * To keep the same interface with the other hash functions\n   * the default is to expose this as an async method.\n   * However, it can sometimes be useful to have a sync method.\n   */\n  async digest(): Promise<Uint8Array> {\n    return this.digestSync();\n  }\n\n  reset(): void {\n    this.hash = new RawSha256();\n    if (this.secret) {\n      this.outer = new RawSha256();\n      const inner = bufferFromSecret(this.secret);\n      const outer = new Uint8Array(BLOCK_SIZE);\n      outer.set(inner);\n\n      for (let i = 0; i < BLOCK_SIZE; i++) {\n        inner[i] ^= 0x36;\n        outer[i] ^= 0x5c;\n      }\n\n      this.hash.update(inner);\n      this.outer.update(outer);\n\n      // overwrite the copied key in memory\n      for (let i = 0; i < inner.byteLength; i++) {\n        inner[i] = 0;\n      }\n    }\n  }\n}\n\nfunction bufferFromSecret(secret: SourceData): Uint8Array {\n  let input = convertToBuffer(secret);\n\n  if (input.byteLength > BLOCK_SIZE) {\n    const bufferHash = new RawSha256();\n    bufferHash.update(input);\n    input = bufferHash.digest();\n  }\n\n  const buffer = new Uint8Array(BLOCK_SIZE);\n  buffer.set(input);\n  return buffer;\n}\n", "export * from \"./supportsWebCrypto\";\n", "type SubtleCryptoMethod =\n  | \"decrypt\"\n  | \"digest\"\n  | \"encrypt\"\n  | \"exportKey\"\n  | \"generateKey\"\n  | \"importKey\"\n  | \"sign\"\n  | \"verify\";\n\nconst subtleCryptoMethods: Array<SubtleCryptoMethod> = [\n  \"decrypt\",\n  \"digest\",\n  \"encrypt\",\n  \"exportKey\",\n  \"generateKey\",\n  \"importKey\",\n  \"sign\",\n  \"verify\"\n];\n\nexport function supportsWebCrypto(window: Window): boolean {\n  if (\n    supportsSecureRandom(window) &&\n    typeof window.crypto.subtle === \"object\"\n  ) {\n    const { subtle } = window.crypto;\n\n    return supportsSubtleCrypto(subtle);\n  }\n\n  return false;\n}\n\nexport function supportsSecureRandom(window: Window): boolean {\n  if (typeof window === \"object\" && typeof window.crypto === \"object\") {\n    const { getRandomValues } = window.crypto;\n\n    return typeof getRandomValues === \"function\";\n  }\n\n  return false;\n}\n\nexport function supportsSubtleCrypto(subtle: SubtleCrypto) {\n  return (\n    subtle &&\n    subtleCryptoMethods.every(\n      methodName => typeof subtle[methodName] === \"function\"\n    )\n  );\n}\n\nexport async function supportsZeroByteGCM(subtle: SubtleCrypto) {\n  if (!supportsSubtleCrypto(subtle)) return false;\n  try {\n    const key = await subtle.generateKey(\n      { name: \"AES-GCM\", length: 128 },\n      false,\n      [\"encrypt\"]\n    );\n    const zeroByteAuthTag = await subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv: new Uint8Array(Array(12)),\n        additionalData: new Uint8Array(Array(16)),\n        tagLength: 128\n      },\n      key,\n      new Uint8Array(0)\n    );\n    return zeroByteAuthTag.byteLength === 16;\n  } catch {\n    return false;\n  }\n}\n", "import bowser from \"bowser\";\nexport const createDefaultUserAgentProvider = ({ serviceId, clientVersion }) => async (config) => {\n    const parsedUA = typeof window !== \"undefined\" && window?.navigator?.userAgent\n        ? bowser.parse(window.navigator.userAgent)\n        : undefined;\n    const sections = [\n        [\"aws-sdk-js\", clientVersion],\n        [\"ua\", \"2.1\"],\n        [`os/${parsedUA?.os?.name || \"other\"}`, parsedUA?.os?.version],\n        [\"lang/js\"],\n        [\"md/browser\", `${parsedUA?.browser?.name ?? \"unknown\"}_${parsedUA?.browser?.version ?? \"unknown\"}`],\n    ];\n    if (serviceId) {\n        sections.push([`api/${serviceId}`, clientVersion]);\n    }\n    const appId = await config?.userAgentAppId?.();\n    if (appId) {\n        sections.push([`app/${appId}`]);\n    }\n    return sections;\n};\nexport const defaultUserAgent = createDefaultUserAgentProvider;\n", "export * from \"./invalidFunction\";\nexport * from \"./invalidProvider\";\n", "export const invalidFunction = (message) => () => {\n    throw new Error(message);\n};\n", "export const invalidProvider = (message) => () => Promise.reject(message);\n", "export * from \"./calculateBodyLength\";\n", "const TEXT_ENCODER = typeof TextEncoder == \"function\" ? new TextEncoder() : null;\nexport const calculateBodyLength = (body) => {\n    if (typeof body === \"string\") {\n        if (TEXT_ENCODER) {\n            return TEXT_ENCODER.encode(body).byteLength;\n        }\n        let len = body.length;\n        for (let i = len - 1; i >= 0; i--) {\n            const code = body.charCodeAt(i);\n            if (code > 0x7f && code <= 0x7ff)\n                len++;\n            else if (code > 0x7ff && code <= 0xffff)\n                len += 2;\n            if (code >= 0xdc00 && code <= 0xdfff)\n                i--;\n        }\n        return len;\n    }\n    else if (typeof body.byteLength === \"number\") {\n        return body.byteLength;\n    }\n    else if (typeof body.size === \"number\") {\n        return body.size;\n    }\n    throw new Error(`Body Length computation failed for ${body}`);\n};\n", "import { AwsSdkSigV4Signer } from \"@aws-sdk/core\";\nimport { NoOpLogger } from \"@smithy/smithy-client\";\nimport { parseUrl } from \"@smithy/url-parser\";\nimport { fromBase64, toBase64 } from \"@smithy/util-base64\";\nimport { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nimport { defaultEC2HttpAuthSchemeProvider } from \"./auth/httpAuthSchemeProvider\";\nimport { defaultEndpointResolver } from \"./endpoint/endpointResolver\";\nexport const getRuntimeConfig = (config) => {\n    return {\n        apiVersion: \"2016-11-15\",\n        base64Decoder: config?.base64Decoder ?? fromBase64,\n        base64Encoder: config?.base64Encoder ?? toBase64,\n        disableHostPrefix: config?.disableHostPrefix ?? false,\n        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,\n        extensions: config?.extensions ?? [],\n        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultEC2HttpAuthSchemeProvider,\n        httpAuthSchemes: config?.httpAuthSchemes ?? [\n            {\n                schemeId: \"aws.auth#sigv4\",\n                identityProvider: (ipc) => ipc.getIdentityProvider(\"aws.auth#sigv4\"),\n                signer: new AwsSdkSigV4Signer(),\n            },\n        ],\n        logger: config?.logger ?? new NoOpLogger(),\n        serviceId: config?.serviceId ?? \"EC2\",\n        urlParser: config?.urlParser ?? parseUrl,\n        utf8Decoder: config?.utf8Decoder ?? fromUtf8,\n        utf8Encoder: config?.utf8Encoder ?? toUtf8,\n    };\n};\n", "import { awsEndpointFunctions } from \"@aws-sdk/util-endpoints\";\nimport { customEndpointFunctions, EndpointCache, resolveEndpoint } from \"@smithy/util-endpoints\";\nimport { ruleSet } from \"./ruleset\";\nconst cache = new EndpointCache({\n    size: 50,\n    params: [\"Endpoint\", \"Region\", \"UseDualStack\", \"UseFIPS\"],\n});\nexport const defaultEndpointResolver = (endpointParams, context = {}) => {\n    return cache.get(endpointParams, () => resolveEndpoint(ruleSet, {\n        endpointParams: endpointParams,\n        logger: context.logger,\n    }));\n};\ncustomEndpointFunctions.aws = awsEndpointFunctions;\n", "const u = \"required\", v = \"fn\", w = \"argv\", x = \"ref\";\nconst a = true, b = \"isSet\", c = \"booleanEquals\", d = \"error\", e = \"endpoint\", f = \"tree\", g = \"PartitionResult\", h = \"getAttr\", i = { [u]: false, \"type\": \"String\" }, j = { [u]: true, \"default\": false, \"type\": \"Boolean\" }, k = { [x]: \"Endpoint\" }, l = { [v]: c, [w]: [{ [x]: \"UseFIPS\" }, true] }, m = { [v]: c, [w]: [{ [x]: \"UseDualStack\" }, true] }, n = {}, o = { [v]: h, [w]: [{ [x]: g }, \"supportsFIPS\"] }, p = { [x]: g }, q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, \"supportsDualStack\"] }] }, r = [l], s = [m], t = [{ [x]: \"Region\" }];\nconst _data = { version: \"1.0\", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: \"Invalid Configuration: FIPS and custom endpoint are not supported\", type: d }, { conditions: s, error: \"Invalid Configuration: Dualstack and custom endpoint are not supported\", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: \"aws.partition\", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: \"https://ec2-fips.{Region}.{PartitionResult#dualStackDnsSuffix}\", properties: n, headers: n }, type: e }], type: f }, { error: \"FIPS and DualStack are enabled, but this partition does not support one or both\", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: \"stringEquals\", [w]: [{ [v]: h, [w]: [p, \"name\"] }, \"aws-us-gov\"] }], endpoint: { url: \"https://ec2.{Region}.amazonaws.com\", properties: n, headers: n }, type: e }, { endpoint: { url: \"https://ec2-fips.{Region}.{PartitionResult#dnsSuffix}\", properties: n, headers: n }, type: e }], type: f }, { error: \"FIPS is enabled but this partition does not support FIPS\", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: \"https://ec2.{Region}.{PartitionResult#dualStackDnsSuffix}\", properties: n, headers: n }, type: e }], type: f }, { error: \"DualStack is enabled but this partition does not support DualStack\", type: d }], type: f }, { endpoint: { url: \"https://ec2.{Region}.{PartitionResult#dnsSuffix}\", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: \"Invalid Configuration: Missing Region\", type: d }] };\nexport const ruleSet = _data;\n", "export * from \"./resolveDefaultsModeConfig\";\n", "import { memoize } from \"@smithy/property-provider\";\nimport bowser from \"bowser\";\nimport { DEFAULTS_MODE_OPTIONS } from \"./constants\";\nexport const resolveDefaultsModeConfig = ({ defaultsMode, } = {}) => memoize(async () => {\n    const mode = typeof defaultsMode === \"function\" ? await defaultsMode() : defaultsMode;\n    switch (mode?.toLowerCase()) {\n        case \"auto\":\n            return Promise.resolve(isMobileBrowser() ? \"mobile\" : \"standard\");\n        case \"mobile\":\n        case \"in-region\":\n        case \"cross-region\":\n        case \"standard\":\n        case \"legacy\":\n            return Promise.resolve(mode?.toLocaleLowerCase());\n        case undefined:\n            return Promise.resolve(\"legacy\");\n        default:\n            throw new Error(`Invalid parameter for \"defaultsMode\", expect ${DEFAULTS_MODE_OPTIONS.join(\", \")}, got ${mode}`);\n    }\n});\nconst isMobileBrowser = () => {\n    const parsedUA = typeof window !== \"undefined\" && window?.navigator?.userAgent\n        ? bowser.parse(window.navigator.userAgent)\n        : undefined;\n    const platform = parsedUA?.platform?.type;\n    return platform === \"tablet\" || platform === \"mobile\";\n};\n", "export const DEFAULTS_MODE_OPTIONS = [\"in-region\", \"cross-region\", \"mobile\", \"standard\", \"legacy\"];\n", "import { getAwsRegionExtensionConfiguration, resolveAwsRegionExtensionConfiguration, } from \"@aws-sdk/region-config-resolver\";\nimport { getHttpHandlerExtensionConfiguration, resolveHttpHandlerRuntimeConfig } from \"@smithy/protocol-http\";\nimport { getDefaultExtensionConfiguration, resolveDefaultRuntimeConfig } from \"@smithy/smithy-client\";\nimport { getHttpAuthExtensionConfiguration, resolveHttpAuthRuntimeConfig } from \"./auth/httpAuthExtensionConfiguration\";\nexport const resolveRuntimeExtensions = (runtimeConfig, extensions) => {\n    const extensionConfiguration = Object.assign(getAwsRegionExtensionConfiguration(runtimeConfig), getDefaultExtensionConfiguration(runtimeConfig), getHttpHandlerExtensionConfiguration(runtimeConfig), getHttpAuthExtensionConfiguration(runtimeConfig));\n    extensions.forEach((extension) => extension.configure(extensionConfiguration));\n    return Object.assign(runtimeConfig, resolveAwsRegionExtensionConfiguration(extensionConfiguration), resolveDefaultRuntimeConfig(extensionConfiguration), resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));\n};\n", "export * from \"./extensions\";\nexport * from \"./regionConfig\";\n", "export const getAwsRegionExtensionConfiguration = (runtimeConfig) => {\n    return {\n        setRegion(region) {\n            runtimeConfig.region = region;\n        },\n        region() {\n            return runtimeConfig.region;\n        },\n    };\n};\nexport const resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {\n    return {\n        region: awsRegionExtensionConfiguration.region(),\n    };\n};\n", "export * from \"./config\";\nexport * from \"./resolveRegionConfig\";\n", "export const REGION_ENV_NAME = \"AWS_REGION\";\nexport const REGION_INI_NAME = \"region\";\nexport const NODE_REGION_CONFIG_OPTIONS = {\n    environmentVariableSelector: (env) => env[REGION_ENV_NAME],\n    configFileSelector: (profile) => profile[REGION_INI_NAME],\n    default: () => {\n        throw new Error(\"Region is missing\");\n    },\n};\nexport const NODE_REGION_CONFIG_FILE_OPTIONS = {\n    preferredFile: \"credentials\",\n};\n", "import { getRealRegion } from \"./getRealRegion\";\nimport { isFipsRegion } from \"./isFipsRegion\";\nexport const resolveRegionConfig = (input) => {\n    const { region, useFipsEndpoint } = input;\n    if (!region) {\n        throw new Error(\"Region is missing\");\n    }\n    return Object.assign(input, {\n        region: async () => {\n            if (typeof region === \"string\") {\n                return getRealRegion(region);\n            }\n            const providedRegion = await region();\n            return getRealRegion(providedRegion);\n        },\n        useFipsEndpoint: async () => {\n            const providedRegion = typeof region === \"string\" ? region : await region();\n            if (isFipsRegion(providedRegion)) {\n                return true;\n            }\n            return typeof useFipsEndpoint !== \"function\" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();\n        },\n    });\n};\n", "import { isFipsRegion } from \"./isFipsRegion\";\nexport const getRealRegion = (region) => isFipsRegion(region)\n    ? [\"fips-aws-global\", \"aws-fips\"].includes(region)\n        ? \"us-east-1\"\n        : region.replace(/fips-(dkr-|prod-)?|-fips/, \"\")\n    : region;\n", "export const isFipsRegion = (region) => typeof region === \"string\" && (region.startsWith(\"fips-\") || region.endsWith(\"-fips\"));\n", "export const getHttpAuthExtensionConfiguration = (runtimeConfig) => {\n    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;\n    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;\n    let _credentials = runtimeConfig.credentials;\n    return {\n        setHttpAuthScheme(httpAuthScheme) {\n            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);\n            if (index === -1) {\n                _httpAuthSchemes.push(httpAuthScheme);\n            }\n            else {\n                _httpAuthSchemes.splice(index, 1, httpAuthScheme);\n            }\n        },\n        httpAuthSchemes() {\n            return _httpAuthSchemes;\n        },\n        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {\n            _httpAuthSchemeProvider = httpAuthSchemeProvider;\n        },\n        httpAuthSchemeProvider() {\n            return _httpAuthSchemeProvider;\n        },\n        setCredentials(credentials) {\n            _credentials = credentials;\n        },\n        credentials() {\n            return _credentials;\n        },\n    };\n};\nexport const resolveHttpAuthRuntimeConfig = (config) => {\n    return {\n        httpAuthSchemes: config.httpAuthSchemes(),\n        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),\n        credentials: config.credentials(),\n    };\n};\n", "import { parseXmlBody as parseBody, parseXmlErrorBody as parseErrorBody } from \"@aws-sdk/core\";\nimport { HttpRequest as __HttpRequest } from \"@smithy/protocol-http\";\nimport { collectBody, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, serializeDateTime as __serializeDateTime, serializeFloat as __serializeFloat, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, strictParseLong as __strictParseLong, withBaseException, } from \"@smithy/smithy-client\";\nimport { v4 as generateIdempotencyToken } from \"uuid\";\nimport { EC2ServiceException as __BaseException } from \"../models/EC2ServiceException\";\nexport const se_AcceptAddressTransferCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AcceptAddressTransferRequest(input, context),\n        [_A]: _AAT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AcceptCapacityReservationBillingOwnershipCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AcceptCapacityReservationBillingOwnershipRequest(input, context),\n        [_A]: _ACRBO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AcceptReservedInstancesExchangeQuoteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AcceptReservedInstancesExchangeQuoteRequest(input, context),\n        [_A]: _ARIEQ,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AcceptTransitGatewayMulticastDomainAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AcceptTransitGatewayMulticastDomainAssociationsRequest(input, context),\n        [_A]: _ATGMDA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AcceptTransitGatewayPeeringAttachmentCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AcceptTransitGatewayPeeringAttachmentRequest(input, context),\n        [_A]: _ATGPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AcceptTransitGatewayVpcAttachmentCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AcceptTransitGatewayVpcAttachmentRequest(input, context),\n        [_A]: _ATGVA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AcceptVpcEndpointConnectionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AcceptVpcEndpointConnectionsRequest(input, context),\n        [_A]: _AVEC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AcceptVpcPeeringConnectionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AcceptVpcPeeringConnectionRequest(input, context),\n        [_A]: _AVPC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AdvertiseByoipCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AdvertiseByoipCidrRequest(input, context),\n        [_A]: _ABC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AllocateAddressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AllocateAddressRequest(input, context),\n        [_A]: _AA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AllocateHostsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AllocateHostsRequest(input, context),\n        [_A]: _AH,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AllocateIpamPoolCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AllocateIpamPoolCidrRequest(input, context),\n        [_A]: _AIPC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ApplySecurityGroupsToClientVpnTargetNetworkCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ApplySecurityGroupsToClientVpnTargetNetworkRequest(input, context),\n        [_A]: _ASGTCVTN,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssignIpv6AddressesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssignIpv6AddressesRequest(input, context),\n        [_A]: _AIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssignPrivateIpAddressesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssignPrivateIpAddressesRequest(input, context),\n        [_A]: _APIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssignPrivateNatGatewayAddressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssignPrivateNatGatewayAddressRequest(input, context),\n        [_A]: _APNGA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateAddressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateAddressRequest(input, context),\n        [_A]: _AAs,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateCapacityReservationBillingOwnerCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateCapacityReservationBillingOwnerRequest(input, context),\n        [_A]: _ACRBOs,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateClientVpnTargetNetworkCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateClientVpnTargetNetworkRequest(input, context),\n        [_A]: _ACVTN,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateDhcpOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateDhcpOptionsRequest(input, context),\n        [_A]: _ADO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateEnclaveCertificateIamRoleCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateEnclaveCertificateIamRoleRequest(input, context),\n        [_A]: _AECIR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateIamInstanceProfileCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateIamInstanceProfileRequest(input, context),\n        [_A]: _AIIP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateInstanceEventWindowCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateInstanceEventWindowRequest(input, context),\n        [_A]: _AIEW,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateIpamByoasnCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateIpamByoasnRequest(input, context),\n        [_A]: _AIB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateIpamResourceDiscoveryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateIpamResourceDiscoveryRequest(input, context),\n        [_A]: _AIRD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateNatGatewayAddressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateNatGatewayAddressRequest(input, context),\n        [_A]: _ANGA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateRouteServerCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateRouteServerRequest(input, context),\n        [_A]: _ARS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateRouteTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateRouteTableRequest(input, context),\n        [_A]: _ART,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateSecurityGroupVpcCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateSecurityGroupVpcRequest(input, context),\n        [_A]: _ASGV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateSubnetCidrBlockCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateSubnetCidrBlockRequest(input, context),\n        [_A]: _ASCB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateTransitGatewayMulticastDomainCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateTransitGatewayMulticastDomainRequest(input, context),\n        [_A]: _ATGMD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateTransitGatewayPolicyTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateTransitGatewayPolicyTableRequest(input, context),\n        [_A]: _ATGPT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateTransitGatewayRouteTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateTransitGatewayRouteTableRequest(input, context),\n        [_A]: _ATGRT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateTrunkInterfaceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateTrunkInterfaceRequest(input, context),\n        [_A]: _ATI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AssociateVpcCidrBlockCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AssociateVpcCidrBlockRequest(input, context),\n        [_A]: _AVCB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AttachClassicLinkVpcCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AttachClassicLinkVpcRequest(input, context),\n        [_A]: _ACLV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AttachInternetGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AttachInternetGatewayRequest(input, context),\n        [_A]: _AIG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AttachNetworkInterfaceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AttachNetworkInterfaceRequest(input, context),\n        [_A]: _ANI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AttachVerifiedAccessTrustProviderCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AttachVerifiedAccessTrustProviderRequest(input, context),\n        [_A]: _AVATP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AttachVolumeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AttachVolumeRequest(input, context),\n        [_A]: _AV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AttachVpnGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AttachVpnGatewayRequest(input, context),\n        [_A]: _AVG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AuthorizeClientVpnIngressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AuthorizeClientVpnIngressRequest(input, context),\n        [_A]: _ACVI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AuthorizeSecurityGroupEgressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AuthorizeSecurityGroupEgressRequest(input, context),\n        [_A]: _ASGE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_AuthorizeSecurityGroupIngressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_AuthorizeSecurityGroupIngressRequest(input, context),\n        [_A]: _ASGI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_BundleInstanceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_BundleInstanceRequest(input, context),\n        [_A]: _BI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CancelBundleTaskCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CancelBundleTaskRequest(input, context),\n        [_A]: _CBT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CancelCapacityReservationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CancelCapacityReservationRequest(input, context),\n        [_A]: _CCR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CancelCapacityReservationFleetsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CancelCapacityReservationFleetsRequest(input, context),\n        [_A]: _CCRF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CancelConversionTaskCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CancelConversionRequest(input, context),\n        [_A]: _CCT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CancelDeclarativePoliciesReportCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CancelDeclarativePoliciesReportRequest(input, context),\n        [_A]: _CDPR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CancelExportTaskCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CancelExportTaskRequest(input, context),\n        [_A]: _CET,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CancelImageLaunchPermissionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CancelImageLaunchPermissionRequest(input, context),\n        [_A]: _CILP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CancelImportTaskCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CancelImportTaskRequest(input, context),\n        [_A]: _CIT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CancelReservedInstancesListingCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CancelReservedInstancesListingRequest(input, context),\n        [_A]: _CRIL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CancelSpotFleetRequestsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CancelSpotFleetRequestsRequest(input, context),\n        [_A]: _CSFR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CancelSpotInstanceRequestsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CancelSpotInstanceRequestsRequest(input, context),\n        [_A]: _CSIR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ConfirmProductInstanceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ConfirmProductInstanceRequest(input, context),\n        [_A]: _CPI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CopyFpgaImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CopyFpgaImageRequest(input, context),\n        [_A]: _CFI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CopyImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CopyImageRequest(input, context),\n        [_A]: _CI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CopySnapshotCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CopySnapshotRequest(input, context),\n        [_A]: _CS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateCapacityReservationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateCapacityReservationRequest(input, context),\n        [_A]: _CCRr,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateCapacityReservationBySplittingCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateCapacityReservationBySplittingRequest(input, context),\n        [_A]: _CCRBS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateCapacityReservationFleetCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateCapacityReservationFleetRequest(input, context),\n        [_A]: _CCRFr,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateCarrierGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateCarrierGatewayRequest(input, context),\n        [_A]: _CCG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateClientVpnEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateClientVpnEndpointRequest(input, context),\n        [_A]: _CCVE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateClientVpnRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateClientVpnRouteRequest(input, context),\n        [_A]: _CCVR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateCoipCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateCoipCidrRequest(input, context),\n        [_A]: _CCC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateCoipPoolCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateCoipPoolRequest(input, context),\n        [_A]: _CCP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateCustomerGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateCustomerGatewayRequest(input, context),\n        [_A]: _CCGr,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateDefaultSubnetCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateDefaultSubnetRequest(input, context),\n        [_A]: _CDS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateDefaultVpcCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateDefaultVpcRequest(input, context),\n        [_A]: _CDV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateDelegateMacVolumeOwnershipTaskCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateDelegateMacVolumeOwnershipTaskRequest(input, context),\n        [_A]: _CDMVOT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateDhcpOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateDhcpOptionsRequest(input, context),\n        [_A]: _CDO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateEgressOnlyInternetGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateEgressOnlyInternetGatewayRequest(input, context),\n        [_A]: _CEOIG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateFleetCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateFleetRequest(input, context),\n        [_A]: _CF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateFlowLogsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateFlowLogsRequest(input, context),\n        [_A]: _CFL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateFpgaImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateFpgaImageRequest(input, context),\n        [_A]: _CFIr,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateImageRequest(input, context),\n        [_A]: _CIr,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateInstanceConnectEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateInstanceConnectEndpointRequest(input, context),\n        [_A]: _CICE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateInstanceEventWindowCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateInstanceEventWindowRequest(input, context),\n        [_A]: _CIEW,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateInstanceExportTaskCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateInstanceExportTaskRequest(input, context),\n        [_A]: _CIET,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateInternetGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateInternetGatewayRequest(input, context),\n        [_A]: _CIG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateIpamCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateIpamRequest(input, context),\n        [_A]: _CIre,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateIpamExternalResourceVerificationTokenCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateIpamExternalResourceVerificationTokenRequest(input, context),\n        [_A]: _CIERVT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateIpamPoolCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateIpamPoolRequest(input, context),\n        [_A]: _CIP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateIpamResourceDiscoveryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateIpamResourceDiscoveryRequest(input, context),\n        [_A]: _CIRD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateIpamScopeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateIpamScopeRequest(input, context),\n        [_A]: _CIS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateKeyPairCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateKeyPairRequest(input, context),\n        [_A]: _CKP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateLaunchTemplateCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateLaunchTemplateRequest(input, context),\n        [_A]: _CLT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateLaunchTemplateVersionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateLaunchTemplateVersionRequest(input, context),\n        [_A]: _CLTV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateLocalGatewayRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateLocalGatewayRouteRequest(input, context),\n        [_A]: _CLGR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateLocalGatewayRouteTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateLocalGatewayRouteTableRequest(input, context),\n        [_A]: _CLGRT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest(input, context),\n        [_A]: _CLGRTVIGA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateLocalGatewayRouteTableVpcAssociationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateLocalGatewayRouteTableVpcAssociationRequest(input, context),\n        [_A]: _CLGRTVA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateLocalGatewayVirtualInterfaceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateLocalGatewayVirtualInterfaceRequest(input, context),\n        [_A]: _CLGVI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateLocalGatewayVirtualInterfaceGroupCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateLocalGatewayVirtualInterfaceGroupRequest(input, context),\n        [_A]: _CLGVIG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateMacSystemIntegrityProtectionModificationTaskCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateMacSystemIntegrityProtectionModificationTaskRequest(input, context),\n        [_A]: _CMSIPMT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateManagedPrefixListCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateManagedPrefixListRequest(input, context),\n        [_A]: _CMPL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateNatGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateNatGatewayRequest(input, context),\n        [_A]: _CNG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateNetworkAclCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateNetworkAclRequest(input, context),\n        [_A]: _CNA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateNetworkAclEntryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateNetworkAclEntryRequest(input, context),\n        [_A]: _CNAE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateNetworkInsightsAccessScopeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateNetworkInsightsAccessScopeRequest(input, context),\n        [_A]: _CNIAS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateNetworkInsightsPathCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateNetworkInsightsPathRequest(input, context),\n        [_A]: _CNIP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateNetworkInterfaceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateNetworkInterfaceRequest(input, context),\n        [_A]: _CNI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateNetworkInterfacePermissionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateNetworkInterfacePermissionRequest(input, context),\n        [_A]: _CNIPr,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreatePlacementGroupCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreatePlacementGroupRequest(input, context),\n        [_A]: _CPG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreatePublicIpv4PoolCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreatePublicIpv4PoolRequest(input, context),\n        [_A]: _CPIP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateReplaceRootVolumeTaskCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateReplaceRootVolumeTaskRequest(input, context),\n        [_A]: _CRRVT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateReservedInstancesListingCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateReservedInstancesListingRequest(input, context),\n        [_A]: _CRILr,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateRestoreImageTaskCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateRestoreImageTaskRequest(input, context),\n        [_A]: _CRIT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateRouteRequest(input, context),\n        [_A]: _CR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateRouteServerCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateRouteServerRequest(input, context),\n        [_A]: _CRS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateRouteServerEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateRouteServerEndpointRequest(input, context),\n        [_A]: _CRSE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateRouteServerPeerCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateRouteServerPeerRequest(input, context),\n        [_A]: _CRSP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateRouteTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateRouteTableRequest(input, context),\n        [_A]: _CRT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateSecurityGroupCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateSecurityGroupRequest(input, context),\n        [_A]: _CSG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateSnapshotCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateSnapshotRequest(input, context),\n        [_A]: _CSr,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateSnapshotsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateSnapshotsRequest(input, context),\n        [_A]: _CSre,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateSpotDatafeedSubscriptionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateSpotDatafeedSubscriptionRequest(input, context),\n        [_A]: _CSDS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateStoreImageTaskCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateStoreImageTaskRequest(input, context),\n        [_A]: _CSIT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateSubnetCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateSubnetRequest(input, context),\n        [_A]: _CSrea,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateSubnetCidrReservationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateSubnetCidrReservationRequest(input, context),\n        [_A]: _CSCR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTagsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTagsRequest(input, context),\n        [_A]: _CT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTrafficMirrorFilterCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTrafficMirrorFilterRequest(input, context),\n        [_A]: _CTMF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTrafficMirrorFilterRuleCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTrafficMirrorFilterRuleRequest(input, context),\n        [_A]: _CTMFR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTrafficMirrorSessionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTrafficMirrorSessionRequest(input, context),\n        [_A]: _CTMS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTrafficMirrorTargetCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTrafficMirrorTargetRequest(input, context),\n        [_A]: _CTMT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTransitGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTransitGatewayRequest(input, context),\n        [_A]: _CTG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTransitGatewayConnectCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTransitGatewayConnectRequest(input, context),\n        [_A]: _CTGC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTransitGatewayConnectPeerCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTransitGatewayConnectPeerRequest(input, context),\n        [_A]: _CTGCP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTransitGatewayMulticastDomainCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTransitGatewayMulticastDomainRequest(input, context),\n        [_A]: _CTGMD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTransitGatewayPeeringAttachmentCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTransitGatewayPeeringAttachmentRequest(input, context),\n        [_A]: _CTGPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTransitGatewayPolicyTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTransitGatewayPolicyTableRequest(input, context),\n        [_A]: _CTGPT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTransitGatewayPrefixListReferenceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTransitGatewayPrefixListReferenceRequest(input, context),\n        [_A]: _CTGPLR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTransitGatewayRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTransitGatewayRouteRequest(input, context),\n        [_A]: _CTGR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTransitGatewayRouteTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTransitGatewayRouteTableRequest(input, context),\n        [_A]: _CTGRT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTransitGatewayRouteTableAnnouncementCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTransitGatewayRouteTableAnnouncementRequest(input, context),\n        [_A]: _CTGRTA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateTransitGatewayVpcAttachmentCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateTransitGatewayVpcAttachmentRequest(input, context),\n        [_A]: _CTGVA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVerifiedAccessEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVerifiedAccessEndpointRequest(input, context),\n        [_A]: _CVAE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVerifiedAccessGroupCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVerifiedAccessGroupRequest(input, context),\n        [_A]: _CVAG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVerifiedAccessInstanceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVerifiedAccessInstanceRequest(input, context),\n        [_A]: _CVAI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVerifiedAccessTrustProviderCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVerifiedAccessTrustProviderRequest(input, context),\n        [_A]: _CVATP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVolumeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVolumeRequest(input, context),\n        [_A]: _CV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVpcCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVpcRequest(input, context),\n        [_A]: _CVr,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVpcBlockPublicAccessExclusionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVpcBlockPublicAccessExclusionRequest(input, context),\n        [_A]: _CVBPAE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVpcEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVpcEndpointRequest(input, context),\n        [_A]: _CVE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVpcEndpointConnectionNotificationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVpcEndpointConnectionNotificationRequest(input, context),\n        [_A]: _CVECN,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVpcEndpointServiceConfigurationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVpcEndpointServiceConfigurationRequest(input, context),\n        [_A]: _CVESC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVpcPeeringConnectionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVpcPeeringConnectionRequest(input, context),\n        [_A]: _CVPC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVpnConnectionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVpnConnectionRequest(input, context),\n        [_A]: _CVC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVpnConnectionRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVpnConnectionRouteRequest(input, context),\n        [_A]: _CVCR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_CreateVpnGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_CreateVpnGatewayRequest(input, context),\n        [_A]: _CVG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteCarrierGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteCarrierGatewayRequest(input, context),\n        [_A]: _DCG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteClientVpnEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteClientVpnEndpointRequest(input, context),\n        [_A]: _DCVE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteClientVpnRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteClientVpnRouteRequest(input, context),\n        [_A]: _DCVR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteCoipCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteCoipCidrRequest(input, context),\n        [_A]: _DCC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteCoipPoolCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteCoipPoolRequest(input, context),\n        [_A]: _DCP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteCustomerGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteCustomerGatewayRequest(input, context),\n        [_A]: _DCGe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteDhcpOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteDhcpOptionsRequest(input, context),\n        [_A]: _DDO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteEgressOnlyInternetGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteEgressOnlyInternetGatewayRequest(input, context),\n        [_A]: _DEOIG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteFleetsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteFleetsRequest(input, context),\n        [_A]: _DF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteFlowLogsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteFlowLogsRequest(input, context),\n        [_A]: _DFL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteFpgaImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteFpgaImageRequest(input, context),\n        [_A]: _DFI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteInstanceConnectEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteInstanceConnectEndpointRequest(input, context),\n        [_A]: _DICE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteInstanceEventWindowCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteInstanceEventWindowRequest(input, context),\n        [_A]: _DIEW,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteInternetGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteInternetGatewayRequest(input, context),\n        [_A]: _DIG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteIpamCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteIpamRequest(input, context),\n        [_A]: _DI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteIpamExternalResourceVerificationTokenCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteIpamExternalResourceVerificationTokenRequest(input, context),\n        [_A]: _DIERVT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteIpamPoolCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteIpamPoolRequest(input, context),\n        [_A]: _DIP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteIpamResourceDiscoveryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteIpamResourceDiscoveryRequest(input, context),\n        [_A]: _DIRD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteIpamScopeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteIpamScopeRequest(input, context),\n        [_A]: _DIS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteKeyPairCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteKeyPairRequest(input, context),\n        [_A]: _DKP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteLaunchTemplateCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteLaunchTemplateRequest(input, context),\n        [_A]: _DLT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteLaunchTemplateVersionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteLaunchTemplateVersionsRequest(input, context),\n        [_A]: _DLTV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteLocalGatewayRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteLocalGatewayRouteRequest(input, context),\n        [_A]: _DLGR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteLocalGatewayRouteTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteLocalGatewayRouteTableRequest(input, context),\n        [_A]: _DLGRT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest(input, context),\n        [_A]: _DLGRTVIGA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteLocalGatewayRouteTableVpcAssociationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteLocalGatewayRouteTableVpcAssociationRequest(input, context),\n        [_A]: _DLGRTVA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteLocalGatewayVirtualInterfaceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteLocalGatewayVirtualInterfaceRequest(input, context),\n        [_A]: _DLGVI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteLocalGatewayVirtualInterfaceGroupCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteLocalGatewayVirtualInterfaceGroupRequest(input, context),\n        [_A]: _DLGVIG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteManagedPrefixListCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteManagedPrefixListRequest(input, context),\n        [_A]: _DMPL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteNatGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteNatGatewayRequest(input, context),\n        [_A]: _DNG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteNetworkAclCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteNetworkAclRequest(input, context),\n        [_A]: _DNA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteNetworkAclEntryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteNetworkAclEntryRequest(input, context),\n        [_A]: _DNAE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteNetworkInsightsAccessScopeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteNetworkInsightsAccessScopeRequest(input, context),\n        [_A]: _DNIAS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteNetworkInsightsAccessScopeAnalysisCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteNetworkInsightsAccessScopeAnalysisRequest(input, context),\n        [_A]: _DNIASA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteNetworkInsightsAnalysisCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteNetworkInsightsAnalysisRequest(input, context),\n        [_A]: _DNIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteNetworkInsightsPathCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteNetworkInsightsPathRequest(input, context),\n        [_A]: _DNIP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteNetworkInterfaceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteNetworkInterfaceRequest(input, context),\n        [_A]: _DNI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteNetworkInterfacePermissionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteNetworkInterfacePermissionRequest(input, context),\n        [_A]: _DNIPe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeletePlacementGroupCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeletePlacementGroupRequest(input, context),\n        [_A]: _DPG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeletePublicIpv4PoolCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeletePublicIpv4PoolRequest(input, context),\n        [_A]: _DPIP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteQueuedReservedInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteQueuedReservedInstancesRequest(input, context),\n        [_A]: _DQRI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteRouteRequest(input, context),\n        [_A]: _DR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteRouteServerCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteRouteServerRequest(input, context),\n        [_A]: _DRS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteRouteServerEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteRouteServerEndpointRequest(input, context),\n        [_A]: _DRSE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteRouteServerPeerCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteRouteServerPeerRequest(input, context),\n        [_A]: _DRSP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteRouteTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteRouteTableRequest(input, context),\n        [_A]: _DRT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteSecurityGroupCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteSecurityGroupRequest(input, context),\n        [_A]: _DSG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteSnapshotCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteSnapshotRequest(input, context),\n        [_A]: _DS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteSpotDatafeedSubscriptionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteSpotDatafeedSubscriptionRequest(input, context),\n        [_A]: _DSDS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteSubnetCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteSubnetRequest(input, context),\n        [_A]: _DSe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteSubnetCidrReservationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteSubnetCidrReservationRequest(input, context),\n        [_A]: _DSCR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTagsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTagsRequest(input, context),\n        [_A]: _DT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTrafficMirrorFilterCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTrafficMirrorFilterRequest(input, context),\n        [_A]: _DTMF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTrafficMirrorFilterRuleCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTrafficMirrorFilterRuleRequest(input, context),\n        [_A]: _DTMFR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTrafficMirrorSessionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTrafficMirrorSessionRequest(input, context),\n        [_A]: _DTMS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTrafficMirrorTargetCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTrafficMirrorTargetRequest(input, context),\n        [_A]: _DTMT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTransitGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTransitGatewayRequest(input, context),\n        [_A]: _DTG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTransitGatewayConnectCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTransitGatewayConnectRequest(input, context),\n        [_A]: _DTGC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTransitGatewayConnectPeerCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTransitGatewayConnectPeerRequest(input, context),\n        [_A]: _DTGCP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTransitGatewayMulticastDomainCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTransitGatewayMulticastDomainRequest(input, context),\n        [_A]: _DTGMD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTransitGatewayPeeringAttachmentCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTransitGatewayPeeringAttachmentRequest(input, context),\n        [_A]: _DTGPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTransitGatewayPolicyTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTransitGatewayPolicyTableRequest(input, context),\n        [_A]: _DTGPT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTransitGatewayPrefixListReferenceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTransitGatewayPrefixListReferenceRequest(input, context),\n        [_A]: _DTGPLR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTransitGatewayRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTransitGatewayRouteRequest(input, context),\n        [_A]: _DTGR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTransitGatewayRouteTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTransitGatewayRouteTableRequest(input, context),\n        [_A]: _DTGRT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTransitGatewayRouteTableAnnouncementCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTransitGatewayRouteTableAnnouncementRequest(input, context),\n        [_A]: _DTGRTA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteTransitGatewayVpcAttachmentCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteTransitGatewayVpcAttachmentRequest(input, context),\n        [_A]: _DTGVA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVerifiedAccessEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVerifiedAccessEndpointRequest(input, context),\n        [_A]: _DVAE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVerifiedAccessGroupCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVerifiedAccessGroupRequest(input, context),\n        [_A]: _DVAG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVerifiedAccessInstanceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVerifiedAccessInstanceRequest(input, context),\n        [_A]: _DVAI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVerifiedAccessTrustProviderCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVerifiedAccessTrustProviderRequest(input, context),\n        [_A]: _DVATP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVolumeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVolumeRequest(input, context),\n        [_A]: _DV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVpcCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVpcRequest(input, context),\n        [_A]: _DVe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVpcBlockPublicAccessExclusionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVpcBlockPublicAccessExclusionRequest(input, context),\n        [_A]: _DVBPAE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVpcEndpointConnectionNotificationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVpcEndpointConnectionNotificationsRequest(input, context),\n        [_A]: _DVECN,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVpcEndpointsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVpcEndpointsRequest(input, context),\n        [_A]: _DVE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVpcEndpointServiceConfigurationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVpcEndpointServiceConfigurationsRequest(input, context),\n        [_A]: _DVESC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVpcPeeringConnectionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVpcPeeringConnectionRequest(input, context),\n        [_A]: _DVPC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVpnConnectionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVpnConnectionRequest(input, context),\n        [_A]: _DVC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVpnConnectionRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVpnConnectionRouteRequest(input, context),\n        [_A]: _DVCR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteVpnGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteVpnGatewayRequest(input, context),\n        [_A]: _DVG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeprovisionByoipCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeprovisionByoipCidrRequest(input, context),\n        [_A]: _DBC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeprovisionIpamByoasnCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeprovisionIpamByoasnRequest(input, context),\n        [_A]: _DIB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeprovisionIpamPoolCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeprovisionIpamPoolCidrRequest(input, context),\n        [_A]: _DIPC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeprovisionPublicIpv4PoolCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeprovisionPublicIpv4PoolCidrRequest(input, context),\n        [_A]: _DPIPC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeregisterImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeregisterImageRequest(input, context),\n        [_A]: _DIe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeregisterInstanceEventNotificationAttributesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeregisterInstanceEventNotificationAttributesRequest(input, context),\n        [_A]: _DIENA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeregisterTransitGatewayMulticastGroupMembersCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeregisterTransitGatewayMulticastGroupMembersRequest(input, context),\n        [_A]: _DTGMGM,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeregisterTransitGatewayMulticastGroupSourcesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeregisterTransitGatewayMulticastGroupSourcesRequest(input, context),\n        [_A]: _DTGMGS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeAccountAttributesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeAccountAttributesRequest(input, context),\n        [_A]: _DAA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeAddressesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeAddressesRequest(input, context),\n        [_A]: _DA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeAddressesAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeAddressesAttributeRequest(input, context),\n        [_A]: _DAAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeAddressTransfersCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeAddressTransfersRequest(input, context),\n        [_A]: _DAT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeAggregateIdFormatCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeAggregateIdFormatRequest(input, context),\n        [_A]: _DAIF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeAvailabilityZonesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeAvailabilityZonesRequest(input, context),\n        [_A]: _DAZ,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeAwsNetworkPerformanceMetricSubscriptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeAwsNetworkPerformanceMetricSubscriptionsRequest(input, context),\n        [_A]: _DANPMS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeBundleTasksCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeBundleTasksRequest(input, context),\n        [_A]: _DBT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeByoipCidrsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeByoipCidrsRequest(input, context),\n        [_A]: _DBCe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeCapacityBlockExtensionHistoryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeCapacityBlockExtensionHistoryRequest(input, context),\n        [_A]: _DCBEH,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeCapacityBlockExtensionOfferingsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeCapacityBlockExtensionOfferingsRequest(input, context),\n        [_A]: _DCBEO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeCapacityBlockOfferingsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeCapacityBlockOfferingsRequest(input, context),\n        [_A]: _DCBO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeCapacityReservationBillingRequestsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeCapacityReservationBillingRequestsRequest(input, context),\n        [_A]: _DCRBR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeCapacityReservationFleetsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeCapacityReservationFleetsRequest(input, context),\n        [_A]: _DCRF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeCapacityReservationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeCapacityReservationsRequest(input, context),\n        [_A]: _DCR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeCarrierGatewaysCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeCarrierGatewaysRequest(input, context),\n        [_A]: _DCGes,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeClassicLinkInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeClassicLinkInstancesRequest(input, context),\n        [_A]: _DCLI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeClientVpnAuthorizationRulesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeClientVpnAuthorizationRulesRequest(input, context),\n        [_A]: _DCVAR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeClientVpnConnectionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeClientVpnConnectionsRequest(input, context),\n        [_A]: _DCVC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeClientVpnEndpointsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeClientVpnEndpointsRequest(input, context),\n        [_A]: _DCVEe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeClientVpnRoutesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeClientVpnRoutesRequest(input, context),\n        [_A]: _DCVRe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeClientVpnTargetNetworksCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeClientVpnTargetNetworksRequest(input, context),\n        [_A]: _DCVTN,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeCoipPoolsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeCoipPoolsRequest(input, context),\n        [_A]: _DCPe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeConversionTasksCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeConversionTasksRequest(input, context),\n        [_A]: _DCT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeCustomerGatewaysCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeCustomerGatewaysRequest(input, context),\n        [_A]: _DCGesc,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeDeclarativePoliciesReportsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeDeclarativePoliciesReportsRequest(input, context),\n        [_A]: _DDPR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeDhcpOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeDhcpOptionsRequest(input, context),\n        [_A]: _DDOe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeEgressOnlyInternetGatewaysCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeEgressOnlyInternetGatewaysRequest(input, context),\n        [_A]: _DEOIGe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeElasticGpusCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeElasticGpusRequest(input, context),\n        [_A]: _DEG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeExportImageTasksCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeExportImageTasksRequest(input, context),\n        [_A]: _DEIT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeExportTasksCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeExportTasksRequest(input, context),\n        [_A]: _DET,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeFastLaunchImagesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeFastLaunchImagesRequest(input, context),\n        [_A]: _DFLI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeFastSnapshotRestoresCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeFastSnapshotRestoresRequest(input, context),\n        [_A]: _DFSR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeFleetHistoryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeFleetHistoryRequest(input, context),\n        [_A]: _DFH,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeFleetInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeFleetInstancesRequest(input, context),\n        [_A]: _DFIe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeFleetsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeFleetsRequest(input, context),\n        [_A]: _DFe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeFlowLogsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeFlowLogsRequest(input, context),\n        [_A]: _DFLe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeFpgaImageAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeFpgaImageAttributeRequest(input, context),\n        [_A]: _DFIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeFpgaImagesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeFpgaImagesRequest(input, context),\n        [_A]: _DFIes,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeHostReservationOfferingsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeHostReservationOfferingsRequest(input, context),\n        [_A]: _DHRO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeHostReservationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeHostReservationsRequest(input, context),\n        [_A]: _DHR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeHostsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeHostsRequest(input, context),\n        [_A]: _DH,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeIamInstanceProfileAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeIamInstanceProfileAssociationsRequest(input, context),\n        [_A]: _DIIPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeIdentityIdFormatCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeIdentityIdFormatRequest(input, context),\n        [_A]: _DIIF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeIdFormatCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeIdFormatRequest(input, context),\n        [_A]: _DIF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeImageAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeImageAttributeRequest(input, context),\n        [_A]: _DIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeImagesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeImagesRequest(input, context),\n        [_A]: _DIes,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeImportImageTasksCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeImportImageTasksRequest(input, context),\n        [_A]: _DIIT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeImportSnapshotTasksCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeImportSnapshotTasksRequest(input, context),\n        [_A]: _DIST,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInstanceAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInstanceAttributeRequest(input, context),\n        [_A]: _DIAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInstanceConnectEndpointsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInstanceConnectEndpointsRequest(input, context),\n        [_A]: _DICEe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInstanceCreditSpecificationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInstanceCreditSpecificationsRequest(input, context),\n        [_A]: _DICS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInstanceEventNotificationAttributesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInstanceEventNotificationAttributesRequest(input, context),\n        [_A]: _DIENAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInstanceEventWindowsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInstanceEventWindowsRequest(input, context),\n        [_A]: _DIEWe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInstanceImageMetadataCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInstanceImageMetadataRequest(input, context),\n        [_A]: _DIIM,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInstancesRequest(input, context),\n        [_A]: _DIesc,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInstanceStatusCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInstanceStatusRequest(input, context),\n        [_A]: _DISe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInstanceTopologyCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInstanceTopologyRequest(input, context),\n        [_A]: _DIT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInstanceTypeOfferingsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInstanceTypeOfferingsRequest(input, context),\n        [_A]: _DITO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInstanceTypesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInstanceTypesRequest(input, context),\n        [_A]: _DITe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInternetGatewaysCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInternetGatewaysRequest(input, context),\n        [_A]: _DIGe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeIpamByoasnCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeIpamByoasnRequest(input, context),\n        [_A]: _DIBe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeIpamExternalResourceVerificationTokensCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeIpamExternalResourceVerificationTokensRequest(input, context),\n        [_A]: _DIERVTe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeIpamPoolsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeIpamPoolsRequest(input, context),\n        [_A]: _DIPe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeIpamResourceDiscoveriesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeIpamResourceDiscoveriesRequest(input, context),\n        [_A]: _DIRDe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeIpamResourceDiscoveryAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeIpamResourceDiscoveryAssociationsRequest(input, context),\n        [_A]: _DIRDA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeIpamsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeIpamsRequest(input, context),\n        [_A]: _DIescr,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeIpamScopesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeIpamScopesRequest(input, context),\n        [_A]: _DISes,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeIpv6PoolsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeIpv6PoolsRequest(input, context),\n        [_A]: _DIPes,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeKeyPairsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeKeyPairsRequest(input, context),\n        [_A]: _DKPe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeLaunchTemplatesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeLaunchTemplatesRequest(input, context),\n        [_A]: _DLTe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeLaunchTemplateVersionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeLaunchTemplateVersionsRequest(input, context),\n        [_A]: _DLTVe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeLocalGatewayRouteTablesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeLocalGatewayRouteTablesRequest(input, context),\n        [_A]: _DLGRTe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest(input, context),\n        [_A]: _DLGRTVIGAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeLocalGatewayRouteTableVpcAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeLocalGatewayRouteTableVpcAssociationsRequest(input, context),\n        [_A]: _DLGRTVAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeLocalGatewaysCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeLocalGatewaysRequest(input, context),\n        [_A]: _DLG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeLocalGatewayVirtualInterfaceGroupsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeLocalGatewayVirtualInterfaceGroupsRequest(input, context),\n        [_A]: _DLGVIGe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeLocalGatewayVirtualInterfacesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeLocalGatewayVirtualInterfacesRequest(input, context),\n        [_A]: _DLGVIe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeLockedSnapshotsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeLockedSnapshotsRequest(input, context),\n        [_A]: _DLS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeMacHostsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeMacHostsRequest(input, context),\n        [_A]: _DMH,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeMacModificationTasksCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeMacModificationTasksRequest(input, context),\n        [_A]: _DMMT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeManagedPrefixListsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeManagedPrefixListsRequest(input, context),\n        [_A]: _DMPLe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeMovingAddressesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeMovingAddressesRequest(input, context),\n        [_A]: _DMA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeNatGatewaysCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeNatGatewaysRequest(input, context),\n        [_A]: _DNGe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeNetworkAclsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeNetworkAclsRequest(input, context),\n        [_A]: _DNAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeNetworkInsightsAccessScopeAnalysesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeNetworkInsightsAccessScopeAnalysesRequest(input, context),\n        [_A]: _DNIASAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeNetworkInsightsAccessScopesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeNetworkInsightsAccessScopesRequest(input, context),\n        [_A]: _DNIASe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeNetworkInsightsAnalysesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeNetworkInsightsAnalysesRequest(input, context),\n        [_A]: _DNIAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeNetworkInsightsPathsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeNetworkInsightsPathsRequest(input, context),\n        [_A]: _DNIPes,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeNetworkInterfaceAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeNetworkInterfaceAttributeRequest(input, context),\n        [_A]: _DNIAes,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeNetworkInterfacePermissionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeNetworkInterfacePermissionsRequest(input, context),\n        [_A]: _DNIPesc,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeNetworkInterfacesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeNetworkInterfacesRequest(input, context),\n        [_A]: _DNIe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeOutpostLagsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeOutpostLagsRequest(input, context),\n        [_A]: _DOL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribePlacementGroupsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribePlacementGroupsRequest(input, context),\n        [_A]: _DPGe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribePrefixListsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribePrefixListsRequest(input, context),\n        [_A]: _DPL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribePrincipalIdFormatCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribePrincipalIdFormatRequest(input, context),\n        [_A]: _DPIF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribePublicIpv4PoolsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribePublicIpv4PoolsRequest(input, context),\n        [_A]: _DPIPe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeRegionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeRegionsRequest(input, context),\n        [_A]: _DRe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeReplaceRootVolumeTasksCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeReplaceRootVolumeTasksRequest(input, context),\n        [_A]: _DRRVT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeReservedInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeReservedInstancesRequest(input, context),\n        [_A]: _DRI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeReservedInstancesListingsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeReservedInstancesListingsRequest(input, context),\n        [_A]: _DRIL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeReservedInstancesModificationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeReservedInstancesModificationsRequest(input, context),\n        [_A]: _DRIM,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeReservedInstancesOfferingsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeReservedInstancesOfferingsRequest(input, context),\n        [_A]: _DRIO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeRouteServerEndpointsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeRouteServerEndpointsRequest(input, context),\n        [_A]: _DRSEe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeRouteServerPeersCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeRouteServerPeersRequest(input, context),\n        [_A]: _DRSPe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeRouteServersCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeRouteServersRequest(input, context),\n        [_A]: _DRSe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeRouteTablesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeRouteTablesRequest(input, context),\n        [_A]: _DRTe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeScheduledInstanceAvailabilityCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeScheduledInstanceAvailabilityRequest(input, context),\n        [_A]: _DSIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeScheduledInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeScheduledInstancesRequest(input, context),\n        [_A]: _DSI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSecurityGroupReferencesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSecurityGroupReferencesRequest(input, context),\n        [_A]: _DSGR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSecurityGroupRulesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSecurityGroupRulesRequest(input, context),\n        [_A]: _DSGRe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSecurityGroupsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSecurityGroupsRequest(input, context),\n        [_A]: _DSGe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSecurityGroupVpcAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSecurityGroupVpcAssociationsRequest(input, context),\n        [_A]: _DSGVA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeServiceLinkVirtualInterfacesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeServiceLinkVirtualInterfacesRequest(input, context),\n        [_A]: _DSLVI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSnapshotAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSnapshotAttributeRequest(input, context),\n        [_A]: _DSA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSnapshotsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSnapshotsRequest(input, context),\n        [_A]: _DSes,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSnapshotTierStatusCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSnapshotTierStatusRequest(input, context),\n        [_A]: _DSTS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSpotDatafeedSubscriptionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSpotDatafeedSubscriptionRequest(input, context),\n        [_A]: _DSDSe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSpotFleetInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSpotFleetInstancesRequest(input, context),\n        [_A]: _DSFI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSpotFleetRequestHistoryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSpotFleetRequestHistoryRequest(input, context),\n        [_A]: _DSFRH,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSpotFleetRequestsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSpotFleetRequestsRequest(input, context),\n        [_A]: _DSFR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSpotInstanceRequestsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSpotInstanceRequestsRequest(input, context),\n        [_A]: _DSIR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSpotPriceHistoryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSpotPriceHistoryRequest(input, context),\n        [_A]: _DSPH,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeStaleSecurityGroupsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeStaleSecurityGroupsRequest(input, context),\n        [_A]: _DSSG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeStoreImageTasksCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeStoreImageTasksRequest(input, context),\n        [_A]: _DSIT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeSubnetsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeSubnetsRequest(input, context),\n        [_A]: _DSesc,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTagsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTagsRequest(input, context),\n        [_A]: _DTe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTrafficMirrorFilterRulesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTrafficMirrorFilterRulesRequest(input, context),\n        [_A]: _DTMFRe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTrafficMirrorFiltersCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTrafficMirrorFiltersRequest(input, context),\n        [_A]: _DTMFe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTrafficMirrorSessionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTrafficMirrorSessionsRequest(input, context),\n        [_A]: _DTMSe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTrafficMirrorTargetsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTrafficMirrorTargetsRequest(input, context),\n        [_A]: _DTMTe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTransitGatewayAttachmentsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTransitGatewayAttachmentsRequest(input, context),\n        [_A]: _DTGA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTransitGatewayConnectPeersCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTransitGatewayConnectPeersRequest(input, context),\n        [_A]: _DTGCPe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTransitGatewayConnectsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTransitGatewayConnectsRequest(input, context),\n        [_A]: _DTGCe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTransitGatewayMulticastDomainsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTransitGatewayMulticastDomainsRequest(input, context),\n        [_A]: _DTGMDe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTransitGatewayPeeringAttachmentsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTransitGatewayPeeringAttachmentsRequest(input, context),\n        [_A]: _DTGPAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTransitGatewayPolicyTablesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTransitGatewayPolicyTablesRequest(input, context),\n        [_A]: _DTGPTe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTransitGatewayRouteTableAnnouncementsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTransitGatewayRouteTableAnnouncementsRequest(input, context),\n        [_A]: _DTGRTAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTransitGatewayRouteTablesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTransitGatewayRouteTablesRequest(input, context),\n        [_A]: _DTGRTe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTransitGatewaysCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTransitGatewaysRequest(input, context),\n        [_A]: _DTGe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTransitGatewayVpcAttachmentsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTransitGatewayVpcAttachmentsRequest(input, context),\n        [_A]: _DTGVAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeTrunkInterfaceAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeTrunkInterfaceAssociationsRequest(input, context),\n        [_A]: _DTIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVerifiedAccessEndpointsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVerifiedAccessEndpointsRequest(input, context),\n        [_A]: _DVAEe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVerifiedAccessGroupsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVerifiedAccessGroupsRequest(input, context),\n        [_A]: _DVAGe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVerifiedAccessInstanceLoggingConfigurationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVerifiedAccessInstanceLoggingConfigurationsRequest(input, context),\n        [_A]: _DVAILC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVerifiedAccessInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVerifiedAccessInstancesRequest(input, context),\n        [_A]: _DVAIe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVerifiedAccessTrustProvidersCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVerifiedAccessTrustProvidersRequest(input, context),\n        [_A]: _DVATPe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVolumeAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVolumeAttributeRequest(input, context),\n        [_A]: _DVA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVolumesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVolumesRequest(input, context),\n        [_A]: _DVes,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVolumesModificationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVolumesModificationsRequest(input, context),\n        [_A]: _DVM,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVolumeStatusCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVolumeStatusRequest(input, context),\n        [_A]: _DVS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcAttributeRequest(input, context),\n        [_A]: _DVAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcBlockPublicAccessExclusionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcBlockPublicAccessExclusionsRequest(input, context),\n        [_A]: _DVBPAEe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcBlockPublicAccessOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcBlockPublicAccessOptionsRequest(input, context),\n        [_A]: _DVBPAO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcClassicLinkCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcClassicLinkRequest(input, context),\n        [_A]: _DVCL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcClassicLinkDnsSupportCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcClassicLinkDnsSupportRequest(input, context),\n        [_A]: _DVCLDS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcEndpointAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcEndpointAssociationsRequest(input, context),\n        [_A]: _DVEA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcEndpointConnectionNotificationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcEndpointConnectionNotificationsRequest(input, context),\n        [_A]: _DVECNe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcEndpointConnectionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcEndpointConnectionsRequest(input, context),\n        [_A]: _DVEC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcEndpointsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcEndpointsRequest(input, context),\n        [_A]: _DVEe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcEndpointServiceConfigurationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcEndpointServiceConfigurationsRequest(input, context),\n        [_A]: _DVESCe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcEndpointServicePermissionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcEndpointServicePermissionsRequest(input, context),\n        [_A]: _DVESP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcEndpointServicesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcEndpointServicesRequest(input, context),\n        [_A]: _DVES,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcPeeringConnectionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcPeeringConnectionsRequest(input, context),\n        [_A]: _DVPCe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpcsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpcsRequest(input, context),\n        [_A]: _DVesc,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpnConnectionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpnConnectionsRequest(input, context),\n        [_A]: _DVCe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeVpnGatewaysCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeVpnGatewaysRequest(input, context),\n        [_A]: _DVGe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DetachClassicLinkVpcCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DetachClassicLinkVpcRequest(input, context),\n        [_A]: _DCLV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DetachInternetGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DetachInternetGatewayRequest(input, context),\n        [_A]: _DIGet,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DetachNetworkInterfaceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DetachNetworkInterfaceRequest(input, context),\n        [_A]: _DNIet,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DetachVerifiedAccessTrustProviderCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DetachVerifiedAccessTrustProviderRequest(input, context),\n        [_A]: _DVATPet,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DetachVolumeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DetachVolumeRequest(input, context),\n        [_A]: _DVet,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DetachVpnGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DetachVpnGatewayRequest(input, context),\n        [_A]: _DVGet,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableAddressTransferCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableAddressTransferRequest(input, context),\n        [_A]: _DATi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableAllowedImagesSettingsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableAllowedImagesSettingsRequest(input, context),\n        [_A]: _DAIS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableAwsNetworkPerformanceMetricSubscriptionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableAwsNetworkPerformanceMetricSubscriptionRequest(input, context),\n        [_A]: _DANPMSi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableEbsEncryptionByDefaultCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableEbsEncryptionByDefaultRequest(input, context),\n        [_A]: _DEEBD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableFastLaunchCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableFastLaunchRequest(input, context),\n        [_A]: _DFLi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableFastSnapshotRestoresCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableFastSnapshotRestoresRequest(input, context),\n        [_A]: _DFSRi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableImageRequest(input, context),\n        [_A]: _DIi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableImageBlockPublicAccessCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableImageBlockPublicAccessRequest(input, context),\n        [_A]: _DIBPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableImageDeprecationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableImageDeprecationRequest(input, context),\n        [_A]: _DID,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableImageDeregistrationProtectionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableImageDeregistrationProtectionRequest(input, context),\n        [_A]: _DIDP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableIpamOrganizationAdminAccountCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableIpamOrganizationAdminAccountRequest(input, context),\n        [_A]: _DIOAA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableRouteServerPropagationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableRouteServerPropagationRequest(input, context),\n        [_A]: _DRSPi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableSerialConsoleAccessCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableSerialConsoleAccessRequest(input, context),\n        [_A]: _DSCA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableSnapshotBlockPublicAccessCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableSnapshotBlockPublicAccessRequest(input, context),\n        [_A]: _DSBPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableTransitGatewayRouteTablePropagationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableTransitGatewayRouteTablePropagationRequest(input, context),\n        [_A]: _DTGRTP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableVgwRoutePropagationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableVgwRoutePropagationRequest(input, context),\n        [_A]: _DVRP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableVpcClassicLinkCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableVpcClassicLinkRequest(input, context),\n        [_A]: _DVCLi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableVpcClassicLinkDnsSupportCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableVpcClassicLinkDnsSupportRequest(input, context),\n        [_A]: _DVCLDSi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateAddressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateAddressRequest(input, context),\n        [_A]: _DAi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateCapacityReservationBillingOwnerCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateCapacityReservationBillingOwnerRequest(input, context),\n        [_A]: _DCRBO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateClientVpnTargetNetworkCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateClientVpnTargetNetworkRequest(input, context),\n        [_A]: _DCVTNi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateEnclaveCertificateIamRoleCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateEnclaveCertificateIamRoleRequest(input, context),\n        [_A]: _DECIR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateIamInstanceProfileCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateIamInstanceProfileRequest(input, context),\n        [_A]: _DIIP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateInstanceEventWindowCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateInstanceEventWindowRequest(input, context),\n        [_A]: _DIEWi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateIpamByoasnCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateIpamByoasnRequest(input, context),\n        [_A]: _DIBi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateIpamResourceDiscoveryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateIpamResourceDiscoveryRequest(input, context),\n        [_A]: _DIRDi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateNatGatewayAddressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateNatGatewayAddressRequest(input, context),\n        [_A]: _DNGA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateRouteServerCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateRouteServerRequest(input, context),\n        [_A]: _DRSi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateRouteTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateRouteTableRequest(input, context),\n        [_A]: _DRTi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateSecurityGroupVpcCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateSecurityGroupVpcRequest(input, context),\n        [_A]: _DSGV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateSubnetCidrBlockCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateSubnetCidrBlockRequest(input, context),\n        [_A]: _DSCB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateTransitGatewayMulticastDomainCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateTransitGatewayMulticastDomainRequest(input, context),\n        [_A]: _DTGMDi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateTransitGatewayPolicyTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateTransitGatewayPolicyTableRequest(input, context),\n        [_A]: _DTGPTi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateTransitGatewayRouteTableCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateTransitGatewayRouteTableRequest(input, context),\n        [_A]: _DTGRTi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateTrunkInterfaceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateTrunkInterfaceRequest(input, context),\n        [_A]: _DTI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisassociateVpcCidrBlockCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisassociateVpcCidrBlockRequest(input, context),\n        [_A]: _DVCB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableAddressTransferCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableAddressTransferRequest(input, context),\n        [_A]: _EAT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableAllowedImagesSettingsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableAllowedImagesSettingsRequest(input, context),\n        [_A]: _EAIS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableAwsNetworkPerformanceMetricSubscriptionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableAwsNetworkPerformanceMetricSubscriptionRequest(input, context),\n        [_A]: _EANPMS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableEbsEncryptionByDefaultCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableEbsEncryptionByDefaultRequest(input, context),\n        [_A]: _EEEBD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableFastLaunchCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableFastLaunchRequest(input, context),\n        [_A]: _EFL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableFastSnapshotRestoresCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableFastSnapshotRestoresRequest(input, context),\n        [_A]: _EFSR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableImageRequest(input, context),\n        [_A]: _EI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableImageBlockPublicAccessCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableImageBlockPublicAccessRequest(input, context),\n        [_A]: _EIBPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableImageDeprecationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableImageDeprecationRequest(input, context),\n        [_A]: _EID,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableImageDeregistrationProtectionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableImageDeregistrationProtectionRequest(input, context),\n        [_A]: _EIDP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableIpamOrganizationAdminAccountCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableIpamOrganizationAdminAccountRequest(input, context),\n        [_A]: _EIOAA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableReachabilityAnalyzerOrganizationSharingCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableReachabilityAnalyzerOrganizationSharingRequest(input, context),\n        [_A]: _ERAOS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableRouteServerPropagationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableRouteServerPropagationRequest(input, context),\n        [_A]: _ERSP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableSerialConsoleAccessCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableSerialConsoleAccessRequest(input, context),\n        [_A]: _ESCA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableSnapshotBlockPublicAccessCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableSnapshotBlockPublicAccessRequest(input, context),\n        [_A]: _ESBPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableTransitGatewayRouteTablePropagationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableTransitGatewayRouteTablePropagationRequest(input, context),\n        [_A]: _ETGRTP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableVgwRoutePropagationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableVgwRoutePropagationRequest(input, context),\n        [_A]: _EVRP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableVolumeIOCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableVolumeIORequest(input, context),\n        [_A]: _EVIO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableVpcClassicLinkCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableVpcClassicLinkRequest(input, context),\n        [_A]: _EVCL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableVpcClassicLinkDnsSupportCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableVpcClassicLinkDnsSupportRequest(input, context),\n        [_A]: _EVCLDS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ExportClientVpnClientCertificateRevocationListCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ExportClientVpnClientCertificateRevocationListRequest(input, context),\n        [_A]: _ECVCCRL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ExportClientVpnClientConfigurationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ExportClientVpnClientConfigurationRequest(input, context),\n        [_A]: _ECVCC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ExportImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ExportImageRequest(input, context),\n        [_A]: _EIx,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ExportTransitGatewayRoutesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ExportTransitGatewayRoutesRequest(input, context),\n        [_A]: _ETGR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ExportVerifiedAccessInstanceClientConfigurationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ExportVerifiedAccessInstanceClientConfigurationRequest(input, context),\n        [_A]: _EVAICC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetActiveVpnTunnelStatusCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetActiveVpnTunnelStatusRequest(input, context),\n        [_A]: _GAVTS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetAllowedImagesSettingsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetAllowedImagesSettingsRequest(input, context),\n        [_A]: _GAIS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetAssociatedEnclaveCertificateIamRolesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetAssociatedEnclaveCertificateIamRolesRequest(input, context),\n        [_A]: _GAECIR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetAssociatedIpv6PoolCidrsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetAssociatedIpv6PoolCidrsRequest(input, context),\n        [_A]: _GAIPC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetAwsNetworkPerformanceDataCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetAwsNetworkPerformanceDataRequest(input, context),\n        [_A]: _GANPD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetCapacityReservationUsageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetCapacityReservationUsageRequest(input, context),\n        [_A]: _GCRU,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetCoipPoolUsageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetCoipPoolUsageRequest(input, context),\n        [_A]: _GCPU,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetConsoleOutputCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetConsoleOutputRequest(input, context),\n        [_A]: _GCO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetConsoleScreenshotCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetConsoleScreenshotRequest(input, context),\n        [_A]: _GCS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetDeclarativePoliciesReportSummaryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetDeclarativePoliciesReportSummaryRequest(input, context),\n        [_A]: _GDPRS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetDefaultCreditSpecificationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetDefaultCreditSpecificationRequest(input, context),\n        [_A]: _GDCS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetEbsDefaultKmsKeyIdCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetEbsDefaultKmsKeyIdRequest(input, context),\n        [_A]: _GEDKKI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetEbsEncryptionByDefaultCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetEbsEncryptionByDefaultRequest(input, context),\n        [_A]: _GEEBD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetFlowLogsIntegrationTemplateCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetFlowLogsIntegrationTemplateRequest(input, context),\n        [_A]: _GFLIT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetGroupsForCapacityReservationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetGroupsForCapacityReservationRequest(input, context),\n        [_A]: _GGFCR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetHostReservationPurchasePreviewCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetHostReservationPurchasePreviewRequest(input, context),\n        [_A]: _GHRPP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetImageBlockPublicAccessStateCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetImageBlockPublicAccessStateRequest(input, context),\n        [_A]: _GIBPAS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetInstanceMetadataDefaultsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetInstanceMetadataDefaultsRequest(input, context),\n        [_A]: _GIMD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetInstanceTpmEkPubCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetInstanceTpmEkPubRequest(input, context),\n        [_A]: _GITEP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetInstanceTypesFromInstanceRequirementsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetInstanceTypesFromInstanceRequirementsRequest(input, context),\n        [_A]: _GITFIR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetInstanceUefiDataCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetInstanceUefiDataRequest(input, context),\n        [_A]: _GIUD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetIpamAddressHistoryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetIpamAddressHistoryRequest(input, context),\n        [_A]: _GIAH,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetIpamDiscoveredAccountsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetIpamDiscoveredAccountsRequest(input, context),\n        [_A]: _GIDA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetIpamDiscoveredPublicAddressesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetIpamDiscoveredPublicAddressesRequest(input, context),\n        [_A]: _GIDPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetIpamDiscoveredResourceCidrsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetIpamDiscoveredResourceCidrsRequest(input, context),\n        [_A]: _GIDRC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetIpamPoolAllocationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetIpamPoolAllocationsRequest(input, context),\n        [_A]: _GIPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetIpamPoolCidrsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetIpamPoolCidrsRequest(input, context),\n        [_A]: _GIPC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetIpamResourceCidrsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetIpamResourceCidrsRequest(input, context),\n        [_A]: _GIRC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetLaunchTemplateDataCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetLaunchTemplateDataRequest(input, context),\n        [_A]: _GLTD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetManagedPrefixListAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetManagedPrefixListAssociationsRequest(input, context),\n        [_A]: _GMPLA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetManagedPrefixListEntriesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetManagedPrefixListEntriesRequest(input, context),\n        [_A]: _GMPLE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetNetworkInsightsAccessScopeAnalysisFindingsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetNetworkInsightsAccessScopeAnalysisFindingsRequest(input, context),\n        [_A]: _GNIASAF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetNetworkInsightsAccessScopeContentCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetNetworkInsightsAccessScopeContentRequest(input, context),\n        [_A]: _GNIASC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetPasswordDataCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetPasswordDataRequest(input, context),\n        [_A]: _GPD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetReservedInstancesExchangeQuoteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetReservedInstancesExchangeQuoteRequest(input, context),\n        [_A]: _GRIEQ,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetRouteServerAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetRouteServerAssociationsRequest(input, context),\n        [_A]: _GRSA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetRouteServerPropagationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetRouteServerPropagationsRequest(input, context),\n        [_A]: _GRSP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetRouteServerRoutingDatabaseCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetRouteServerRoutingDatabaseRequest(input, context),\n        [_A]: _GRSRD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetSecurityGroupsForVpcCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetSecurityGroupsForVpcRequest(input, context),\n        [_A]: _GSGFV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetSerialConsoleAccessStatusCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetSerialConsoleAccessStatusRequest(input, context),\n        [_A]: _GSCAS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetSnapshotBlockPublicAccessStateCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetSnapshotBlockPublicAccessStateRequest(input, context),\n        [_A]: _GSBPAS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetSpotPlacementScoresCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetSpotPlacementScoresRequest(input, context),\n        [_A]: _GSPS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetSubnetCidrReservationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetSubnetCidrReservationsRequest(input, context),\n        [_A]: _GSCR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetTransitGatewayAttachmentPropagationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetTransitGatewayAttachmentPropagationsRequest(input, context),\n        [_A]: _GTGAP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetTransitGatewayMulticastDomainAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetTransitGatewayMulticastDomainAssociationsRequest(input, context),\n        [_A]: _GTGMDA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetTransitGatewayPolicyTableAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetTransitGatewayPolicyTableAssociationsRequest(input, context),\n        [_A]: _GTGPTA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetTransitGatewayPolicyTableEntriesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetTransitGatewayPolicyTableEntriesRequest(input, context),\n        [_A]: _GTGPTE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetTransitGatewayPrefixListReferencesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetTransitGatewayPrefixListReferencesRequest(input, context),\n        [_A]: _GTGPLR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetTransitGatewayRouteTableAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetTransitGatewayRouteTableAssociationsRequest(input, context),\n        [_A]: _GTGRTA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetTransitGatewayRouteTablePropagationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetTransitGatewayRouteTablePropagationsRequest(input, context),\n        [_A]: _GTGRTP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetVerifiedAccessEndpointPolicyCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetVerifiedAccessEndpointPolicyRequest(input, context),\n        [_A]: _GVAEP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetVerifiedAccessEndpointTargetsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetVerifiedAccessEndpointTargetsRequest(input, context),\n        [_A]: _GVAET,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetVerifiedAccessGroupPolicyCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetVerifiedAccessGroupPolicyRequest(input, context),\n        [_A]: _GVAGP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetVpnConnectionDeviceSampleConfigurationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetVpnConnectionDeviceSampleConfigurationRequest(input, context),\n        [_A]: _GVCDSC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetVpnConnectionDeviceTypesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetVpnConnectionDeviceTypesRequest(input, context),\n        [_A]: _GVCDT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetVpnTunnelReplacementStatusCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetVpnTunnelReplacementStatusRequest(input, context),\n        [_A]: _GVTRS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ImportClientVpnClientCertificateRevocationListCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ImportClientVpnClientCertificateRevocationListRequest(input, context),\n        [_A]: _ICVCCRL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ImportImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ImportImageRequest(input, context),\n        [_A]: _II,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ImportInstanceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ImportInstanceRequest(input, context),\n        [_A]: _IIm,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ImportKeyPairCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ImportKeyPairRequest(input, context),\n        [_A]: _IKP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ImportSnapshotCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ImportSnapshotRequest(input, context),\n        [_A]: _IS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ImportVolumeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ImportVolumeRequest(input, context),\n        [_A]: _IV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ListImagesInRecycleBinCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ListImagesInRecycleBinRequest(input, context),\n        [_A]: _LIIRB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ListSnapshotsInRecycleBinCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ListSnapshotsInRecycleBinRequest(input, context),\n        [_A]: _LSIRB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_LockSnapshotCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_LockSnapshotRequest(input, context),\n        [_A]: _LS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyAddressAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyAddressAttributeRequest(input, context),\n        [_A]: _MAA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyAvailabilityZoneGroupCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyAvailabilityZoneGroupRequest(input, context),\n        [_A]: _MAZG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyCapacityReservationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyCapacityReservationRequest(input, context),\n        [_A]: _MCR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyCapacityReservationFleetCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyCapacityReservationFleetRequest(input, context),\n        [_A]: _MCRF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyClientVpnEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyClientVpnEndpointRequest(input, context),\n        [_A]: _MCVE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyDefaultCreditSpecificationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyDefaultCreditSpecificationRequest(input, context),\n        [_A]: _MDCS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyEbsDefaultKmsKeyIdCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyEbsDefaultKmsKeyIdRequest(input, context),\n        [_A]: _MEDKKI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyFleetCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyFleetRequest(input, context),\n        [_A]: _MF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyFpgaImageAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyFpgaImageAttributeRequest(input, context),\n        [_A]: _MFIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyHostsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyHostsRequest(input, context),\n        [_A]: _MH,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyIdentityIdFormatCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyIdentityIdFormatRequest(input, context),\n        [_A]: _MIIF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyIdFormatCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyIdFormatRequest(input, context),\n        [_A]: _MIF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyImageAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyImageAttributeRequest(input, context),\n        [_A]: _MIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyInstanceAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyInstanceAttributeRequest(input, context),\n        [_A]: _MIAo,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyInstanceCapacityReservationAttributesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyInstanceCapacityReservationAttributesRequest(input, context),\n        [_A]: _MICRA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyInstanceCpuOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyInstanceCpuOptionsRequest(input, context),\n        [_A]: _MICO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyInstanceCreditSpecificationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyInstanceCreditSpecificationRequest(input, context),\n        [_A]: _MICS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyInstanceEventStartTimeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyInstanceEventStartTimeRequest(input, context),\n        [_A]: _MIEST,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyInstanceEventWindowCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyInstanceEventWindowRequest(input, context),\n        [_A]: _MIEW,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyInstanceMaintenanceOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyInstanceMaintenanceOptionsRequest(input, context),\n        [_A]: _MIMO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyInstanceMetadataDefaultsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyInstanceMetadataDefaultsRequest(input, context),\n        [_A]: _MIMD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyInstanceMetadataOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyInstanceMetadataOptionsRequest(input, context),\n        [_A]: _MIMOo,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyInstanceNetworkPerformanceOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyInstanceNetworkPerformanceRequest(input, context),\n        [_A]: _MINPO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyInstancePlacementCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyInstancePlacementRequest(input, context),\n        [_A]: _MIP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyIpamCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyIpamRequest(input, context),\n        [_A]: _MI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyIpamPoolCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyIpamPoolRequest(input, context),\n        [_A]: _MIPo,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyIpamResourceCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyIpamResourceCidrRequest(input, context),\n        [_A]: _MIRC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyIpamResourceDiscoveryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyIpamResourceDiscoveryRequest(input, context),\n        [_A]: _MIRD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyIpamScopeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyIpamScopeRequest(input, context),\n        [_A]: _MIS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyLaunchTemplateCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyLaunchTemplateRequest(input, context),\n        [_A]: _MLT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyLocalGatewayRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyLocalGatewayRouteRequest(input, context),\n        [_A]: _MLGR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyManagedPrefixListCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyManagedPrefixListRequest(input, context),\n        [_A]: _MMPL,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyNetworkInterfaceAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyNetworkInterfaceAttributeRequest(input, context),\n        [_A]: _MNIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyPrivateDnsNameOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyPrivateDnsNameOptionsRequest(input, context),\n        [_A]: _MPDNO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyPublicIpDnsNameOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyPublicIpDnsNameOptionsRequest(input, context),\n        [_A]: _MPIDNO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyReservedInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyReservedInstancesRequest(input, context),\n        [_A]: _MRI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyRouteServerCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyRouteServerRequest(input, context),\n        [_A]: _MRS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifySecurityGroupRulesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifySecurityGroupRulesRequest(input, context),\n        [_A]: _MSGR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifySnapshotAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifySnapshotAttributeRequest(input, context),\n        [_A]: _MSA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifySnapshotTierCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifySnapshotTierRequest(input, context),\n        [_A]: _MST,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifySpotFleetRequestCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifySpotFleetRequestRequest(input, context),\n        [_A]: _MSFR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifySubnetAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifySubnetAttributeRequest(input, context),\n        [_A]: _MSAo,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyTrafficMirrorFilterNetworkServicesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyTrafficMirrorFilterNetworkServicesRequest(input, context),\n        [_A]: _MTMFNS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyTrafficMirrorFilterRuleCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyTrafficMirrorFilterRuleRequest(input, context),\n        [_A]: _MTMFR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyTrafficMirrorSessionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyTrafficMirrorSessionRequest(input, context),\n        [_A]: _MTMS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyTransitGatewayCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyTransitGatewayRequest(input, context),\n        [_A]: _MTG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyTransitGatewayPrefixListReferenceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyTransitGatewayPrefixListReferenceRequest(input, context),\n        [_A]: _MTGPLR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyTransitGatewayVpcAttachmentCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyTransitGatewayVpcAttachmentRequest(input, context),\n        [_A]: _MTGVA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVerifiedAccessEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVerifiedAccessEndpointRequest(input, context),\n        [_A]: _MVAE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVerifiedAccessEndpointPolicyCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVerifiedAccessEndpointPolicyRequest(input, context),\n        [_A]: _MVAEP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVerifiedAccessGroupCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVerifiedAccessGroupRequest(input, context),\n        [_A]: _MVAG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVerifiedAccessGroupPolicyCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVerifiedAccessGroupPolicyRequest(input, context),\n        [_A]: _MVAGP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVerifiedAccessInstanceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVerifiedAccessInstanceRequest(input, context),\n        [_A]: _MVAI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVerifiedAccessInstanceLoggingConfigurationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVerifiedAccessInstanceLoggingConfigurationRequest(input, context),\n        [_A]: _MVAILC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVerifiedAccessTrustProviderCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVerifiedAccessTrustProviderRequest(input, context),\n        [_A]: _MVATP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVolumeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVolumeRequest(input, context),\n        [_A]: _MV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVolumeAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVolumeAttributeRequest(input, context),\n        [_A]: _MVA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpcAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpcAttributeRequest(input, context),\n        [_A]: _MVAo,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpcBlockPublicAccessExclusionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpcBlockPublicAccessExclusionRequest(input, context),\n        [_A]: _MVBPAE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpcBlockPublicAccessOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpcBlockPublicAccessOptionsRequest(input, context),\n        [_A]: _MVBPAO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpcEndpointCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpcEndpointRequest(input, context),\n        [_A]: _MVE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpcEndpointConnectionNotificationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpcEndpointConnectionNotificationRequest(input, context),\n        [_A]: _MVECN,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpcEndpointServiceConfigurationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpcEndpointServiceConfigurationRequest(input, context),\n        [_A]: _MVESC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpcEndpointServicePayerResponsibilityCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpcEndpointServicePayerResponsibilityRequest(input, context),\n        [_A]: _MVESPR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpcEndpointServicePermissionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpcEndpointServicePermissionsRequest(input, context),\n        [_A]: _MVESP,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpcPeeringConnectionOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpcPeeringConnectionOptionsRequest(input, context),\n        [_A]: _MVPCO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpcTenancyCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpcTenancyRequest(input, context),\n        [_A]: _MVT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpnConnectionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpnConnectionRequest(input, context),\n        [_A]: _MVC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpnConnectionOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpnConnectionOptionsRequest(input, context),\n        [_A]: _MVCO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpnTunnelCertificateCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpnTunnelCertificateRequest(input, context),\n        [_A]: _MVTC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ModifyVpnTunnelOptionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ModifyVpnTunnelOptionsRequest(input, context),\n        [_A]: _MVTO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_MonitorInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_MonitorInstancesRequest(input, context),\n        [_A]: _MIo,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_MoveAddressToVpcCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_MoveAddressToVpcRequest(input, context),\n        [_A]: _MATV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_MoveByoipCidrToIpamCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_MoveByoipCidrToIpamRequest(input, context),\n        [_A]: _MBCTI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_MoveCapacityReservationInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_MoveCapacityReservationInstancesRequest(input, context),\n        [_A]: _MCRI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ProvisionByoipCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ProvisionByoipCidrRequest(input, context),\n        [_A]: _PBC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ProvisionIpamByoasnCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ProvisionIpamByoasnRequest(input, context),\n        [_A]: _PIB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ProvisionIpamPoolCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ProvisionIpamPoolCidrRequest(input, context),\n        [_A]: _PIPC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ProvisionPublicIpv4PoolCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ProvisionPublicIpv4PoolCidrRequest(input, context),\n        [_A]: _PPIPC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PurchaseCapacityBlockCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PurchaseCapacityBlockRequest(input, context),\n        [_A]: _PCB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PurchaseCapacityBlockExtensionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PurchaseCapacityBlockExtensionRequest(input, context),\n        [_A]: _PCBE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PurchaseHostReservationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PurchaseHostReservationRequest(input, context),\n        [_A]: _PHR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PurchaseReservedInstancesOfferingCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PurchaseReservedInstancesOfferingRequest(input, context),\n        [_A]: _PRIO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PurchaseScheduledInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PurchaseScheduledInstancesRequest(input, context),\n        [_A]: _PSI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RebootInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RebootInstancesRequest(input, context),\n        [_A]: _RI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RegisterImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RegisterImageRequest(input, context),\n        [_A]: _RIe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RegisterInstanceEventNotificationAttributesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RegisterInstanceEventNotificationAttributesRequest(input, context),\n        [_A]: _RIENA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RegisterTransitGatewayMulticastGroupMembersCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RegisterTransitGatewayMulticastGroupMembersRequest(input, context),\n        [_A]: _RTGMGM,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RegisterTransitGatewayMulticastGroupSourcesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RegisterTransitGatewayMulticastGroupSourcesRequest(input, context),\n        [_A]: _RTGMGS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RejectCapacityReservationBillingOwnershipCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RejectCapacityReservationBillingOwnershipRequest(input, context),\n        [_A]: _RCRBO,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RejectTransitGatewayMulticastDomainAssociationsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RejectTransitGatewayMulticastDomainAssociationsRequest(input, context),\n        [_A]: _RTGMDA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RejectTransitGatewayPeeringAttachmentCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RejectTransitGatewayPeeringAttachmentRequest(input, context),\n        [_A]: _RTGPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RejectTransitGatewayVpcAttachmentCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RejectTransitGatewayVpcAttachmentRequest(input, context),\n        [_A]: _RTGVA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RejectVpcEndpointConnectionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RejectVpcEndpointConnectionsRequest(input, context),\n        [_A]: _RVEC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RejectVpcPeeringConnectionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RejectVpcPeeringConnectionRequest(input, context),\n        [_A]: _RVPC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReleaseAddressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReleaseAddressRequest(input, context),\n        [_A]: _RA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReleaseHostsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReleaseHostsRequest(input, context),\n        [_A]: _RH,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReleaseIpamPoolAllocationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReleaseIpamPoolAllocationRequest(input, context),\n        [_A]: _RIPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReplaceIamInstanceProfileAssociationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReplaceIamInstanceProfileAssociationRequest(input, context),\n        [_A]: _RIIPA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReplaceImageCriteriaInAllowedImagesSettingsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReplaceImageCriteriaInAllowedImagesSettingsRequest(input, context),\n        [_A]: _RICIAIS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReplaceNetworkAclAssociationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReplaceNetworkAclAssociationRequest(input, context),\n        [_A]: _RNAA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReplaceNetworkAclEntryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReplaceNetworkAclEntryRequest(input, context),\n        [_A]: _RNAE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReplaceRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReplaceRouteRequest(input, context),\n        [_A]: _RR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReplaceRouteTableAssociationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReplaceRouteTableAssociationRequest(input, context),\n        [_A]: _RRTA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReplaceTransitGatewayRouteCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReplaceTransitGatewayRouteRequest(input, context),\n        [_A]: _RTGR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReplaceVpnTunnelCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReplaceVpnTunnelRequest(input, context),\n        [_A]: _RVT,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ReportInstanceStatusCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ReportInstanceStatusRequest(input, context),\n        [_A]: _RIS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RequestSpotFleetCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RequestSpotFleetRequest(input, context),\n        [_A]: _RSF,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RequestSpotInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RequestSpotInstancesRequest(input, context),\n        [_A]: _RSI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ResetAddressAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ResetAddressAttributeRequest(input, context),\n        [_A]: _RAA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ResetEbsDefaultKmsKeyIdCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ResetEbsDefaultKmsKeyIdRequest(input, context),\n        [_A]: _REDKKI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ResetFpgaImageAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ResetFpgaImageAttributeRequest(input, context),\n        [_A]: _RFIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ResetImageAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ResetImageAttributeRequest(input, context),\n        [_A]: _RIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ResetInstanceAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ResetInstanceAttributeRequest(input, context),\n        [_A]: _RIAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ResetNetworkInterfaceAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ResetNetworkInterfaceAttributeRequest(input, context),\n        [_A]: _RNIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ResetSnapshotAttributeCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ResetSnapshotAttributeRequest(input, context),\n        [_A]: _RSA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RestoreAddressToClassicCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RestoreAddressToClassicRequest(input, context),\n        [_A]: _RATC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RestoreImageFromRecycleBinCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RestoreImageFromRecycleBinRequest(input, context),\n        [_A]: _RIFRB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RestoreManagedPrefixListVersionCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RestoreManagedPrefixListVersionRequest(input, context),\n        [_A]: _RMPLV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RestoreSnapshotFromRecycleBinCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RestoreSnapshotFromRecycleBinRequest(input, context),\n        [_A]: _RSFRB,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RestoreSnapshotTierCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RestoreSnapshotTierRequest(input, context),\n        [_A]: _RST,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RevokeClientVpnIngressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RevokeClientVpnIngressRequest(input, context),\n        [_A]: _RCVI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RevokeSecurityGroupEgressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RevokeSecurityGroupEgressRequest(input, context),\n        [_A]: _RSGE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RevokeSecurityGroupIngressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RevokeSecurityGroupIngressRequest(input, context),\n        [_A]: _RSGI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RunInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RunInstancesRequest(input, context),\n        [_A]: _RIu,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_RunScheduledInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_RunScheduledInstancesRequest(input, context),\n        [_A]: _RSIu,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_SearchLocalGatewayRoutesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_SearchLocalGatewayRoutesRequest(input, context),\n        [_A]: _SLGR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_SearchTransitGatewayMulticastGroupsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_SearchTransitGatewayMulticastGroupsRequest(input, context),\n        [_A]: _STGMG,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_SearchTransitGatewayRoutesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_SearchTransitGatewayRoutesRequest(input, context),\n        [_A]: _STGR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_SendDiagnosticInterruptCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_SendDiagnosticInterruptRequest(input, context),\n        [_A]: _SDI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_StartDeclarativePoliciesReportCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_StartDeclarativePoliciesReportRequest(input, context),\n        [_A]: _SDPR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_StartInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_StartInstancesRequest(input, context),\n        [_A]: _SI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_StartNetworkInsightsAccessScopeAnalysisCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_StartNetworkInsightsAccessScopeAnalysisRequest(input, context),\n        [_A]: _SNIASA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_StartNetworkInsightsAnalysisCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_StartNetworkInsightsAnalysisRequest(input, context),\n        [_A]: _SNIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_StartVpcEndpointServicePrivateDnsVerificationCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_StartVpcEndpointServicePrivateDnsVerificationRequest(input, context),\n        [_A]: _SVESPDV,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_StopInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_StopInstancesRequest(input, context),\n        [_A]: _SIt,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_TerminateClientVpnConnectionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_TerminateClientVpnConnectionsRequest(input, context),\n        [_A]: _TCVC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_TerminateInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_TerminateInstancesRequest(input, context),\n        [_A]: _TI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_UnassignIpv6AddressesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_UnassignIpv6AddressesRequest(input, context),\n        [_A]: _UIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_UnassignPrivateIpAddressesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_UnassignPrivateIpAddressesRequest(input, context),\n        [_A]: _UPIA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_UnassignPrivateNatGatewayAddressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_UnassignPrivateNatGatewayAddressRequest(input, context),\n        [_A]: _UPNGA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_UnlockSnapshotCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_UnlockSnapshotRequest(input, context),\n        [_A]: _US,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_UnmonitorInstancesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_UnmonitorInstancesRequest(input, context),\n        [_A]: _UI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_UpdateSecurityGroupRuleDescriptionsEgressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_UpdateSecurityGroupRuleDescriptionsEgressRequest(input, context),\n        [_A]: _USGRDE,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_UpdateSecurityGroupRuleDescriptionsIngressCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_UpdateSecurityGroupRuleDescriptionsIngressRequest(input, context),\n        [_A]: _USGRDI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_WithdrawByoipCidrCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_WithdrawByoipCidrRequest(input, context),\n        [_A]: _WBC,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const de_AcceptAddressTransferCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AcceptAddressTransferResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AcceptCapacityReservationBillingOwnershipCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AcceptCapacityReservationBillingOwnershipResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AcceptReservedInstancesExchangeQuoteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AcceptReservedInstancesExchangeQuoteResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AcceptTransitGatewayMulticastDomainAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AcceptTransitGatewayMulticastDomainAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AcceptTransitGatewayPeeringAttachmentCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AcceptTransitGatewayPeeringAttachmentResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AcceptTransitGatewayVpcAttachmentCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AcceptTransitGatewayVpcAttachmentResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AcceptVpcEndpointConnectionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AcceptVpcEndpointConnectionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AcceptVpcPeeringConnectionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AcceptVpcPeeringConnectionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AdvertiseByoipCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AdvertiseByoipCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AllocateAddressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AllocateAddressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AllocateHostsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AllocateHostsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AllocateIpamPoolCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AllocateIpamPoolCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ApplySecurityGroupsToClientVpnTargetNetworkCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ApplySecurityGroupsToClientVpnTargetNetworkResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssignIpv6AddressesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssignIpv6AddressesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssignPrivateIpAddressesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssignPrivateIpAddressesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssignPrivateNatGatewayAddressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssignPrivateNatGatewayAddressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateAddressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateAddressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateCapacityReservationBillingOwnerCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateCapacityReservationBillingOwnerResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateClientVpnTargetNetworkCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateClientVpnTargetNetworkResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateDhcpOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_AssociateEnclaveCertificateIamRoleCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateEnclaveCertificateIamRoleResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateIamInstanceProfileCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateIamInstanceProfileResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateInstanceEventWindowCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateInstanceEventWindowResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateIpamByoasnCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateIpamByoasnResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateIpamResourceDiscoveryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateIpamResourceDiscoveryResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateNatGatewayAddressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateNatGatewayAddressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateRouteServerCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateRouteServerResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateRouteTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateRouteTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateSecurityGroupVpcCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateSecurityGroupVpcResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateSubnetCidrBlockCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateSubnetCidrBlockResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateTransitGatewayMulticastDomainCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateTransitGatewayMulticastDomainResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateTransitGatewayPolicyTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateTransitGatewayPolicyTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateTransitGatewayRouteTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateTransitGatewayRouteTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateTrunkInterfaceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateTrunkInterfaceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AssociateVpcCidrBlockCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AssociateVpcCidrBlockResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AttachClassicLinkVpcCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AttachClassicLinkVpcResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AttachInternetGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_AttachNetworkInterfaceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AttachNetworkInterfaceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AttachVerifiedAccessTrustProviderCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AttachVerifiedAccessTrustProviderResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AttachVolumeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_VolumeAttachment(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AttachVpnGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AttachVpnGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AuthorizeClientVpnIngressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AuthorizeClientVpnIngressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AuthorizeSecurityGroupEgressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AuthorizeSecurityGroupEgressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_AuthorizeSecurityGroupIngressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_AuthorizeSecurityGroupIngressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_BundleInstanceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_BundleInstanceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CancelBundleTaskCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CancelBundleTaskResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CancelCapacityReservationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CancelCapacityReservationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CancelCapacityReservationFleetsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CancelCapacityReservationFleetsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CancelConversionTaskCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_CancelDeclarativePoliciesReportCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CancelDeclarativePoliciesReportResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CancelExportTaskCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_CancelImageLaunchPermissionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CancelImageLaunchPermissionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CancelImportTaskCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CancelImportTaskResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CancelReservedInstancesListingCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CancelReservedInstancesListingResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CancelSpotFleetRequestsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CancelSpotFleetRequestsResponse(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CancelSpotInstanceRequestsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CancelSpotInstanceRequestsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ConfirmProductInstanceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ConfirmProductInstanceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CopyFpgaImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CopyFpgaImageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CopyImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CopyImageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CopySnapshotCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CopySnapshotResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateCapacityReservationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateCapacityReservationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateCapacityReservationBySplittingCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateCapacityReservationBySplittingResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateCapacityReservationFleetCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateCapacityReservationFleetResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateCarrierGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateCarrierGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateClientVpnEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateClientVpnEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateClientVpnRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateClientVpnRouteResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateCoipCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateCoipCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateCoipPoolCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateCoipPoolResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateCustomerGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateCustomerGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateDefaultSubnetCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateDefaultSubnetResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateDefaultVpcCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateDefaultVpcResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateDelegateMacVolumeOwnershipTaskCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateDelegateMacVolumeOwnershipTaskResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateDhcpOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateDhcpOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateEgressOnlyInternetGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateEgressOnlyInternetGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateFleetCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateFleetResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateFlowLogsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateFlowLogsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateFpgaImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateFpgaImageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateImageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateInstanceConnectEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateInstanceConnectEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateInstanceEventWindowCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateInstanceEventWindowResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateInstanceExportTaskCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateInstanceExportTaskResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateInternetGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateInternetGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateIpamCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateIpamResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateIpamExternalResourceVerificationTokenCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateIpamExternalResourceVerificationTokenResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateIpamPoolCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateIpamPoolResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateIpamResourceDiscoveryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateIpamResourceDiscoveryResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateIpamScopeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateIpamScopeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateKeyPairCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_KeyPair(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateLaunchTemplateCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateLaunchTemplateResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateLaunchTemplateVersionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateLaunchTemplateVersionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateLocalGatewayRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateLocalGatewayRouteResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateLocalGatewayRouteTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateLocalGatewayRouteTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateLocalGatewayRouteTableVpcAssociationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateLocalGatewayRouteTableVpcAssociationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateLocalGatewayVirtualInterfaceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateLocalGatewayVirtualInterfaceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateLocalGatewayVirtualInterfaceGroupCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateLocalGatewayVirtualInterfaceGroupResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateMacSystemIntegrityProtectionModificationTaskCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateMacSystemIntegrityProtectionModificationTaskResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateManagedPrefixListCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateManagedPrefixListResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateNatGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateNatGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateNetworkAclCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateNetworkAclResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateNetworkAclEntryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_CreateNetworkInsightsAccessScopeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateNetworkInsightsAccessScopeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateNetworkInsightsPathCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateNetworkInsightsPathResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateNetworkInterfaceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateNetworkInterfaceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateNetworkInterfacePermissionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateNetworkInterfacePermissionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreatePlacementGroupCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreatePlacementGroupResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreatePublicIpv4PoolCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreatePublicIpv4PoolResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateReplaceRootVolumeTaskCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateReplaceRootVolumeTaskResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateReservedInstancesListingCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateReservedInstancesListingResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateRestoreImageTaskCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateRestoreImageTaskResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateRouteResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateRouteServerCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateRouteServerResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateRouteServerEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateRouteServerEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateRouteServerPeerCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateRouteServerPeerResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateRouteTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateRouteTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateSecurityGroupCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateSecurityGroupResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateSnapshotCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_Snapshot(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateSnapshotsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateSnapshotsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateSpotDatafeedSubscriptionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateSpotDatafeedSubscriptionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateStoreImageTaskCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateStoreImageTaskResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateSubnetCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateSubnetResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateSubnetCidrReservationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateSubnetCidrReservationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTagsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_CreateTrafficMirrorFilterCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTrafficMirrorFilterResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTrafficMirrorFilterRuleCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTrafficMirrorFilterRuleResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTrafficMirrorSessionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTrafficMirrorSessionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTrafficMirrorTargetCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTrafficMirrorTargetResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTransitGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTransitGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTransitGatewayConnectCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTransitGatewayConnectResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTransitGatewayConnectPeerCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTransitGatewayConnectPeerResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTransitGatewayMulticastDomainCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTransitGatewayMulticastDomainResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTransitGatewayPeeringAttachmentCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTransitGatewayPeeringAttachmentResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTransitGatewayPolicyTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTransitGatewayPolicyTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTransitGatewayPrefixListReferenceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTransitGatewayPrefixListReferenceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTransitGatewayRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTransitGatewayRouteResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTransitGatewayRouteTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTransitGatewayRouteTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTransitGatewayRouteTableAnnouncementCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTransitGatewayRouteTableAnnouncementResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateTransitGatewayVpcAttachmentCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateTransitGatewayVpcAttachmentResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVerifiedAccessEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVerifiedAccessEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVerifiedAccessGroupCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVerifiedAccessGroupResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVerifiedAccessInstanceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVerifiedAccessInstanceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVerifiedAccessTrustProviderCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVerifiedAccessTrustProviderResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVolumeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_Volume(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVpcCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVpcResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVpcBlockPublicAccessExclusionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVpcBlockPublicAccessExclusionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVpcEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVpcEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVpcEndpointConnectionNotificationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVpcEndpointConnectionNotificationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVpcEndpointServiceConfigurationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVpcEndpointServiceConfigurationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVpcPeeringConnectionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVpcPeeringConnectionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVpnConnectionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVpnConnectionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_CreateVpnConnectionRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_CreateVpnGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_CreateVpnGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteCarrierGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteCarrierGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteClientVpnEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteClientVpnEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteClientVpnRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteClientVpnRouteResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteCoipCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteCoipCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteCoipPoolCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteCoipPoolResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteCustomerGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteDhcpOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteEgressOnlyInternetGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteEgressOnlyInternetGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteFleetsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteFleetsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteFlowLogsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteFlowLogsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteFpgaImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteFpgaImageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteInstanceConnectEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteInstanceConnectEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteInstanceEventWindowCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteInstanceEventWindowResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteInternetGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteIpamCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteIpamResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteIpamExternalResourceVerificationTokenCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteIpamExternalResourceVerificationTokenResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteIpamPoolCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteIpamPoolResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteIpamResourceDiscoveryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteIpamResourceDiscoveryResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteIpamScopeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteIpamScopeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteKeyPairCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteKeyPairResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteLaunchTemplateCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteLaunchTemplateResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteLaunchTemplateVersionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteLaunchTemplateVersionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteLocalGatewayRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteLocalGatewayRouteResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteLocalGatewayRouteTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteLocalGatewayRouteTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteLocalGatewayRouteTableVpcAssociationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteLocalGatewayRouteTableVpcAssociationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteLocalGatewayVirtualInterfaceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteLocalGatewayVirtualInterfaceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteLocalGatewayVirtualInterfaceGroupCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteLocalGatewayVirtualInterfaceGroupResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteManagedPrefixListCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteManagedPrefixListResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteNatGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteNatGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteNetworkAclCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteNetworkAclEntryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteNetworkInsightsAccessScopeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteNetworkInsightsAccessScopeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteNetworkInsightsAccessScopeAnalysisCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteNetworkInsightsAccessScopeAnalysisResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteNetworkInsightsAnalysisCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteNetworkInsightsAnalysisResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteNetworkInsightsPathCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteNetworkInsightsPathResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteNetworkInterfaceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteNetworkInterfacePermissionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteNetworkInterfacePermissionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeletePlacementGroupCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeletePublicIpv4PoolCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeletePublicIpv4PoolResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteQueuedReservedInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteQueuedReservedInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteRouteServerCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteRouteServerResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteRouteServerEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteRouteServerEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteRouteServerPeerCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteRouteServerPeerResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteRouteTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteSecurityGroupCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteSecurityGroupResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteSnapshotCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteSpotDatafeedSubscriptionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteSubnetCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteSubnetCidrReservationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteSubnetCidrReservationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTagsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteTrafficMirrorFilterCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTrafficMirrorFilterResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTrafficMirrorFilterRuleCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTrafficMirrorFilterRuleResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTrafficMirrorSessionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTrafficMirrorSessionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTrafficMirrorTargetCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTrafficMirrorTargetResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTransitGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTransitGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTransitGatewayConnectCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTransitGatewayConnectResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTransitGatewayConnectPeerCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTransitGatewayConnectPeerResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTransitGatewayMulticastDomainCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTransitGatewayMulticastDomainResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTransitGatewayPeeringAttachmentCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTransitGatewayPeeringAttachmentResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTransitGatewayPolicyTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTransitGatewayPolicyTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTransitGatewayPrefixListReferenceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTransitGatewayPrefixListReferenceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTransitGatewayRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTransitGatewayRouteResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTransitGatewayRouteTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTransitGatewayRouteTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTransitGatewayRouteTableAnnouncementCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTransitGatewayRouteTableAnnouncementResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteTransitGatewayVpcAttachmentCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteTransitGatewayVpcAttachmentResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteVerifiedAccessEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteVerifiedAccessEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteVerifiedAccessGroupCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteVerifiedAccessGroupResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteVerifiedAccessInstanceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteVerifiedAccessInstanceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteVerifiedAccessTrustProviderCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteVerifiedAccessTrustProviderResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteVolumeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteVpcCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteVpcBlockPublicAccessExclusionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteVpcBlockPublicAccessExclusionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteVpcEndpointConnectionNotificationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteVpcEndpointConnectionNotificationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteVpcEndpointsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteVpcEndpointsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteVpcEndpointServiceConfigurationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteVpcEndpointServiceConfigurationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteVpcPeeringConnectionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteVpcPeeringConnectionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteVpnConnectionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteVpnConnectionRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteVpnGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeprovisionByoipCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeprovisionByoipCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeprovisionIpamByoasnCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeprovisionIpamByoasnResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeprovisionIpamPoolCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeprovisionIpamPoolCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeprovisionPublicIpv4PoolCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeprovisionPublicIpv4PoolCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeregisterImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeregisterImageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeregisterInstanceEventNotificationAttributesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeregisterInstanceEventNotificationAttributesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeregisterTransitGatewayMulticastGroupMembersCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeregisterTransitGatewayMulticastGroupMembersResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeregisterTransitGatewayMulticastGroupSourcesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeregisterTransitGatewayMulticastGroupSourcesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeAccountAttributesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeAccountAttributesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeAddressesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeAddressesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeAddressesAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeAddressesAttributeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeAddressTransfersCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeAddressTransfersResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeAggregateIdFormatCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeAggregateIdFormatResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeAvailabilityZonesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeAvailabilityZonesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeAwsNetworkPerformanceMetricSubscriptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeAwsNetworkPerformanceMetricSubscriptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeBundleTasksCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeBundleTasksResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeByoipCidrsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeByoipCidrsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeCapacityBlockExtensionHistoryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeCapacityBlockExtensionHistoryResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeCapacityBlockExtensionOfferingsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeCapacityBlockExtensionOfferingsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeCapacityBlockOfferingsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeCapacityBlockOfferingsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeCapacityReservationBillingRequestsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeCapacityReservationBillingRequestsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeCapacityReservationFleetsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeCapacityReservationFleetsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeCapacityReservationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeCapacityReservationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeCarrierGatewaysCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeCarrierGatewaysResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeClassicLinkInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeClassicLinkInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeClientVpnAuthorizationRulesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeClientVpnAuthorizationRulesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeClientVpnConnectionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeClientVpnConnectionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeClientVpnEndpointsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeClientVpnEndpointsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeClientVpnRoutesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeClientVpnRoutesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeClientVpnTargetNetworksCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeClientVpnTargetNetworksResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeCoipPoolsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeCoipPoolsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeConversionTasksCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeConversionTasksResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeCustomerGatewaysCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeCustomerGatewaysResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeDeclarativePoliciesReportsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeDeclarativePoliciesReportsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeDhcpOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeDhcpOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeEgressOnlyInternetGatewaysCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeEgressOnlyInternetGatewaysResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeElasticGpusCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeElasticGpusResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeExportImageTasksCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeExportImageTasksResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeExportTasksCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeExportTasksResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeFastLaunchImagesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeFastLaunchImagesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeFastSnapshotRestoresCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeFastSnapshotRestoresResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeFleetHistoryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeFleetHistoryResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeFleetInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeFleetInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeFleetsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeFleetsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeFlowLogsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeFlowLogsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeFpgaImageAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeFpgaImageAttributeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeFpgaImagesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeFpgaImagesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeHostReservationOfferingsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeHostReservationOfferingsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeHostReservationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeHostReservationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeHostsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeHostsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeIamInstanceProfileAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeIamInstanceProfileAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeIdentityIdFormatCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeIdentityIdFormatResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeIdFormatCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeIdFormatResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeImageAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ImageAttribute(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeImagesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeImagesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeImportImageTasksCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeImportImageTasksResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeImportSnapshotTasksCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeImportSnapshotTasksResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInstanceAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_InstanceAttribute(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInstanceConnectEndpointsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInstanceConnectEndpointsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInstanceCreditSpecificationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInstanceCreditSpecificationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInstanceEventNotificationAttributesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInstanceEventNotificationAttributesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInstanceEventWindowsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInstanceEventWindowsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInstanceImageMetadataCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInstanceImageMetadataResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInstanceStatusCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInstanceStatusResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInstanceTopologyCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInstanceTopologyResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInstanceTypeOfferingsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInstanceTypeOfferingsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInstanceTypesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInstanceTypesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInternetGatewaysCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInternetGatewaysResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeIpamByoasnCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeIpamByoasnResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeIpamExternalResourceVerificationTokensCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeIpamExternalResourceVerificationTokensResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeIpamPoolsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeIpamPoolsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeIpamResourceDiscoveriesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeIpamResourceDiscoveriesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeIpamResourceDiscoveryAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeIpamResourceDiscoveryAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeIpamsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeIpamsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeIpamScopesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeIpamScopesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeIpv6PoolsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeIpv6PoolsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeKeyPairsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeKeyPairsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeLaunchTemplatesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeLaunchTemplatesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeLaunchTemplateVersionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeLaunchTemplateVersionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeLocalGatewayRouteTablesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeLocalGatewayRouteTablesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeLocalGatewayRouteTableVpcAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeLocalGatewayRouteTableVpcAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeLocalGatewaysCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeLocalGatewaysResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeLocalGatewayVirtualInterfaceGroupsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeLocalGatewayVirtualInterfaceGroupsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeLocalGatewayVirtualInterfacesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeLocalGatewayVirtualInterfacesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeLockedSnapshotsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeLockedSnapshotsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeMacHostsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeMacHostsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeMacModificationTasksCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeMacModificationTasksResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeManagedPrefixListsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeManagedPrefixListsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeMovingAddressesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeMovingAddressesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeNatGatewaysCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeNatGatewaysResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeNetworkAclsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeNetworkAclsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeNetworkInsightsAccessScopeAnalysesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeNetworkInsightsAccessScopeAnalysesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeNetworkInsightsAccessScopesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeNetworkInsightsAccessScopesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeNetworkInsightsAnalysesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeNetworkInsightsAnalysesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeNetworkInsightsPathsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeNetworkInsightsPathsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeNetworkInterfaceAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeNetworkInterfaceAttributeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeNetworkInterfacePermissionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeNetworkInterfacePermissionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeNetworkInterfacesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeNetworkInterfacesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeOutpostLagsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeOutpostLagsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribePlacementGroupsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribePlacementGroupsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribePrefixListsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribePrefixListsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribePrincipalIdFormatCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribePrincipalIdFormatResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribePublicIpv4PoolsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribePublicIpv4PoolsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeRegionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeRegionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeReplaceRootVolumeTasksCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeReplaceRootVolumeTasksResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeReservedInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeReservedInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeReservedInstancesListingsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeReservedInstancesListingsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeReservedInstancesModificationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeReservedInstancesModificationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeReservedInstancesOfferingsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeReservedInstancesOfferingsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeRouteServerEndpointsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeRouteServerEndpointsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeRouteServerPeersCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeRouteServerPeersResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeRouteServersCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeRouteServersResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeRouteTablesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeRouteTablesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeScheduledInstanceAvailabilityCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeScheduledInstanceAvailabilityResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeScheduledInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeScheduledInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSecurityGroupReferencesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSecurityGroupReferencesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSecurityGroupRulesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSecurityGroupRulesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSecurityGroupsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSecurityGroupsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSecurityGroupVpcAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSecurityGroupVpcAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeServiceLinkVirtualInterfacesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeServiceLinkVirtualInterfacesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSnapshotAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSnapshotAttributeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSnapshotsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSnapshotsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSnapshotTierStatusCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSnapshotTierStatusResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSpotDatafeedSubscriptionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSpotDatafeedSubscriptionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSpotFleetInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSpotFleetInstancesResponse(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSpotFleetRequestHistoryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSpotFleetRequestHistoryResponse(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSpotFleetRequestsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSpotFleetRequestsResponse(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSpotInstanceRequestsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSpotInstanceRequestsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSpotPriceHistoryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSpotPriceHistoryResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeStaleSecurityGroupsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeStaleSecurityGroupsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeStoreImageTasksCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeStoreImageTasksResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeSubnetsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeSubnetsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTagsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTagsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTrafficMirrorFilterRulesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTrafficMirrorFilterRulesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTrafficMirrorFiltersCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTrafficMirrorFiltersResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTrafficMirrorSessionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTrafficMirrorSessionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTrafficMirrorTargetsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTrafficMirrorTargetsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTransitGatewayAttachmentsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTransitGatewayAttachmentsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTransitGatewayConnectPeersCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTransitGatewayConnectPeersResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTransitGatewayConnectsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTransitGatewayConnectsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTransitGatewayMulticastDomainsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTransitGatewayMulticastDomainsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTransitGatewayPeeringAttachmentsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTransitGatewayPeeringAttachmentsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTransitGatewayPolicyTablesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTransitGatewayPolicyTablesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTransitGatewayRouteTableAnnouncementsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTransitGatewayRouteTableAnnouncementsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTransitGatewayRouteTablesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTransitGatewayRouteTablesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTransitGatewaysCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTransitGatewaysResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTransitGatewayVpcAttachmentsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTransitGatewayVpcAttachmentsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeTrunkInterfaceAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeTrunkInterfaceAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVerifiedAccessEndpointsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVerifiedAccessEndpointsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVerifiedAccessGroupsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVerifiedAccessGroupsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVerifiedAccessInstanceLoggingConfigurationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVerifiedAccessInstanceLoggingConfigurationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVerifiedAccessInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVerifiedAccessInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVerifiedAccessTrustProvidersCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVerifiedAccessTrustProvidersResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVolumeAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVolumeAttributeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVolumesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVolumesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVolumesModificationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVolumesModificationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVolumeStatusCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVolumeStatusResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcAttributeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcBlockPublicAccessExclusionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcBlockPublicAccessExclusionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcBlockPublicAccessOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcBlockPublicAccessOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcClassicLinkCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcClassicLinkResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcClassicLinkDnsSupportCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcClassicLinkDnsSupportResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcEndpointAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcEndpointAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcEndpointConnectionNotificationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcEndpointConnectionNotificationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcEndpointConnectionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcEndpointConnectionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcEndpointsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcEndpointsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcEndpointServiceConfigurationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcEndpointServiceConfigurationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcEndpointServicePermissionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcEndpointServicePermissionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcEndpointServicesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcEndpointServicesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcPeeringConnectionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcPeeringConnectionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpcsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpcsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpnConnectionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpnConnectionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeVpnGatewaysCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeVpnGatewaysResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DetachClassicLinkVpcCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DetachClassicLinkVpcResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DetachInternetGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DetachNetworkInterfaceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DetachVerifiedAccessTrustProviderCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DetachVerifiedAccessTrustProviderResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DetachVolumeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_VolumeAttachment(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DetachVpnGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DisableAddressTransferCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableAddressTransferResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableAllowedImagesSettingsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableAllowedImagesSettingsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableAwsNetworkPerformanceMetricSubscriptionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableAwsNetworkPerformanceMetricSubscriptionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableEbsEncryptionByDefaultCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableEbsEncryptionByDefaultResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableFastLaunchCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableFastLaunchResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableFastSnapshotRestoresCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableFastSnapshotRestoresResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableImageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableImageBlockPublicAccessCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableImageBlockPublicAccessResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableImageDeprecationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableImageDeprecationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableImageDeregistrationProtectionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableImageDeregistrationProtectionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableIpamOrganizationAdminAccountCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableIpamOrganizationAdminAccountResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableRouteServerPropagationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableRouteServerPropagationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableSerialConsoleAccessCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableSerialConsoleAccessResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableSnapshotBlockPublicAccessCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableSnapshotBlockPublicAccessResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableTransitGatewayRouteTablePropagationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableTransitGatewayRouteTablePropagationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableVgwRoutePropagationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DisableVpcClassicLinkCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableVpcClassicLinkResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableVpcClassicLinkDnsSupportCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableVpcClassicLinkDnsSupportResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateAddressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DisassociateCapacityReservationBillingOwnerCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateCapacityReservationBillingOwnerResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateClientVpnTargetNetworkCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateClientVpnTargetNetworkResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateEnclaveCertificateIamRoleCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateEnclaveCertificateIamRoleResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateIamInstanceProfileCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateIamInstanceProfileResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateInstanceEventWindowCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateInstanceEventWindowResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateIpamByoasnCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateIpamByoasnResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateIpamResourceDiscoveryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateIpamResourceDiscoveryResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateNatGatewayAddressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateNatGatewayAddressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateRouteServerCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateRouteServerResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateRouteTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DisassociateSecurityGroupVpcCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateSecurityGroupVpcResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateSubnetCidrBlockCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateSubnetCidrBlockResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateTransitGatewayMulticastDomainCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateTransitGatewayMulticastDomainResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateTransitGatewayPolicyTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateTransitGatewayPolicyTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateTransitGatewayRouteTableCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateTransitGatewayRouteTableResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateTrunkInterfaceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateTrunkInterfaceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisassociateVpcCidrBlockCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisassociateVpcCidrBlockResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableAddressTransferCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableAddressTransferResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableAllowedImagesSettingsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableAllowedImagesSettingsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableAwsNetworkPerformanceMetricSubscriptionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableAwsNetworkPerformanceMetricSubscriptionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableEbsEncryptionByDefaultCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableEbsEncryptionByDefaultResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableFastLaunchCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableFastLaunchResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableFastSnapshotRestoresCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableFastSnapshotRestoresResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableImageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableImageBlockPublicAccessCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableImageBlockPublicAccessResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableImageDeprecationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableImageDeprecationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableImageDeregistrationProtectionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableImageDeregistrationProtectionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableIpamOrganizationAdminAccountCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableIpamOrganizationAdminAccountResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableReachabilityAnalyzerOrganizationSharingCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableReachabilityAnalyzerOrganizationSharingResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableRouteServerPropagationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableRouteServerPropagationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableSerialConsoleAccessCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableSerialConsoleAccessResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableSnapshotBlockPublicAccessCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableSnapshotBlockPublicAccessResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableTransitGatewayRouteTablePropagationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableTransitGatewayRouteTablePropagationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableVgwRoutePropagationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_EnableVolumeIOCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_EnableVpcClassicLinkCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableVpcClassicLinkResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableVpcClassicLinkDnsSupportCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableVpcClassicLinkDnsSupportResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ExportClientVpnClientCertificateRevocationListCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ExportClientVpnClientCertificateRevocationListResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ExportClientVpnClientConfigurationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ExportClientVpnClientConfigurationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ExportImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ExportImageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ExportTransitGatewayRoutesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ExportTransitGatewayRoutesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ExportVerifiedAccessInstanceClientConfigurationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ExportVerifiedAccessInstanceClientConfigurationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetActiveVpnTunnelStatusCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetActiveVpnTunnelStatusResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetAllowedImagesSettingsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetAllowedImagesSettingsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetAssociatedEnclaveCertificateIamRolesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetAssociatedEnclaveCertificateIamRolesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetAssociatedIpv6PoolCidrsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetAssociatedIpv6PoolCidrsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetAwsNetworkPerformanceDataCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetAwsNetworkPerformanceDataResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetCapacityReservationUsageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetCapacityReservationUsageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetCoipPoolUsageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetCoipPoolUsageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetConsoleOutputCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetConsoleOutputResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetConsoleScreenshotCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetConsoleScreenshotResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetDeclarativePoliciesReportSummaryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetDeclarativePoliciesReportSummaryResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetDefaultCreditSpecificationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetDefaultCreditSpecificationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetEbsDefaultKmsKeyIdCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetEbsDefaultKmsKeyIdResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetEbsEncryptionByDefaultCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetEbsEncryptionByDefaultResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetFlowLogsIntegrationTemplateCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetFlowLogsIntegrationTemplateResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetGroupsForCapacityReservationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetGroupsForCapacityReservationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetHostReservationPurchasePreviewCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetHostReservationPurchasePreviewResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetImageBlockPublicAccessStateCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetImageBlockPublicAccessStateResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetInstanceMetadataDefaultsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetInstanceMetadataDefaultsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetInstanceTpmEkPubCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetInstanceTpmEkPubResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetInstanceTypesFromInstanceRequirementsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetInstanceTypesFromInstanceRequirementsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetInstanceUefiDataCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetInstanceUefiDataResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetIpamAddressHistoryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetIpamAddressHistoryResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetIpamDiscoveredAccountsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetIpamDiscoveredAccountsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetIpamDiscoveredPublicAddressesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetIpamDiscoveredPublicAddressesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetIpamDiscoveredResourceCidrsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetIpamDiscoveredResourceCidrsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetIpamPoolAllocationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetIpamPoolAllocationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetIpamPoolCidrsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetIpamPoolCidrsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetIpamResourceCidrsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetIpamResourceCidrsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetLaunchTemplateDataCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetLaunchTemplateDataResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetManagedPrefixListAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetManagedPrefixListAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetManagedPrefixListEntriesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetManagedPrefixListEntriesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetNetworkInsightsAccessScopeAnalysisFindingsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetNetworkInsightsAccessScopeAnalysisFindingsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetNetworkInsightsAccessScopeContentCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetNetworkInsightsAccessScopeContentResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetPasswordDataCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetPasswordDataResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetReservedInstancesExchangeQuoteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetReservedInstancesExchangeQuoteResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetRouteServerAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetRouteServerAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetRouteServerPropagationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetRouteServerPropagationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetRouteServerRoutingDatabaseCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetRouteServerRoutingDatabaseResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetSecurityGroupsForVpcCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetSecurityGroupsForVpcResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetSerialConsoleAccessStatusCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetSerialConsoleAccessStatusResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetSnapshotBlockPublicAccessStateCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetSnapshotBlockPublicAccessStateResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetSpotPlacementScoresCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetSpotPlacementScoresResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetSubnetCidrReservationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetSubnetCidrReservationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetTransitGatewayAttachmentPropagationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetTransitGatewayAttachmentPropagationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetTransitGatewayMulticastDomainAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetTransitGatewayMulticastDomainAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetTransitGatewayPolicyTableAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetTransitGatewayPolicyTableAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetTransitGatewayPolicyTableEntriesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetTransitGatewayPolicyTableEntriesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetTransitGatewayPrefixListReferencesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetTransitGatewayPrefixListReferencesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetTransitGatewayRouteTableAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetTransitGatewayRouteTableAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetTransitGatewayRouteTablePropagationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetTransitGatewayRouteTablePropagationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetVerifiedAccessEndpointPolicyCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetVerifiedAccessEndpointPolicyResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetVerifiedAccessEndpointTargetsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetVerifiedAccessEndpointTargetsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetVerifiedAccessGroupPolicyCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetVerifiedAccessGroupPolicyResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetVpnConnectionDeviceSampleConfigurationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetVpnConnectionDeviceSampleConfigurationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetVpnConnectionDeviceTypesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetVpnConnectionDeviceTypesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetVpnTunnelReplacementStatusCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetVpnTunnelReplacementStatusResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ImportClientVpnClientCertificateRevocationListCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ImportClientVpnClientCertificateRevocationListResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ImportImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ImportImageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ImportInstanceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ImportInstanceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ImportKeyPairCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ImportKeyPairResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ImportSnapshotCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ImportSnapshotResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ImportVolumeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ImportVolumeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ListImagesInRecycleBinCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ListImagesInRecycleBinResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ListSnapshotsInRecycleBinCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ListSnapshotsInRecycleBinResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_LockSnapshotCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_LockSnapshotResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyAddressAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyAddressAttributeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyAvailabilityZoneGroupCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyAvailabilityZoneGroupResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyCapacityReservationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyCapacityReservationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyCapacityReservationFleetCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyCapacityReservationFleetResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyClientVpnEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyClientVpnEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyDefaultCreditSpecificationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyDefaultCreditSpecificationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyEbsDefaultKmsKeyIdCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyEbsDefaultKmsKeyIdResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyFleetCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyFleetResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyFpgaImageAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyFpgaImageAttributeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyHostsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyHostsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyIdentityIdFormatCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ModifyIdFormatCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ModifyImageAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ModifyInstanceAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ModifyInstanceCapacityReservationAttributesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyInstanceCapacityReservationAttributesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyInstanceCpuOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyInstanceCpuOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyInstanceCreditSpecificationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyInstanceCreditSpecificationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyInstanceEventStartTimeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyInstanceEventStartTimeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyInstanceEventWindowCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyInstanceEventWindowResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyInstanceMaintenanceOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyInstanceMaintenanceOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyInstanceMetadataDefaultsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyInstanceMetadataDefaultsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyInstanceMetadataOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyInstanceMetadataOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyInstanceNetworkPerformanceOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyInstanceNetworkPerformanceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyInstancePlacementCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyInstancePlacementResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyIpamCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyIpamResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyIpamPoolCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyIpamPoolResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyIpamResourceCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyIpamResourceCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyIpamResourceDiscoveryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyIpamResourceDiscoveryResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyIpamScopeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyIpamScopeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyLaunchTemplateCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyLaunchTemplateResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyLocalGatewayRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyLocalGatewayRouteResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyManagedPrefixListCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyManagedPrefixListResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyNetworkInterfaceAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ModifyPrivateDnsNameOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyPrivateDnsNameOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyPublicIpDnsNameOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyPublicIpDnsNameOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyReservedInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyReservedInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyRouteServerCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyRouteServerResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifySecurityGroupRulesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifySecurityGroupRulesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifySnapshotAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ModifySnapshotTierCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifySnapshotTierResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifySpotFleetRequestCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifySpotFleetRequestResponse(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifySubnetAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ModifyTrafficMirrorFilterNetworkServicesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyTrafficMirrorFilterNetworkServicesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyTrafficMirrorFilterRuleCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyTrafficMirrorFilterRuleResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyTrafficMirrorSessionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyTrafficMirrorSessionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyTransitGatewayCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyTransitGatewayResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyTransitGatewayPrefixListReferenceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyTransitGatewayPrefixListReferenceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyTransitGatewayVpcAttachmentCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyTransitGatewayVpcAttachmentResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVerifiedAccessEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVerifiedAccessEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVerifiedAccessEndpointPolicyCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVerifiedAccessEndpointPolicyResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVerifiedAccessGroupCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVerifiedAccessGroupResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVerifiedAccessGroupPolicyCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVerifiedAccessGroupPolicyResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVerifiedAccessInstanceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVerifiedAccessInstanceResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVerifiedAccessInstanceLoggingConfigurationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVerifiedAccessInstanceLoggingConfigurationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVerifiedAccessTrustProviderCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVerifiedAccessTrustProviderResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVolumeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVolumeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVolumeAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ModifyVpcAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ModifyVpcBlockPublicAccessExclusionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpcBlockPublicAccessExclusionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpcBlockPublicAccessOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpcBlockPublicAccessOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpcEndpointCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpcEndpointResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpcEndpointConnectionNotificationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpcEndpointConnectionNotificationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpcEndpointServiceConfigurationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpcEndpointServiceConfigurationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpcEndpointServicePayerResponsibilityCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpcEndpointServicePayerResponsibilityResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpcEndpointServicePermissionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpcEndpointServicePermissionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpcPeeringConnectionOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpcPeeringConnectionOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpcTenancyCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpcTenancyResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpnConnectionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpnConnectionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpnConnectionOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpnConnectionOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpnTunnelCertificateCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpnTunnelCertificateResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ModifyVpnTunnelOptionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ModifyVpnTunnelOptionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_MonitorInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_MonitorInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_MoveAddressToVpcCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_MoveAddressToVpcResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_MoveByoipCidrToIpamCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_MoveByoipCidrToIpamResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_MoveCapacityReservationInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_MoveCapacityReservationInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ProvisionByoipCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ProvisionByoipCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ProvisionIpamByoasnCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ProvisionIpamByoasnResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ProvisionIpamPoolCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ProvisionIpamPoolCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ProvisionPublicIpv4PoolCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ProvisionPublicIpv4PoolCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_PurchaseCapacityBlockCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_PurchaseCapacityBlockResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_PurchaseCapacityBlockExtensionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_PurchaseCapacityBlockExtensionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_PurchaseHostReservationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_PurchaseHostReservationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_PurchaseReservedInstancesOfferingCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_PurchaseReservedInstancesOfferingResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_PurchaseScheduledInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_PurchaseScheduledInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RebootInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_RegisterImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RegisterImageResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RegisterInstanceEventNotificationAttributesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RegisterInstanceEventNotificationAttributesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RegisterTransitGatewayMulticastGroupMembersCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RegisterTransitGatewayMulticastGroupMembersResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RegisterTransitGatewayMulticastGroupSourcesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RegisterTransitGatewayMulticastGroupSourcesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RejectCapacityReservationBillingOwnershipCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RejectCapacityReservationBillingOwnershipResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RejectTransitGatewayMulticastDomainAssociationsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RejectTransitGatewayMulticastDomainAssociationsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RejectTransitGatewayPeeringAttachmentCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RejectTransitGatewayPeeringAttachmentResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RejectTransitGatewayVpcAttachmentCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RejectTransitGatewayVpcAttachmentResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RejectVpcEndpointConnectionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RejectVpcEndpointConnectionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RejectVpcPeeringConnectionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RejectVpcPeeringConnectionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ReleaseAddressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ReleaseHostsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ReleaseHostsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ReleaseIpamPoolAllocationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ReleaseIpamPoolAllocationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ReplaceIamInstanceProfileAssociationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ReplaceIamInstanceProfileAssociationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ReplaceImageCriteriaInAllowedImagesSettingsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ReplaceImageCriteriaInAllowedImagesSettingsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ReplaceNetworkAclAssociationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ReplaceNetworkAclAssociationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ReplaceNetworkAclEntryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ReplaceRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ReplaceRouteTableAssociationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ReplaceRouteTableAssociationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ReplaceTransitGatewayRouteCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ReplaceTransitGatewayRouteResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ReplaceVpnTunnelCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ReplaceVpnTunnelResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ReportInstanceStatusCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_RequestSpotFleetCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RequestSpotFleetResponse(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RequestSpotInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RequestSpotInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ResetAddressAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ResetAddressAttributeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ResetEbsDefaultKmsKeyIdCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ResetEbsDefaultKmsKeyIdResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ResetFpgaImageAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ResetFpgaImageAttributeResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ResetImageAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ResetInstanceAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ResetNetworkInterfaceAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_ResetSnapshotAttributeCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_RestoreAddressToClassicCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RestoreAddressToClassicResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RestoreImageFromRecycleBinCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RestoreImageFromRecycleBinResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RestoreManagedPrefixListVersionCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RestoreManagedPrefixListVersionResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RestoreSnapshotFromRecycleBinCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RestoreSnapshotFromRecycleBinResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RestoreSnapshotTierCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RestoreSnapshotTierResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RevokeClientVpnIngressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RevokeClientVpnIngressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RevokeSecurityGroupEgressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RevokeSecurityGroupEgressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RevokeSecurityGroupIngressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RevokeSecurityGroupIngressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RunInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_Reservation(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_RunScheduledInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_RunScheduledInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_SearchLocalGatewayRoutesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_SearchLocalGatewayRoutesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_SearchTransitGatewayMulticastGroupsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_SearchTransitGatewayMulticastGroupsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_SearchTransitGatewayRoutesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_SearchTransitGatewayRoutesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_SendDiagnosticInterruptCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_StartDeclarativePoliciesReportCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_StartDeclarativePoliciesReportResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_StartInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_StartInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_StartNetworkInsightsAccessScopeAnalysisCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_StartNetworkInsightsAccessScopeAnalysisResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_StartNetworkInsightsAnalysisCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_StartNetworkInsightsAnalysisResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_StartVpcEndpointServicePrivateDnsVerificationCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_StartVpcEndpointServicePrivateDnsVerificationResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_StopInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_StopInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_TerminateClientVpnConnectionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_TerminateClientVpnConnectionsResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_TerminateInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_TerminateInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_UnassignIpv6AddressesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_UnassignIpv6AddressesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_UnassignPrivateIpAddressesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_UnassignPrivateNatGatewayAddressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_UnassignPrivateNatGatewayAddressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_UnlockSnapshotCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_UnlockSnapshotResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_UnmonitorInstancesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_UnmonitorInstancesResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_UpdateSecurityGroupRuleDescriptionsEgressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_UpdateSecurityGroupRuleDescriptionsEgressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_UpdateSecurityGroupRuleDescriptionsIngressCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_UpdateSecurityGroupRuleDescriptionsIngressResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_WithdrawByoipCidrCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_WithdrawByoipCidrResult(data, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nconst de_CommandError = async (output, context) => {\n    const parsedOutput = {\n        ...output,\n        body: await parseErrorBody(output.body, context),\n    };\n    const errorCode = loadEc2ErrorCode(output, parsedOutput.body);\n    const parsedBody = parsedOutput.body;\n    return throwDefaultError({\n        output,\n        parsedBody: parsedBody.Errors.Error,\n        errorCode,\n    });\n};\nconst se_AcceleratorCount = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_AcceleratorCountRequest = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_AcceleratorManufacturerSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_AcceleratorNameSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_AcceleratorTotalMemoryMiB = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_AcceleratorTotalMemoryMiBRequest = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_AcceleratorTypeSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_AcceptAddressTransferRequest = (input, context) => {\n    const entries = {};\n    if (input[_Ad] != null) {\n        entries[_Ad] = input[_Ad];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AcceptCapacityReservationBillingOwnershipRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CRI] != null) {\n        entries[_CRI] = input[_CRI];\n    }\n    return entries;\n};\nconst se_AcceptReservedInstancesExchangeQuoteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RII] != null) {\n        const memberEntries = se_ReservedInstanceIdSet(input[_RII], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReservedInstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TC] != null) {\n        const memberEntries = se_TargetConfigurationRequestSet(input[_TC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TargetConfiguration.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_AcceptTransitGatewayMulticastDomainAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDI] != null) {\n        entries[_TGMDI] = input[_TGMDI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_SIu] != null) {\n        const memberEntries = se_ValueStringList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AcceptTransitGatewayPeeringAttachmentRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AcceptTransitGatewayVpcAttachmentRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AcceptVpcEndpointConnectionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIe] != null) {\n        entries[_SIe] = input[_SIe];\n    }\n    if (input[_VEI] != null) {\n        const memberEntries = se_VpcEndpointIdList(input[_VEI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VpcEndpointId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_AcceptVpcPeeringConnectionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VPCI] != null) {\n        entries[_VPCI] = input[_VPCI];\n    }\n    return entries;\n};\nconst se_AccessScopePathListRequest = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_AccessScopePathRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_AccessScopePathRequest = (input, context) => {\n    const entries = {};\n    if (input[_S] != null) {\n        const memberEntries = se_PathStatementRequest(input[_S], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Source.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_D] != null) {\n        const memberEntries = se_PathStatementRequest(input[_D], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Destination.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TR] != null) {\n        const memberEntries = se_ThroughResourcesStatementRequestList(input[_TR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ThroughResource.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_AccountAttributeNameStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`AttributeName.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_AddIpamOperatingRegion = (input, context) => {\n    const entries = {};\n    if (input[_RN] != null) {\n        entries[_RN] = input[_RN];\n    }\n    return entries;\n};\nconst se_AddIpamOperatingRegionSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_AddIpamOperatingRegion(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_AddIpamOrganizationalUnitExclusion = (input, context) => {\n    const entries = {};\n    if (input[_OEP] != null) {\n        entries[_OEP] = input[_OEP];\n    }\n    return entries;\n};\nconst se_AddIpamOrganizationalUnitExclusionSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_AddIpamOrganizationalUnitExclusion(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_AddPrefixListEntries = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_AddPrefixListEntry(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_AddPrefixListEntry = (input, context) => {\n    const entries = {};\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    return entries;\n};\nconst se_AdvertiseByoipCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_As] != null) {\n        entries[_As] = input[_As];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NBG] != null) {\n        entries[_NBG] = input[_NBG];\n    }\n    return entries;\n};\nconst se_AllocateAddressRequest = (input, context) => {\n    const entries = {};\n    if (input[_Do] != null) {\n        entries[_Do] = input[_Do];\n    }\n    if (input[_Ad] != null) {\n        entries[_Ad] = input[_Ad];\n    }\n    if (input[_PIP] != null) {\n        entries[_PIP] = input[_PIP];\n    }\n    if (input[_NBG] != null) {\n        entries[_NBG] = input[_NBG];\n    }\n    if (input[_COIP] != null) {\n        entries[_COIP] = input[_COIP];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AllocateHostsRequest = (input, context) => {\n    const entries = {};\n    if (input[_IF] != null) {\n        entries[_IF] = input[_IF];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_HR] != null) {\n        entries[_HR] = input[_HR];\n    }\n    if (input[_OA] != null) {\n        entries[_OA] = input[_OA];\n    }\n    if (input[_HM] != null) {\n        entries[_HM] = input[_HM];\n    }\n    if (input[_AI] != null) {\n        const memberEntries = se_AssetIdList(input[_AI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AssetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AZI] != null) {\n        entries[_AZI] = input[_AZI];\n    }\n    if (input[_AP] != null) {\n        entries[_AP] = input[_AP];\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_Q] != null) {\n        entries[_Q] = input[_Q];\n    }\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    return entries;\n};\nconst se_AllocateIpamPoolCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_NL] != null) {\n        entries[_NL] = input[_NL];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_PNC] != null) {\n        entries[_PNC] = input[_PNC];\n    }\n    if (input[_AC] != null) {\n        const memberEntries = se_IpamPoolAllocationAllowedCidrs(input[_AC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AllowedCidr.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DC] != null) {\n        const memberEntries = se_IpamPoolAllocationDisallowedCidrs(input[_DC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DisallowedCidr.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_AllocationIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`AllocationId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_AllocationIds = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_AllowedInstanceTypeSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ApplySecurityGroupsToClientVpnTargetNetworkRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_SGI] != null) {\n        const memberEntries = se_ClientVpnSecurityGroupIdSet(input[_SGI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ArchitectureTypeSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ArnList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_AsnAuthorizationContext = (input, context) => {\n    const entries = {};\n    if (input[_Me] != null) {\n        entries[_Me] = input[_Me];\n    }\n    if (input[_Si] != null) {\n        entries[_Si] = input[_Si];\n    }\n    return entries;\n};\nconst se_AssetIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_AssignIpv6AddressesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IPC] != null) {\n        entries[_IPC] = input[_IPC];\n    }\n    if (input[_IP] != null) {\n        const memberEntries = se_IpPrefixList(input[_IP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Prefix.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_IA] != null) {\n        const memberEntries = se_Ipv6AddressList(input[_IA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Addresses.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IAC] != null) {\n        entries[_IAC] = input[_IAC];\n    }\n    return entries;\n};\nconst se_AssignPrivateIpAddressesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IPp] != null) {\n        const memberEntries = se_IpPrefixList(input[_IPp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv4Prefix.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPCp] != null) {\n        entries[_IPCp] = input[_IPCp];\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_PIA] != null) {\n        const memberEntries = se_PrivateIpAddressStringList(input[_PIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrivateIpAddress.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPIAC] != null) {\n        entries[_SPIAC] = input[_SPIAC];\n    }\n    if (input[_AR] != null) {\n        entries[_AR] = input[_AR];\n    }\n    return entries;\n};\nconst se_AssignPrivateNatGatewayAddressRequest = (input, context) => {\n    const entries = {};\n    if (input[_NGI] != null) {\n        entries[_NGI] = input[_NGI];\n    }\n    if (input[_PIA] != null) {\n        const memberEntries = se_IpList(input[_PIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrivateIpAddress.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PIAC] != null) {\n        entries[_PIAC] = input[_PIAC];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AssociateAddressRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIl] != null) {\n        entries[_AIl] = input[_AIl];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_PI] != null) {\n        entries[_PI] = input[_PI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_PIAr] != null) {\n        entries[_PIAr] = input[_PIAr];\n    }\n    if (input[_ARl] != null) {\n        entries[_ARl] = input[_ARl];\n    }\n    return entries;\n};\nconst se_AssociateCapacityReservationBillingOwnerRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CRI] != null) {\n        entries[_CRI] = input[_CRI];\n    }\n    if (input[_URBOI] != null) {\n        entries[_URBOI] = input[_URBOI];\n    }\n    return entries;\n};\nconst se_AssociateClientVpnTargetNetworkRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AssociateDhcpOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DOI] != null) {\n        entries[_DOI] = input[_DOI];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AssociateEnclaveCertificateIamRoleRequest = (input, context) => {\n    const entries = {};\n    if (input[_CA] != null) {\n        entries[_CA] = input[_CA];\n    }\n    if (input[_RAo] != null) {\n        entries[_RAo] = input[_RAo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AssociateIamInstanceProfileRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIP] != null) {\n        const memberEntries = se_IamInstanceProfileSpecification(input[_IIP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IamInstanceProfile.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    return entries;\n};\nconst se_AssociateInstanceEventWindowRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IEWI] != null) {\n        entries[_IEWI] = input[_IEWI];\n    }\n    if (input[_AT] != null) {\n        const memberEntries = se_InstanceEventWindowAssociationRequest(input[_AT], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AssociationTarget.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_AssociateIpamByoasnRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_As] != null) {\n        entries[_As] = input[_As];\n    }\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    return entries;\n};\nconst se_AssociateIpamResourceDiscoveryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIp] != null) {\n        entries[_IIp] = input[_IIp];\n    }\n    if (input[_IRDI] != null) {\n        entries[_IRDI] = input[_IRDI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_AssociateNatGatewayAddressRequest = (input, context) => {\n    const entries = {};\n    if (input[_NGI] != null) {\n        entries[_NGI] = input[_NGI];\n    }\n    if (input[_AIll] != null) {\n        const memberEntries = se_AllocationIdList(input[_AIll], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AllocationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PIA] != null) {\n        const memberEntries = se_IpList(input[_PIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrivateIpAddress.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AssociateRouteServerRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSIo] != null) {\n        entries[_RSIo] = input[_RSIo];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AssociateRouteTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_GI] != null) {\n        entries[_GI] = input[_GI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_RTI] != null) {\n        entries[_RTI] = input[_RTI];\n    }\n    return entries;\n};\nconst se_AssociateSecurityGroupVpcRequest = (input, context) => {\n    const entries = {};\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AssociateSubnetCidrBlockRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIPI] != null) {\n        entries[_IIPI] = input[_IIPI];\n    }\n    if (input[_INL] != null) {\n        entries[_INL] = input[_INL];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_ICB] != null) {\n        entries[_ICB] = input[_ICB];\n    }\n    return entries;\n};\nconst se_AssociateTransitGatewayMulticastDomainRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDI] != null) {\n        entries[_TGMDI] = input[_TGMDI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_SIu] != null) {\n        const memberEntries = se_TransitGatewaySubnetIdList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AssociateTransitGatewayPolicyTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGPTI] != null) {\n        entries[_TGPTI] = input[_TGPTI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AssociateTransitGatewayRouteTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AssociateTrunkInterfaceRequest = (input, context) => {\n    const entries = {};\n    if (input[_BII] != null) {\n        entries[_BII] = input[_BII];\n    }\n    if (input[_TII] != null) {\n        entries[_TII] = input[_TII];\n    }\n    if (input[_VIl] != null) {\n        entries[_VIl] = input[_VIl];\n    }\n    if (input[_GK] != null) {\n        entries[_GK] = input[_GK];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AssociateVpcCidrBlockRequest = (input, context) => {\n    const entries = {};\n    if (input[_CB] != null) {\n        entries[_CB] = input[_CB];\n    }\n    if (input[_ICBNBG] != null) {\n        entries[_ICBNBG] = input[_ICBNBG];\n    }\n    if (input[_IPpv] != null) {\n        entries[_IPpv] = input[_IPpv];\n    }\n    if (input[_ICB] != null) {\n        entries[_ICB] = input[_ICB];\n    }\n    if (input[_IIPIp] != null) {\n        entries[_IIPIp] = input[_IIPIp];\n    }\n    if (input[_INLp] != null) {\n        entries[_INLp] = input[_INLp];\n    }\n    if (input[_IIPI] != null) {\n        entries[_IIPI] = input[_IIPI];\n    }\n    if (input[_INL] != null) {\n        entries[_INL] = input[_INL];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_APICB] != null) {\n        entries[_APICB] = input[_APICB];\n    }\n    return entries;\n};\nconst se_AssociationIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`AssociationId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_AthenaIntegration = (input, context) => {\n    const entries = {};\n    if (input[_IRSDA] != null) {\n        entries[_IRSDA] = input[_IRSDA];\n    }\n    if (input[_PLF] != null) {\n        entries[_PLF] = input[_PLF];\n    }\n    if (input[_PSD] != null) {\n        entries[_PSD] = __serializeDateTime(input[_PSD]);\n    }\n    if (input[_PED] != null) {\n        entries[_PED] = __serializeDateTime(input[_PED]);\n    }\n    return entries;\n};\nconst se_AthenaIntegrationsSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_AthenaIntegration(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_AttachClassicLinkVpcRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_G] != null) {\n        const memberEntries = se_GroupIdStringList(input[_G], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_AttachInternetGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IGI] != null) {\n        entries[_IGI] = input[_IGI];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    return entries;\n};\nconst se_AttachNetworkInterfaceRequest = (input, context) => {\n    const entries = {};\n    if (input[_NCI] != null) {\n        entries[_NCI] = input[_NCI];\n    }\n    if (input[_ESS] != null) {\n        const memberEntries = se_EnaSrdSpecification(input[_ESS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnaSrdSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EQC] != null) {\n        entries[_EQC] = input[_EQC];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_DIev] != null) {\n        entries[_DIev] = input[_DIev];\n    }\n    return entries;\n};\nconst se_AttachVerifiedAccessTrustProviderRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAII] != null) {\n        entries[_VAII] = input[_VAII];\n    }\n    if (input[_VATPI] != null) {\n        entries[_VATPI] = input[_VATPI];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AttachVolumeRequest = (input, context) => {\n    const entries = {};\n    if (input[_Dev] != null) {\n        entries[_Dev] = input[_Dev];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_VIo] != null) {\n        entries[_VIo] = input[_VIo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AttachVpnGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_VGI] != null) {\n        entries[_VGI] = input[_VGI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AttributeBooleanValue = (input, context) => {\n    const entries = {};\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_AttributeValue = (input, context) => {\n    const entries = {};\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_AuthorizeClientVpnIngressRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_TNC] != null) {\n        entries[_TNC] = input[_TNC];\n    }\n    if (input[_AGI] != null) {\n        entries[_AGI] = input[_AGI];\n    }\n    if (input[_AAG] != null) {\n        entries[_AAG] = input[_AAG];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AuthorizeSecurityGroupEgressRequest = (input, context) => {\n    const entries = {};\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_SSGN] != null) {\n        entries[_SSGN] = input[_SSGN];\n    }\n    if (input[_SSGOI] != null) {\n        entries[_SSGOI] = input[_SSGOI];\n    }\n    if (input[_IPpr] != null) {\n        entries[_IPpr] = input[_IPpr];\n    }\n    if (input[_FP] != null) {\n        entries[_FP] = input[_FP];\n    }\n    if (input[_TP] != null) {\n        entries[_TP] = input[_TP];\n    }\n    if (input[_CIi] != null) {\n        entries[_CIi] = input[_CIi];\n    }\n    if (input[_IPpe] != null) {\n        const memberEntries = se_IpPermissionList(input[_IPpe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpPermissions.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_AuthorizeSecurityGroupIngressRequest = (input, context) => {\n    const entries = {};\n    if (input[_CIi] != null) {\n        entries[_CIi] = input[_CIi];\n    }\n    if (input[_FP] != null) {\n        entries[_FP] = input[_FP];\n    }\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_IPpe] != null) {\n        const memberEntries = se_IpPermissionList(input[_IPpe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpPermissions.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPpr] != null) {\n        entries[_IPpr] = input[_IPpr];\n    }\n    if (input[_SSGN] != null) {\n        entries[_SSGN] = input[_SSGN];\n    }\n    if (input[_SSGOI] != null) {\n        entries[_SSGOI] = input[_SSGOI];\n    }\n    if (input[_TP] != null) {\n        entries[_TP] = input[_TP];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_AvailabilityZoneStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`AvailabilityZone.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_BaselineEbsBandwidthMbps = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_BaselineEbsBandwidthMbpsRequest = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_BaselinePerformanceFactors = (input, context) => {\n    const entries = {};\n    if (input[_Cp] != null) {\n        const memberEntries = se_CpuPerformanceFactor(input[_Cp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Cpu.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_BaselinePerformanceFactorsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Cp] != null) {\n        const memberEntries = se_CpuPerformanceFactorRequest(input[_Cp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Cpu.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_BillingProductList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_BlobAttributeValue = (input, context) => {\n    const entries = {};\n    if (input[_Va] != null) {\n        entries[_Va] = context.base64Encoder(input[_Va]);\n    }\n    return entries;\n};\nconst se_BlockDeviceMapping = (input, context) => {\n    const entries = {};\n    if (input[_E] != null) {\n        const memberEntries = se_EbsBlockDevice(input[_E], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ebs.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ND] != null) {\n        entries[_ND] = input[_ND];\n    }\n    if (input[_DN] != null) {\n        entries[_DN] = input[_DN];\n    }\n    if (input[_VN] != null) {\n        entries[_VN] = input[_VN];\n    }\n    return entries;\n};\nconst se_BlockDeviceMappingList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_BlockDeviceMapping(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_BlockDeviceMappingRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_BlockDeviceMapping(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`BlockDeviceMapping.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_BundleIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`BundleId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_BundleInstanceRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_St] != null) {\n        const memberEntries = se_Storage(input[_St], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Storage.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CancelBundleTaskRequest = (input, context) => {\n    const entries = {};\n    if (input[_BIu] != null) {\n        entries[_BIu] = input[_BIu];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CancelCapacityReservationFleetsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CRFI] != null) {\n        const memberEntries = se_CapacityReservationFleetIdSet(input[_CRFI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityReservationFleetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CancelCapacityReservationRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRI] != null) {\n        entries[_CRI] = input[_CRI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CancelConversionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTI] != null) {\n        entries[_CTI] = input[_CTI];\n    }\n    if (input[_RM] != null) {\n        entries[_RM] = input[_RM];\n    }\n    return entries;\n};\nconst se_CancelDeclarativePoliciesReportRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RIep] != null) {\n        entries[_RIep] = input[_RIep];\n    }\n    return entries;\n};\nconst se_CancelExportTaskRequest = (input, context) => {\n    const entries = {};\n    if (input[_ETI] != null) {\n        entries[_ETI] = input[_ETI];\n    }\n    return entries;\n};\nconst se_CancelImageLaunchPermissionRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CancelImportTaskRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRa] != null) {\n        entries[_CRa] = input[_CRa];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ITI] != null) {\n        entries[_ITI] = input[_ITI];\n    }\n    return entries;\n};\nconst se_CancelReservedInstancesListingRequest = (input, context) => {\n    const entries = {};\n    if (input[_RILI] != null) {\n        entries[_RILI] = input[_RILI];\n    }\n    return entries;\n};\nconst se_CancelSpotFleetRequestsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SFRI] != null) {\n        const memberEntries = se_SpotFleetRequestIdList(input[_SFRI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SpotFleetRequestId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TI] != null) {\n        entries[_TI] = input[_TI];\n    }\n    return entries;\n};\nconst se_CancelSpotInstanceRequestsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIRI] != null) {\n        const memberEntries = se_SpotInstanceRequestIdList(input[_SIRI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SpotInstanceRequestId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CapacityReservationFleetIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_CapacityReservationIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_CapacityReservationOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_USs] != null) {\n        entries[_USs] = input[_USs];\n    }\n    return entries;\n};\nconst se_CapacityReservationSpecification = (input, context) => {\n    const entries = {};\n    if (input[_CRP] != null) {\n        entries[_CRP] = input[_CRP];\n    }\n    if (input[_CRTa] != null) {\n        const memberEntries = se_CapacityReservationTarget(input[_CRTa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityReservationTarget.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CapacityReservationTarget = (input, context) => {\n    const entries = {};\n    if (input[_CRI] != null) {\n        entries[_CRI] = input[_CRI];\n    }\n    if (input[_CRRGA] != null) {\n        entries[_CRRGA] = input[_CRRGA];\n    }\n    return entries;\n};\nconst se_CarrierGatewayIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_CertificateAuthenticationRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRCCA] != null) {\n        entries[_CRCCA] = input[_CRCCA];\n    }\n    return entries;\n};\nconst se_CidrAuthorizationContext = (input, context) => {\n    const entries = {};\n    if (input[_Me] != null) {\n        entries[_Me] = input[_Me];\n    }\n    if (input[_Si] != null) {\n        entries[_Si] = input[_Si];\n    }\n    return entries;\n};\nconst se_ClassicLoadBalancer = (input, context) => {\n    const entries = {};\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    return entries;\n};\nconst se_ClassicLoadBalancers = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ClassicLoadBalancer(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ClassicLoadBalancersConfig = (input, context) => {\n    const entries = {};\n    if (input[_CLB] != null) {\n        const memberEntries = se_ClassicLoadBalancers(input[_CLB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ClassicLoadBalancers.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ClientConnectOptions = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    if (input[_LFA] != null) {\n        entries[_LFA] = input[_LFA];\n    }\n    return entries;\n};\nconst se_ClientData = (input, context) => {\n    const entries = {};\n    if (input[_Co] != null) {\n        entries[_Co] = input[_Co];\n    }\n    if (input[_UE] != null) {\n        entries[_UE] = __serializeDateTime(input[_UE]);\n    }\n    if (input[_USp] != null) {\n        entries[_USp] = __serializeFloat(input[_USp]);\n    }\n    if (input[_USpl] != null) {\n        entries[_USpl] = __serializeDateTime(input[_USpl]);\n    }\n    return entries;\n};\nconst se_ClientLoginBannerOptions = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    if (input[_BT] != null) {\n        entries[_BT] = input[_BT];\n    }\n    return entries;\n};\nconst se_ClientRouteEnforcementOptions = (input, context) => {\n    const entries = {};\n    if (input[_Enf] != null) {\n        entries[_Enf] = input[_Enf];\n    }\n    return entries;\n};\nconst se_ClientVpnAuthenticationRequest = (input, context) => {\n    const entries = {};\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    if (input[_AD] != null) {\n        const memberEntries = se_DirectoryServiceAuthenticationRequest(input[_AD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ActiveDirectory.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MA] != null) {\n        const memberEntries = se_CertificateAuthenticationRequest(input[_MA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MutualAuthentication.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_FA] != null) {\n        const memberEntries = se_FederatedAuthenticationRequest(input[_FA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `FederatedAuthentication.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ClientVpnAuthenticationRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ClientVpnAuthenticationRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ClientVpnEndpointIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ClientVpnSecurityGroupIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_CloudWatchLogOptionsSpecification = (input, context) => {\n    const entries = {};\n    if (input[_LE] != null) {\n        entries[_LE] = input[_LE];\n    }\n    if (input[_LGA] != null) {\n        entries[_LGA] = input[_LGA];\n    }\n    if (input[_LOF] != null) {\n        entries[_LOF] = input[_LOF];\n    }\n    return entries;\n};\nconst se_CoipPoolIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ConfirmProductInstanceRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_PC] != null) {\n        entries[_PC] = input[_PC];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ConnectionLogOptions = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    if (input[_CLG] != null) {\n        entries[_CLG] = input[_CLG];\n    }\n    if (input[_CLS] != null) {\n        entries[_CLS] = input[_CLS];\n    }\n    return entries;\n};\nconst se_ConnectionNotificationIdsList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ConnectionTrackingSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_TET] != null) {\n        entries[_TET] = input[_TET];\n    }\n    if (input[_UST] != null) {\n        entries[_UST] = input[_UST];\n    }\n    if (input[_UT] != null) {\n        entries[_UT] = input[_UT];\n    }\n    return entries;\n};\nconst se_ConversionIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_CopyFpgaImageRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SFII] != null) {\n        entries[_SFII] = input[_SFII];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_SR] != null) {\n        entries[_SR] = input[_SR];\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_CopyImageRequest = (input, context) => {\n    const entries = {};\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_Enc] != null) {\n        entries[_Enc] = input[_Enc];\n    }\n    if (input[_KKI] != null) {\n        entries[_KKI] = input[_KKI];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_SII] != null) {\n        entries[_SII] = input[_SII];\n    }\n    if (input[_SR] != null) {\n        entries[_SR] = input[_SR];\n    }\n    if (input[_DOA] != null) {\n        entries[_DOA] = input[_DOA];\n    }\n    if (input[_CITo] != null) {\n        entries[_CITo] = input[_CITo];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SCCDM] != null) {\n        entries[_SCCDM] = input[_SCCDM];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CopySnapshotRequest = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DOA] != null) {\n        entries[_DOA] = input[_DOA];\n    }\n    if (input[_DRes] != null) {\n        entries[_DRes] = input[_DRes];\n    }\n    if (input[_Enc] != null) {\n        entries[_Enc] = input[_Enc];\n    }\n    if (input[_KKI] != null) {\n        entries[_KKI] = input[_KKI];\n    }\n    if (input[_PU] != null) {\n        entries[_PU] = input[_PU];\n    }\n    if (input[_SR] != null) {\n        entries[_SR] = input[_SR];\n    }\n    if (input[_SSI] != null) {\n        entries[_SSI] = input[_SSI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CDM] != null) {\n        entries[_CDM] = input[_CDM];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CpuManufacturerSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_CpuOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_CC] != null) {\n        entries[_CC] = input[_CC];\n    }\n    if (input[_TPC] != null) {\n        entries[_TPC] = input[_TPC];\n    }\n    if (input[_ASS] != null) {\n        entries[_ASS] = input[_ASS];\n    }\n    return entries;\n};\nconst se_CpuPerformanceFactor = (input, context) => {\n    const entries = {};\n    if (input[_R] != null) {\n        const memberEntries = se_PerformanceFactorReferenceSet(input[_R], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReferenceSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CpuPerformanceFactorRequest = (input, context) => {\n    const entries = {};\n    if (input[_R] != null) {\n        const memberEntries = se_PerformanceFactorReferenceSetRequest(input[_R], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Reference.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateCapacityReservationBySplittingRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_SCRI] != null) {\n        entries[_SCRI] = input[_SCRI];\n    }\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateCapacityReservationFleetRequest = (input, context) => {\n    const entries = {};\n    if (input[_AS] != null) {\n        entries[_AS] = input[_AS];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_ITS] != null) {\n        const memberEntries = se_ReservationFleetInstanceSpecificationList(input[_ITS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceTypeSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Te] != null) {\n        entries[_Te] = input[_Te];\n    }\n    if (input[_TTC] != null) {\n        entries[_TTC] = input[_TTC];\n    }\n    if (input[_ED] != null) {\n        entries[_ED] = __serializeDateTime(input[_ED]);\n    }\n    if (input[_IMC] != null) {\n        entries[_IMC] = input[_IMC];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateCapacityReservationRequest = (input, context) => {\n    const entries = {};\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_IPn] != null) {\n        entries[_IPn] = input[_IPn];\n    }\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_AZI] != null) {\n        entries[_AZI] = input[_AZI];\n    }\n    if (input[_Te] != null) {\n        entries[_Te] = input[_Te];\n    }\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    if (input[_EO] != null) {\n        entries[_EO] = input[_EO];\n    }\n    if (input[_ES] != null) {\n        entries[_ES] = input[_ES];\n    }\n    if (input[_ED] != null) {\n        entries[_ED] = __serializeDateTime(input[_ED]);\n    }\n    if (input[_EDT] != null) {\n        entries[_EDT] = input[_EDT];\n    }\n    if (input[_IMC] != null) {\n        entries[_IMC] = input[_IMC];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecifications.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_OA] != null) {\n        entries[_OA] = input[_OA];\n    }\n    if (input[_PGA] != null) {\n        entries[_PGA] = input[_PGA];\n    }\n    if (input[_SD] != null) {\n        entries[_SD] = __serializeDateTime(input[_SD]);\n    }\n    if (input[_CD] != null) {\n        entries[_CD] = input[_CD];\n    }\n    if (input[_DP] != null) {\n        entries[_DP] = input[_DP];\n    }\n    return entries;\n};\nconst se_CreateCarrierGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_CreateClientVpnEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_CCB] != null) {\n        entries[_CCB] = input[_CCB];\n    }\n    if (input[_SCA] != null) {\n        entries[_SCA] = input[_SCA];\n    }\n    if (input[_AO] != null) {\n        const memberEntries = se_ClientVpnAuthenticationRequestList(input[_AO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Authentication.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CLO] != null) {\n        const memberEntries = se_ConnectionLogOptions(input[_CLO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ConnectionLogOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DSn] != null) {\n        const memberEntries = se_ValueStringList(input[_DSn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DnsServers.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TPr] != null) {\n        entries[_TPr] = input[_TPr];\n    }\n    if (input[_VP] != null) {\n        entries[_VP] = input[_VP];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_ST] != null) {\n        entries[_ST] = input[_ST];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SGI] != null) {\n        const memberEntries = se_ClientVpnSecurityGroupIdSet(input[_SGI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_SSP] != null) {\n        entries[_SSP] = input[_SSP];\n    }\n    if (input[_CCO] != null) {\n        const memberEntries = se_ClientConnectOptions(input[_CCO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ClientConnectOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_STH] != null) {\n        entries[_STH] = input[_STH];\n    }\n    if (input[_CLBO] != null) {\n        const memberEntries = se_ClientLoginBannerOptions(input[_CLBO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ClientLoginBannerOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CREO] != null) {\n        const memberEntries = se_ClientRouteEnforcementOptions(input[_CREO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ClientRouteEnforcementOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DOST] != null) {\n        entries[_DOST] = input[_DOST];\n    }\n    return entries;\n};\nconst se_CreateClientVpnRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_TVSI] != null) {\n        entries[_TVSI] = input[_TVSI];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateCoipCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_CPIo] != null) {\n        entries[_CPIo] = input[_CPIo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateCoipPoolRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGRTI] != null) {\n        entries[_LGRTI] = input[_LGRTI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateCustomerGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_BA] != null) {\n        entries[_BA] = input[_BA];\n    }\n    if (input[_PI] != null) {\n        entries[_PI] = input[_PI];\n    }\n    if (input[_CA] != null) {\n        entries[_CA] = input[_CA];\n    }\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DN] != null) {\n        entries[_DN] = input[_DN];\n    }\n    if (input[_IAp] != null) {\n        entries[_IAp] = input[_IAp];\n    }\n    if (input[_BAE] != null) {\n        entries[_BAE] = input[_BAE];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateDefaultSubnetRequest = (input, context) => {\n    const entries = {};\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IN] != null) {\n        entries[_IN] = input[_IN];\n    }\n    return entries;\n};\nconst se_CreateDefaultVpcRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateDelegateMacVolumeOwnershipTaskRequest = (input, context) => {\n    const entries = {};\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_MC] != null) {\n        entries[_MC] = input[_MC];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateDhcpOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DCh] != null) {\n        const memberEntries = se_NewDhcpConfigurationList(input[_DCh], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DhcpConfiguration.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateEgressOnlyInternetGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateFleetRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_SO] != null) {\n        const memberEntries = se_SpotOptionsRequest(input[_SO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SpotOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ODO] != null) {\n        const memberEntries = se_OnDemandOptionsRequest(input[_ODO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `OnDemandOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ECTP] != null) {\n        entries[_ECTP] = input[_ECTP];\n    }\n    if (input[_LTC] != null) {\n        const memberEntries = se_FleetLaunchTemplateConfigListRequest(input[_LTC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateConfigs.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TCS] != null) {\n        const memberEntries = se_TargetCapacitySpecificationRequest(input[_TCS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TargetCapacitySpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TIWE] != null) {\n        entries[_TIWE] = input[_TIWE];\n    }\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    if (input[_VF] != null) {\n        entries[_VF] = __serializeDateTime(input[_VF]);\n    }\n    if (input[_VU] != null) {\n        entries[_VU] = __serializeDateTime(input[_VU]);\n    }\n    if (input[_RUI] != null) {\n        entries[_RUI] = input[_RUI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Con] != null) {\n        entries[_Con] = input[_Con];\n    }\n    return entries;\n};\nconst se_CreateFlowLogsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DLPA] != null) {\n        entries[_DLPA] = input[_DLPA];\n    }\n    if (input[_DCAR] != null) {\n        entries[_DCAR] = input[_DCAR];\n    }\n    if (input[_LGN] != null) {\n        entries[_LGN] = input[_LGN];\n    }\n    if (input[_RIes] != null) {\n        const memberEntries = se_FlowLogResourceIds(input[_RIes], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ResourceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RT] != null) {\n        entries[_RT] = input[_RT];\n    }\n    if (input[_TT] != null) {\n        entries[_TT] = input[_TT];\n    }\n    if (input[_LDT] != null) {\n        entries[_LDT] = input[_LDT];\n    }\n    if (input[_LD] != null) {\n        entries[_LD] = input[_LD];\n    }\n    if (input[_LF] != null) {\n        entries[_LF] = input[_LF];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MAI] != null) {\n        entries[_MAI] = input[_MAI];\n    }\n    if (input[_DO] != null) {\n        const memberEntries = se_DestinationOptionsRequest(input[_DO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DestinationOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateFpgaImageRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ISL] != null) {\n        const memberEntries = se_StorageLocation(input[_ISL], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InputStorageLocation.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LSL] != null) {\n        const memberEntries = se_StorageLocation(input[_LSL], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LogsStorageLocation.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateImageRequest = (input, context) => {\n    const entries = {};\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_NR] != null) {\n        entries[_NR] = input[_NR];\n    }\n    if (input[_BDM] != null) {\n        const memberEntries = se_BlockDeviceMappingRequestList(input[_BDM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateInstanceConnectEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_SGI] != null) {\n        const memberEntries = se_SecurityGroupIdStringListRequest(input[_SGI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PCI] != null) {\n        entries[_PCI] = input[_PCI];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateInstanceEventWindowRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_TRi] != null) {\n        const memberEntries = se_InstanceEventWindowTimeRangeRequestSet(input[_TRi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TimeRange.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CE] != null) {\n        entries[_CE] = input[_CE];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateInstanceExportTaskRequest = (input, context) => {\n    const entries = {};\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_TE] != null) {\n        entries[_TE] = input[_TE];\n    }\n    if (input[_ETST] != null) {\n        const memberEntries = se_ExportToS3TaskSpecification(input[_ETST], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExportToS3.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateInternetGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateIpamExternalResourceVerificationTokenRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIp] != null) {\n        entries[_IIp] = input[_IIp];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_CreateIpamPoolRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ISI] != null) {\n        entries[_ISI] = input[_ISI];\n    }\n    if (input[_L] != null) {\n        entries[_L] = input[_L];\n    }\n    if (input[_SIPI] != null) {\n        entries[_SIPI] = input[_SIPI];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_AF] != null) {\n        entries[_AF] = input[_AF];\n    }\n    if (input[_AIu] != null) {\n        entries[_AIu] = input[_AIu];\n    }\n    if (input[_PA] != null) {\n        entries[_PA] = input[_PA];\n    }\n    if (input[_AMNL] != null) {\n        entries[_AMNL] = input[_AMNL];\n    }\n    if (input[_AMNLl] != null) {\n        entries[_AMNLl] = input[_AMNLl];\n    }\n    if (input[_ADNL] != null) {\n        entries[_ADNL] = input[_ADNL];\n    }\n    if (input[_ARTl] != null) {\n        const memberEntries = se_RequestIpamResourceTagList(input[_ARTl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AllocationResourceTag.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_ASw] != null) {\n        entries[_ASw] = input[_ASw];\n    }\n    if (input[_PIS] != null) {\n        entries[_PIS] = input[_PIS];\n    }\n    if (input[_SRo] != null) {\n        const memberEntries = se_IpamPoolSourceResourceRequest(input[_SRo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SourceResource.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateIpamRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_OR] != null) {\n        const memberEntries = se_AddIpamOperatingRegionSet(input[_OR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `OperatingRegion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_Ti] != null) {\n        entries[_Ti] = input[_Ti];\n    }\n    if (input[_EPG] != null) {\n        entries[_EPG] = input[_EPG];\n    }\n    if (input[_MAe] != null) {\n        entries[_MAe] = input[_MAe];\n    }\n    return entries;\n};\nconst se_CreateIpamResourceDiscoveryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_OR] != null) {\n        const memberEntries = se_AddIpamOperatingRegionSet(input[_OR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `OperatingRegion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_CreateIpamScopeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIp] != null) {\n        entries[_IIp] = input[_IIp];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_CreateKeyPairRequest = (input, context) => {\n    const entries = {};\n    if (input[_KN] != null) {\n        entries[_KN] = input[_KN];\n    }\n    if (input[_KT] != null) {\n        entries[_KT] = input[_KT];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_KF] != null) {\n        entries[_KF] = input[_KF];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateLaunchTemplateRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_LTN] != null) {\n        entries[_LTN] = input[_LTN];\n    }\n    if (input[_VD] != null) {\n        entries[_VD] = input[_VD];\n    }\n    if (input[_LTD] != null) {\n        const memberEntries = se_RequestLaunchTemplateData(input[_LTD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateData.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_O] != null) {\n        const memberEntries = se_OperatorRequest(input[_O], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Operator.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateLaunchTemplateVersionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_LTI] != null) {\n        entries[_LTI] = input[_LTI];\n    }\n    if (input[_LTN] != null) {\n        entries[_LTN] = input[_LTN];\n    }\n    if (input[_SV] != null) {\n        entries[_SV] = input[_SV];\n    }\n    if (input[_VD] != null) {\n        entries[_VD] = input[_VD];\n    }\n    if (input[_LTD] != null) {\n        const memberEntries = se_RequestLaunchTemplateData(input[_LTD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateData.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RAe] != null) {\n        entries[_RAe] = input[_RAe];\n    }\n    return entries;\n};\nconst se_CreateLocalGatewayRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_LGRTI] != null) {\n        entries[_LGRTI] = input[_LGRTI];\n    }\n    if (input[_LGVIGI] != null) {\n        entries[_LGVIGI] = input[_LGVIGI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_DPLI] != null) {\n        entries[_DPLI] = input[_DPLI];\n    }\n    return entries;\n};\nconst se_CreateLocalGatewayRouteTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGI] != null) {\n        entries[_LGI] = input[_LGI];\n    }\n    if (input[_Mo] != null) {\n        entries[_Mo] = input[_Mo];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGRTI] != null) {\n        entries[_LGRTI] = input[_LGRTI];\n    }\n    if (input[_LGVIGI] != null) {\n        entries[_LGVIGI] = input[_LGVIGI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateLocalGatewayRouteTableVpcAssociationRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGRTI] != null) {\n        entries[_LGRTI] = input[_LGRTI];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateLocalGatewayVirtualInterfaceGroupRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGI] != null) {\n        entries[_LGI] = input[_LGI];\n    }\n    if (input[_LBA] != null) {\n        entries[_LBA] = input[_LBA];\n    }\n    if (input[_LBAE] != null) {\n        entries[_LBAE] = input[_LBAE];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateLocalGatewayVirtualInterfaceRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGVIGI] != null) {\n        entries[_LGVIGI] = input[_LGVIGI];\n    }\n    if (input[_OLI] != null) {\n        entries[_OLI] = input[_OLI];\n    }\n    if (input[_Vl] != null) {\n        entries[_Vl] = input[_Vl];\n    }\n    if (input[_LA] != null) {\n        entries[_LA] = input[_LA];\n    }\n    if (input[_PAe] != null) {\n        entries[_PAe] = input[_PAe];\n    }\n    if (input[_PBA] != null) {\n        entries[_PBA] = input[_PBA];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PBAE] != null) {\n        entries[_PBAE] = input[_PBAE];\n    }\n    return entries;\n};\nconst se_CreateMacSystemIntegrityProtectionModificationTaskRequest = (input, context) => {\n    const entries = {};\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_MC] != null) {\n        entries[_MC] = input[_MC];\n    }\n    if (input[_MSIPC] != null) {\n        const memberEntries = se_MacSystemIntegrityProtectionConfigurationRequest(input[_MSIPC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MacSystemIntegrityProtectionConfiguration.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MSIPS] != null) {\n        entries[_MSIPS] = input[_MSIPS];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateManagedPrefixListRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PLN] != null) {\n        entries[_PLN] = input[_PLN];\n    }\n    if (input[_Ent] != null) {\n        const memberEntries = se_AddPrefixListEntries(input[_Ent], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Entry.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ME] != null) {\n        entries[_ME] = input[_ME];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AF] != null) {\n        entries[_AF] = input[_AF];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_CreateNatGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIl] != null) {\n        entries[_AIl] = input[_AIl];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTo] != null) {\n        entries[_CTo] = input[_CTo];\n    }\n    if (input[_PIAr] != null) {\n        entries[_PIAr] = input[_PIAr];\n    }\n    if (input[_SAI] != null) {\n        const memberEntries = se_AllocationIdList(input[_SAI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecondaryAllocationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPIA] != null) {\n        const memberEntries = se_IpList(input[_SPIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecondaryPrivateIpAddress.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPIAC] != null) {\n        entries[_SPIAC] = input[_SPIAC];\n    }\n    return entries;\n};\nconst se_CreateNetworkAclEntryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NAI] != null) {\n        entries[_NAI] = input[_NAI];\n    }\n    if (input[_RNu] != null) {\n        entries[_RNu] = input[_RNu];\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_RAu] != null) {\n        entries[_RAu] = input[_RAu];\n    }\n    if (input[_Eg] != null) {\n        entries[_Eg] = input[_Eg];\n    }\n    if (input[_CB] != null) {\n        entries[_CB] = input[_CB];\n    }\n    if (input[_ICB] != null) {\n        entries[_ICB] = input[_ICB];\n    }\n    if (input[_ITC] != null) {\n        const memberEntries = se_IcmpTypeCode(input[_ITC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Icmp.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PR] != null) {\n        const memberEntries = se_PortRange(input[_PR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PortRange.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateNetworkAclRequest = (input, context) => {\n    const entries = {};\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    return entries;\n};\nconst se_CreateNetworkInsightsAccessScopeRequest = (input, context) => {\n    const entries = {};\n    if (input[_MP] != null) {\n        const memberEntries = se_AccessScopePathListRequest(input[_MP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MatchPath.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EP] != null) {\n        const memberEntries = se_AccessScopePathListRequest(input[_EP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExcludePath.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateNetworkInsightsPathRequest = (input, context) => {\n    const entries = {};\n    if (input[_SIo] != null) {\n        entries[_SIo] = input[_SIo];\n    }\n    if (input[_DIest] != null) {\n        entries[_DIest] = input[_DIest];\n    }\n    if (input[_S] != null) {\n        entries[_S] = input[_S];\n    }\n    if (input[_D] != null) {\n        entries[_D] = input[_D];\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_DPe] != null) {\n        entries[_DPe] = input[_DPe];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_FAS] != null) {\n        const memberEntries = se_PathRequestFilter(input[_FAS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `FilterAtSource.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_FAD] != null) {\n        const memberEntries = se_PathRequestFilter(input[_FAD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `FilterAtDestination.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateNetworkInterfacePermissionRequest = (input, context) => {\n    const entries = {};\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_AAI] != null) {\n        entries[_AAI] = input[_AAI];\n    }\n    if (input[_ASw] != null) {\n        entries[_ASw] = input[_ASw];\n    }\n    if (input[_Pe] != null) {\n        entries[_Pe] = input[_Pe];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateNetworkInterfaceRequest = (input, context) => {\n    const entries = {};\n    if (input[_IPp] != null) {\n        const memberEntries = se_Ipv4PrefixList(input[_IPp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv4Prefix.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPCp] != null) {\n        entries[_IPCp] = input[_IPCp];\n    }\n    if (input[_IP] != null) {\n        const memberEntries = se_Ipv6PrefixList(input[_IP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Prefix.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPC] != null) {\n        entries[_IPC] = input[_IPC];\n    }\n    if (input[_ITn] != null) {\n        entries[_ITn] = input[_ITn];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_EPI] != null) {\n        entries[_EPI] = input[_EPI];\n    }\n    if (input[_CTS] != null) {\n        const memberEntries = se_ConnectionTrackingSpecificationRequest(input[_CTS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ConnectionTrackingSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_O] != null) {\n        const memberEntries = se_OperatorRequest(input[_O], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Operator.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_PIAr] != null) {\n        entries[_PIAr] = input[_PIAr];\n    }\n    if (input[_G] != null) {\n        const memberEntries = se_SecurityGroupIdStringList(input[_G], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PIA] != null) {\n        const memberEntries = se_PrivateIpAddressSpecificationList(input[_PIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrivateIpAddresses.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPIAC] != null) {\n        entries[_SPIAC] = input[_SPIAC];\n    }\n    if (input[_IA] != null) {\n        const memberEntries = se_InstanceIpv6AddressList(input[_IA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Addresses.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IAC] != null) {\n        entries[_IAC] = input[_IAC];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreatePlacementGroupRequest = (input, context) => {\n    const entries = {};\n    if (input[_PCa] != null) {\n        entries[_PCa] = input[_PCa];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SL] != null) {\n        entries[_SL] = input[_SL];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_Str] != null) {\n        entries[_Str] = input[_Str];\n    }\n    return entries;\n};\nconst se_CreatePublicIpv4PoolRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NBG] != null) {\n        entries[_NBG] = input[_NBG];\n    }\n    return entries;\n};\nconst se_CreateReplaceRootVolumeTaskRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_DRRV] != null) {\n        entries[_DRRV] = input[_DRRV];\n    }\n    if (input[_VIR] != null) {\n        entries[_VIR] = input[_VIR];\n    }\n    return entries;\n};\nconst se_CreateReservedInstancesListingRequest = (input, context) => {\n    const entries = {};\n    if (input[_RIIe] != null) {\n        entries[_RIIe] = input[_RIIe];\n    }\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    if (input[_PS] != null) {\n        const memberEntries = se_PriceScheduleSpecificationList(input[_PS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PriceSchedules.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_CreateRestoreImageTaskRequest = (input, context) => {\n    const entries = {};\n    if (input[_B] != null) {\n        entries[_B] = input[_B];\n    }\n    if (input[_OK] != null) {\n        entries[_OK] = input[_OK];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DPLI] != null) {\n        entries[_DPLI] = input[_DPLI];\n    }\n    if (input[_VEIp] != null) {\n        entries[_VEIp] = input[_VEIp];\n    }\n    if (input[_TGI] != null) {\n        entries[_TGI] = input[_TGI];\n    }\n    if (input[_LGI] != null) {\n        entries[_LGI] = input[_LGI];\n    }\n    if (input[_CGI] != null) {\n        entries[_CGI] = input[_CGI];\n    }\n    if (input[_CNAo] != null) {\n        entries[_CNAo] = input[_CNAo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RTI] != null) {\n        entries[_RTI] = input[_RTI];\n    }\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_GI] != null) {\n        entries[_GI] = input[_GI];\n    }\n    if (input[_DICB] != null) {\n        entries[_DICB] = input[_DICB];\n    }\n    if (input[_EOIGI] != null) {\n        entries[_EOIGI] = input[_EOIGI];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_VPCI] != null) {\n        entries[_VPCI] = input[_VPCI];\n    }\n    if (input[_NGI] != null) {\n        entries[_NGI] = input[_NGI];\n    }\n    return entries;\n};\nconst se_CreateRouteServerEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSIo] != null) {\n        entries[_RSIo] = input[_RSIo];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateRouteServerPeerRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSEI] != null) {\n        entries[_RSEI] = input[_RSEI];\n    }\n    if (input[_PAe] != null) {\n        entries[_PAe] = input[_PAe];\n    }\n    if (input[_BO] != null) {\n        const memberEntries = se_RouteServerBgpOptionsRequest(input[_BO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BgpOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateRouteServerRequest = (input, context) => {\n    const entries = {};\n    if (input[_ASA] != null) {\n        entries[_ASA] = input[_ASA];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PRe] != null) {\n        entries[_PRe] = input[_PRe];\n    }\n    if (input[_PRD] != null) {\n        entries[_PRD] = input[_PRD];\n    }\n    if (input[_SNE] != null) {\n        entries[_SNE] = input[_SNE];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateRouteTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    return entries;\n};\nconst se_CreateSecurityGroupRequest = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_GD] = input[_De];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateSnapshotRequest = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_OA] != null) {\n        entries[_OA] = input[_OA];\n    }\n    if (input[_VIo] != null) {\n        entries[_VIo] = input[_VIo];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Lo] != null) {\n        entries[_Lo] = input[_Lo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateSnapshotsRequest = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_ISn] != null) {\n        const memberEntries = se_InstanceSpecification(input[_ISn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_OA] != null) {\n        entries[_OA] = input[_OA];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTFS] != null) {\n        entries[_CTFS] = input[_CTFS];\n    }\n    if (input[_Lo] != null) {\n        entries[_Lo] = input[_Lo];\n    }\n    return entries;\n};\nconst se_CreateSpotDatafeedSubscriptionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_B] != null) {\n        entries[_B] = input[_B];\n    }\n    if (input[_Pr] != null) {\n        entries[_Pr] = input[_Pr];\n    }\n    return entries;\n};\nconst se_CreateStoreImageTaskRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_B] != null) {\n        entries[_B] = input[_B];\n    }\n    if (input[_SOT] != null) {\n        const memberEntries = se_S3ObjectTagList(input[_SOT], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `S3ObjectTag.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateSubnetCidrReservationRequest = (input, context) => {\n    const entries = {};\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_RTe] != null) {\n        entries[_RTe] = input[_RTe];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateSubnetRequest = (input, context) => {\n    const entries = {};\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_AZI] != null) {\n        entries[_AZI] = input[_AZI];\n    }\n    if (input[_CB] != null) {\n        entries[_CB] = input[_CB];\n    }\n    if (input[_ICB] != null) {\n        entries[_ICB] = input[_ICB];\n    }\n    if (input[_OA] != null) {\n        entries[_OA] = input[_OA];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_IN] != null) {\n        entries[_IN] = input[_IN];\n    }\n    if (input[_IIPIp] != null) {\n        entries[_IIPIp] = input[_IIPIp];\n    }\n    if (input[_INLp] != null) {\n        entries[_INLp] = input[_INLp];\n    }\n    if (input[_IIPI] != null) {\n        entries[_IIPI] = input[_IIPI];\n    }\n    if (input[_INL] != null) {\n        entries[_INL] = input[_INL];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTagsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Re] != null) {\n        const memberEntries = se_ResourceIdList(input[_Re], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ResourceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ta] != null) {\n        const memberEntries = se_TagList(input[_Ta], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Tag.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateTrafficMirrorFilterRequest = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_CreateTrafficMirrorFilterRuleRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMFI] != null) {\n        entries[_TMFI] = input[_TMFI];\n    }\n    if (input[_TD] != null) {\n        entries[_TD] = input[_TD];\n    }\n    if (input[_RNu] != null) {\n        entries[_RNu] = input[_RNu];\n    }\n    if (input[_RAu] != null) {\n        entries[_RAu] = input[_RAu];\n    }\n    if (input[_DPR] != null) {\n        const memberEntries = se_TrafficMirrorPortRangeRequest(input[_DPR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DestinationPortRange.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPR] != null) {\n        const memberEntries = se_TrafficMirrorPortRangeRequest(input[_SPR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SourcePortRange.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_SCB] != null) {\n        entries[_SCB] = input[_SCB];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateTrafficMirrorSessionRequest = (input, context) => {\n    const entries = {};\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_TMTI] != null) {\n        entries[_TMTI] = input[_TMTI];\n    }\n    if (input[_TMFI] != null) {\n        entries[_TMFI] = input[_TMFI];\n    }\n    if (input[_PL] != null) {\n        entries[_PL] = input[_PL];\n    }\n    if (input[_SN] != null) {\n        entries[_SN] = input[_SN];\n    }\n    if (input[_VNI] != null) {\n        entries[_VNI] = input[_VNI];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_CreateTrafficMirrorTargetRequest = (input, context) => {\n    const entries = {};\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_NLBA] != null) {\n        entries[_NLBA] = input[_NLBA];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_GLBEI] != null) {\n        entries[_GLBEI] = input[_GLBEI];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayConnectPeerRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_TGA] != null) {\n        entries[_TGA] = input[_TGA];\n    }\n    if (input[_PAe] != null) {\n        entries[_PAe] = input[_PAe];\n    }\n    if (input[_BO] != null) {\n        const memberEntries = se_TransitGatewayConnectRequestBgpOptions(input[_BO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BgpOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ICBn] != null) {\n        const memberEntries = se_InsideCidrBlocksStringList(input[_ICBn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InsideCidrBlocks.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayConnectRequest = (input, context) => {\n    const entries = {};\n    if (input[_TTGAI] != null) {\n        entries[_TTGAI] = input[_TTGAI];\n    }\n    if (input[_Op] != null) {\n        const memberEntries = se_CreateTransitGatewayConnectRequestOptions(input[_Op], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Options.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayConnectRequestOptions = (input, context) => {\n    const entries = {};\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayMulticastDomainRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGI] != null) {\n        entries[_TGI] = input[_TGI];\n    }\n    if (input[_Op] != null) {\n        const memberEntries = se_CreateTransitGatewayMulticastDomainRequestOptions(input[_Op], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Options.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayMulticastDomainRequestOptions = (input, context) => {\n    const entries = {};\n    if (input[_ISg] != null) {\n        entries[_ISg] = input[_ISg];\n    }\n    if (input[_SSS] != null) {\n        entries[_SSS] = input[_SSS];\n    }\n    if (input[_AASA] != null) {\n        entries[_AASA] = input[_AASA];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayPeeringAttachmentRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGI] != null) {\n        entries[_TGI] = input[_TGI];\n    }\n    if (input[_PTGI] != null) {\n        entries[_PTGI] = input[_PTGI];\n    }\n    if (input[_PAI] != null) {\n        entries[_PAI] = input[_PAI];\n    }\n    if (input[_PRee] != null) {\n        entries[_PRee] = input[_PRee];\n    }\n    if (input[_Op] != null) {\n        const memberEntries = se_CreateTransitGatewayPeeringAttachmentRequestOptions(input[_Op], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Options.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayPeeringAttachmentRequestOptions = (input, context) => {\n    const entries = {};\n    if (input[_DRy] != null) {\n        entries[_DRy] = input[_DRy];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayPolicyTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGI] != null) {\n        entries[_TGI] = input[_TGI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecifications.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayPrefixListReferenceRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_PLI] != null) {\n        entries[_PLI] = input[_PLI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_Bl] != null) {\n        entries[_Bl] = input[_Bl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_Op] != null) {\n        const memberEntries = se_TransitGatewayRequestOptions(input[_Op], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Options.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_Bl] != null) {\n        entries[_Bl] = input[_Bl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayRouteTableAnnouncementRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_PAIe] != null) {\n        entries[_PAIe] = input[_PAIe];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayRouteTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGI] != null) {\n        entries[_TGI] = input[_TGI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecifications.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayVpcAttachmentRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGI] != null) {\n        entries[_TGI] = input[_TGI];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_SIu] != null) {\n        const memberEntries = se_TransitGatewaySubnetIdList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Op] != null) {\n        const memberEntries = se_CreateTransitGatewayVpcAttachmentRequestOptions(input[_Op], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Options.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecifications.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateTransitGatewayVpcAttachmentRequestOptions = (input, context) => {\n    const entries = {};\n    if (input[_DSns] != null) {\n        entries[_DSns] = input[_DSns];\n    }\n    if (input[_SGRS] != null) {\n        entries[_SGRS] = input[_SGRS];\n    }\n    if (input[_ISp] != null) {\n        entries[_ISp] = input[_ISp];\n    }\n    if (input[_AMS] != null) {\n        entries[_AMS] = input[_AMS];\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessEndpointCidrOptions = (input, context) => {\n    const entries = {};\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_SIu] != null) {\n        const memberEntries = se_CreateVerifiedAccessEndpointSubnetIdList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_PRo] != null) {\n        const memberEntries = se_CreateVerifiedAccessEndpointPortRangeList(input[_PRo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PortRange.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessEndpointEniOptions = (input, context) => {\n    const entries = {};\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_Po] != null) {\n        entries[_Po] = input[_Po];\n    }\n    if (input[_PRo] != null) {\n        const memberEntries = se_CreateVerifiedAccessEndpointPortRangeList(input[_PRo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PortRange.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessEndpointLoadBalancerOptions = (input, context) => {\n    const entries = {};\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_Po] != null) {\n        entries[_Po] = input[_Po];\n    }\n    if (input[_LBAo] != null) {\n        entries[_LBAo] = input[_LBAo];\n    }\n    if (input[_SIu] != null) {\n        const memberEntries = se_CreateVerifiedAccessEndpointSubnetIdList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PRo] != null) {\n        const memberEntries = se_CreateVerifiedAccessEndpointPortRangeList(input[_PRo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PortRange.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessEndpointPortRange = (input, context) => {\n    const entries = {};\n    if (input[_FP] != null) {\n        entries[_FP] = input[_FP];\n    }\n    if (input[_TP] != null) {\n        entries[_TP] = input[_TP];\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessEndpointPortRangeList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_CreateVerifiedAccessEndpointPortRange(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessEndpointRdsOptions = (input, context) => {\n    const entries = {};\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_Po] != null) {\n        entries[_Po] = input[_Po];\n    }\n    if (input[_RDIA] != null) {\n        entries[_RDIA] = input[_RDIA];\n    }\n    if (input[_RDCA] != null) {\n        entries[_RDCA] = input[_RDCA];\n    }\n    if (input[_RDPA] != null) {\n        entries[_RDPA] = input[_RDPA];\n    }\n    if (input[_RE] != null) {\n        entries[_RE] = input[_RE];\n    }\n    if (input[_SIu] != null) {\n        const memberEntries = se_CreateVerifiedAccessEndpointSubnetIdList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAGI] != null) {\n        entries[_VAGI] = input[_VAGI];\n    }\n    if (input[_ET] != null) {\n        entries[_ET] = input[_ET];\n    }\n    if (input[_ATt] != null) {\n        entries[_ATt] = input[_ATt];\n    }\n    if (input[_DCA] != null) {\n        entries[_DCA] = input[_DCA];\n    }\n    if (input[_ADp] != null) {\n        entries[_ADp] = input[_ADp];\n    }\n    if (input[_EDP] != null) {\n        entries[_EDP] = input[_EDP];\n    }\n    if (input[_SGI] != null) {\n        const memberEntries = se_SecurityGroupIdList(input[_SGI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LBO] != null) {\n        const memberEntries = se_CreateVerifiedAccessEndpointLoadBalancerOptions(input[_LBO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LoadBalancerOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NIO] != null) {\n        const memberEntries = se_CreateVerifiedAccessEndpointEniOptions(input[_NIO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterfaceOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_PD] != null) {\n        entries[_PD] = input[_PD];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SS] != null) {\n        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SseSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RO] != null) {\n        const memberEntries = se_CreateVerifiedAccessEndpointRdsOptions(input[_RO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RdsOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CO] != null) {\n        const memberEntries = se_CreateVerifiedAccessEndpointCidrOptions(input[_CO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CidrOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessEndpointSubnetIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessGroupRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAII] != null) {\n        entries[_VAII] = input[_VAII];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_PD] != null) {\n        entries[_PD] = input[_PD];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SS] != null) {\n        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SseSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessInstanceRequest = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_FIPSE] != null) {\n        entries[_FIPSE] = input[_FIPSE];\n    }\n    if (input[_CECSD] != null) {\n        entries[_CECSD] = input[_CECSD];\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessNativeApplicationOidcOptions = (input, context) => {\n    const entries = {};\n    if (input[_PSKE] != null) {\n        entries[_PSKE] = input[_PSKE];\n    }\n    if (input[_I] != null) {\n        entries[_I] = input[_I];\n    }\n    if (input[_AE] != null) {\n        entries[_AE] = input[_AE];\n    }\n    if (input[_TEo] != null) {\n        entries[_TEo] = input[_TEo];\n    }\n    if (input[_UIE] != null) {\n        entries[_UIE] = input[_UIE];\n    }\n    if (input[_CIl] != null) {\n        entries[_CIl] = input[_CIl];\n    }\n    if (input[_CSl] != null) {\n        entries[_CSl] = input[_CSl];\n    }\n    if (input[_Sc] != null) {\n        entries[_Sc] = input[_Sc];\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessTrustProviderDeviceOptions = (input, context) => {\n    const entries = {};\n    if (input[_TIe] != null) {\n        entries[_TIe] = input[_TIe];\n    }\n    if (input[_PSKU] != null) {\n        entries[_PSKU] = input[_PSKU];\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessTrustProviderOidcOptions = (input, context) => {\n    const entries = {};\n    if (input[_I] != null) {\n        entries[_I] = input[_I];\n    }\n    if (input[_AE] != null) {\n        entries[_AE] = input[_AE];\n    }\n    if (input[_TEo] != null) {\n        entries[_TEo] = input[_TEo];\n    }\n    if (input[_UIE] != null) {\n        entries[_UIE] = input[_UIE];\n    }\n    if (input[_CIl] != null) {\n        entries[_CIl] = input[_CIl];\n    }\n    if (input[_CSl] != null) {\n        entries[_CSl] = input[_CSl];\n    }\n    if (input[_Sc] != null) {\n        entries[_Sc] = input[_Sc];\n    }\n    return entries;\n};\nconst se_CreateVerifiedAccessTrustProviderRequest = (input, context) => {\n    const entries = {};\n    if (input[_TPT] != null) {\n        entries[_TPT] = input[_TPT];\n    }\n    if (input[_UTPT] != null) {\n        entries[_UTPT] = input[_UTPT];\n    }\n    if (input[_DTPT] != null) {\n        entries[_DTPT] = input[_DTPT];\n    }\n    if (input[_OO] != null) {\n        const memberEntries = se_CreateVerifiedAccessTrustProviderOidcOptions(input[_OO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `OidcOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DOe] != null) {\n        const memberEntries = se_CreateVerifiedAccessTrustProviderDeviceOptions(input[_DOe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DeviceOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PRN] != null) {\n        entries[_PRN] = input[_PRN];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SS] != null) {\n        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SseSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NAOO] != null) {\n        const memberEntries = se_CreateVerifiedAccessNativeApplicationOidcOptions(input[_NAOO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NativeApplicationOidcOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateVolumePermission = (input, context) => {\n    const entries = {};\n    if (input[_UIs] != null) {\n        entries[_UIs] = input[_UIs];\n    }\n    if (input[_Gr] != null) {\n        entries[_Gr] = input[_Gr];\n    }\n    return entries;\n};\nconst se_CreateVolumePermissionList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_CreateVolumePermission(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_CreateVolumePermissionModifications = (input, context) => {\n    const entries = {};\n    if (input[_Add] != null) {\n        const memberEntries = se_CreateVolumePermissionList(input[_Add], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Add.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Rem] != null) {\n        const memberEntries = se_CreateVolumePermissionList(input[_Rem], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Remove.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateVolumeRequest = (input, context) => {\n    const entries = {};\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_Enc] != null) {\n        entries[_Enc] = input[_Enc];\n    }\n    if (input[_Io] != null) {\n        entries[_Io] = input[_Io];\n    }\n    if (input[_KKI] != null) {\n        entries[_KKI] = input[_KKI];\n    }\n    if (input[_OA] != null) {\n        entries[_OA] = input[_OA];\n    }\n    if (input[_Siz] != null) {\n        entries[_Siz] = input[_Siz];\n    }\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_VT] != null) {\n        entries[_VT] = input[_VT];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MAE] != null) {\n        entries[_MAE] = input[_MAE];\n    }\n    if (input[_Th] != null) {\n        entries[_Th] = input[_Th];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_VIR] != null) {\n        entries[_VIR] = input[_VIR];\n    }\n    if (input[_O] != null) {\n        const memberEntries = se_OperatorRequest(input[_O], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Operator.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreateVpcBlockPublicAccessExclusionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_IGEM] != null) {\n        entries[_IGEM] = input[_IGEM];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateVpcEndpointConnectionNotificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIe] != null) {\n        entries[_SIe] = input[_SIe];\n    }\n    if (input[_VEIp] != null) {\n        entries[_VEIp] = input[_VEIp];\n    }\n    if (input[_CNAon] != null) {\n        entries[_CNAon] = input[_CNAon];\n    }\n    if (input[_CEo] != null) {\n        const memberEntries = se_ValueStringList(input[_CEo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ConnectionEvents.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_CreateVpcEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VET] != null) {\n        entries[_VET] = input[_VET];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_SNe] != null) {\n        entries[_SNe] = input[_SNe];\n    }\n    if (input[_PD] != null) {\n        entries[_PD] = input[_PD];\n    }\n    if (input[_RTIo] != null) {\n        const memberEntries = se_VpcEndpointRouteTableIdList(input[_RTIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RouteTableId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SIu] != null) {\n        const memberEntries = se_VpcEndpointSubnetIdList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SGI] != null) {\n        const memberEntries = se_VpcEndpointSecurityGroupIdList(input[_SGI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IAT] != null) {\n        entries[_IAT] = input[_IAT];\n    }\n    if (input[_DOn] != null) {\n        const memberEntries = se_DnsOptionsSpecification(input[_DOn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DnsOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_PDE] != null) {\n        entries[_PDE] = input[_PDE];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SC] != null) {\n        const memberEntries = se_SubnetConfigurationsList(input[_SC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetConfiguration.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SNA] != null) {\n        entries[_SNA] = input[_SNA];\n    }\n    if (input[_RCA] != null) {\n        entries[_RCA] = input[_RCA];\n    }\n    if (input[_SRe] != null) {\n        entries[_SRe] = input[_SRe];\n    }\n    return entries;\n};\nconst se_CreateVpcEndpointServiceConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ARc] != null) {\n        entries[_ARc] = input[_ARc];\n    }\n    if (input[_PDN] != null) {\n        entries[_PDN] = input[_PDN];\n    }\n    if (input[_NLBAe] != null) {\n        const memberEntries = se_ValueStringList(input[_NLBAe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkLoadBalancerArn.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_GLBA] != null) {\n        const memberEntries = se_ValueStringList(input[_GLBA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `GatewayLoadBalancerArn.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SIAT] != null) {\n        const memberEntries = se_ValueStringList(input[_SIAT], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SupportedIpAddressType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SRu] != null) {\n        const memberEntries = se_ValueStringList(input[_SRu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SupportedRegion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateVpcPeeringConnectionRequest = (input, context) => {\n    const entries = {};\n    if (input[_PRee] != null) {\n        entries[_PRee] = input[_PRee];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_PVI] != null) {\n        entries[_PVI] = input[_PVI];\n    }\n    if (input[_POI] != null) {\n        entries[_POI] = input[_POI];\n    }\n    return entries;\n};\nconst se_CreateVpcRequest = (input, context) => {\n    const entries = {};\n    if (input[_CB] != null) {\n        entries[_CB] = input[_CB];\n    }\n    if (input[_IPpv] != null) {\n        entries[_IPpv] = input[_IPpv];\n    }\n    if (input[_ICB] != null) {\n        entries[_ICB] = input[_ICB];\n    }\n    if (input[_IIPIp] != null) {\n        entries[_IIPIp] = input[_IIPIp];\n    }\n    if (input[_INLp] != null) {\n        entries[_INLp] = input[_INLp];\n    }\n    if (input[_IIPI] != null) {\n        entries[_IIPI] = input[_IIPI];\n    }\n    if (input[_INL] != null) {\n        entries[_INL] = input[_INL];\n    }\n    if (input[_ICBNBG] != null) {\n        entries[_ICBNBG] = input[_ICBNBG];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ITns] != null) {\n        entries[_ITns] = input[_ITns];\n    }\n    if (input[_APICB] != null) {\n        entries[_APICB] = input[_APICB];\n    }\n    return entries;\n};\nconst se_CreateVpnConnectionRequest = (input, context) => {\n    const entries = {};\n    if (input[_CGIu] != null) {\n        entries[_CGIu] = input[_CGIu];\n    }\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    if (input[_VGI] != null) {\n        entries[_VGI] = input[_VGI];\n    }\n    if (input[_TGI] != null) {\n        entries[_TGI] = input[_TGI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PSKS] != null) {\n        entries[_PSKS] = input[_PSKS];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Op] != null) {\n        const memberEntries = se_VpnConnectionOptionsSpecification(input[_Op], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Options.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_CreateVpnConnectionRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_VCI] != null) {\n        entries[_VCI] = input[_VCI];\n    }\n    return entries;\n};\nconst se_CreateVpnGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ASA] != null) {\n        entries[_ASA] = input[_ASA];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_CreditSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_CCp] != null) {\n        entries[_CCp] = input[_CCp];\n    }\n    return entries;\n};\nconst se_CustomerGatewayIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`CustomerGatewayId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_DataQueries = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_DataQuery(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_DataQuery = (input, context) => {\n    const entries = {};\n    if (input[_Id] != null) {\n        entries[_Id] = input[_Id];\n    }\n    if (input[_S] != null) {\n        entries[_S] = input[_S];\n    }\n    if (input[_D] != null) {\n        entries[_D] = input[_D];\n    }\n    if (input[_Met] != null) {\n        entries[_Met] = input[_Met];\n    }\n    if (input[_Sta] != null) {\n        entries[_Sta] = input[_Sta];\n    }\n    if (input[_Per] != null) {\n        entries[_Per] = input[_Per];\n    }\n    return entries;\n};\nconst se_DedicatedHostIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_DeleteCarrierGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_CGI] != null) {\n        entries[_CGI] = input[_CGI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteClientVpnEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteClientVpnRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_TVSI] != null) {\n        entries[_TVSI] = input[_TVSI];\n    }\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteCoipCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_CPIo] != null) {\n        entries[_CPIo] = input[_CPIo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteCoipPoolRequest = (input, context) => {\n    const entries = {};\n    if (input[_CPIo] != null) {\n        entries[_CPIo] = input[_CPIo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteCustomerGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_CGIu] != null) {\n        entries[_CGIu] = input[_CGIu];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteDhcpOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DOI] != null) {\n        entries[_DOI] = input[_DOI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteEgressOnlyInternetGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_EOIGI] != null) {\n        entries[_EOIGI] = input[_EOIGI];\n    }\n    return entries;\n};\nconst se_DeleteFleetsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_FI] != null) {\n        const memberEntries = se_FleetIdSet(input[_FI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `FleetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TI] != null) {\n        entries[_TI] = input[_TI];\n    }\n    return entries;\n};\nconst se_DeleteFlowLogsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_FLI] != null) {\n        const memberEntries = se_FlowLogIdList(input[_FLI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `FlowLogId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeleteFpgaImageRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_FII] != null) {\n        entries[_FII] = input[_FII];\n    }\n    return entries;\n};\nconst se_DeleteInstanceConnectEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ICEI] != null) {\n        entries[_ICEI] = input[_ICEI];\n    }\n    return entries;\n};\nconst se_DeleteInstanceEventWindowRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_FD] != null) {\n        entries[_FD] = input[_FD];\n    }\n    if (input[_IEWI] != null) {\n        entries[_IEWI] = input[_IEWI];\n    }\n    return entries;\n};\nconst se_DeleteInternetGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IGI] != null) {\n        entries[_IGI] = input[_IGI];\n    }\n    return entries;\n};\nconst se_DeleteIpamExternalResourceVerificationTokenRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IERVTI] != null) {\n        entries[_IERVTI] = input[_IERVTI];\n    }\n    return entries;\n};\nconst se_DeleteIpamPoolRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_Ca] != null) {\n        entries[_Ca] = input[_Ca];\n    }\n    return entries;\n};\nconst se_DeleteIpamRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIp] != null) {\n        entries[_IIp] = input[_IIp];\n    }\n    if (input[_Ca] != null) {\n        entries[_Ca] = input[_Ca];\n    }\n    return entries;\n};\nconst se_DeleteIpamResourceDiscoveryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IRDI] != null) {\n        entries[_IRDI] = input[_IRDI];\n    }\n    return entries;\n};\nconst se_DeleteIpamScopeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ISI] != null) {\n        entries[_ISI] = input[_ISI];\n    }\n    return entries;\n};\nconst se_DeleteKeyPairRequest = (input, context) => {\n    const entries = {};\n    if (input[_KN] != null) {\n        entries[_KN] = input[_KN];\n    }\n    if (input[_KPI] != null) {\n        entries[_KPI] = input[_KPI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteLaunchTemplateRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_LTI] != null) {\n        entries[_LTI] = input[_LTI];\n    }\n    if (input[_LTN] != null) {\n        entries[_LTN] = input[_LTN];\n    }\n    return entries;\n};\nconst se_DeleteLaunchTemplateVersionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_LTI] != null) {\n        entries[_LTI] = input[_LTI];\n    }\n    if (input[_LTN] != null) {\n        entries[_LTN] = input[_LTN];\n    }\n    if (input[_Ve] != null) {\n        const memberEntries = se_VersionStringList(input[_Ve], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateVersion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeleteLocalGatewayRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_LGRTI] != null) {\n        entries[_LGRTI] = input[_LGRTI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_DPLI] != null) {\n        entries[_DPLI] = input[_DPLI];\n    }\n    return entries;\n};\nconst se_DeleteLocalGatewayRouteTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGRTI] != null) {\n        entries[_LGRTI] = input[_LGRTI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGRTVIGAI] != null) {\n        entries[_LGRTVIGAI] = input[_LGRTVIGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteLocalGatewayRouteTableVpcAssociationRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGRTVAI] != null) {\n        entries[_LGRTVAI] = input[_LGRTVAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteLocalGatewayVirtualInterfaceGroupRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGVIGI] != null) {\n        entries[_LGVIGI] = input[_LGVIGI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteLocalGatewayVirtualInterfaceRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGVII] != null) {\n        entries[_LGVII] = input[_LGVII];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteManagedPrefixListRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PLI] != null) {\n        entries[_PLI] = input[_PLI];\n    }\n    return entries;\n};\nconst se_DeleteNatGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NGI] != null) {\n        entries[_NGI] = input[_NGI];\n    }\n    return entries;\n};\nconst se_DeleteNetworkAclEntryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NAI] != null) {\n        entries[_NAI] = input[_NAI];\n    }\n    if (input[_RNu] != null) {\n        entries[_RNu] = input[_RNu];\n    }\n    if (input[_Eg] != null) {\n        entries[_Eg] = input[_Eg];\n    }\n    return entries;\n};\nconst se_DeleteNetworkAclRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NAI] != null) {\n        entries[_NAI] = input[_NAI];\n    }\n    return entries;\n};\nconst se_DeleteNetworkInsightsAccessScopeAnalysisRequest = (input, context) => {\n    const entries = {};\n    if (input[_NIASAI] != null) {\n        entries[_NIASAI] = input[_NIASAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteNetworkInsightsAccessScopeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NIASI] != null) {\n        entries[_NIASI] = input[_NIASI];\n    }\n    return entries;\n};\nconst se_DeleteNetworkInsightsAnalysisRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NIAI] != null) {\n        entries[_NIAI] = input[_NIAI];\n    }\n    return entries;\n};\nconst se_DeleteNetworkInsightsPathRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NIPI] != null) {\n        entries[_NIPI] = input[_NIPI];\n    }\n    return entries;\n};\nconst se_DeleteNetworkInterfacePermissionRequest = (input, context) => {\n    const entries = {};\n    if (input[_NIPIe] != null) {\n        entries[_NIPIe] = input[_NIPIe];\n    }\n    if (input[_F] != null) {\n        entries[_F] = input[_F];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteNetworkInterfaceRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    return entries;\n};\nconst se_DeletePlacementGroupRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    return entries;\n};\nconst se_DeletePublicIpv4PoolRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PIo] != null) {\n        entries[_PIo] = input[_PIo];\n    }\n    if (input[_NBG] != null) {\n        entries[_NBG] = input[_NBG];\n    }\n    return entries;\n};\nconst se_DeleteQueuedReservedInstancesIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_DeleteQueuedReservedInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RIIes] != null) {\n        const memberEntries = se_DeleteQueuedReservedInstancesIdList(input[_RIIes], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReservedInstancesId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeleteRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DPLI] != null) {\n        entries[_DPLI] = input[_DPLI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RTI] != null) {\n        entries[_RTI] = input[_RTI];\n    }\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_DICB] != null) {\n        entries[_DICB] = input[_DICB];\n    }\n    return entries;\n};\nconst se_DeleteRouteServerEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSEI] != null) {\n        entries[_RSEI] = input[_RSEI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteRouteServerPeerRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSPI] != null) {\n        entries[_RSPI] = input[_RSPI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteRouteServerRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSIo] != null) {\n        entries[_RSIo] = input[_RSIo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteRouteTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RTI] != null) {\n        entries[_RTI] = input[_RTI];\n    }\n    return entries;\n};\nconst se_DeleteSecurityGroupRequest = (input, context) => {\n    const entries = {};\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteSnapshotRequest = (input, context) => {\n    const entries = {};\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteSpotDatafeedSubscriptionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteSubnetCidrReservationRequest = (input, context) => {\n    const entries = {};\n    if (input[_SCRIu] != null) {\n        entries[_SCRIu] = input[_SCRIu];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteSubnetRequest = (input, context) => {\n    const entries = {};\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTagsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Re] != null) {\n        const memberEntries = se_ResourceIdList(input[_Re], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ResourceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ta] != null) {\n        const memberEntries = se_TagList(input[_Ta], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Tag.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeleteTrafficMirrorFilterRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMFI] != null) {\n        entries[_TMFI] = input[_TMFI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTrafficMirrorFilterRuleRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMFRI] != null) {\n        entries[_TMFRI] = input[_TMFRI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTrafficMirrorSessionRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMSI] != null) {\n        entries[_TMSI] = input[_TMSI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTrafficMirrorTargetRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMTI] != null) {\n        entries[_TMTI] = input[_TMTI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTransitGatewayConnectPeerRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGCPI] != null) {\n        entries[_TGCPI] = input[_TGCPI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTransitGatewayConnectRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTransitGatewayMulticastDomainRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDI] != null) {\n        entries[_TGMDI] = input[_TGMDI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTransitGatewayPeeringAttachmentRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTransitGatewayPolicyTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGPTI] != null) {\n        entries[_TGPTI] = input[_TGPTI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTransitGatewayPrefixListReferenceRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_PLI] != null) {\n        entries[_PLI] = input[_PLI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTransitGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGI] != null) {\n        entries[_TGI] = input[_TGI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTransitGatewayRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTransitGatewayRouteTableAnnouncementRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTAI] != null) {\n        entries[_TGRTAI] = input[_TGRTAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTransitGatewayRouteTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteTransitGatewayVpcAttachmentRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteVerifiedAccessEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAEI] != null) {\n        entries[_VAEI] = input[_VAEI];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteVerifiedAccessGroupRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAGI] != null) {\n        entries[_VAGI] = input[_VAGI];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteVerifiedAccessInstanceRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAII] != null) {\n        entries[_VAII] = input[_VAII];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_DeleteVerifiedAccessTrustProviderRequest = (input, context) => {\n    const entries = {};\n    if (input[_VATPI] != null) {\n        entries[_VATPI] = input[_VATPI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_DeleteVolumeRequest = (input, context) => {\n    const entries = {};\n    if (input[_VIo] != null) {\n        entries[_VIo] = input[_VIo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteVpcBlockPublicAccessExclusionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_EIxc] != null) {\n        entries[_EIxc] = input[_EIxc];\n    }\n    return entries;\n};\nconst se_DeleteVpcEndpointConnectionNotificationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CNIo] != null) {\n        const memberEntries = se_ConnectionNotificationIdsList(input[_CNIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ConnectionNotificationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeleteVpcEndpointServiceConfigurationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIer] != null) {\n        const memberEntries = se_VpcEndpointServiceIdList(input[_SIer], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ServiceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeleteVpcEndpointsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VEI] != null) {\n        const memberEntries = se_VpcEndpointIdList(input[_VEI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VpcEndpointId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeleteVpcPeeringConnectionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VPCI] != null) {\n        entries[_VPCI] = input[_VPCI];\n    }\n    return entries;\n};\nconst se_DeleteVpcRequest = (input, context) => {\n    const entries = {};\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteVpnConnectionRequest = (input, context) => {\n    const entries = {};\n    if (input[_VCI] != null) {\n        entries[_VCI] = input[_VCI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeleteVpnConnectionRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_VCI] != null) {\n        entries[_VCI] = input[_VCI];\n    }\n    return entries;\n};\nconst se_DeleteVpnGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_VGI] != null) {\n        entries[_VGI] = input[_VGI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeprovisionByoipCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeprovisionIpamByoasnRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIp] != null) {\n        entries[_IIp] = input[_IIp];\n    }\n    if (input[_As] != null) {\n        entries[_As] = input[_As];\n    }\n    return entries;\n};\nconst se_DeprovisionIpamPoolCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    return entries;\n};\nconst se_DeprovisionPublicIpv4PoolCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PIo] != null) {\n        entries[_PIo] = input[_PIo];\n    }\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    return entries;\n};\nconst se_DeregisterImageRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_DAS] != null) {\n        entries[_DAS] = input[_DAS];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeregisterInstanceEventNotificationAttributesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ITA] != null) {\n        const memberEntries = se_DeregisterInstanceTagAttributeRequest(input[_ITA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceTagAttribute.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeregisterInstanceTagAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_IATOI] != null) {\n        entries[_IATOI] = input[_IATOI];\n    }\n    if (input[_ITK] != null) {\n        const memberEntries = se_InstanceTagKeySet(input[_ITK], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceTagKey.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeregisterTransitGatewayMulticastGroupMembersRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDI] != null) {\n        entries[_TGMDI] = input[_TGMDI];\n    }\n    if (input[_GIA] != null) {\n        entries[_GIA] = input[_GIA];\n    }\n    if (input[_NIIe] != null) {\n        const memberEntries = se_TransitGatewayNetworkInterfaceIdList(input[_NIIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DeregisterTransitGatewayMulticastGroupSourcesRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDI] != null) {\n        entries[_TGMDI] = input[_TGMDI];\n    }\n    if (input[_GIA] != null) {\n        entries[_GIA] = input[_GIA];\n    }\n    if (input[_NIIe] != null) {\n        const memberEntries = se_TransitGatewayNetworkInterfaceIdList(input[_NIIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeAccountAttributesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_AN] != null) {\n        const memberEntries = se_AccountAttributeNameStringList(input[_AN], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AttributeName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeAddressesAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIll] != null) {\n        const memberEntries = se_AllocationIds(input[_AIll], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AllocationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeAddressesRequest = (input, context) => {\n    const entries = {};\n    if (input[_PIu] != null) {\n        const memberEntries = se_PublicIpStringList(input[_PIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PublicIp.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AIll] != null) {\n        const memberEntries = se_AllocationIdList(input[_AIll], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AllocationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeAddressTransfersRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIll] != null) {\n        const memberEntries = se_AllocationIdList(input[_AIll], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AllocationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeAggregateIdFormatRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeAvailabilityZonesRequest = (input, context) => {\n    const entries = {};\n    if (input[_ZN] != null) {\n        const memberEntries = se_ZoneNameStringList(input[_ZN], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ZoneName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ZI] != null) {\n        const memberEntries = se_ZoneIdStringList(input[_ZI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ZoneId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AAZ] != null) {\n        entries[_AAZ] = input[_AAZ];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeAwsNetworkPerformanceMetricSubscriptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeBundleTasksRequest = (input, context) => {\n    const entries = {};\n    if (input[_BIun] != null) {\n        const memberEntries = se_BundleIdStringList(input[_BIun], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BundleId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeByoipCidrsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeCapacityBlockExtensionHistoryRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRIa] != null) {\n        const memberEntries = se_CapacityReservationIdSet(input[_CRIa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityReservationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeCapacityBlockExtensionOfferingsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CBEDH] != null) {\n        entries[_CBEDH] = input[_CBEDH];\n    }\n    if (input[_CRI] != null) {\n        entries[_CRI] = input[_CRI];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeCapacityBlockOfferingsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    if (input[_SDR] != null) {\n        entries[_SDR] = __serializeDateTime(input[_SDR]);\n    }\n    if (input[_EDR] != null) {\n        entries[_EDR] = __serializeDateTime(input[_EDR]);\n    }\n    if (input[_CDH] != null) {\n        entries[_CDH] = input[_CDH];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeCapacityReservationBillingRequestsRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRIa] != null) {\n        const memberEntries = se_CapacityReservationIdSet(input[_CRIa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityReservationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ro] != null) {\n        entries[_Ro] = input[_Ro];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeCapacityReservationFleetsRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRFI] != null) {\n        const memberEntries = se_CapacityReservationFleetIdSet(input[_CRFI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityReservationFleetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeCapacityReservationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRIa] != null) {\n        const memberEntries = se_CapacityReservationIdSet(input[_CRIa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityReservationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeCarrierGatewaysRequest = (input, context) => {\n    const entries = {};\n    if (input[_CGIa] != null) {\n        const memberEntries = se_CarrierGatewayIdSet(input[_CGIa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CarrierGatewayId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeClassicLinkInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeClientVpnAuthorizationRulesRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeClientVpnConnectionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeClientVpnEndpointsRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEIl] != null) {\n        const memberEntries = se_ClientVpnEndpointIdList(input[_CVEIl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ClientVpnEndpointId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeClientVpnRoutesRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeClientVpnTargetNetworksRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_AIs] != null) {\n        const memberEntries = se_ValueStringList(input[_AIs], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AssociationIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeCoipPoolsRequest = (input, context) => {\n    const entries = {};\n    if (input[_PIoo] != null) {\n        const memberEntries = se_CoipPoolIdSet(input[_PIoo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PoolId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeConversionTasksRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTIo] != null) {\n        const memberEntries = se_ConversionIdStringList(input[_CTIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ConversionTaskId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeCustomerGatewaysRequest = (input, context) => {\n    const entries = {};\n    if (input[_CGIus] != null) {\n        const memberEntries = se_CustomerGatewayIdStringList(input[_CGIus], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CustomerGatewayId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeDeclarativePoliciesReportsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_RIepo] != null) {\n        const memberEntries = se_ValueStringList(input[_RIepo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReportId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeDhcpOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DOIh] != null) {\n        const memberEntries = se_DhcpOptionsIdStringList(input[_DOIh], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DhcpOptionsId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeEgressOnlyInternetGatewaysRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_EOIGIg] != null) {\n        const memberEntries = se_EgressOnlyInternetGatewayIdList(input[_EOIGIg], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EgressOnlyInternetGatewayId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeElasticGpusRequest = (input, context) => {\n    const entries = {};\n    if (input[_EGI] != null) {\n        const memberEntries = se_ElasticGpuIdSet(input[_EGI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ElasticGpuId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeExportImageTasksRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EITI] != null) {\n        const memberEntries = se_ExportImageTaskIdList(input[_EITI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExportImageTaskId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeExportTasksRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ETIx] != null) {\n        const memberEntries = se_ExportTaskIdStringList(input[_ETIx], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExportTaskId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeFastLaunchImagesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IImag] != null) {\n        const memberEntries = se_FastLaunchImageIdList(input[_IImag], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ImageId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeFastSnapshotRestoresRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeFleetHistoryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ETv] != null) {\n        entries[_ETv] = input[_ETv];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_FIl] != null) {\n        entries[_FIl] = input[_FIl];\n    }\n    if (input[_STt] != null) {\n        entries[_STt] = __serializeDateTime(input[_STt]);\n    }\n    return entries;\n};\nconst se_DescribeFleetInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_FIl] != null) {\n        entries[_FIl] = input[_FIl];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeFleetsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_FI] != null) {\n        const memberEntries = se_FleetIdSet(input[_FI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `FleetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeFlowLogsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fil] != null) {\n        const memberEntries = se_FilterList(input[_Fil], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_FLI] != null) {\n        const memberEntries = se_FlowLogIdList(input[_FLI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `FlowLogId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeFpgaImageAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_FII] != null) {\n        entries[_FII] = input[_FII];\n    }\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    return entries;\n};\nconst se_DescribeFpgaImagesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_FIIp] != null) {\n        const memberEntries = se_FpgaImageIdList(input[_FIIp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `FpgaImageId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ow] != null) {\n        const memberEntries = se_OwnerStringList(input[_Ow], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Owner.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeHostReservationOfferingsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fil] != null) {\n        const memberEntries = se_FilterList(input[_Fil], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MD] != null) {\n        entries[_MD] = input[_MD];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_MDi] != null) {\n        entries[_MDi] = input[_MDi];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_OI] != null) {\n        entries[_OI] = input[_OI];\n    }\n    return entries;\n};\nconst se_DescribeHostReservationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fil] != null) {\n        const memberEntries = se_FilterList(input[_Fil], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_HRIS] != null) {\n        const memberEntries = se_HostReservationIdSet(input[_HRIS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `HostReservationIdSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeHostsRequest = (input, context) => {\n    const entries = {};\n    if (input[_HI] != null) {\n        const memberEntries = se_RequestHostIdList(input[_HI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `HostId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fil] != null) {\n        const memberEntries = se_FilterList(input[_Fil], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeIamInstanceProfileAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIs] != null) {\n        const memberEntries = se_AssociationIdList(input[_AIs], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AssociationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeIdentityIdFormatRequest = (input, context) => {\n    const entries = {};\n    if (input[_Res] != null) {\n        entries[_Res] = input[_Res];\n    }\n    if (input[_PAr] != null) {\n        entries[_PAr] = input[_PAr];\n    }\n    return entries;\n};\nconst se_DescribeIdFormatRequest = (input, context) => {\n    const entries = {};\n    if (input[_Res] != null) {\n        entries[_Res] = input[_Res];\n    }\n    return entries;\n};\nconst se_DescribeImageAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeImagesRequest = (input, context) => {\n    const entries = {};\n    if (input[_EU] != null) {\n        const memberEntries = se_ExecutableByStringList(input[_EU], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExecutableBy.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IImag] != null) {\n        const memberEntries = se_ImageIdStringList(input[_IImag], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ImageId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ow] != null) {\n        const memberEntries = se_OwnerStringList(input[_Ow], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Owner.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ID] != null) {\n        entries[_ID] = input[_ID];\n    }\n    if (input[_IDn] != null) {\n        entries[_IDn] = input[_IDn];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeImportImageTasksRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filters.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ITIm] != null) {\n        const memberEntries = se_ImportTaskIdList(input[_ITIm], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ImportTaskId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeImportSnapshotTasksRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filters.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ITIm] != null) {\n        const memberEntries = se_ImportSnapshotTaskIdList(input[_ITIm], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ImportTaskId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeInstanceAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    return entries;\n};\nconst se_DescribeInstanceConnectEndpointsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ICEIn] != null) {\n        const memberEntries = se_ValueStringList(input[_ICEIn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceConnectEndpointId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeInstanceCreditSpecificationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeInstanceEventNotificationAttributesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeInstanceEventWindowsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IEWIn] != null) {\n        const memberEntries = se_InstanceEventWindowIdSet(input[_IEWIn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceEventWindowId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeInstanceImageMetadataRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeInstanceStatusRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IAI] != null) {\n        entries[_IAI] = input[_IAI];\n    }\n    return entries;\n};\nconst se_DescribeInstanceTopologyGroupNameSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_DescribeInstanceTopologyInstanceIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_DescribeInstanceTopologyRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_IIns] != null) {\n        const memberEntries = se_DescribeInstanceTopologyInstanceIdSet(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_GNr] != null) {\n        const memberEntries = se_DescribeInstanceTopologyGroupNameSet(input[_GNr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `GroupName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeInstanceTypeOfferingsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_LT] != null) {\n        entries[_LT] = input[_LT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeInstanceTypesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ITnst] != null) {\n        const memberEntries = se_RequestInstanceTypeList(input[_ITnst], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeInternetGatewaysRequest = (input, context) => {\n    const entries = {};\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IGIn] != null) {\n        const memberEntries = se_InternetGatewayIdList(input[_IGIn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InternetGatewayId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeIpamByoasnRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeIpamExternalResourceVerificationTokensRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_IERVTIp] != null) {\n        const memberEntries = se_ValueStringList(input[_IERVTIp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpamExternalResourceVerificationTokenId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeIpamPoolsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_IPIp] != null) {\n        const memberEntries = se_ValueStringList(input[_IPIp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpamPoolId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeIpamResourceDiscoveriesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IRDIp] != null) {\n        const memberEntries = se_ValueStringList(input[_IRDIp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpamResourceDiscoveryId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeIpamResourceDiscoveryAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IRDAI] != null) {\n        const memberEntries = se_ValueStringList(input[_IRDAI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpamResourceDiscoveryAssociationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeIpamScopesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_ISIp] != null) {\n        const memberEntries = se_ValueStringList(input[_ISIp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpamScopeId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeIpamsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_IIpa] != null) {\n        const memberEntries = se_ValueStringList(input[_IIpa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpamId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeIpv6PoolsRequest = (input, context) => {\n    const entries = {};\n    if (input[_PIoo] != null) {\n        const memberEntries = se_Ipv6PoolIdList(input[_PIoo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PoolId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeKeyPairsRequest = (input, context) => {\n    const entries = {};\n    if (input[_KNe] != null) {\n        const memberEntries = se_KeyNameStringList(input[_KNe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `KeyName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_KPIe] != null) {\n        const memberEntries = se_KeyPairIdStringList(input[_KPIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `KeyPairId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPK] != null) {\n        entries[_IPK] = input[_IPK];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeLaunchTemplatesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_LTIa] != null) {\n        const memberEntries = se_LaunchTemplateIdStringList(input[_LTIa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LTNa] != null) {\n        const memberEntries = se_LaunchTemplateNameStringList(input[_LTNa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeLaunchTemplateVersionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_LTI] != null) {\n        entries[_LTI] = input[_LTI];\n    }\n    if (input[_LTN] != null) {\n        entries[_LTN] = input[_LTN];\n    }\n    if (input[_Ve] != null) {\n        const memberEntries = se_VersionStringList(input[_Ve], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateVersion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MVi] != null) {\n        entries[_MVi] = input[_MVi];\n    }\n    if (input[_MVa] != null) {\n        entries[_MVa] = input[_MVa];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RAe] != null) {\n        entries[_RAe] = input[_RAe];\n    }\n    return entries;\n};\nconst se_DescribeLocalGatewayRouteTablesRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGRTIo] != null) {\n        const memberEntries = se_LocalGatewayRouteTableIdSet(input[_LGRTIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LocalGatewayRouteTableId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGRTVIGAIo] != null) {\n        const memberEntries = se_LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet(input[_LGRTVIGAIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LocalGatewayRouteTableVirtualInterfaceGroupAssociationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeLocalGatewayRouteTableVpcAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGRTVAIo] != null) {\n        const memberEntries = se_LocalGatewayRouteTableVpcAssociationIdSet(input[_LGRTVAIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LocalGatewayRouteTableVpcAssociationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeLocalGatewaysRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGIo] != null) {\n        const memberEntries = se_LocalGatewayIdSet(input[_LGIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LocalGatewayId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeLocalGatewayVirtualInterfaceGroupsRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGVIGIo] != null) {\n        const memberEntries = se_LocalGatewayVirtualInterfaceGroupIdSet(input[_LGVIGIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LocalGatewayVirtualInterfaceGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeLocalGatewayVirtualInterfacesRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGVIIo] != null) {\n        const memberEntries = se_LocalGatewayVirtualInterfaceIdSet(input[_LGVIIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LocalGatewayVirtualInterfaceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeLockedSnapshotsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_SIna] != null) {\n        const memberEntries = se_SnapshotIdStringList(input[_SIna], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SnapshotId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeMacHostsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_HI] != null) {\n        const memberEntries = se_RequestHostIdList(input[_HI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `HostId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeMacModificationTasksRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MMTI] != null) {\n        const memberEntries = se_MacModificationTaskIdList(input[_MMTI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MacModificationTaskId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeManagedPrefixListsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_PLIr] != null) {\n        const memberEntries = se_ValueStringList(input[_PLIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrefixListId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeMovingAddressesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PIu] != null) {\n        const memberEntries = se_ValueStringList(input[_PIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PublicIp.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeNatGatewaysRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fil] != null) {\n        const memberEntries = se_FilterList(input[_Fil], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NGIa] != null) {\n        const memberEntries = se_NatGatewayIdStringList(input[_NGIa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NatGatewayId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeNetworkAclsRequest = (input, context) => {\n    const entries = {};\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NAIe] != null) {\n        const memberEntries = se_NetworkAclIdStringList(input[_NAIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkAclId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeNetworkInsightsAccessScopeAnalysesRequest = (input, context) => {\n    const entries = {};\n    if (input[_NIASAIe] != null) {\n        const memberEntries = se_NetworkInsightsAccessScopeAnalysisIdList(input[_NIASAIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInsightsAccessScopeAnalysisId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NIASI] != null) {\n        entries[_NIASI] = input[_NIASI];\n    }\n    if (input[_ASTB] != null) {\n        entries[_ASTB] = __serializeDateTime(input[_ASTB]);\n    }\n    if (input[_ASTE] != null) {\n        entries[_ASTE] = __serializeDateTime(input[_ASTE]);\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeNetworkInsightsAccessScopesRequest = (input, context) => {\n    const entries = {};\n    if (input[_NIASIe] != null) {\n        const memberEntries = se_NetworkInsightsAccessScopeIdList(input[_NIASIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInsightsAccessScopeId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeNetworkInsightsAnalysesRequest = (input, context) => {\n    const entries = {};\n    if (input[_NIAIe] != null) {\n        const memberEntries = se_NetworkInsightsAnalysisIdList(input[_NIAIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInsightsAnalysisId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NIPI] != null) {\n        entries[_NIPI] = input[_NIPI];\n    }\n    if (input[_AST] != null) {\n        entries[_AST] = __serializeDateTime(input[_AST]);\n    }\n    if (input[_AET] != null) {\n        entries[_AET] = __serializeDateTime(input[_AET]);\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeNetworkInsightsPathsRequest = (input, context) => {\n    const entries = {};\n    if (input[_NIPIet] != null) {\n        const memberEntries = se_NetworkInsightsPathIdList(input[_NIPIet], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInsightsPathId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeNetworkInterfaceAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    return entries;\n};\nconst se_DescribeNetworkInterfacePermissionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_NIPIetw] != null) {\n        const memberEntries = se_NetworkInterfacePermissionIdList(input[_NIPIetw], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterfacePermissionId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeNetworkInterfacesRequest = (input, context) => {\n    const entries = {};\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NIIe] != null) {\n        const memberEntries = se_NetworkInterfaceIdList(input[_NIIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterfaceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeOutpostLagsRequest = (input, context) => {\n    const entries = {};\n    if (input[_OLIu] != null) {\n        const memberEntries = se_OutpostLagIdSet(input[_OLIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `OutpostLagId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribePlacementGroupsRequest = (input, context) => {\n    const entries = {};\n    if (input[_GIro] != null) {\n        const memberEntries = se_PlacementGroupIdStringList(input[_GIro], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `GroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_GNr] != null) {\n        const memberEntries = se_PlacementGroupStringList(input[_GNr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `GroupName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribePrefixListsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_PLIr] != null) {\n        const memberEntries = se_PrefixListResourceIdStringList(input[_PLIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrefixListId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribePrincipalIdFormatRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Re] != null) {\n        const memberEntries = se_ResourceList(input[_Re], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Resource.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribePublicIpv4PoolsRequest = (input, context) => {\n    const entries = {};\n    if (input[_PIoo] != null) {\n        const memberEntries = se_PublicIpv4PoolIdStringList(input[_PIoo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PoolId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeRegionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_RNe] != null) {\n        const memberEntries = se_RegionNameStringList(input[_RNe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RegionName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ARll] != null) {\n        entries[_ARll] = input[_ARll];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeReplaceRootVolumeTasksRequest = (input, context) => {\n    const entries = {};\n    if (input[_RRVTI] != null) {\n        const memberEntries = se_ReplaceRootVolumeTaskIds(input[_RRVTI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReplaceRootVolumeTaskId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeReservedInstancesListingsRequest = (input, context) => {\n    const entries = {};\n    if (input[_RIIe] != null) {\n        entries[_RIIe] = input[_RIIe];\n    }\n    if (input[_RILI] != null) {\n        entries[_RILI] = input[_RILI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeReservedInstancesModificationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_RIMI] != null) {\n        const memberEntries = se_ReservedInstancesModificationIdStringList(input[_RIMI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReservedInstancesModificationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeReservedInstancesOfferingsRequest = (input, context) => {\n    const entries = {};\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_IM] != null) {\n        entries[_IM] = input[_IM];\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_MD] != null) {\n        entries[_MD] = input[_MD];\n    }\n    if (input[_MIC] != null) {\n        entries[_MIC] = input[_MIC];\n    }\n    if (input[_MDi] != null) {\n        entries[_MDi] = input[_MDi];\n    }\n    if (input[_OC] != null) {\n        entries[_OC] = input[_OC];\n    }\n    if (input[_PDr] != null) {\n        entries[_PDr] = input[_PDr];\n    }\n    if (input[_RIOI] != null) {\n        const memberEntries = se_ReservedInstancesOfferingIdStringList(input[_RIOI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReservedInstancesOfferingId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AZI] != null) {\n        entries[_AZI] = input[_AZI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ITns] != null) {\n        entries[_ITns] = input[_ITns];\n    }\n    if (input[_OT] != null) {\n        entries[_OT] = input[_OT];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeReservedInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_OC] != null) {\n        entries[_OC] = input[_OC];\n    }\n    if (input[_RIIes] != null) {\n        const memberEntries = se_ReservedInstancesIdStringList(input[_RIIes], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReservedInstancesId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_OT] != null) {\n        entries[_OT] = input[_OT];\n    }\n    return entries;\n};\nconst se_DescribeRouteServerEndpointsRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSEIo] != null) {\n        const memberEntries = se_RouteServerEndpointIdsList(input[_RSEIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RouteServerEndpointId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeRouteServerPeersRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSPIo] != null) {\n        const memberEntries = se_RouteServerPeerIdsList(input[_RSPIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RouteServerPeerId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeRouteServersRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSIou] != null) {\n        const memberEntries = se_RouteServerIdsList(input[_RSIou], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RouteServerId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeRouteTablesRequest = (input, context) => {\n    const entries = {};\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RTIo] != null) {\n        const memberEntries = se_RouteTableIdStringList(input[_RTIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RouteTableId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeScheduledInstanceAvailabilityRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_FSSTR] != null) {\n        const memberEntries = se_SlotDateTimeRangeRequest(input[_FSSTR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `FirstSlotStartTimeRange.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_MSDIH] != null) {\n        entries[_MSDIH] = input[_MSDIH];\n    }\n    if (input[_MSDIHi] != null) {\n        entries[_MSDIHi] = input[_MSDIHi];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Rec] != null) {\n        const memberEntries = se_ScheduledInstanceRecurrenceRequest(input[_Rec], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Recurrence.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeScheduledInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_SIIc] != null) {\n        const memberEntries = se_ScheduledInstanceIdRequestSet(input[_SIIc], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ScheduledInstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SSTR] != null) {\n        const memberEntries = se_SlotStartTimeRangeRequest(input[_SSTR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SlotStartTimeRange.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeSecurityGroupReferencesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_GIr] != null) {\n        const memberEntries = se_GroupIds(input[_GIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `GroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeSecurityGroupRulesRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SGRI] != null) {\n        const memberEntries = se_SecurityGroupRuleIdList(input[_SGRI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupRuleId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeSecurityGroupsRequest = (input, context) => {\n    const entries = {};\n    if (input[_GIro] != null) {\n        const memberEntries = se_GroupIdStringList(input[_GIro], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `GroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_GNr] != null) {\n        const memberEntries = se_GroupNameStringList(input[_GNr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `GroupName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeSecurityGroupVpcAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeServiceLinkVirtualInterfacesRequest = (input, context) => {\n    const entries = {};\n    if (input[_SLVII] != null) {\n        const memberEntries = se_ServiceLinkVirtualInterfaceIdSet(input[_SLVII], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ServiceLinkVirtualInterfaceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeSnapshotAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeSnapshotsRequest = (input, context) => {\n    const entries = {};\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_OIw] != null) {\n        const memberEntries = se_OwnerStringList(input[_OIw], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Owner.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RBUI] != null) {\n        const memberEntries = se_RestorableByStringList(input[_RBUI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RestorableBy.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SIna] != null) {\n        const memberEntries = se_SnapshotIdStringList(input[_SIna], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SnapshotId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeSnapshotTierStatusRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeSpotDatafeedSubscriptionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeSpotFleetInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SFRIp] != null) {\n        entries[_SFRIp] = input[_SFRIp];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeSpotFleetRequestHistoryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SFRIp] != null) {\n        entries[_SFRIp] = input[_SFRIp];\n    }\n    if (input[_ETv] != null) {\n        entries[_ETv] = input[_ETv];\n    }\n    if (input[_STt] != null) {\n        entries[_STt] = __serializeDateTime(input[_STt]);\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeSpotFleetRequestsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SFRI] != null) {\n        const memberEntries = se_SpotFleetRequestIdList(input[_SFRI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SpotFleetRequestId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeSpotInstanceRequestsRequest = (input, context) => {\n    const entries = {};\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIRI] != null) {\n        const memberEntries = se_SpotInstanceRequestIdList(input[_SIRI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SpotInstanceRequestId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeSpotPriceHistoryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_STt] != null) {\n        entries[_STt] = __serializeDateTime(input[_STt]);\n    }\n    if (input[_ETn] != null) {\n        entries[_ETn] = __serializeDateTime(input[_ETn]);\n    }\n    if (input[_ITnst] != null) {\n        const memberEntries = se_InstanceTypeList(input[_ITnst], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PDro] != null) {\n        const memberEntries = se_ProductDescriptionList(input[_PDro], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ProductDescription.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeStaleSecurityGroupsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    return entries;\n};\nconst se_DescribeStoreImageTasksRequest = (input, context) => {\n    const entries = {};\n    if (input[_IImag] != null) {\n        const memberEntries = se_ImageIdList(input[_IImag], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ImageId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeSubnetsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SIu] != null) {\n        const memberEntries = se_SubnetIdStringList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeTagsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeTrafficMirrorFilterRulesRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMFRIr] != null) {\n        const memberEntries = se_TrafficMirrorFilterRuleIdList(input[_TMFRIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TrafficMirrorFilterRuleId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TMFI] != null) {\n        entries[_TMFI] = input[_TMFI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeTrafficMirrorFiltersRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMFIr] != null) {\n        const memberEntries = se_TrafficMirrorFilterIdList(input[_TMFIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TrafficMirrorFilterId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeTrafficMirrorSessionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMSIr] != null) {\n        const memberEntries = se_TrafficMirrorSessionIdList(input[_TMSIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TrafficMirrorSessionId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeTrafficMirrorTargetsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMTIr] != null) {\n        const memberEntries = se_TrafficMirrorTargetIdList(input[_TMTIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TrafficMirrorTargetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeTransitGatewayAttachmentsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAIr] != null) {\n        const memberEntries = se_TransitGatewayAttachmentIdStringList(input[_TGAIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TransitGatewayAttachmentIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeTransitGatewayConnectPeersRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGCPIr] != null) {\n        const memberEntries = se_TransitGatewayConnectPeerIdStringList(input[_TGCPIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TransitGatewayConnectPeerIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeTransitGatewayConnectsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAIr] != null) {\n        const memberEntries = se_TransitGatewayAttachmentIdStringList(input[_TGAIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TransitGatewayAttachmentIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeTransitGatewayMulticastDomainsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDIr] != null) {\n        const memberEntries = se_TransitGatewayMulticastDomainIdStringList(input[_TGMDIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TransitGatewayMulticastDomainIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeTransitGatewayPeeringAttachmentsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAIr] != null) {\n        const memberEntries = se_TransitGatewayAttachmentIdStringList(input[_TGAIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TransitGatewayAttachmentIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeTransitGatewayPolicyTablesRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGPTIr] != null) {\n        const memberEntries = se_TransitGatewayPolicyTableIdStringList(input[_TGPTIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TransitGatewayPolicyTableIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeTransitGatewayRouteTableAnnouncementsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTAIr] != null) {\n        const memberEntries = se_TransitGatewayRouteTableAnnouncementIdStringList(input[_TGRTAIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TransitGatewayRouteTableAnnouncementIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeTransitGatewayRouteTablesRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTIr] != null) {\n        const memberEntries = se_TransitGatewayRouteTableIdStringList(input[_TGRTIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TransitGatewayRouteTableIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeTransitGatewaysRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGIr] != null) {\n        const memberEntries = se_TransitGatewayIdStringList(input[_TGIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TransitGatewayIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeTransitGatewayVpcAttachmentsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAIr] != null) {\n        const memberEntries = se_TransitGatewayAttachmentIdStringList(input[_TGAIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TransitGatewayAttachmentIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeTrunkInterfaceAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIs] != null) {\n        const memberEntries = se_TrunkInterfaceAssociationIdList(input[_AIs], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AssociationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeVerifiedAccessEndpointsRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAEIe] != null) {\n        const memberEntries = se_VerifiedAccessEndpointIdList(input[_VAEIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VerifiedAccessEndpointId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VAII] != null) {\n        entries[_VAII] = input[_VAII];\n    }\n    if (input[_VAGI] != null) {\n        entries[_VAGI] = input[_VAGI];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeVerifiedAccessGroupsRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAGIe] != null) {\n        const memberEntries = se_VerifiedAccessGroupIdList(input[_VAGIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VerifiedAccessGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VAII] != null) {\n        entries[_VAII] = input[_VAII];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeVerifiedAccessInstanceLoggingConfigurationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAIIe] != null) {\n        const memberEntries = se_VerifiedAccessInstanceIdList(input[_VAIIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VerifiedAccessInstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeVerifiedAccessInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAIIe] != null) {\n        const memberEntries = se_VerifiedAccessInstanceIdList(input[_VAIIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VerifiedAccessInstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeVerifiedAccessTrustProvidersRequest = (input, context) => {\n    const entries = {};\n    if (input[_VATPIe] != null) {\n        const memberEntries = se_VerifiedAccessTrustProviderIdList(input[_VATPIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VerifiedAccessTrustProviderId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeVolumeAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_VIo] != null) {\n        entries[_VIo] = input[_VIo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeVolumesModificationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VIol] != null) {\n        const memberEntries = se_VolumeIdStringList(input[_VIol], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VolumeId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeVolumesRequest = (input, context) => {\n    const entries = {};\n    if (input[_VIol] != null) {\n        const memberEntries = se_VolumeIdStringList(input[_VIol], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VolumeId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeVolumeStatusRequest = (input, context) => {\n    const entries = {};\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_VIol] != null) {\n        const memberEntries = se_VolumeIdStringList(input[_VIol], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VolumeId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeVpcAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeVpcBlockPublicAccessExclusionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EIxcl] != null) {\n        const memberEntries = se_VpcBlockPublicAccessExclusionIdList(input[_EIxcl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExclusionId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_DescribeVpcBlockPublicAccessOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeVpcClassicLinkDnsSupportRequest = (input, context) => {\n    const entries = {};\n    if (input[_VIp] != null) {\n        const memberEntries = se_VpcClassicLinkIdList(input[_VIp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VpcIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeVpcClassicLinkRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VIp] != null) {\n        const memberEntries = se_VpcClassicLinkIdList(input[_VIp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VpcId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeVpcEndpointAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VEI] != null) {\n        const memberEntries = se_VpcEndpointIdList(input[_VEI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VpcEndpointId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeVpcEndpointConnectionNotificationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CNIon] != null) {\n        entries[_CNIon] = input[_CNIon];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeVpcEndpointConnectionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeVpcEndpointServiceConfigurationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIer] != null) {\n        const memberEntries = se_VpcEndpointServiceIdList(input[_SIer], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ServiceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeVpcEndpointServicePermissionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIe] != null) {\n        entries[_SIe] = input[_SIe];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeVpcEndpointServicesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SNer] != null) {\n        const memberEntries = se_ValueStringList(input[_SNer], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ServiceName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_SRer] != null) {\n        const memberEntries = se_ValueStringList(input[_SRer], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ServiceRegion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeVpcEndpointsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VEI] != null) {\n        const memberEntries = se_VpcEndpointIdList(input[_VEI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VpcEndpointId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeVpcPeeringConnectionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VPCIp] != null) {\n        const memberEntries = se_VpcPeeringConnectionIdList(input[_VPCIp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VpcPeeringConnectionId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeVpcsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VIp] != null) {\n        const memberEntries = se_VpcIdStringList(input[_VIp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VpcId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeVpnConnectionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VCIp] != null) {\n        const memberEntries = se_VpnConnectionIdStringList(input[_VCIp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VpnConnectionId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DescribeVpnGatewaysRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VGIp] != null) {\n        const memberEntries = se_VpnGatewayIdStringList(input[_VGIp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VpnGatewayId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DestinationOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_FF] != null) {\n        entries[_FF] = input[_FF];\n    }\n    if (input[_HCP] != null) {\n        entries[_HCP] = input[_HCP];\n    }\n    if (input[_PHP] != null) {\n        entries[_PHP] = input[_PHP];\n    }\n    return entries;\n};\nconst se_DetachClassicLinkVpcRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    return entries;\n};\nconst se_DetachInternetGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IGI] != null) {\n        entries[_IGI] = input[_IGI];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    return entries;\n};\nconst se_DetachNetworkInterfaceRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_AIt] != null) {\n        entries[_AIt] = input[_AIt];\n    }\n    if (input[_F] != null) {\n        entries[_F] = input[_F];\n    }\n    return entries;\n};\nconst se_DetachVerifiedAccessTrustProviderRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAII] != null) {\n        entries[_VAII] = input[_VAII];\n    }\n    if (input[_VATPI] != null) {\n        entries[_VATPI] = input[_VATPI];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DetachVolumeRequest = (input, context) => {\n    const entries = {};\n    if (input[_Dev] != null) {\n        entries[_Dev] = input[_Dev];\n    }\n    if (input[_F] != null) {\n        entries[_F] = input[_F];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_VIo] != null) {\n        entries[_VIo] = input[_VIo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DetachVpnGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_VGI] != null) {\n        entries[_VGI] = input[_VGI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DhcpOptionsIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`DhcpOptionsId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_DirectoryServiceAuthenticationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DIir] != null) {\n        entries[_DIir] = input[_DIir];\n    }\n    return entries;\n};\nconst se_DisableAddressTransferRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIl] != null) {\n        entries[_AIl] = input[_AIl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableAllowedImagesSettingsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableAwsNetworkPerformanceMetricSubscriptionRequest = (input, context) => {\n    const entries = {};\n    if (input[_S] != null) {\n        entries[_S] = input[_S];\n    }\n    if (input[_D] != null) {\n        entries[_D] = input[_D];\n    }\n    if (input[_Met] != null) {\n        entries[_Met] = input[_Met];\n    }\n    if (input[_Sta] != null) {\n        entries[_Sta] = input[_Sta];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableEbsEncryptionByDefaultRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableFastLaunchRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_F] != null) {\n        entries[_F] = input[_F];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableFastSnapshotRestoresRequest = (input, context) => {\n    const entries = {};\n    if (input[_AZv] != null) {\n        const memberEntries = se_AvailabilityZoneStringList(input[_AZv], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AvailabilityZone.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SSIo] != null) {\n        const memberEntries = se_SnapshotIdStringList(input[_SSIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SourceSnapshotId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableImageBlockPublicAccessRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableImageDeprecationRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableImageDeregistrationProtectionRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableImageRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableIpamOrganizationAdminAccountRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_DAAI] != null) {\n        entries[_DAAI] = input[_DAAI];\n    }\n    return entries;\n};\nconst se_DisableRouteServerPropagationRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSIo] != null) {\n        entries[_RSIo] = input[_RSIo];\n    }\n    if (input[_RTI] != null) {\n        entries[_RTI] = input[_RTI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableSerialConsoleAccessRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableSnapshotBlockPublicAccessRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableTransitGatewayRouteTablePropagationRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_TGRTAI] != null) {\n        entries[_TGRTAI] = input[_TGRTAI];\n    }\n    return entries;\n};\nconst se_DisableVgwRoutePropagationRequest = (input, context) => {\n    const entries = {};\n    if (input[_GI] != null) {\n        entries[_GI] = input[_GI];\n    }\n    if (input[_RTI] != null) {\n        entries[_RTI] = input[_RTI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisableVpcClassicLinkDnsSupportRequest = (input, context) => {\n    const entries = {};\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    return entries;\n};\nconst se_DisableVpcClassicLinkRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    return entries;\n};\nconst se_DisassociateAddressRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIss] != null) {\n        entries[_AIss] = input[_AIss];\n    }\n    if (input[_PI] != null) {\n        entries[_PI] = input[_PI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisassociateCapacityReservationBillingOwnerRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CRI] != null) {\n        entries[_CRI] = input[_CRI];\n    }\n    if (input[_URBOI] != null) {\n        entries[_URBOI] = input[_URBOI];\n    }\n    return entries;\n};\nconst se_DisassociateClientVpnTargetNetworkRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_AIss] != null) {\n        entries[_AIss] = input[_AIss];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisassociateEnclaveCertificateIamRoleRequest = (input, context) => {\n    const entries = {};\n    if (input[_CA] != null) {\n        entries[_CA] = input[_CA];\n    }\n    if (input[_RAo] != null) {\n        entries[_RAo] = input[_RAo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisassociateIamInstanceProfileRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIss] != null) {\n        entries[_AIss] = input[_AIss];\n    }\n    return entries;\n};\nconst se_DisassociateInstanceEventWindowRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IEWI] != null) {\n        entries[_IEWI] = input[_IEWI];\n    }\n    if (input[_AT] != null) {\n        const memberEntries = se_InstanceEventWindowDisassociationRequest(input[_AT], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AssociationTarget.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DisassociateIpamByoasnRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_As] != null) {\n        entries[_As] = input[_As];\n    }\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    return entries;\n};\nconst se_DisassociateIpamResourceDiscoveryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IRDAIp] != null) {\n        entries[_IRDAIp] = input[_IRDAIp];\n    }\n    return entries;\n};\nconst se_DisassociateNatGatewayAddressRequest = (input, context) => {\n    const entries = {};\n    if (input[_NGI] != null) {\n        entries[_NGI] = input[_NGI];\n    }\n    if (input[_AIs] != null) {\n        const memberEntries = se_EipAssociationIdList(input[_AIs], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AssociationId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MDDS] != null) {\n        entries[_MDDS] = input[_MDDS];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisassociateRouteServerRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSIo] != null) {\n        entries[_RSIo] = input[_RSIo];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisassociateRouteTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_AIss] != null) {\n        entries[_AIss] = input[_AIss];\n    }\n    return entries;\n};\nconst se_DisassociateSecurityGroupVpcRequest = (input, context) => {\n    const entries = {};\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisassociateSubnetCidrBlockRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIss] != null) {\n        entries[_AIss] = input[_AIss];\n    }\n    return entries;\n};\nconst se_DisassociateTransitGatewayMulticastDomainRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDI] != null) {\n        entries[_TGMDI] = input[_TGMDI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_SIu] != null) {\n        const memberEntries = se_TransitGatewaySubnetIdList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisassociateTransitGatewayPolicyTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGPTI] != null) {\n        entries[_TGPTI] = input[_TGPTI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisassociateTransitGatewayRouteTableRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisassociateTrunkInterfaceRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIss] != null) {\n        entries[_AIss] = input[_AIss];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_DisassociateVpcCidrBlockRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIss] != null) {\n        entries[_AIss] = input[_AIss];\n    }\n    return entries;\n};\nconst se_DiskImage = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_Im] != null) {\n        const memberEntries = se_DiskImageDetail(input[_Im], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Image.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Vo] != null) {\n        const memberEntries = se_VolumeDetail(input[_Vo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Volume.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DiskImageDetail = (input, context) => {\n    const entries = {};\n    if (input[_Fo] != null) {\n        entries[_Fo] = input[_Fo];\n    }\n    if (input[_By] != null) {\n        entries[_By] = input[_By];\n    }\n    if (input[_IMU] != null) {\n        entries[_IMU] = input[_IMU];\n    }\n    return entries;\n};\nconst se_DiskImageList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_DiskImage(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_DnsOptionsSpecification = (input, context) => {\n    const entries = {};\n    if (input[_DRIT] != null) {\n        entries[_DRIT] = input[_DRIT];\n    }\n    if (input[_PDOFIRE] != null) {\n        entries[_PDOFIRE] = input[_PDOFIRE];\n    }\n    return entries;\n};\nconst se_DnsServersOptionsModifyStructure = (input, context) => {\n    const entries = {};\n    if (input[_CDSu] != null) {\n        const memberEntries = se_ValueStringList(input[_CDSu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CustomDnsServers.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    return entries;\n};\nconst se_EbsBlockDevice = (input, context) => {\n    const entries = {};\n    if (input[_DOT] != null) {\n        entries[_DOT] = input[_DOT];\n    }\n    if (input[_Io] != null) {\n        entries[_Io] = input[_Io];\n    }\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_VS] != null) {\n        entries[_VS] = input[_VS];\n    }\n    if (input[_VT] != null) {\n        entries[_VT] = input[_VT];\n    }\n    if (input[_KKI] != null) {\n        entries[_KKI] = input[_KKI];\n    }\n    if (input[_Th] != null) {\n        entries[_Th] = input[_Th];\n    }\n    if (input[_OA] != null) {\n        entries[_OA] = input[_OA];\n    }\n    if (input[_Enc] != null) {\n        entries[_Enc] = input[_Enc];\n    }\n    if (input[_VIR] != null) {\n        entries[_VIR] = input[_VIR];\n    }\n    return entries;\n};\nconst se_EbsInstanceBlockDeviceSpecification = (input, context) => {\n    const entries = {};\n    if (input[_VIo] != null) {\n        entries[_VIo] = input[_VIo];\n    }\n    if (input[_DOT] != null) {\n        entries[_DOT] = input[_DOT];\n    }\n    return entries;\n};\nconst se_EgressOnlyInternetGatewayIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_EipAssociationIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ElasticGpuIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ElasticGpuSpecification = (input, context) => {\n    const entries = {};\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    return entries;\n};\nconst se_ElasticGpuSpecificationList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ElasticGpuSpecification(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`ElasticGpuSpecification.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ElasticGpuSpecifications = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ElasticGpuSpecification(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ElasticInferenceAccelerator = (input, context) => {\n    const entries = {};\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    if (input[_Cou] != null) {\n        entries[_Cou] = input[_Cou];\n    }\n    return entries;\n};\nconst se_ElasticInferenceAccelerators = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ElasticInferenceAccelerator(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_EnableAddressTransferRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIl] != null) {\n        entries[_AIl] = input[_AIl];\n    }\n    if (input[_TAI] != null) {\n        entries[_TAI] = input[_TAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableAllowedImagesSettingsRequest = (input, context) => {\n    const entries = {};\n    if (input[_AISS] != null) {\n        entries[_AISS] = input[_AISS];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableAwsNetworkPerformanceMetricSubscriptionRequest = (input, context) => {\n    const entries = {};\n    if (input[_S] != null) {\n        entries[_S] = input[_S];\n    }\n    if (input[_D] != null) {\n        entries[_D] = input[_D];\n    }\n    if (input[_Met] != null) {\n        entries[_Met] = input[_Met];\n    }\n    if (input[_Sta] != null) {\n        entries[_Sta] = input[_Sta];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableEbsEncryptionByDefaultRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableFastLaunchRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_RT] != null) {\n        entries[_RT] = input[_RT];\n    }\n    if (input[_SCn] != null) {\n        const memberEntries = se_FastLaunchSnapshotConfigurationRequest(input[_SCn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SnapshotConfiguration.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LTa] != null) {\n        const memberEntries = se_FastLaunchLaunchTemplateSpecificationRequest(input[_LTa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplate.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MPL] != null) {\n        entries[_MPL] = input[_MPL];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableFastSnapshotRestoresRequest = (input, context) => {\n    const entries = {};\n    if (input[_AZv] != null) {\n        const memberEntries = se_AvailabilityZoneStringList(input[_AZv], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AvailabilityZone.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SSIo] != null) {\n        const memberEntries = se_SnapshotIdStringList(input[_SSIo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SourceSnapshotId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableImageBlockPublicAccessRequest = (input, context) => {\n    const entries = {};\n    if (input[_IBPAS] != null) {\n        entries[_IBPAS] = input[_IBPAS];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableImageDeprecationRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_DAe] != null) {\n        entries[_DAe] = __serializeDateTime(input[_DAe]);\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableImageDeregistrationProtectionRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_WC] != null) {\n        entries[_WC] = input[_WC];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableImageRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableIpamOrganizationAdminAccountRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_DAAI] != null) {\n        entries[_DAAI] = input[_DAAI];\n    }\n    return entries;\n};\nconst se_EnableReachabilityAnalyzerOrganizationSharingRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableRouteServerPropagationRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSIo] != null) {\n        entries[_RSIo] = input[_RSIo];\n    }\n    if (input[_RTI] != null) {\n        entries[_RTI] = input[_RTI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableSerialConsoleAccessRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableSnapshotBlockPublicAccessRequest = (input, context) => {\n    const entries = {};\n    if (input[_Stat] != null) {\n        entries[_Stat] = input[_Stat];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableTransitGatewayRouteTablePropagationRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_TGRTAI] != null) {\n        entries[_TGRTAI] = input[_TGRTAI];\n    }\n    return entries;\n};\nconst se_EnableVgwRoutePropagationRequest = (input, context) => {\n    const entries = {};\n    if (input[_GI] != null) {\n        entries[_GI] = input[_GI];\n    }\n    if (input[_RTI] != null) {\n        entries[_RTI] = input[_RTI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_EnableVolumeIORequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VIo] != null) {\n        entries[_VIo] = input[_VIo];\n    }\n    return entries;\n};\nconst se_EnableVpcClassicLinkDnsSupportRequest = (input, context) => {\n    const entries = {};\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    return entries;\n};\nconst se_EnableVpcClassicLinkRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    return entries;\n};\nconst se_EnaSrdSpecification = (input, context) => {\n    const entries = {};\n    if (input[_ESE] != null) {\n        entries[_ESE] = input[_ESE];\n    }\n    if (input[_ESUS] != null) {\n        const memberEntries = se_EnaSrdUdpSpecification(input[_ESUS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnaSrdUdpSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_EnaSrdSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_ESE] != null) {\n        entries[_ESE] = input[_ESE];\n    }\n    if (input[_ESUS] != null) {\n        const memberEntries = se_EnaSrdUdpSpecificationRequest(input[_ESUS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnaSrdUdpSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_EnaSrdUdpSpecification = (input, context) => {\n    const entries = {};\n    if (input[_ESUE] != null) {\n        entries[_ESUE] = input[_ESUE];\n    }\n    return entries;\n};\nconst se_EnaSrdUdpSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_ESUE] != null) {\n        entries[_ESUE] = input[_ESUE];\n    }\n    return entries;\n};\nconst se_EnclaveOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    return entries;\n};\nconst se_ExcludedInstanceTypeSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ExecutableByStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ExecutableBy.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ExportClientVpnClientCertificateRevocationListRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ExportClientVpnClientConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ExportImageRequest = (input, context) => {\n    const entries = {};\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DIFi] != null) {\n        entries[_DIFi] = input[_DIFi];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_SEL] != null) {\n        const memberEntries = se_ExportTaskS3LocationRequest(input[_SEL], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `S3ExportLocation.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RNo] != null) {\n        entries[_RNo] = input[_RNo];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ExportImageTaskIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ExportImageTaskId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ExportTaskIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ExportTaskId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ExportTaskS3LocationRequest = (input, context) => {\n    const entries = {};\n    if (input[_SB] != null) {\n        entries[_SB] = input[_SB];\n    }\n    if (input[_SP] != null) {\n        entries[_SP] = input[_SP];\n    }\n    return entries;\n};\nconst se_ExportToS3TaskSpecification = (input, context) => {\n    const entries = {};\n    if (input[_DIFi] != null) {\n        entries[_DIFi] = input[_DIFi];\n    }\n    if (input[_CFo] != null) {\n        entries[_CFo] = input[_CFo];\n    }\n    if (input[_SB] != null) {\n        entries[_SB] = input[_SB];\n    }\n    if (input[_SP] != null) {\n        entries[_SP] = input[_SP];\n    }\n    return entries;\n};\nconst se_ExportTransitGatewayRoutesRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SB] != null) {\n        entries[_SB] = input[_SB];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ExportVerifiedAccessInstanceClientConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAII] != null) {\n        entries[_VAII] = input[_VAII];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_FastLaunchImageIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ImageId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_FastLaunchLaunchTemplateSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_LTI] != null) {\n        entries[_LTI] = input[_LTI];\n    }\n    if (input[_LTN] != null) {\n        entries[_LTN] = input[_LTN];\n    }\n    if (input[_V] != null) {\n        entries[_V] = input[_V];\n    }\n    return entries;\n};\nconst se_FastLaunchSnapshotConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_TRC] != null) {\n        entries[_TRC] = input[_TRC];\n    }\n    return entries;\n};\nconst se_FederatedAuthenticationRequest = (input, context) => {\n    const entries = {};\n    if (input[_SAMLPA] != null) {\n        entries[_SAMLPA] = input[_SAMLPA];\n    }\n    if (input[_SSSAMLPA] != null) {\n        entries[_SSSAMLPA] = input[_SSSAMLPA];\n    }\n    return entries;\n};\nconst se_Filter = (input, context) => {\n    const entries = {};\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_Val] != null) {\n        const memberEntries = se_ValueStringList(input[_Val], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Value.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_FilterList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Filter(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Filter.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_FleetBlockDeviceMappingRequest = (input, context) => {\n    const entries = {};\n    if (input[_DN] != null) {\n        entries[_DN] = input[_DN];\n    }\n    if (input[_VN] != null) {\n        entries[_VN] = input[_VN];\n    }\n    if (input[_E] != null) {\n        const memberEntries = se_FleetEbsBlockDeviceRequest(input[_E], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ebs.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ND] != null) {\n        entries[_ND] = input[_ND];\n    }\n    return entries;\n};\nconst se_FleetBlockDeviceMappingRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_FleetBlockDeviceMappingRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`BlockDeviceMapping.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_FleetEbsBlockDeviceRequest = (input, context) => {\n    const entries = {};\n    if (input[_Enc] != null) {\n        entries[_Enc] = input[_Enc];\n    }\n    if (input[_DOT] != null) {\n        entries[_DOT] = input[_DOT];\n    }\n    if (input[_Io] != null) {\n        entries[_Io] = input[_Io];\n    }\n    if (input[_Th] != null) {\n        entries[_Th] = input[_Th];\n    }\n    if (input[_KKI] != null) {\n        entries[_KKI] = input[_KKI];\n    }\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_VS] != null) {\n        entries[_VS] = input[_VS];\n    }\n    if (input[_VT] != null) {\n        entries[_VT] = input[_VT];\n    }\n    return entries;\n};\nconst se_FleetIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_FleetLaunchTemplateConfigListRequest = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_FleetLaunchTemplateConfigRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_FleetLaunchTemplateConfigRequest = (input, context) => {\n    const entries = {};\n    if (input[_LTS] != null) {\n        const memberEntries = se_FleetLaunchTemplateSpecificationRequest(input[_LTS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ov] != null) {\n        const memberEntries = se_FleetLaunchTemplateOverridesListRequest(input[_Ov], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Overrides.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_FleetLaunchTemplateOverridesListRequest = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_FleetLaunchTemplateOverridesRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_FleetLaunchTemplateOverridesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_MPa] != null) {\n        entries[_MPa] = input[_MPa];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_WCe] != null) {\n        entries[_WCe] = __serializeFloat(input[_WCe]);\n    }\n    if (input[_Pri] != null) {\n        entries[_Pri] = __serializeFloat(input[_Pri]);\n    }\n    if (input[_Pl] != null) {\n        const memberEntries = se_Placement(input[_Pl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Placement.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_BDM] != null) {\n        const memberEntries = se_FleetBlockDeviceMappingRequestList(input[_BDM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IR] != null) {\n        const memberEntries = se_InstanceRequirementsRequest(input[_IR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceRequirements.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    return entries;\n};\nconst se_FleetLaunchTemplateSpecification = (input, context) => {\n    const entries = {};\n    if (input[_LTI] != null) {\n        entries[_LTI] = input[_LTI];\n    }\n    if (input[_LTN] != null) {\n        entries[_LTN] = input[_LTN];\n    }\n    if (input[_V] != null) {\n        entries[_V] = input[_V];\n    }\n    return entries;\n};\nconst se_FleetLaunchTemplateSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_LTI] != null) {\n        entries[_LTI] = input[_LTI];\n    }\n    if (input[_LTN] != null) {\n        entries[_LTN] = input[_LTN];\n    }\n    if (input[_V] != null) {\n        entries[_V] = input[_V];\n    }\n    return entries;\n};\nconst se_FleetSpotCapacityRebalanceRequest = (input, context) => {\n    const entries = {};\n    if (input[_RS] != null) {\n        entries[_RS] = input[_RS];\n    }\n    if (input[_TDe] != null) {\n        entries[_TDe] = input[_TDe];\n    }\n    return entries;\n};\nconst se_FleetSpotMaintenanceStrategiesRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRap] != null) {\n        const memberEntries = se_FleetSpotCapacityRebalanceRequest(input[_CRap], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityRebalance.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_FlowLogIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_FlowLogResourceIds = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_FpgaImageIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_GetActiveVpnTunnelStatusRequest = (input, context) => {\n    const entries = {};\n    if (input[_VCI] != null) {\n        entries[_VCI] = input[_VCI];\n    }\n    if (input[_VTOIA] != null) {\n        entries[_VTOIA] = input[_VTOIA];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetAllowedImagesSettingsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetAssociatedEnclaveCertificateIamRolesRequest = (input, context) => {\n    const entries = {};\n    if (input[_CA] != null) {\n        entries[_CA] = input[_CA];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetAssociatedIpv6PoolCidrsRequest = (input, context) => {\n    const entries = {};\n    if (input[_PIo] != null) {\n        entries[_PIo] = input[_PIo];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetAwsNetworkPerformanceDataRequest = (input, context) => {\n    const entries = {};\n    if (input[_DQ] != null) {\n        const memberEntries = se_DataQueries(input[_DQ], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DataQuery.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_STt] != null) {\n        entries[_STt] = __serializeDateTime(input[_STt]);\n    }\n    if (input[_ETn] != null) {\n        entries[_ETn] = __serializeDateTime(input[_ETn]);\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetCapacityReservationUsageRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRI] != null) {\n        entries[_CRI] = input[_CRI];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetCoipPoolUsageRequest = (input, context) => {\n    const entries = {};\n    if (input[_PIo] != null) {\n        entries[_PIo] = input[_PIo];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetConsoleOutputRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_La] != null) {\n        entries[_La] = input[_La];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetConsoleScreenshotRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_WU] != null) {\n        entries[_WU] = input[_WU];\n    }\n    return entries;\n};\nconst se_GetDeclarativePoliciesReportSummaryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RIep] != null) {\n        entries[_RIep] = input[_RIep];\n    }\n    return entries;\n};\nconst se_GetDefaultCreditSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IF] != null) {\n        entries[_IF] = input[_IF];\n    }\n    return entries;\n};\nconst se_GetEbsDefaultKmsKeyIdRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetEbsEncryptionByDefaultRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetFlowLogsIntegrationTemplateRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_FLIl] != null) {\n        entries[_FLIl] = input[_FLIl];\n    }\n    if (input[_CDSDA] != null) {\n        entries[_CDSDA] = input[_CDSDA];\n    }\n    if (input[_ISnt] != null) {\n        const memberEntries = se_IntegrateServices(input[_ISnt], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IntegrateService.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_GetGroupsForCapacityReservationRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRI] != null) {\n        entries[_CRI] = input[_CRI];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetHostReservationPurchasePreviewRequest = (input, context) => {\n    const entries = {};\n    if (input[_HIS] != null) {\n        const memberEntries = se_RequestHostIdSet(input[_HIS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `HostIdSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_OI] != null) {\n        entries[_OI] = input[_OI];\n    }\n    return entries;\n};\nconst se_GetImageBlockPublicAccessStateRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetInstanceMetadataDefaultsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetInstanceTpmEkPubRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_KT] != null) {\n        entries[_KT] = input[_KT];\n    }\n    if (input[_KF] != null) {\n        entries[_KF] = input[_KF];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetInstanceTypesFromInstanceRequirementsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ATr] != null) {\n        const memberEntries = se_ArchitectureTypeSet(input[_ATr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ArchitectureType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VTi] != null) {\n        const memberEntries = se_VirtualizationTypeSet(input[_VTi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VirtualizationType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IR] != null) {\n        const memberEntries = se_InstanceRequirementsRequest(input[_IR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceRequirements.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_GetInstanceUefiDataRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetIpamAddressHistoryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_ISI] != null) {\n        entries[_ISI] = input[_ISI];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_STt] != null) {\n        entries[_STt] = __serializeDateTime(input[_STt]);\n    }\n    if (input[_ETn] != null) {\n        entries[_ETn] = __serializeDateTime(input[_ETn]);\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_GetIpamDiscoveredAccountsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IRDI] != null) {\n        entries[_IRDI] = input[_IRDI];\n    }\n    if (input[_DRi] != null) {\n        entries[_DRi] = input[_DRi];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_GetIpamDiscoveredPublicAddressesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IRDI] != null) {\n        entries[_IRDI] = input[_IRDI];\n    }\n    if (input[_ARd] != null) {\n        entries[_ARd] = input[_ARd];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_GetIpamDiscoveredResourceCidrsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IRDI] != null) {\n        entries[_IRDI] = input[_IRDI];\n    }\n    if (input[_RRe] != null) {\n        entries[_RRe] = input[_RRe];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_GetIpamPoolAllocationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_IPAI] != null) {\n        entries[_IPAI] = input[_IPAI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_GetIpamPoolCidrsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_GetIpamResourceCidrsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_ISI] != null) {\n        entries[_ISI] = input[_ISI];\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_RIeso] != null) {\n        entries[_RIeso] = input[_RIeso];\n    }\n    if (input[_RT] != null) {\n        entries[_RT] = input[_RT];\n    }\n    if (input[_RTes] != null) {\n        const memberEntries = se_RequestIpamResourceTag(input[_RTes], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ResourceTag.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ROe] != null) {\n        entries[_ROe] = input[_ROe];\n    }\n    return entries;\n};\nconst se_GetLaunchTemplateDataRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    return entries;\n};\nconst se_GetManagedPrefixListAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PLI] != null) {\n        entries[_PLI] = input[_PLI];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_GetManagedPrefixListEntriesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PLI] != null) {\n        entries[_PLI] = input[_PLI];\n    }\n    if (input[_TV] != null) {\n        entries[_TV] = input[_TV];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_GetNetworkInsightsAccessScopeAnalysisFindingsRequest = (input, context) => {\n    const entries = {};\n    if (input[_NIASAI] != null) {\n        entries[_NIASAI] = input[_NIASAI];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetNetworkInsightsAccessScopeContentRequest = (input, context) => {\n    const entries = {};\n    if (input[_NIASI] != null) {\n        entries[_NIASI] = input[_NIASI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetPasswordDataRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetReservedInstancesExchangeQuoteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RII] != null) {\n        const memberEntries = se_ReservedInstanceIdSet(input[_RII], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReservedInstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TC] != null) {\n        const memberEntries = se_TargetConfigurationRequestSet(input[_TC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TargetConfiguration.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_GetRouteServerAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSIo] != null) {\n        entries[_RSIo] = input[_RSIo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetRouteServerPropagationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSIo] != null) {\n        entries[_RSIo] = input[_RSIo];\n    }\n    if (input[_RTI] != null) {\n        entries[_RTI] = input[_RTI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetRouteServerRoutingDatabaseRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSIo] != null) {\n        entries[_RSIo] = input[_RSIo];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_GetSecurityGroupsForVpcRequest = (input, context) => {\n    const entries = {};\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetSerialConsoleAccessStatusRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetSnapshotBlockPublicAccessStateRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetSpotPlacementScoresRequest = (input, context) => {\n    const entries = {};\n    if (input[_ITnst] != null) {\n        const memberEntries = se_InstanceTypes(input[_ITnst], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TCa] != null) {\n        entries[_TCa] = input[_TCa];\n    }\n    if (input[_TCUT] != null) {\n        entries[_TCUT] = input[_TCUT];\n    }\n    if (input[_SAZ] != null) {\n        entries[_SAZ] = input[_SAZ];\n    }\n    if (input[_RNe] != null) {\n        const memberEntries = se_RegionNames(input[_RNe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RegionName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IRWM] != null) {\n        const memberEntries = se_InstanceRequirementsWithMetadataRequest(input[_IRWM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceRequirementsWithMetadata.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_GetSubnetCidrReservationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    return entries;\n};\nconst se_GetTransitGatewayAttachmentPropagationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetTransitGatewayMulticastDomainAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDI] != null) {\n        entries[_TGMDI] = input[_TGMDI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetTransitGatewayPolicyTableAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGPTI] != null) {\n        entries[_TGPTI] = input[_TGPTI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetTransitGatewayPolicyTableEntriesRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGPTI] != null) {\n        entries[_TGPTI] = input[_TGPTI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetTransitGatewayPrefixListReferencesRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetTransitGatewayRouteTableAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetTransitGatewayRouteTablePropagationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetVerifiedAccessEndpointPolicyRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAEI] != null) {\n        entries[_VAEI] = input[_VAEI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetVerifiedAccessEndpointTargetsRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAEI] != null) {\n        entries[_VAEI] = input[_VAEI];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetVerifiedAccessGroupPolicyRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAGI] != null) {\n        entries[_VAGI] = input[_VAGI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetVpnConnectionDeviceSampleConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_VCI] != null) {\n        entries[_VCI] = input[_VCI];\n    }\n    if (input[_VCDTI] != null) {\n        entries[_VCDTI] = input[_VCDTI];\n    }\n    if (input[_IKEV] != null) {\n        entries[_IKEV] = input[_IKEV];\n    }\n    if (input[_STa] != null) {\n        entries[_STa] = input[_STa];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetVpnConnectionDeviceTypesRequest = (input, context) => {\n    const entries = {};\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GetVpnTunnelReplacementStatusRequest = (input, context) => {\n    const entries = {};\n    if (input[_VCI] != null) {\n        entries[_VCI] = input[_VCI];\n    }\n    if (input[_VTOIA] != null) {\n        entries[_VTOIA] = input[_VTOIA];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_GroupIdentifier = (input, context) => {\n    const entries = {};\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    return entries;\n};\nconst se_GroupIdentifierList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_GroupIdentifier(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_GroupIds = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_GroupIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`GroupId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_GroupNameStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`GroupName.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_HibernationOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Conf] != null) {\n        entries[_Conf] = input[_Conf];\n    }\n    return entries;\n};\nconst se_HostReservationIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_IamInstanceProfileSpecification = (input, context) => {\n    const entries = {};\n    if (input[_Ar] != null) {\n        entries[_Ar] = input[_Ar];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    return entries;\n};\nconst se_IcmpTypeCode = (input, context) => {\n    const entries = {};\n    if (input[_Cod] != null) {\n        entries[_Cod] = input[_Cod];\n    }\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    return entries;\n};\nconst se_IKEVersionsRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_IKEVersionsRequestListValue(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_IKEVersionsRequestListValue = (input, context) => {\n    const entries = {};\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_ImageCriterionRequest = (input, context) => {\n    const entries = {};\n    if (input[_IPm] != null) {\n        const memberEntries = se_ImageProviderRequestList(input[_IPm], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ImageProvider.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ImageCriterionRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ImageCriterionRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`ImageCriterion.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ImageDiskContainer = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DN] != null) {\n        entries[_DN] = input[_DN];\n    }\n    if (input[_Fo] != null) {\n        entries[_Fo] = input[_Fo];\n    }\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_U] != null) {\n        entries[_U] = input[_U];\n    }\n    if (input[_UB] != null) {\n        const memberEntries = se_UserBucket(input[_UB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `UserBucket.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ImageDiskContainerList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ImageDiskContainer(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ImageIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ImageIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ImageId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ImageProviderRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ImportClientVpnClientCertificateRevocationListRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_CRL] != null) {\n        entries[_CRL] = input[_CRL];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ImportImageLicenseConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_LCA] != null) {\n        entries[_LCA] = input[_LCA];\n    }\n    return entries;\n};\nconst se_ImportImageLicenseSpecificationListRequest = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ImportImageLicenseConfigurationRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ImportImageRequest = (input, context) => {\n    const entries = {};\n    if (input[_Arc] != null) {\n        entries[_Arc] = input[_Arc];\n    }\n    if (input[_CDl] != null) {\n        const memberEntries = se_ClientData(input[_CDl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ClientData.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DCi] != null) {\n        const memberEntries = se_ImageDiskContainerList(input[_DCi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DiskContainer.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Enc] != null) {\n        entries[_Enc] = input[_Enc];\n    }\n    if (input[_H] != null) {\n        entries[_H] = input[_H];\n    }\n    if (input[_KKI] != null) {\n        entries[_KKI] = input[_KKI];\n    }\n    if (input[_LTi] != null) {\n        entries[_LTi] = input[_LTi];\n    }\n    if (input[_Pla] != null) {\n        entries[_Pla] = input[_Pla];\n    }\n    if (input[_RNo] != null) {\n        entries[_RNo] = input[_RNo];\n    }\n    if (input[_LSi] != null) {\n        const memberEntries = se_ImportImageLicenseSpecificationListRequest(input[_LSi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LicenseSpecifications.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_UO] != null) {\n        entries[_UO] = input[_UO];\n    }\n    if (input[_BM] != null) {\n        entries[_BM] = input[_BM];\n    }\n    return entries;\n};\nconst se_ImportInstanceLaunchSpecification = (input, context) => {\n    const entries = {};\n    if (input[_Arc] != null) {\n        entries[_Arc] = input[_Arc];\n    }\n    if (input[_GNr] != null) {\n        const memberEntries = se_SecurityGroupStringList(input[_GNr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `GroupName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_GIro] != null) {\n        const memberEntries = se_SecurityGroupIdStringList(input[_GIro], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `GroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AId] != null) {\n        entries[_AId] = input[_AId];\n    }\n    if (input[_UD] != null) {\n        const memberEntries = se_UserData(input[_UD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `UserData.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_Pl] != null) {\n        const memberEntries = se_Placement(input[_Pl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Placement.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Mon] != null) {\n        entries[_Mon] = input[_Mon];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_IISB] != null) {\n        entries[_IISB] = input[_IISB];\n    }\n    if (input[_PIAr] != null) {\n        entries[_PIAr] = input[_PIAr];\n    }\n    return entries;\n};\nconst se_ImportInstanceRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_LSa] != null) {\n        const memberEntries = se_ImportInstanceLaunchSpecification(input[_LSa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DIis] != null) {\n        const memberEntries = se_DiskImageList(input[_DIis], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DiskImage.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Pla] != null) {\n        entries[_Pla] = input[_Pla];\n    }\n    return entries;\n};\nconst se_ImportKeyPairRequest = (input, context) => {\n    const entries = {};\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_KN] != null) {\n        entries[_KN] = input[_KN];\n    }\n    if (input[_PKM] != null) {\n        entries[_PKM] = context.base64Encoder(input[_PKM]);\n    }\n    return entries;\n};\nconst se_ImportSnapshotRequest = (input, context) => {\n    const entries = {};\n    if (input[_CDl] != null) {\n        const memberEntries = se_ClientData(input[_CDl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ClientData.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DCis] != null) {\n        const memberEntries = se_SnapshotDiskContainer(input[_DCis], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DiskContainer.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_Enc] != null) {\n        entries[_Enc] = input[_Enc];\n    }\n    if (input[_KKI] != null) {\n        entries[_KKI] = input[_KKI];\n    }\n    if (input[_RNo] != null) {\n        entries[_RNo] = input[_RNo];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ImportSnapshotTaskIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ImportTaskId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ImportTaskIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ImportTaskId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ImportVolumeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_Im] != null) {\n        const memberEntries = se_DiskImageDetail(input[_Im], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Image.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_Vo] != null) {\n        const memberEntries = se_VolumeDetail(input[_Vo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Volume.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_InsideCidrBlocksStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceBlockDeviceMappingSpecification = (input, context) => {\n    const entries = {};\n    if (input[_DN] != null) {\n        entries[_DN] = input[_DN];\n    }\n    if (input[_E] != null) {\n        const memberEntries = se_EbsInstanceBlockDeviceSpecification(input[_E], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ebs.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VN] != null) {\n        entries[_VN] = input[_VN];\n    }\n    if (input[_ND] != null) {\n        entries[_ND] = input[_ND];\n    }\n    return entries;\n};\nconst se_InstanceBlockDeviceMappingSpecificationList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_InstanceBlockDeviceMappingSpecification(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceCreditSpecificationListRequest = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_InstanceCreditSpecificationRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceCreditSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_CCp] != null) {\n        entries[_CCp] = input[_CCp];\n    }\n    return entries;\n};\nconst se_InstanceEventWindowAssociationRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ITnsta] != null) {\n        const memberEntries = se_TagList(input[_ITnsta], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceTag.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DHI] != null) {\n        const memberEntries = se_DedicatedHostIdList(input[_DHI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DedicatedHostId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_InstanceEventWindowDisassociationRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ITnsta] != null) {\n        const memberEntries = se_TagList(input[_ITnsta], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceTag.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DHI] != null) {\n        const memberEntries = se_DedicatedHostIdList(input[_DHI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DedicatedHostId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_InstanceEventWindowIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`InstanceEventWindowId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceEventWindowTimeRangeRequest = (input, context) => {\n    const entries = {};\n    if (input[_SWD] != null) {\n        entries[_SWD] = input[_SWD];\n    }\n    if (input[_SH] != null) {\n        entries[_SH] = input[_SH];\n    }\n    if (input[_EWD] != null) {\n        entries[_EWD] = input[_EWD];\n    }\n    if (input[_EH] != null) {\n        entries[_EH] = input[_EH];\n    }\n    return entries;\n};\nconst se_InstanceEventWindowTimeRangeRequestSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_InstanceEventWindowTimeRangeRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceGenerationSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`InstanceId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceIpv6Address = (input, context) => {\n    const entries = {};\n    if (input[_IApv] != null) {\n        entries[_IApv] = input[_IApv];\n    }\n    if (input[_IPIs] != null) {\n        entries[_IPIs] = input[_IPIs];\n    }\n    return entries;\n};\nconst se_InstanceIpv6AddressList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_InstanceIpv6Address(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceIpv6AddressListRequest = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_InstanceIpv6AddressRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`InstanceIpv6Address.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceIpv6AddressRequest = (input, context) => {\n    const entries = {};\n    if (input[_IApv] != null) {\n        entries[_IApv] = input[_IApv];\n    }\n    return entries;\n};\nconst se_InstanceMaintenanceOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_ARu] != null) {\n        entries[_ARu] = input[_ARu];\n    }\n    return entries;\n};\nconst se_InstanceMarketOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_MT] != null) {\n        entries[_MT] = input[_MT];\n    }\n    if (input[_SO] != null) {\n        const memberEntries = se_SpotMarketOptions(input[_SO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SpotOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_InstanceMetadataOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_HT] != null) {\n        entries[_HT] = input[_HT];\n    }\n    if (input[_HPRHL] != null) {\n        entries[_HPRHL] = input[_HPRHL];\n    }\n    if (input[_HE] != null) {\n        entries[_HE] = input[_HE];\n    }\n    if (input[_HPI] != null) {\n        entries[_HPI] = input[_HPI];\n    }\n    if (input[_IMT] != null) {\n        entries[_IMT] = input[_IMT];\n    }\n    return entries;\n};\nconst se_InstanceNetworkInterfaceSpecification = (input, context) => {\n    const entries = {};\n    if (input[_APIAs] != null) {\n        entries[_APIAs] = input[_APIAs];\n    }\n    if (input[_DOT] != null) {\n        entries[_DOT] = input[_DOT];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DIev] != null) {\n        entries[_DIev] = input[_DIev];\n    }\n    if (input[_G] != null) {\n        const memberEntries = se_SecurityGroupIdStringList(input[_G], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IAC] != null) {\n        entries[_IAC] = input[_IAC];\n    }\n    if (input[_IA] != null) {\n        const memberEntries = se_InstanceIpv6AddressList(input[_IA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Addresses.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_PIAr] != null) {\n        entries[_PIAr] = input[_PIAr];\n    }\n    if (input[_PIA] != null) {\n        const memberEntries = se_PrivateIpAddressSpecificationList(input[_PIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrivateIpAddresses.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPIAC] != null) {\n        entries[_SPIAC] = input[_SPIAC];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_ACIA] != null) {\n        entries[_ACIA] = input[_ACIA];\n    }\n    if (input[_ITn] != null) {\n        entries[_ITn] = input[_ITn];\n    }\n    if (input[_NCI] != null) {\n        entries[_NCI] = input[_NCI];\n    }\n    if (input[_IPp] != null) {\n        const memberEntries = se_Ipv4PrefixList(input[_IPp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv4Prefix.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPCp] != null) {\n        entries[_IPCp] = input[_IPCp];\n    }\n    if (input[_IP] != null) {\n        const memberEntries = se_Ipv6PrefixList(input[_IP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Prefix.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPC] != null) {\n        entries[_IPC] = input[_IPC];\n    }\n    if (input[_PIr] != null) {\n        entries[_PIr] = input[_PIr];\n    }\n    if (input[_ESS] != null) {\n        const memberEntries = se_EnaSrdSpecificationRequest(input[_ESS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnaSrdSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTS] != null) {\n        const memberEntries = se_ConnectionTrackingSpecificationRequest(input[_CTS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ConnectionTrackingSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EQC] != null) {\n        entries[_EQC] = input[_EQC];\n    }\n    return entries;\n};\nconst se_InstanceNetworkInterfaceSpecificationList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_InstanceNetworkInterfaceSpecification(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceNetworkPerformanceOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_BW] != null) {\n        entries[_BW] = input[_BW];\n    }\n    return entries;\n};\nconst se_InstanceRequirements = (input, context) => {\n    const entries = {};\n    if (input[_VCC] != null) {\n        const memberEntries = se_VCpuCountRange(input[_VCC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VCpuCount.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MMB] != null) {\n        const memberEntries = se_MemoryMiB(input[_MMB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MemoryMiB.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CM] != null) {\n        const memberEntries = se_CpuManufacturerSet(input[_CM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CpuManufacturerSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MGBPVC] != null) {\n        const memberEntries = se_MemoryGiBPerVCpu(input[_MGBPVC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MemoryGiBPerVCpu.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EIT] != null) {\n        const memberEntries = se_ExcludedInstanceTypeSet(input[_EIT], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExcludedInstanceTypeSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IG] != null) {\n        const memberEntries = se_InstanceGenerationSet(input[_IG], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceGenerationSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SMPPOLP] != null) {\n        entries[_SMPPOLP] = input[_SMPPOLP];\n    }\n    if (input[_ODMPPOLP] != null) {\n        entries[_ODMPPOLP] = input[_ODMPPOLP];\n    }\n    if (input[_BMa] != null) {\n        entries[_BMa] = input[_BMa];\n    }\n    if (input[_BP] != null) {\n        entries[_BP] = input[_BP];\n    }\n    if (input[_RHS] != null) {\n        entries[_RHS] = input[_RHS];\n    }\n    if (input[_NIC] != null) {\n        const memberEntries = se_NetworkInterfaceCount(input[_NIC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterfaceCount.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LSo] != null) {\n        entries[_LSo] = input[_LSo];\n    }\n    if (input[_LST] != null) {\n        const memberEntries = se_LocalStorageTypeSet(input[_LST], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LocalStorageTypeSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TLSGB] != null) {\n        const memberEntries = se_TotalLocalStorageGB(input[_TLSGB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TotalLocalStorageGB.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_BEBM] != null) {\n        const memberEntries = se_BaselineEbsBandwidthMbps(input[_BEBM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BaselineEbsBandwidthMbps.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ATc] != null) {\n        const memberEntries = se_AcceleratorTypeSet(input[_ATc], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AcceleratorTypeSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ACc] != null) {\n        const memberEntries = se_AcceleratorCount(input[_ACc], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AcceleratorCount.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AM] != null) {\n        const memberEntries = se_AcceleratorManufacturerSet(input[_AM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AcceleratorManufacturerSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ANc] != null) {\n        const memberEntries = se_AcceleratorNameSet(input[_ANc], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AcceleratorNameSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ATMMB] != null) {\n        const memberEntries = se_AcceleratorTotalMemoryMiB(input[_ATMMB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AcceleratorTotalMemoryMiB.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NBGe] != null) {\n        const memberEntries = se_NetworkBandwidthGbps(input[_NBGe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkBandwidthGbps.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AIT] != null) {\n        const memberEntries = se_AllowedInstanceTypeSet(input[_AIT], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AllowedInstanceTypeSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MSPAPOOODP] != null) {\n        entries[_MSPAPOOODP] = input[_MSPAPOOODP];\n    }\n    if (input[_BPF] != null) {\n        const memberEntries = se_BaselinePerformanceFactors(input[_BPF], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BaselinePerformanceFactors.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_InstanceRequirementsRequest = (input, context) => {\n    const entries = {};\n    if (input[_VCC] != null) {\n        const memberEntries = se_VCpuCountRangeRequest(input[_VCC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VCpuCount.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MMB] != null) {\n        const memberEntries = se_MemoryMiBRequest(input[_MMB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MemoryMiB.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CM] != null) {\n        const memberEntries = se_CpuManufacturerSet(input[_CM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CpuManufacturer.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MGBPVC] != null) {\n        const memberEntries = se_MemoryGiBPerVCpuRequest(input[_MGBPVC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MemoryGiBPerVCpu.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EIT] != null) {\n        const memberEntries = se_ExcludedInstanceTypeSet(input[_EIT], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExcludedInstanceType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IG] != null) {\n        const memberEntries = se_InstanceGenerationSet(input[_IG], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceGeneration.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SMPPOLP] != null) {\n        entries[_SMPPOLP] = input[_SMPPOLP];\n    }\n    if (input[_ODMPPOLP] != null) {\n        entries[_ODMPPOLP] = input[_ODMPPOLP];\n    }\n    if (input[_BMa] != null) {\n        entries[_BMa] = input[_BMa];\n    }\n    if (input[_BP] != null) {\n        entries[_BP] = input[_BP];\n    }\n    if (input[_RHS] != null) {\n        entries[_RHS] = input[_RHS];\n    }\n    if (input[_NIC] != null) {\n        const memberEntries = se_NetworkInterfaceCountRequest(input[_NIC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterfaceCount.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LSo] != null) {\n        entries[_LSo] = input[_LSo];\n    }\n    if (input[_LST] != null) {\n        const memberEntries = se_LocalStorageTypeSet(input[_LST], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LocalStorageType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TLSGB] != null) {\n        const memberEntries = se_TotalLocalStorageGBRequest(input[_TLSGB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TotalLocalStorageGB.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_BEBM] != null) {\n        const memberEntries = se_BaselineEbsBandwidthMbpsRequest(input[_BEBM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BaselineEbsBandwidthMbps.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ATc] != null) {\n        const memberEntries = se_AcceleratorTypeSet(input[_ATc], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AcceleratorType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ACc] != null) {\n        const memberEntries = se_AcceleratorCountRequest(input[_ACc], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AcceleratorCount.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AM] != null) {\n        const memberEntries = se_AcceleratorManufacturerSet(input[_AM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AcceleratorManufacturer.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ANc] != null) {\n        const memberEntries = se_AcceleratorNameSet(input[_ANc], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AcceleratorName.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ATMMB] != null) {\n        const memberEntries = se_AcceleratorTotalMemoryMiBRequest(input[_ATMMB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AcceleratorTotalMemoryMiB.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NBGe] != null) {\n        const memberEntries = se_NetworkBandwidthGbpsRequest(input[_NBGe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkBandwidthGbps.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AIT] != null) {\n        const memberEntries = se_AllowedInstanceTypeSet(input[_AIT], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AllowedInstanceType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MSPAPOOODP] != null) {\n        entries[_MSPAPOOODP] = input[_MSPAPOOODP];\n    }\n    if (input[_BPF] != null) {\n        const memberEntries = se_BaselinePerformanceFactorsRequest(input[_BPF], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BaselinePerformanceFactors.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_InstanceRequirementsWithMetadataRequest = (input, context) => {\n    const entries = {};\n    if (input[_ATr] != null) {\n        const memberEntries = se_ArchitectureTypeSet(input[_ATr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ArchitectureType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VTi] != null) {\n        const memberEntries = se_VirtualizationTypeSet(input[_VTi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VirtualizationType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IR] != null) {\n        const memberEntries = se_InstanceRequirementsRequest(input[_IR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceRequirements.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_InstanceSpecification = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_EBV] != null) {\n        entries[_EBV] = input[_EBV];\n    }\n    if (input[_EDVI] != null) {\n        const memberEntries = se_VolumeIdStringList(input[_EDVI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExcludeDataVolumeId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_InstanceTagKeySet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceTypeList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_InstanceTypes = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_IntegrateServices = (input, context) => {\n    const entries = {};\n    if (input[_AIth] != null) {\n        const memberEntries = se_AthenaIntegrationsSet(input[_AIth], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AthenaIntegration.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_InternetGatewayIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_IpamCidrAuthorizationContext = (input, context) => {\n    const entries = {};\n    if (input[_Me] != null) {\n        entries[_Me] = input[_Me];\n    }\n    if (input[_Si] != null) {\n        entries[_Si] = input[_Si];\n    }\n    return entries;\n};\nconst se_IpamPoolAllocationAllowedCidrs = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_IpamPoolAllocationDisallowedCidrs = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_IpamPoolSourceResourceRequest = (input, context) => {\n    const entries = {};\n    if (input[_RIeso] != null) {\n        entries[_RIeso] = input[_RIeso];\n    }\n    if (input[_RT] != null) {\n        entries[_RT] = input[_RT];\n    }\n    if (input[_RRe] != null) {\n        entries[_RRe] = input[_RRe];\n    }\n    if (input[_ROe] != null) {\n        entries[_ROe] = input[_ROe];\n    }\n    return entries;\n};\nconst se_IpList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_IpPermission = (input, context) => {\n    const entries = {};\n    if (input[_IPpr] != null) {\n        entries[_IPpr] = input[_IPpr];\n    }\n    if (input[_FP] != null) {\n        entries[_FP] = input[_FP];\n    }\n    if (input[_TP] != null) {\n        entries[_TP] = input[_TP];\n    }\n    if (input[_UIGP] != null) {\n        const memberEntries = se_UserIdGroupPairList(input[_UIGP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Groups.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IRp] != null) {\n        const memberEntries = se_IpRangeList(input[_IRp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpRanges.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IRpv] != null) {\n        const memberEntries = se_Ipv6RangeList(input[_IRpv], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Ranges.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PLIr] != null) {\n        const memberEntries = se_PrefixListIdList(input[_PLIr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrefixListIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_IpPermissionList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_IpPermission(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_IpPrefixList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_IpRange = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_CIi] != null) {\n        entries[_CIi] = input[_CIi];\n    }\n    return entries;\n};\nconst se_IpRangeList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_IpRange(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Ipv4PrefixList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Ipv4PrefixSpecificationRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Ipv4PrefixSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_IPpvr] != null) {\n        entries[_IPpvr] = input[_IPpvr];\n    }\n    return entries;\n};\nconst se_Ipv6AddressList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_Ipv6PoolIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_Ipv6PrefixList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Ipv6PrefixSpecificationRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Ipv6PrefixSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_IPpvre] != null) {\n        entries[_IPpvre] = input[_IPpvre];\n    }\n    return entries;\n};\nconst se_Ipv6Range = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_CIid] != null) {\n        entries[_CIid] = input[_CIid];\n    }\n    return entries;\n};\nconst se_Ipv6RangeList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Ipv6Range(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_KeyNameStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`KeyName.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_KeyPairIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`KeyPairId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_LaunchPermission = (input, context) => {\n    const entries = {};\n    if (input[_OAr] != null) {\n        entries[_OAr] = input[_OAr];\n    }\n    if (input[_OUA] != null) {\n        entries[_OUA] = input[_OUA];\n    }\n    if (input[_UIs] != null) {\n        entries[_UIs] = input[_UIs];\n    }\n    if (input[_Gr] != null) {\n        entries[_Gr] = input[_Gr];\n    }\n    return entries;\n};\nconst se_LaunchPermissionList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_LaunchPermission(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_LaunchPermissionModifications = (input, context) => {\n    const entries = {};\n    if (input[_Add] != null) {\n        const memberEntries = se_LaunchPermissionList(input[_Add], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Add.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Rem] != null) {\n        const memberEntries = se_LaunchPermissionList(input[_Rem], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Remove.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_LaunchSpecsList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_SpotFleetLaunchSpecification(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_LaunchTemplateBlockDeviceMappingRequest = (input, context) => {\n    const entries = {};\n    if (input[_DN] != null) {\n        entries[_DN] = input[_DN];\n    }\n    if (input[_VN] != null) {\n        entries[_VN] = input[_VN];\n    }\n    if (input[_E] != null) {\n        const memberEntries = se_LaunchTemplateEbsBlockDeviceRequest(input[_E], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ebs.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ND] != null) {\n        entries[_ND] = input[_ND];\n    }\n    return entries;\n};\nconst se_LaunchTemplateBlockDeviceMappingRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_LaunchTemplateBlockDeviceMappingRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`BlockDeviceMapping.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_LaunchTemplateCapacityReservationSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRP] != null) {\n        entries[_CRP] = input[_CRP];\n    }\n    if (input[_CRTa] != null) {\n        const memberEntries = se_CapacityReservationTarget(input[_CRTa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityReservationTarget.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_LaunchTemplateConfig = (input, context) => {\n    const entries = {};\n    if (input[_LTS] != null) {\n        const memberEntries = se_FleetLaunchTemplateSpecification(input[_LTS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ov] != null) {\n        const memberEntries = se_LaunchTemplateOverridesList(input[_Ov], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Overrides.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_LaunchTemplateConfigList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_LaunchTemplateConfig(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_LaunchTemplateCpuOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_CC] != null) {\n        entries[_CC] = input[_CC];\n    }\n    if (input[_TPC] != null) {\n        entries[_TPC] = input[_TPC];\n    }\n    if (input[_ASS] != null) {\n        entries[_ASS] = input[_ASS];\n    }\n    return entries;\n};\nconst se_LaunchTemplateEbsBlockDeviceRequest = (input, context) => {\n    const entries = {};\n    if (input[_Enc] != null) {\n        entries[_Enc] = input[_Enc];\n    }\n    if (input[_DOT] != null) {\n        entries[_DOT] = input[_DOT];\n    }\n    if (input[_Io] != null) {\n        entries[_Io] = input[_Io];\n    }\n    if (input[_KKI] != null) {\n        entries[_KKI] = input[_KKI];\n    }\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_VS] != null) {\n        entries[_VS] = input[_VS];\n    }\n    if (input[_VT] != null) {\n        entries[_VT] = input[_VT];\n    }\n    if (input[_Th] != null) {\n        entries[_Th] = input[_Th];\n    }\n    if (input[_VIR] != null) {\n        entries[_VIR] = input[_VIR];\n    }\n    return entries;\n};\nconst se_LaunchTemplateElasticInferenceAccelerator = (input, context) => {\n    const entries = {};\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    if (input[_Cou] != null) {\n        entries[_Cou] = input[_Cou];\n    }\n    return entries;\n};\nconst se_LaunchTemplateElasticInferenceAcceleratorList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_LaunchTemplateElasticInferenceAccelerator(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_LaunchTemplateEnclaveOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    return entries;\n};\nconst se_LaunchTemplateHibernationOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_Conf] != null) {\n        entries[_Conf] = input[_Conf];\n    }\n    return entries;\n};\nconst se_LaunchTemplateIamInstanceProfileSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_Ar] != null) {\n        entries[_Ar] = input[_Ar];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    return entries;\n};\nconst se_LaunchTemplateIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_LaunchTemplateInstanceMaintenanceOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_ARu] != null) {\n        entries[_ARu] = input[_ARu];\n    }\n    return entries;\n};\nconst se_LaunchTemplateInstanceMarketOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_MT] != null) {\n        entries[_MT] = input[_MT];\n    }\n    if (input[_SO] != null) {\n        const memberEntries = se_LaunchTemplateSpotMarketOptionsRequest(input[_SO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SpotOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_LaunchTemplateInstanceMetadataOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_HT] != null) {\n        entries[_HT] = input[_HT];\n    }\n    if (input[_HPRHL] != null) {\n        entries[_HPRHL] = input[_HPRHL];\n    }\n    if (input[_HE] != null) {\n        entries[_HE] = input[_HE];\n    }\n    if (input[_HPI] != null) {\n        entries[_HPI] = input[_HPI];\n    }\n    if (input[_IMT] != null) {\n        entries[_IMT] = input[_IMT];\n    }\n    return entries;\n};\nconst se_LaunchTemplateInstanceNetworkInterfaceSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_ACIA] != null) {\n        entries[_ACIA] = input[_ACIA];\n    }\n    if (input[_APIAs] != null) {\n        entries[_APIAs] = input[_APIAs];\n    }\n    if (input[_DOT] != null) {\n        entries[_DOT] = input[_DOT];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DIev] != null) {\n        entries[_DIev] = input[_DIev];\n    }\n    if (input[_G] != null) {\n        const memberEntries = se_SecurityGroupIdStringList(input[_G], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ITn] != null) {\n        entries[_ITn] = input[_ITn];\n    }\n    if (input[_IAC] != null) {\n        entries[_IAC] = input[_IAC];\n    }\n    if (input[_IA] != null) {\n        const memberEntries = se_InstanceIpv6AddressListRequest(input[_IA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Addresses.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_PIAr] != null) {\n        entries[_PIAr] = input[_PIAr];\n    }\n    if (input[_PIA] != null) {\n        const memberEntries = se_PrivateIpAddressSpecificationList(input[_PIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrivateIpAddresses.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPIAC] != null) {\n        entries[_SPIAC] = input[_SPIAC];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_NCI] != null) {\n        entries[_NCI] = input[_NCI];\n    }\n    if (input[_IPp] != null) {\n        const memberEntries = se_Ipv4PrefixList(input[_IPp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv4Prefix.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPCp] != null) {\n        entries[_IPCp] = input[_IPCp];\n    }\n    if (input[_IP] != null) {\n        const memberEntries = se_Ipv6PrefixList(input[_IP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Prefix.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPC] != null) {\n        entries[_IPC] = input[_IPC];\n    }\n    if (input[_PIr] != null) {\n        entries[_PIr] = input[_PIr];\n    }\n    if (input[_ESS] != null) {\n        const memberEntries = se_EnaSrdSpecificationRequest(input[_ESS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnaSrdSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTS] != null) {\n        const memberEntries = se_ConnectionTrackingSpecificationRequest(input[_CTS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ConnectionTrackingSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EQC] != null) {\n        entries[_EQC] = input[_EQC];\n    }\n    return entries;\n};\nconst se_LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_LaunchTemplateInstanceNetworkInterfaceSpecificationRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`InstanceNetworkInterfaceSpecification.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_LaunchTemplateLicenseConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_LCA] != null) {\n        entries[_LCA] = input[_LCA];\n    }\n    return entries;\n};\nconst se_LaunchTemplateLicenseSpecificationListRequest = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_LaunchTemplateLicenseConfigurationRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_LaunchTemplateNameStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_LaunchTemplateNetworkPerformanceOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_BW] != null) {\n        entries[_BW] = input[_BW];\n    }\n    return entries;\n};\nconst se_LaunchTemplateOverrides = (input, context) => {\n    const entries = {};\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_SPp] != null) {\n        entries[_SPp] = input[_SPp];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_WCe] != null) {\n        entries[_WCe] = __serializeFloat(input[_WCe]);\n    }\n    if (input[_Pri] != null) {\n        entries[_Pri] = __serializeFloat(input[_Pri]);\n    }\n    if (input[_IR] != null) {\n        const memberEntries = se_InstanceRequirements(input[_IR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceRequirements.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_LaunchTemplateOverridesList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_LaunchTemplateOverrides(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_LaunchTemplatePlacementRequest = (input, context) => {\n    const entries = {};\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_Af] != null) {\n        entries[_Af] = input[_Af];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_HIo] != null) {\n        entries[_HIo] = input[_HIo];\n    }\n    if (input[_Te] != null) {\n        entries[_Te] = input[_Te];\n    }\n    if (input[_SDp] != null) {\n        entries[_SDp] = input[_SDp];\n    }\n    if (input[_HRGA] != null) {\n        entries[_HRGA] = input[_HRGA];\n    }\n    if (input[_PN] != null) {\n        entries[_PN] = input[_PN];\n    }\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    return entries;\n};\nconst se_LaunchTemplatePrivateDnsNameOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_HTo] != null) {\n        entries[_HTo] = input[_HTo];\n    }\n    if (input[_ERNDAR] != null) {\n        entries[_ERNDAR] = input[_ERNDAR];\n    }\n    if (input[_ERNDAAAAR] != null) {\n        entries[_ERNDAAAAR] = input[_ERNDAAAAR];\n    }\n    return entries;\n};\nconst se_LaunchTemplatesMonitoringRequest = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    return entries;\n};\nconst se_LaunchTemplateSpecification = (input, context) => {\n    const entries = {};\n    if (input[_LTI] != null) {\n        entries[_LTI] = input[_LTI];\n    }\n    if (input[_LTN] != null) {\n        entries[_LTN] = input[_LTN];\n    }\n    if (input[_V] != null) {\n        entries[_V] = input[_V];\n    }\n    return entries;\n};\nconst se_LaunchTemplateSpotMarketOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_MPa] != null) {\n        entries[_MPa] = input[_MPa];\n    }\n    if (input[_SIT] != null) {\n        entries[_SIT] = input[_SIT];\n    }\n    if (input[_BDMl] != null) {\n        entries[_BDMl] = input[_BDMl];\n    }\n    if (input[_VU] != null) {\n        entries[_VU] = __serializeDateTime(input[_VU]);\n    }\n    if (input[_IIB] != null) {\n        entries[_IIB] = input[_IIB];\n    }\n    return entries;\n};\nconst se_LaunchTemplateTagSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_RT] != null) {\n        entries[_RT] = input[_RT];\n    }\n    if (input[_Ta] != null) {\n        const memberEntries = se_TagList(input[_Ta], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Tag.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_LaunchTemplateTagSpecificationRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_LaunchTemplateTagSpecificationRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`LaunchTemplateTagSpecificationRequest.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_LicenseConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_LCA] != null) {\n        entries[_LCA] = input[_LCA];\n    }\n    return entries;\n};\nconst se_LicenseSpecificationListRequest = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_LicenseConfigurationRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ListImagesInRecycleBinRequest = (input, context) => {\n    const entries = {};\n    if (input[_IImag] != null) {\n        const memberEntries = se_ImageIdStringList(input[_IImag], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ImageId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ListSnapshotsInRecycleBinRequest = (input, context) => {\n    const entries = {};\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_SIna] != null) {\n        const memberEntries = se_SnapshotIdStringList(input[_SIna], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SnapshotId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_LoadBalancersConfig = (input, context) => {\n    const entries = {};\n    if (input[_CLBC] != null) {\n        const memberEntries = se_ClassicLoadBalancersConfig(input[_CLBC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ClassicLoadBalancersConfig.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TGC] != null) {\n        const memberEntries = se_TargetGroupsConfig(input[_TGC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TargetGroupsConfig.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_LoadPermissionListRequest = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_LoadPermissionRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_LoadPermissionModifications = (input, context) => {\n    const entries = {};\n    if (input[_Add] != null) {\n        const memberEntries = se_LoadPermissionListRequest(input[_Add], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Add.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Rem] != null) {\n        const memberEntries = se_LoadPermissionListRequest(input[_Rem], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Remove.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_LoadPermissionRequest = (input, context) => {\n    const entries = {};\n    if (input[_Gr] != null) {\n        entries[_Gr] = input[_Gr];\n    }\n    if (input[_UIs] != null) {\n        entries[_UIs] = input[_UIs];\n    }\n    return entries;\n};\nconst se_LocalGatewayIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_LocalGatewayRouteTableIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_LocalGatewayRouteTableVpcAssociationIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_LocalGatewayVirtualInterfaceGroupIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_LocalGatewayVirtualInterfaceIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_LocalStorageTypeSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_LockSnapshotRequest = (input, context) => {\n    const entries = {};\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_LM] != null) {\n        entries[_LM] = input[_LM];\n    }\n    if (input[_COP] != null) {\n        entries[_COP] = input[_COP];\n    }\n    if (input[_LDo] != null) {\n        entries[_LDo] = input[_LDo];\n    }\n    if (input[_EDx] != null) {\n        entries[_EDx] = __serializeDateTime(input[_EDx]);\n    }\n    return entries;\n};\nconst se_MacModificationTaskIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_MacSystemIntegrityProtectionConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIp] != null) {\n        entries[_AIp] = input[_AIp];\n    }\n    if (input[_BS] != null) {\n        entries[_BS] = input[_BS];\n    }\n    if (input[_DReb] != null) {\n        entries[_DReb] = input[_DReb];\n    }\n    if (input[_DTR] != null) {\n        entries[_DTR] = input[_DTR];\n    }\n    if (input[_FPi] != null) {\n        entries[_FPi] = input[_FPi];\n    }\n    if (input[_KS] != null) {\n        entries[_KS] = input[_KS];\n    }\n    if (input[_NP] != null) {\n        entries[_NP] = input[_NP];\n    }\n    return entries;\n};\nconst se_MemoryGiBPerVCpu = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = __serializeFloat(input[_M]);\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = __serializeFloat(input[_Ma]);\n    }\n    return entries;\n};\nconst se_MemoryGiBPerVCpuRequest = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = __serializeFloat(input[_M]);\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = __serializeFloat(input[_Ma]);\n    }\n    return entries;\n};\nconst se_MemoryMiB = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_MemoryMiBRequest = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_ModifyAddressAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIl] != null) {\n        entries[_AIl] = input[_AIl];\n    }\n    if (input[_DNo] != null) {\n        entries[_DNo] = input[_DNo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyAvailabilityZoneGroupRequest = (input, context) => {\n    const entries = {};\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_OIS] != null) {\n        entries[_OIS] = input[_OIS];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyCapacityReservationFleetRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRFIa] != null) {\n        entries[_CRFIa] = input[_CRFIa];\n    }\n    if (input[_TTC] != null) {\n        entries[_TTC] = input[_TTC];\n    }\n    if (input[_ED] != null) {\n        entries[_ED] = __serializeDateTime(input[_ED]);\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RED] != null) {\n        entries[_RED] = input[_RED];\n    }\n    return entries;\n};\nconst se_ModifyCapacityReservationRequest = (input, context) => {\n    const entries = {};\n    if (input[_CRI] != null) {\n        entries[_CRI] = input[_CRI];\n    }\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    if (input[_ED] != null) {\n        entries[_ED] = __serializeDateTime(input[_ED]);\n    }\n    if (input[_EDT] != null) {\n        entries[_EDT] = input[_EDT];\n    }\n    if (input[_Ac] != null) {\n        entries[_Ac] = input[_Ac];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_AId] != null) {\n        entries[_AId] = input[_AId];\n    }\n    if (input[_IMC] != null) {\n        entries[_IMC] = input[_IMC];\n    }\n    return entries;\n};\nconst se_ModifyClientVpnEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_SCA] != null) {\n        entries[_SCA] = input[_SCA];\n    }\n    if (input[_CLO] != null) {\n        const memberEntries = se_ConnectionLogOptions(input[_CLO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ConnectionLogOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DSn] != null) {\n        const memberEntries = se_DnsServersOptionsModifyStructure(input[_DSn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DnsServers.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VP] != null) {\n        entries[_VP] = input[_VP];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_ST] != null) {\n        entries[_ST] = input[_ST];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SGI] != null) {\n        const memberEntries = se_ClientVpnSecurityGroupIdSet(input[_SGI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_SSP] != null) {\n        entries[_SSP] = input[_SSP];\n    }\n    if (input[_CCO] != null) {\n        const memberEntries = se_ClientConnectOptions(input[_CCO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ClientConnectOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_STH] != null) {\n        entries[_STH] = input[_STH];\n    }\n    if (input[_CLBO] != null) {\n        const memberEntries = se_ClientLoginBannerOptions(input[_CLBO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ClientLoginBannerOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CREO] != null) {\n        const memberEntries = se_ClientRouteEnforcementOptions(input[_CREO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ClientRouteEnforcementOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DOST] != null) {\n        entries[_DOST] = input[_DOST];\n    }\n    return entries;\n};\nconst se_ModifyDefaultCreditSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IF] != null) {\n        entries[_IF] = input[_IF];\n    }\n    if (input[_CCp] != null) {\n        entries[_CCp] = input[_CCp];\n    }\n    return entries;\n};\nconst se_ModifyEbsDefaultKmsKeyIdRequest = (input, context) => {\n    const entries = {};\n    if (input[_KKI] != null) {\n        entries[_KKI] = input[_KKI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyFleetRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ECTP] != null) {\n        entries[_ECTP] = input[_ECTP];\n    }\n    if (input[_LTC] != null) {\n        const memberEntries = se_FleetLaunchTemplateConfigListRequest(input[_LTC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateConfig.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_FIl] != null) {\n        entries[_FIl] = input[_FIl];\n    }\n    if (input[_TCS] != null) {\n        const memberEntries = se_TargetCapacitySpecificationRequest(input[_TCS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TargetCapacitySpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Con] != null) {\n        entries[_Con] = input[_Con];\n    }\n    return entries;\n};\nconst se_ModifyFpgaImageAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_FII] != null) {\n        entries[_FII] = input[_FII];\n    }\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_OTp] != null) {\n        entries[_OTp] = input[_OTp];\n    }\n    if (input[_UIse] != null) {\n        const memberEntries = se_UserIdStringList(input[_UIse], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `UserId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_UG] != null) {\n        const memberEntries = se_UserGroupStringList(input[_UG], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `UserGroup.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PCr] != null) {\n        const memberEntries = se_ProductCodeStringList(input[_PCr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ProductCode.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LP] != null) {\n        const memberEntries = se_LoadPermissionModifications(input[_LP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LoadPermission.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    return entries;\n};\nconst se_ModifyHostsRequest = (input, context) => {\n    const entries = {};\n    if (input[_HR] != null) {\n        entries[_HR] = input[_HR];\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_IF] != null) {\n        entries[_IF] = input[_IF];\n    }\n    if (input[_HM] != null) {\n        entries[_HM] = input[_HM];\n    }\n    if (input[_HI] != null) {\n        const memberEntries = se_RequestHostIdList(input[_HI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `HostId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AP] != null) {\n        entries[_AP] = input[_AP];\n    }\n    return entries;\n};\nconst se_ModifyIdentityIdFormatRequest = (input, context) => {\n    const entries = {};\n    if (input[_Res] != null) {\n        entries[_Res] = input[_Res];\n    }\n    if (input[_ULI] != null) {\n        entries[_ULI] = input[_ULI];\n    }\n    if (input[_PAr] != null) {\n        entries[_PAr] = input[_PAr];\n    }\n    return entries;\n};\nconst se_ModifyIdFormatRequest = (input, context) => {\n    const entries = {};\n    if (input[_Res] != null) {\n        entries[_Res] = input[_Res];\n    }\n    if (input[_ULI] != null) {\n        entries[_ULI] = input[_ULI];\n    }\n    return entries;\n};\nconst se_ModifyImageAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_De] != null) {\n        const memberEntries = se_AttributeValue(input[_De], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Description.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_LPa] != null) {\n        const memberEntries = se_LaunchPermissionModifications(input[_LPa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchPermission.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_OTp] != null) {\n        entries[_OTp] = input[_OTp];\n    }\n    if (input[_PCr] != null) {\n        const memberEntries = se_ProductCodeStringList(input[_PCr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ProductCode.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_UG] != null) {\n        const memberEntries = se_UserGroupStringList(input[_UG], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `UserGroup.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_UIse] != null) {\n        const memberEntries = se_UserIdStringList(input[_UIse], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `UserId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    if (input[_OArg] != null) {\n        const memberEntries = se_OrganizationArnStringList(input[_OArg], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `OrganizationArn.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_OUAr] != null) {\n        const memberEntries = se_OrganizationalUnitArnStringList(input[_OUAr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `OrganizationalUnitArn.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ISm] != null) {\n        const memberEntries = se_AttributeValue(input[_ISm], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ImdsSupport.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyInstanceAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_SDC] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_SDC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SourceDestCheck.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DASi] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_DASi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DisableApiStop.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    if (input[_BDM] != null) {\n        const memberEntries = se_InstanceBlockDeviceMappingSpecificationList(input[_BDM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DATis] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_DATis], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DisableApiTermination.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IT] != null) {\n        const memberEntries = se_AttributeValue(input[_IT], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceType.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_K] != null) {\n        const memberEntries = se_AttributeValue(input[_K], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Kernel.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ra] != null) {\n        const memberEntries = se_AttributeValue(input[_Ra], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ramdisk.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_UD] != null) {\n        const memberEntries = se_BlobAttributeValue(input[_UD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `UserData.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IISB] != null) {\n        const memberEntries = se_AttributeValue(input[_IISB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceInitiatedShutdownBehavior.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_G] != null) {\n        const memberEntries = se_GroupIdStringList(input[_G], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `GroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EO] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_EO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EbsOptimized.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SNS] != null) {\n        const memberEntries = se_AttributeValue(input[_SNS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SriovNetSupport.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ESn] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_ESn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnaSupport.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyInstanceCapacityReservationAttributesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_CRSa] != null) {\n        const memberEntries = se_CapacityReservationSpecification(input[_CRSa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityReservationSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyInstanceCpuOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_CC] != null) {\n        entries[_CC] = input[_CC];\n    }\n    if (input[_TPC] != null) {\n        entries[_TPC] = input[_TPC];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyInstanceCreditSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_ICS] != null) {\n        const memberEntries = se_InstanceCreditSpecificationListRequest(input[_ICS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceCreditSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyInstanceEventStartTimeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_IEI] != null) {\n        entries[_IEI] = input[_IEI];\n    }\n    if (input[_NB] != null) {\n        entries[_NB] = __serializeDateTime(input[_NB]);\n    }\n    return entries;\n};\nconst se_ModifyInstanceEventWindowRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_IEWI] != null) {\n        entries[_IEWI] = input[_IEWI];\n    }\n    if (input[_TRi] != null) {\n        const memberEntries = se_InstanceEventWindowTimeRangeRequestSet(input[_TRi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TimeRange.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CE] != null) {\n        entries[_CE] = input[_CE];\n    }\n    return entries;\n};\nconst se_ModifyInstanceMaintenanceOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_ARu] != null) {\n        entries[_ARu] = input[_ARu];\n    }\n    if (input[_RMe] != null) {\n        entries[_RMe] = input[_RMe];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyInstanceMetadataDefaultsRequest = (input, context) => {\n    const entries = {};\n    if (input[_HT] != null) {\n        entries[_HT] = input[_HT];\n    }\n    if (input[_HPRHL] != null) {\n        entries[_HPRHL] = input[_HPRHL];\n    }\n    if (input[_HE] != null) {\n        entries[_HE] = input[_HE];\n    }\n    if (input[_IMT] != null) {\n        entries[_IMT] = input[_IMT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyInstanceMetadataOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_HT] != null) {\n        entries[_HT] = input[_HT];\n    }\n    if (input[_HPRHL] != null) {\n        entries[_HPRHL] = input[_HPRHL];\n    }\n    if (input[_HE] != null) {\n        entries[_HE] = input[_HE];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_HPI] != null) {\n        entries[_HPI] = input[_HPI];\n    }\n    if (input[_IMT] != null) {\n        entries[_IMT] = input[_IMT];\n    }\n    return entries;\n};\nconst se_ModifyInstanceNetworkPerformanceRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_BW] != null) {\n        entries[_BW] = input[_BW];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyInstancePlacementRequest = (input, context) => {\n    const entries = {};\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_PN] != null) {\n        entries[_PN] = input[_PN];\n    }\n    if (input[_HRGA] != null) {\n        entries[_HRGA] = input[_HRGA];\n    }\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_Te] != null) {\n        entries[_Te] = input[_Te];\n    }\n    if (input[_Af] != null) {\n        entries[_Af] = input[_Af];\n    }\n    if (input[_HIo] != null) {\n        entries[_HIo] = input[_HIo];\n    }\n    return entries;\n};\nconst se_ModifyIpamPoolRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_AIu] != null) {\n        entries[_AIu] = input[_AIu];\n    }\n    if (input[_AMNL] != null) {\n        entries[_AMNL] = input[_AMNL];\n    }\n    if (input[_AMNLl] != null) {\n        entries[_AMNLl] = input[_AMNLl];\n    }\n    if (input[_ADNL] != null) {\n        entries[_ADNL] = input[_ADNL];\n    }\n    if (input[_CADNL] != null) {\n        entries[_CADNL] = input[_CADNL];\n    }\n    if (input[_AART] != null) {\n        const memberEntries = se_RequestIpamResourceTagList(input[_AART], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddAllocationResourceTag.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RART] != null) {\n        const memberEntries = se_RequestIpamResourceTagList(input[_RART], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveAllocationResourceTag.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyIpamRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIp] != null) {\n        entries[_IIp] = input[_IIp];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_AOR] != null) {\n        const memberEntries = se_AddIpamOperatingRegionSet(input[_AOR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddOperatingRegion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ROR] != null) {\n        const memberEntries = se_RemoveIpamOperatingRegionSet(input[_ROR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveOperatingRegion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ti] != null) {\n        entries[_Ti] = input[_Ti];\n    }\n    if (input[_EPG] != null) {\n        entries[_EPG] = input[_EPG];\n    }\n    if (input[_MAe] != null) {\n        entries[_MAe] = input[_MAe];\n    }\n    return entries;\n};\nconst se_ModifyIpamResourceCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RIeso] != null) {\n        entries[_RIeso] = input[_RIeso];\n    }\n    if (input[_RC] != null) {\n        entries[_RC] = input[_RC];\n    }\n    if (input[_RRe] != null) {\n        entries[_RRe] = input[_RRe];\n    }\n    if (input[_CISI] != null) {\n        entries[_CISI] = input[_CISI];\n    }\n    if (input[_DISI] != null) {\n        entries[_DISI] = input[_DISI];\n    }\n    if (input[_Moni] != null) {\n        entries[_Moni] = input[_Moni];\n    }\n    return entries;\n};\nconst se_ModifyIpamResourceDiscoveryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IRDI] != null) {\n        entries[_IRDI] = input[_IRDI];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_AOR] != null) {\n        const memberEntries = se_AddIpamOperatingRegionSet(input[_AOR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddOperatingRegion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ROR] != null) {\n        const memberEntries = se_RemoveIpamOperatingRegionSet(input[_ROR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveOperatingRegion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AOUE] != null) {\n        const memberEntries = se_AddIpamOrganizationalUnitExclusionSet(input[_AOUE], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddOrganizationalUnitExclusion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ROUE] != null) {\n        const memberEntries = se_RemoveIpamOrganizationalUnitExclusionSet(input[_ROUE], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveOrganizationalUnitExclusion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyIpamScopeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ISI] != null) {\n        entries[_ISI] = input[_ISI];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    return entries;\n};\nconst se_ModifyLaunchTemplateRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_LTI] != null) {\n        entries[_LTI] = input[_LTI];\n    }\n    if (input[_LTN] != null) {\n        entries[_LTN] = input[_LTN];\n    }\n    if (input[_DVef] != null) {\n        entries[_SDV] = input[_DVef];\n    }\n    return entries;\n};\nconst se_ModifyLocalGatewayRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_LGRTI] != null) {\n        entries[_LGRTI] = input[_LGRTI];\n    }\n    if (input[_LGVIGI] != null) {\n        entries[_LGVIGI] = input[_LGVIGI];\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_DPLI] != null) {\n        entries[_DPLI] = input[_DPLI];\n    }\n    return entries;\n};\nconst se_ModifyManagedPrefixListRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PLI] != null) {\n        entries[_PLI] = input[_PLI];\n    }\n    if (input[_CVu] != null) {\n        entries[_CVu] = input[_CVu];\n    }\n    if (input[_PLN] != null) {\n        entries[_PLN] = input[_PLN];\n    }\n    if (input[_AEd] != null) {\n        const memberEntries = se_AddPrefixListEntries(input[_AEd], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddEntry.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_REe] != null) {\n        const memberEntries = se_RemovePrefixListEntries(input[_REe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveEntry.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ME] != null) {\n        entries[_ME] = input[_ME];\n    }\n    return entries;\n};\nconst se_ModifyNetworkInterfaceAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_ESS] != null) {\n        const memberEntries = se_EnaSrdSpecification(input[_ESS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnaSrdSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EPI] != null) {\n        entries[_EPI] = input[_EPI];\n    }\n    if (input[_CTS] != null) {\n        const memberEntries = se_ConnectionTrackingSpecificationRequest(input[_CTS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ConnectionTrackingSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_APIAs] != null) {\n        entries[_APIAs] = input[_APIAs];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_De] != null) {\n        const memberEntries = se_AttributeValue(input[_De], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Description.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SDC] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_SDC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SourceDestCheck.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_G] != null) {\n        const memberEntries = se_SecurityGroupIdStringList(input[_G], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Att] != null) {\n        const memberEntries = se_NetworkInterfaceAttachmentChanges(input[_Att], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Attachment.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyPrivateDnsNameOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_PDHT] != null) {\n        entries[_PDHT] = input[_PDHT];\n    }\n    if (input[_ERNDAR] != null) {\n        entries[_ERNDAR] = input[_ERNDAR];\n    }\n    if (input[_ERNDAAAAR] != null) {\n        entries[_ERNDAAAAR] = input[_ERNDAAAAR];\n    }\n    return entries;\n};\nconst se_ModifyPublicIpDnsNameOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_HTo] != null) {\n        entries[_HTo] = input[_HTo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyReservedInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_RIIes] != null) {\n        const memberEntries = se_ReservedInstancesIdStringList(input[_RIIes], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReservedInstancesId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_TC] != null) {\n        const memberEntries = se_ReservedInstancesConfigurationList(input[_TC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReservedInstancesConfigurationSetItemType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyRouteServerRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSIo] != null) {\n        entries[_RSIo] = input[_RSIo];\n    }\n    if (input[_PRe] != null) {\n        entries[_PRe] = input[_PRe];\n    }\n    if (input[_PRD] != null) {\n        entries[_PRD] = input[_PRD];\n    }\n    if (input[_SNE] != null) {\n        entries[_SNE] = input[_SNE];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifySecurityGroupRulesRequest = (input, context) => {\n    const entries = {};\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_SGR] != null) {\n        const memberEntries = se_SecurityGroupRuleUpdateList(input[_SGR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupRule.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifySnapshotAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_CVP] != null) {\n        const memberEntries = se_CreateVolumePermissionModifications(input[_CVP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CreateVolumePermission.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_GNr] != null) {\n        const memberEntries = se_GroupNameStringList(input[_GNr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `UserGroup.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_OTp] != null) {\n        entries[_OTp] = input[_OTp];\n    }\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_UIse] != null) {\n        const memberEntries = se_UserIdStringList(input[_UIse], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `UserId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifySnapshotTierRequest = (input, context) => {\n    const entries = {};\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_STto] != null) {\n        entries[_STto] = input[_STto];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifySpotFleetRequestRequest = (input, context) => {\n    const entries = {};\n    if (input[_LTC] != null) {\n        const memberEntries = se_LaunchTemplateConfigList(input[_LTC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateConfig.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ODTC] != null) {\n        entries[_ODTC] = input[_ODTC];\n    }\n    if (input[_Con] != null) {\n        entries[_Con] = input[_Con];\n    }\n    if (input[_SFRIp] != null) {\n        entries[_SFRIp] = input[_SFRIp];\n    }\n    if (input[_TCa] != null) {\n        entries[_TCa] = input[_TCa];\n    }\n    if (input[_ECTP] != null) {\n        entries[_ECTP] = input[_ECTP];\n    }\n    return entries;\n};\nconst se_ModifySubnetAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIAOC] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_AIAOC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AssignIpv6AddressOnCreation.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MPIOL] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_MPIOL], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MapPublicIpOnLaunch.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_MCOIOL] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_MCOIOL], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MapCustomerOwnedIpOnLaunch.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_COIP] != null) {\n        entries[_COIP] = input[_COIP];\n    }\n    if (input[_EDn] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_EDn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnableDns64.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PDHTOL] != null) {\n        entries[_PDHTOL] = input[_PDHTOL];\n    }\n    if (input[_ERNDAROL] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_ERNDAROL], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnableResourceNameDnsARecordOnLaunch.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ERNDAAAAROL] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_ERNDAAAAROL], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnableResourceNameDnsAAAARecordOnLaunch.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ELADI] != null) {\n        entries[_ELADI] = input[_ELADI];\n    }\n    if (input[_DLADI] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_DLADI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DisableLniAtDeviceIndex.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyTrafficMirrorFilterNetworkServicesRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMFI] != null) {\n        entries[_TMFI] = input[_TMFI];\n    }\n    if (input[_ANS] != null) {\n        const memberEntries = se_TrafficMirrorNetworkServiceList(input[_ANS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddNetworkService.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RNS] != null) {\n        const memberEntries = se_TrafficMirrorNetworkServiceList(input[_RNS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveNetworkService.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyTrafficMirrorFilterRuleRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMFRI] != null) {\n        entries[_TMFRI] = input[_TMFRI];\n    }\n    if (input[_TD] != null) {\n        entries[_TD] = input[_TD];\n    }\n    if (input[_RNu] != null) {\n        entries[_RNu] = input[_RNu];\n    }\n    if (input[_RAu] != null) {\n        entries[_RAu] = input[_RAu];\n    }\n    if (input[_DPR] != null) {\n        const memberEntries = se_TrafficMirrorPortRangeRequest(input[_DPR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DestinationPortRange.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPR] != null) {\n        const memberEntries = se_TrafficMirrorPortRangeRequest(input[_SPR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SourcePortRange.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_SCB] != null) {\n        entries[_SCB] = input[_SCB];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_RF] != null) {\n        const memberEntries = se_TrafficMirrorFilterRuleFieldList(input[_RF], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveField.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyTrafficMirrorSessionRequest = (input, context) => {\n    const entries = {};\n    if (input[_TMSI] != null) {\n        entries[_TMSI] = input[_TMSI];\n    }\n    if (input[_TMTI] != null) {\n        entries[_TMTI] = input[_TMTI];\n    }\n    if (input[_TMFI] != null) {\n        entries[_TMFI] = input[_TMFI];\n    }\n    if (input[_PL] != null) {\n        entries[_PL] = input[_PL];\n    }\n    if (input[_SN] != null) {\n        entries[_SN] = input[_SN];\n    }\n    if (input[_VNI] != null) {\n        entries[_VNI] = input[_VNI];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_RF] != null) {\n        const memberEntries = se_TrafficMirrorSessionFieldList(input[_RF], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveField.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyTransitGatewayOptions = (input, context) => {\n    const entries = {};\n    if (input[_ATGCB] != null) {\n        const memberEntries = se_TransitGatewayCidrBlockStringList(input[_ATGCB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddTransitGatewayCidrBlocks.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RTGCB] != null) {\n        const memberEntries = se_TransitGatewayCidrBlockStringList(input[_RTGCB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveTransitGatewayCidrBlocks.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VES] != null) {\n        entries[_VES] = input[_VES];\n    }\n    if (input[_DSns] != null) {\n        entries[_DSns] = input[_DSns];\n    }\n    if (input[_SGRS] != null) {\n        entries[_SGRS] = input[_SGRS];\n    }\n    if (input[_AASAu] != null) {\n        entries[_AASAu] = input[_AASAu];\n    }\n    if (input[_DRTA] != null) {\n        entries[_DRTA] = input[_DRTA];\n    }\n    if (input[_ADRTI] != null) {\n        entries[_ADRTI] = input[_ADRTI];\n    }\n    if (input[_DRTP] != null) {\n        entries[_DRTP] = input[_DRTP];\n    }\n    if (input[_PDRTI] != null) {\n        entries[_PDRTI] = input[_PDRTI];\n    }\n    if (input[_ASA] != null) {\n        entries[_ASA] = input[_ASA];\n    }\n    return entries;\n};\nconst se_ModifyTransitGatewayPrefixListReferenceRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_PLI] != null) {\n        entries[_PLI] = input[_PLI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_Bl] != null) {\n        entries[_Bl] = input[_Bl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyTransitGatewayRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGI] != null) {\n        entries[_TGI] = input[_TGI];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_Op] != null) {\n        const memberEntries = se_ModifyTransitGatewayOptions(input[_Op], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Options.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyTransitGatewayVpcAttachmentRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_ASI] != null) {\n        const memberEntries = se_TransitGatewaySubnetIdList(input[_ASI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddSubnetIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RSIe] != null) {\n        const memberEntries = se_TransitGatewaySubnetIdList(input[_RSIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveSubnetIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Op] != null) {\n        const memberEntries = se_ModifyTransitGatewayVpcAttachmentRequestOptions(input[_Op], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Options.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyTransitGatewayVpcAttachmentRequestOptions = (input, context) => {\n    const entries = {};\n    if (input[_DSns] != null) {\n        entries[_DSns] = input[_DSns];\n    }\n    if (input[_SGRS] != null) {\n        entries[_SGRS] = input[_SGRS];\n    }\n    if (input[_ISp] != null) {\n        entries[_ISp] = input[_ISp];\n    }\n    if (input[_AMS] != null) {\n        entries[_AMS] = input[_AMS];\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessEndpointCidrOptions = (input, context) => {\n    const entries = {};\n    if (input[_PRo] != null) {\n        const memberEntries = se_ModifyVerifiedAccessEndpointPortRangeList(input[_PRo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PortRange.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessEndpointEniOptions = (input, context) => {\n    const entries = {};\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_Po] != null) {\n        entries[_Po] = input[_Po];\n    }\n    if (input[_PRo] != null) {\n        const memberEntries = se_ModifyVerifiedAccessEndpointPortRangeList(input[_PRo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PortRange.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessEndpointLoadBalancerOptions = (input, context) => {\n    const entries = {};\n    if (input[_SIu] != null) {\n        const memberEntries = se_ModifyVerifiedAccessEndpointSubnetIdList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_Po] != null) {\n        entries[_Po] = input[_Po];\n    }\n    if (input[_PRo] != null) {\n        const memberEntries = se_ModifyVerifiedAccessEndpointPortRangeList(input[_PRo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PortRange.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessEndpointPolicyRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAEI] != null) {\n        entries[_VAEI] = input[_VAEI];\n    }\n    if (input[_PE] != null) {\n        entries[_PE] = input[_PE];\n    }\n    if (input[_PD] != null) {\n        entries[_PD] = input[_PD];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SS] != null) {\n        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SseSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessEndpointPortRange = (input, context) => {\n    const entries = {};\n    if (input[_FP] != null) {\n        entries[_FP] = input[_FP];\n    }\n    if (input[_TP] != null) {\n        entries[_TP] = input[_TP];\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessEndpointPortRangeList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ModifyVerifiedAccessEndpointPortRange(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessEndpointRdsOptions = (input, context) => {\n    const entries = {};\n    if (input[_SIu] != null) {\n        const memberEntries = se_ModifyVerifiedAccessEndpointSubnetIdList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Po] != null) {\n        entries[_Po] = input[_Po];\n    }\n    if (input[_RE] != null) {\n        entries[_RE] = input[_RE];\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAEI] != null) {\n        entries[_VAEI] = input[_VAEI];\n    }\n    if (input[_VAGI] != null) {\n        entries[_VAGI] = input[_VAGI];\n    }\n    if (input[_LBO] != null) {\n        const memberEntries = se_ModifyVerifiedAccessEndpointLoadBalancerOptions(input[_LBO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LoadBalancerOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NIO] != null) {\n        const memberEntries = se_ModifyVerifiedAccessEndpointEniOptions(input[_NIO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterfaceOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RO] != null) {\n        const memberEntries = se_ModifyVerifiedAccessEndpointRdsOptions(input[_RO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RdsOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CO] != null) {\n        const memberEntries = se_ModifyVerifiedAccessEndpointCidrOptions(input[_CO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CidrOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessEndpointSubnetIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessGroupPolicyRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAGI] != null) {\n        entries[_VAGI] = input[_VAGI];\n    }\n    if (input[_PE] != null) {\n        entries[_PE] = input[_PE];\n    }\n    if (input[_PD] != null) {\n        entries[_PD] = input[_PD];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SS] != null) {\n        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SseSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessGroupRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAGI] != null) {\n        entries[_VAGI] = input[_VAGI];\n    }\n    if (input[_VAII] != null) {\n        entries[_VAII] = input[_VAII];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessInstanceLoggingConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAII] != null) {\n        entries[_VAII] = input[_VAII];\n    }\n    if (input[_AL] != null) {\n        const memberEntries = se_VerifiedAccessLogOptions(input[_AL], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AccessLogs.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessInstanceRequest = (input, context) => {\n    const entries = {};\n    if (input[_VAII] != null) {\n        entries[_VAII] = input[_VAII];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_CECSD] != null) {\n        entries[_CECSD] = input[_CECSD];\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessNativeApplicationOidcOptions = (input, context) => {\n    const entries = {};\n    if (input[_PSKE] != null) {\n        entries[_PSKE] = input[_PSKE];\n    }\n    if (input[_I] != null) {\n        entries[_I] = input[_I];\n    }\n    if (input[_AE] != null) {\n        entries[_AE] = input[_AE];\n    }\n    if (input[_TEo] != null) {\n        entries[_TEo] = input[_TEo];\n    }\n    if (input[_UIE] != null) {\n        entries[_UIE] = input[_UIE];\n    }\n    if (input[_CIl] != null) {\n        entries[_CIl] = input[_CIl];\n    }\n    if (input[_CSl] != null) {\n        entries[_CSl] = input[_CSl];\n    }\n    if (input[_Sc] != null) {\n        entries[_Sc] = input[_Sc];\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessTrustProviderDeviceOptions = (input, context) => {\n    const entries = {};\n    if (input[_PSKU] != null) {\n        entries[_PSKU] = input[_PSKU];\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessTrustProviderOidcOptions = (input, context) => {\n    const entries = {};\n    if (input[_I] != null) {\n        entries[_I] = input[_I];\n    }\n    if (input[_AE] != null) {\n        entries[_AE] = input[_AE];\n    }\n    if (input[_TEo] != null) {\n        entries[_TEo] = input[_TEo];\n    }\n    if (input[_UIE] != null) {\n        entries[_UIE] = input[_UIE];\n    }\n    if (input[_CIl] != null) {\n        entries[_CIl] = input[_CIl];\n    }\n    if (input[_CSl] != null) {\n        entries[_CSl] = input[_CSl];\n    }\n    if (input[_Sc] != null) {\n        entries[_Sc] = input[_Sc];\n    }\n    return entries;\n};\nconst se_ModifyVerifiedAccessTrustProviderRequest = (input, context) => {\n    const entries = {};\n    if (input[_VATPI] != null) {\n        entries[_VATPI] = input[_VATPI];\n    }\n    if (input[_OO] != null) {\n        const memberEntries = se_ModifyVerifiedAccessTrustProviderOidcOptions(input[_OO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `OidcOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DOe] != null) {\n        const memberEntries = se_ModifyVerifiedAccessTrustProviderDeviceOptions(input[_DOe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DeviceOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_SS] != null) {\n        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SseSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NAOO] != null) {\n        const memberEntries = se_ModifyVerifiedAccessNativeApplicationOidcOptions(input[_NAOO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NativeApplicationOidcOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVolumeAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_AEIO] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_AEIO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AutoEnableIO.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VIo] != null) {\n        entries[_VIo] = input[_VIo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyVolumeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VIo] != null) {\n        entries[_VIo] = input[_VIo];\n    }\n    if (input[_Siz] != null) {\n        entries[_Siz] = input[_Siz];\n    }\n    if (input[_VT] != null) {\n        entries[_VT] = input[_VT];\n    }\n    if (input[_Io] != null) {\n        entries[_Io] = input[_Io];\n    }\n    if (input[_Th] != null) {\n        entries[_Th] = input[_Th];\n    }\n    if (input[_MAE] != null) {\n        entries[_MAE] = input[_MAE];\n    }\n    return entries;\n};\nconst se_ModifyVpcAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_EDH] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_EDH], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnableDnsHostnames.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EDS] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_EDS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnableDnsSupport.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_ENAUM] != null) {\n        const memberEntries = se_AttributeBooleanValue(input[_ENAUM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnableNetworkAddressUsageMetrics.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVpcBlockPublicAccessExclusionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_EIxc] != null) {\n        entries[_EIxc] = input[_EIxc];\n    }\n    if (input[_IGEM] != null) {\n        entries[_IGEM] = input[_IGEM];\n    }\n    return entries;\n};\nconst se_ModifyVpcBlockPublicAccessOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IGBM] != null) {\n        entries[_IGBM] = input[_IGBM];\n    }\n    return entries;\n};\nconst se_ModifyVpcEndpointConnectionNotificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CNIon] != null) {\n        entries[_CNIon] = input[_CNIon];\n    }\n    if (input[_CNAon] != null) {\n        entries[_CNAon] = input[_CNAon];\n    }\n    if (input[_CEo] != null) {\n        const memberEntries = se_ValueStringList(input[_CEo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ConnectionEvents.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVpcEndpointRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VEIp] != null) {\n        entries[_VEIp] = input[_VEIp];\n    }\n    if (input[_RP] != null) {\n        entries[_RP] = input[_RP];\n    }\n    if (input[_PD] != null) {\n        entries[_PD] = input[_PD];\n    }\n    if (input[_ARTI] != null) {\n        const memberEntries = se_VpcEndpointRouteTableIdList(input[_ARTI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddRouteTableId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RRTI] != null) {\n        const memberEntries = se_VpcEndpointRouteTableIdList(input[_RRTI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveRouteTableId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ASI] != null) {\n        const memberEntries = se_VpcEndpointSubnetIdList(input[_ASI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddSubnetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RSIe] != null) {\n        const memberEntries = se_VpcEndpointSubnetIdList(input[_RSIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveSubnetId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ASGId] != null) {\n        const memberEntries = se_VpcEndpointSecurityGroupIdList(input[_ASGId], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddSecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RSGIe] != null) {\n        const memberEntries = se_VpcEndpointSecurityGroupIdList(input[_RSGIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveSecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IAT] != null) {\n        entries[_IAT] = input[_IAT];\n    }\n    if (input[_DOn] != null) {\n        const memberEntries = se_DnsOptionsSpecification(input[_DOn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DnsOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PDE] != null) {\n        entries[_PDE] = input[_PDE];\n    }\n    if (input[_SC] != null) {\n        const memberEntries = se_SubnetConfigurationsList(input[_SC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetConfiguration.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVpcEndpointServiceConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIe] != null) {\n        entries[_SIe] = input[_SIe];\n    }\n    if (input[_PDN] != null) {\n        entries[_PDN] = input[_PDN];\n    }\n    if (input[_RPDN] != null) {\n        entries[_RPDN] = input[_RPDN];\n    }\n    if (input[_ARc] != null) {\n        entries[_ARc] = input[_ARc];\n    }\n    if (input[_ANLBA] != null) {\n        const memberEntries = se_ValueStringList(input[_ANLBA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddNetworkLoadBalancerArn.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RNLBA] != null) {\n        const memberEntries = se_ValueStringList(input[_RNLBA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveNetworkLoadBalancerArn.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AGLBA] != null) {\n        const memberEntries = se_ValueStringList(input[_AGLBA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddGatewayLoadBalancerArn.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RGLBA] != null) {\n        const memberEntries = se_ValueStringList(input[_RGLBA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveGatewayLoadBalancerArn.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ASIAT] != null) {\n        const memberEntries = se_ValueStringList(input[_ASIAT], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddSupportedIpAddressType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RSIAT] != null) {\n        const memberEntries = se_ValueStringList(input[_RSIAT], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveSupportedIpAddressType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ASR] != null) {\n        const memberEntries = se_ValueStringList(input[_ASR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddSupportedRegion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RSR] != null) {\n        const memberEntries = se_ValueStringList(input[_RSR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveSupportedRegion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVpcEndpointServicePayerResponsibilityRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIe] != null) {\n        entries[_SIe] = input[_SIe];\n    }\n    if (input[_PRa] != null) {\n        entries[_PRa] = input[_PRa];\n    }\n    return entries;\n};\nconst se_ModifyVpcEndpointServicePermissionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIe] != null) {\n        entries[_SIe] = input[_SIe];\n    }\n    if (input[_AAP] != null) {\n        const memberEntries = se_ValueStringList(input[_AAP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AddAllowedPrincipals.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RAP] != null) {\n        const memberEntries = se_ValueStringList(input[_RAP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RemoveAllowedPrincipals.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ModifyVpcPeeringConnectionOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_APCO] != null) {\n        const memberEntries = se_PeeringConnectionOptionsRequest(input[_APCO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AccepterPeeringConnectionOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RPCO] != null) {\n        const memberEntries = se_PeeringConnectionOptionsRequest(input[_RPCO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RequesterPeeringConnectionOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VPCI] != null) {\n        entries[_VPCI] = input[_VPCI];\n    }\n    return entries;\n};\nconst se_ModifyVpcTenancyRequest = (input, context) => {\n    const entries = {};\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_ITns] != null) {\n        entries[_ITns] = input[_ITns];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyVpnConnectionOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_VCI] != null) {\n        entries[_VCI] = input[_VCI];\n    }\n    if (input[_LINC] != null) {\n        entries[_LINC] = input[_LINC];\n    }\n    if (input[_RINC] != null) {\n        entries[_RINC] = input[_RINC];\n    }\n    if (input[_LINCo] != null) {\n        entries[_LINCo] = input[_LINCo];\n    }\n    if (input[_RINCe] != null) {\n        entries[_RINCe] = input[_RINCe];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyVpnConnectionRequest = (input, context) => {\n    const entries = {};\n    if (input[_VCI] != null) {\n        entries[_VCI] = input[_VCI];\n    }\n    if (input[_TGI] != null) {\n        entries[_TGI] = input[_TGI];\n    }\n    if (input[_CGIu] != null) {\n        entries[_CGIu] = input[_CGIu];\n    }\n    if (input[_VGI] != null) {\n        entries[_VGI] = input[_VGI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyVpnTunnelCertificateRequest = (input, context) => {\n    const entries = {};\n    if (input[_VCI] != null) {\n        entries[_VCI] = input[_VCI];\n    }\n    if (input[_VTOIA] != null) {\n        entries[_VTOIA] = input[_VTOIA];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ModifyVpnTunnelOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_VCI] != null) {\n        entries[_VCI] = input[_VCI];\n    }\n    if (input[_VTOIA] != null) {\n        entries[_VTOIA] = input[_VTOIA];\n    }\n    if (input[_TO] != null) {\n        const memberEntries = se_ModifyVpnTunnelOptionsSpecification(input[_TO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TunnelOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_STR] != null) {\n        entries[_STR] = input[_STR];\n    }\n    if (input[_PSKS] != null) {\n        entries[_PSKS] = input[_PSKS];\n    }\n    return entries;\n};\nconst se_ModifyVpnTunnelOptionsSpecification = (input, context) => {\n    const entries = {};\n    if (input[_TIC] != null) {\n        entries[_TIC] = input[_TIC];\n    }\n    if (input[_TIIC] != null) {\n        entries[_TIIC] = input[_TIIC];\n    }\n    if (input[_PSK] != null) {\n        entries[_PSK] = input[_PSK];\n    }\n    if (input[_PLS] != null) {\n        entries[_PLS] = input[_PLS];\n    }\n    if (input[_PLSh] != null) {\n        entries[_PLSh] = input[_PLSh];\n    }\n    if (input[_RMTS] != null) {\n        entries[_RMTS] = input[_RMTS];\n    }\n    if (input[_RFP] != null) {\n        entries[_RFP] = input[_RFP];\n    }\n    if (input[_RWS] != null) {\n        entries[_RWS] = input[_RWS];\n    }\n    if (input[_DPDTS] != null) {\n        entries[_DPDTS] = input[_DPDTS];\n    }\n    if (input[_DPDTA] != null) {\n        entries[_DPDTA] = input[_DPDTA];\n    }\n    if (input[_PEA] != null) {\n        const memberEntries = se_Phase1EncryptionAlgorithmsRequestList(input[_PEA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase1EncryptionAlgorithm.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PEAh] != null) {\n        const memberEntries = se_Phase2EncryptionAlgorithmsRequestList(input[_PEAh], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase2EncryptionAlgorithm.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PIAh] != null) {\n        const memberEntries = se_Phase1IntegrityAlgorithmsRequestList(input[_PIAh], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase1IntegrityAlgorithm.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PIAha] != null) {\n        const memberEntries = se_Phase2IntegrityAlgorithmsRequestList(input[_PIAha], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase2IntegrityAlgorithm.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PDHGN] != null) {\n        const memberEntries = se_Phase1DHGroupNumbersRequestList(input[_PDHGN], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase1DHGroupNumber.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PDHGNh] != null) {\n        const memberEntries = se_Phase2DHGroupNumbersRequestList(input[_PDHGNh], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase2DHGroupNumber.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IKEVe] != null) {\n        const memberEntries = se_IKEVersionsRequestList(input[_IKEVe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IKEVersion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SA] != null) {\n        entries[_SA] = input[_SA];\n    }\n    if (input[_LO] != null) {\n        const memberEntries = se_VpnTunnelLogOptionsSpecification(input[_LO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LogOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ETLC] != null) {\n        entries[_ETLC] = input[_ETLC];\n    }\n    return entries;\n};\nconst se_MonitorInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_MoveAddressToVpcRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PI] != null) {\n        entries[_PI] = input[_PI];\n    }\n    return entries;\n};\nconst se_MoveByoipCidrToIpamRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_IPO] != null) {\n        entries[_IPO] = input[_IPO];\n    }\n    return entries;\n};\nconst se_MoveCapacityReservationInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_SCRI] != null) {\n        entries[_SCRI] = input[_SCRI];\n    }\n    if (input[_DCRI] != null) {\n        entries[_DCRI] = input[_DCRI];\n    }\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    return entries;\n};\nconst se_NatGatewayIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_NetworkAclIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_NetworkBandwidthGbps = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = __serializeFloat(input[_M]);\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = __serializeFloat(input[_Ma]);\n    }\n    return entries;\n};\nconst se_NetworkBandwidthGbpsRequest = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = __serializeFloat(input[_M]);\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = __serializeFloat(input[_Ma]);\n    }\n    return entries;\n};\nconst se_NetworkInsightsAccessScopeAnalysisIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_NetworkInsightsAccessScopeIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_NetworkInsightsAnalysisIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_NetworkInsightsPathIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_NetworkInterfaceAttachmentChanges = (input, context) => {\n    const entries = {};\n    if (input[_DEQC] != null) {\n        entries[_DEQC] = input[_DEQC];\n    }\n    if (input[_EQC] != null) {\n        entries[_EQC] = input[_EQC];\n    }\n    if (input[_AIt] != null) {\n        entries[_AIt] = input[_AIt];\n    }\n    if (input[_DOT] != null) {\n        entries[_DOT] = input[_DOT];\n    }\n    return entries;\n};\nconst se_NetworkInterfaceCount = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_NetworkInterfaceCountRequest = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_NetworkInterfaceIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_NetworkInterfacePermissionIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_NewDhcpConfiguration = (input, context) => {\n    const entries = {};\n    if (input[_Ke] != null) {\n        entries[_Ke] = input[_Ke];\n    }\n    if (input[_Val] != null) {\n        const memberEntries = se_ValueStringList(input[_Val], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Value.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_NewDhcpConfigurationList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_NewDhcpConfiguration(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_OccurrenceDayRequestSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`OccurenceDay.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_OnDemandOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_AS] != null) {\n        entries[_AS] = input[_AS];\n    }\n    if (input[_CRO] != null) {\n        const memberEntries = se_CapacityReservationOptionsRequest(input[_CRO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityReservationOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SITi] != null) {\n        entries[_SITi] = input[_SITi];\n    }\n    if (input[_SAZ] != null) {\n        entries[_SAZ] = input[_SAZ];\n    }\n    if (input[_MTC] != null) {\n        entries[_MTC] = input[_MTC];\n    }\n    if (input[_MTP] != null) {\n        entries[_MTP] = input[_MTP];\n    }\n    return entries;\n};\nconst se_OperatorRequest = (input, context) => {\n    const entries = {};\n    if (input[_Prin] != null) {\n        entries[_Prin] = input[_Prin];\n    }\n    return entries;\n};\nconst se_OrganizationalUnitArnStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`OrganizationalUnitArn.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_OrganizationArnStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`OrganizationArn.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_OutpostLagIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_OwnerStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Owner.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_PacketHeaderStatementRequest = (input, context) => {\n    const entries = {};\n    if (input[_SAo] != null) {\n        const memberEntries = se_ValueStringList(input[_SAo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SourceAddress.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DAes] != null) {\n        const memberEntries = se_ValueStringList(input[_DAes], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DestinationAddress.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPo] != null) {\n        const memberEntries = se_ValueStringList(input[_SPo], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SourcePort.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DPes] != null) {\n        const memberEntries = se_ValueStringList(input[_DPes], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DestinationPort.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPL] != null) {\n        const memberEntries = se_ValueStringList(input[_SPL], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SourcePrefixList.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DPLe] != null) {\n        const memberEntries = se_ValueStringList(input[_DPLe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DestinationPrefixList.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Pro] != null) {\n        const memberEntries = se_ProtocolList(input[_Pro], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Protocol.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_PathRequestFilter = (input, context) => {\n    const entries = {};\n    if (input[_SAou] != null) {\n        entries[_SAou] = input[_SAou];\n    }\n    if (input[_SPR] != null) {\n        const memberEntries = se_RequestFilterPortRange(input[_SPR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SourcePortRange.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DAest] != null) {\n        entries[_DAest] = input[_DAest];\n    }\n    if (input[_DPR] != null) {\n        const memberEntries = se_RequestFilterPortRange(input[_DPR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DestinationPortRange.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_PathStatementRequest = (input, context) => {\n    const entries = {};\n    if (input[_PHS] != null) {\n        const memberEntries = se_PacketHeaderStatementRequest(input[_PHS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PacketHeaderStatement.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RSe] != null) {\n        const memberEntries = se_ResourceStatementRequest(input[_RSe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ResourceStatement.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_PeeringConnectionOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_ADRFRV] != null) {\n        entries[_ADRFRV] = input[_ADRFRV];\n    }\n    if (input[_AEFLCLTRV] != null) {\n        entries[_AEFLCLTRV] = input[_AEFLCLTRV];\n    }\n    if (input[_AEFLVTRCL] != null) {\n        entries[_AEFLVTRCL] = input[_AEFLVTRCL];\n    }\n    return entries;\n};\nconst se_PerformanceFactorReference = (input, context) => {\n    const entries = {};\n    if (input[_IF] != null) {\n        entries[_IF] = input[_IF];\n    }\n    return entries;\n};\nconst se_PerformanceFactorReferenceRequest = (input, context) => {\n    const entries = {};\n    if (input[_IF] != null) {\n        entries[_IF] = input[_IF];\n    }\n    return entries;\n};\nconst se_PerformanceFactorReferenceSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_PerformanceFactorReference(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_PerformanceFactorReferenceSetRequest = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_PerformanceFactorReferenceRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Phase1DHGroupNumbersRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Phase1DHGroupNumbersRequestListValue(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Phase1DHGroupNumbersRequestListValue = (input, context) => {\n    const entries = {};\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_Phase1EncryptionAlgorithmsRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Phase1EncryptionAlgorithmsRequestListValue(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Phase1EncryptionAlgorithmsRequestListValue = (input, context) => {\n    const entries = {};\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_Phase1IntegrityAlgorithmsRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Phase1IntegrityAlgorithmsRequestListValue(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Phase1IntegrityAlgorithmsRequestListValue = (input, context) => {\n    const entries = {};\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_Phase2DHGroupNumbersRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Phase2DHGroupNumbersRequestListValue(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Phase2DHGroupNumbersRequestListValue = (input, context) => {\n    const entries = {};\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_Phase2EncryptionAlgorithmsRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Phase2EncryptionAlgorithmsRequestListValue(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Phase2EncryptionAlgorithmsRequestListValue = (input, context) => {\n    const entries = {};\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_Phase2IntegrityAlgorithmsRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Phase2IntegrityAlgorithmsRequestListValue(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Phase2IntegrityAlgorithmsRequestListValue = (input, context) => {\n    const entries = {};\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_Placement = (input, context) => {\n    const entries = {};\n    if (input[_Af] != null) {\n        entries[_Af] = input[_Af];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_PN] != null) {\n        entries[_PN] = input[_PN];\n    }\n    if (input[_HIo] != null) {\n        entries[_HIo] = input[_HIo];\n    }\n    if (input[_Te] != null) {\n        entries[_Te] = input[_Te];\n    }\n    if (input[_SDp] != null) {\n        entries[_SDp] = input[_SDp];\n    }\n    if (input[_HRGA] != null) {\n        entries[_HRGA] = input[_HRGA];\n    }\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    return entries;\n};\nconst se_PlacementGroupIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`GroupId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_PlacementGroupStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_PortRange = (input, context) => {\n    const entries = {};\n    if (input[_Fr] != null) {\n        entries[_Fr] = input[_Fr];\n    }\n    if (input[_To] != null) {\n        entries[_To] = input[_To];\n    }\n    return entries;\n};\nconst se_PrefixListId = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_PLI] != null) {\n        entries[_PLI] = input[_PLI];\n    }\n    return entries;\n};\nconst se_PrefixListIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_PrefixListId(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_PrefixListResourceIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_PriceScheduleSpecification = (input, context) => {\n    const entries = {};\n    if (input[_Ter] != null) {\n        entries[_Ter] = input[_Ter];\n    }\n    if (input[_Pric] != null) {\n        entries[_Pric] = __serializeFloat(input[_Pric]);\n    }\n    if (input[_CCu] != null) {\n        entries[_CCu] = input[_CCu];\n    }\n    return entries;\n};\nconst se_PriceScheduleSpecificationList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_PriceScheduleSpecification(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_PrivateDnsNameOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_HTo] != null) {\n        entries[_HTo] = input[_HTo];\n    }\n    if (input[_ERNDAR] != null) {\n        entries[_ERNDAR] = input[_ERNDAR];\n    }\n    if (input[_ERNDAAAAR] != null) {\n        entries[_ERNDAAAAR] = input[_ERNDAAAAR];\n    }\n    return entries;\n};\nconst se_PrivateIpAddressConfigSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ScheduledInstancesPrivateIpAddressConfig(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`PrivateIpAddressConfigSet.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_PrivateIpAddressSpecification = (input, context) => {\n    const entries = {};\n    if (input[_Prim] != null) {\n        entries[_Prim] = input[_Prim];\n    }\n    if (input[_PIAr] != null) {\n        entries[_PIAr] = input[_PIAr];\n    }\n    return entries;\n};\nconst se_PrivateIpAddressSpecificationList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_PrivateIpAddressSpecification(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_PrivateIpAddressStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`PrivateIpAddress.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ProductCodeStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ProductCode.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ProductDescriptionList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ProtocolList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ProvisionByoipCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_CAC] != null) {\n        const memberEntries = se_CidrAuthorizationContext(input[_CAC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CidrAuthorizationContext.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PA] != null) {\n        entries[_PA] = input[_PA];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PTS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_PTS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PoolTagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MRu] != null) {\n        entries[_MRu] = input[_MRu];\n    }\n    if (input[_NBG] != null) {\n        entries[_NBG] = input[_NBG];\n    }\n    return entries;\n};\nconst se_ProvisionIpamByoasnRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIp] != null) {\n        entries[_IIp] = input[_IIp];\n    }\n    if (input[_As] != null) {\n        entries[_As] = input[_As];\n    }\n    if (input[_AAC] != null) {\n        const memberEntries = se_AsnAuthorizationContext(input[_AAC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AsnAuthorizationContext.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ProvisionIpamPoolCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_CAC] != null) {\n        const memberEntries = se_IpamCidrAuthorizationContext(input[_CAC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CidrAuthorizationContext.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NL] != null) {\n        entries[_NL] = input[_NL];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_VM] != null) {\n        entries[_VM] = input[_VM];\n    }\n    if (input[_IERVTI] != null) {\n        entries[_IERVTI] = input[_IERVTI];\n    }\n    return entries;\n};\nconst se_ProvisionPublicIpv4PoolCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_PIo] != null) {\n        entries[_PIo] = input[_PIo];\n    }\n    if (input[_NL] != null) {\n        entries[_NL] = input[_NL];\n    }\n    if (input[_NBG] != null) {\n        entries[_NBG] = input[_NBG];\n    }\n    return entries;\n};\nconst se_PublicIpStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`PublicIp.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_PublicIpv4PoolIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_PurchaseCapacityBlockExtensionRequest = (input, context) => {\n    const entries = {};\n    if (input[_CBEOI] != null) {\n        entries[_CBEOI] = input[_CBEOI];\n    }\n    if (input[_CRI] != null) {\n        entries[_CRI] = input[_CRI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_PurchaseCapacityBlockRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CBOI] != null) {\n        entries[_CBOI] = input[_CBOI];\n    }\n    if (input[_IPn] != null) {\n        entries[_IPn] = input[_IPn];\n    }\n    return entries;\n};\nconst se_PurchaseHostReservationRequest = (input, context) => {\n    const entries = {};\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_CCu] != null) {\n        entries[_CCu] = input[_CCu];\n    }\n    if (input[_HIS] != null) {\n        const memberEntries = se_RequestHostIdSet(input[_HIS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `HostIdSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LPi] != null) {\n        entries[_LPi] = input[_LPi];\n    }\n    if (input[_OI] != null) {\n        entries[_OI] = input[_OI];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_PurchaseRequest = (input, context) => {\n    const entries = {};\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    if (input[_PT] != null) {\n        entries[_PT] = input[_PT];\n    }\n    return entries;\n};\nconst se_PurchaseRequestSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_PurchaseRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`PurchaseRequest.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_PurchaseReservedInstancesOfferingRequest = (input, context) => {\n    const entries = {};\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    if (input[_RIOIe] != null) {\n        entries[_RIOIe] = input[_RIOIe];\n    }\n    if (input[_PTu] != null) {\n        entries[_PTu] = __serializeDateTime(input[_PTu]);\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_LPi] != null) {\n        const memberEntries = se_ReservedInstanceLimitPrice(input[_LPi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LimitPrice.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_PurchaseScheduledInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PRu] != null) {\n        const memberEntries = se_PurchaseRequestSet(input[_PRu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PurchaseRequest.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ReasonCodesList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RebootInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_RegionNames = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RegionNameStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`RegionName.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RegisterImageRequest = (input, context) => {\n    const entries = {};\n    if (input[_IL] != null) {\n        entries[_IL] = input[_IL];\n    }\n    if (input[_BPi] != null) {\n        const memberEntries = se_BillingProductList(input[_BPi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BillingProduct.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_BM] != null) {\n        entries[_BM] = input[_BM];\n    }\n    if (input[_TSp] != null) {\n        entries[_TSp] = input[_TSp];\n    }\n    if (input[_UDe] != null) {\n        entries[_UDe] = input[_UDe];\n    }\n    if (input[_ISm] != null) {\n        entries[_ISm] = input[_ISm];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_Arc] != null) {\n        entries[_Arc] = input[_Arc];\n    }\n    if (input[_KI] != null) {\n        entries[_KI] = input[_KI];\n    }\n    if (input[_RIa] != null) {\n        entries[_RIa] = input[_RIa];\n    }\n    if (input[_RDN] != null) {\n        entries[_RDN] = input[_RDN];\n    }\n    if (input[_BDM] != null) {\n        const memberEntries = se_BlockDeviceMappingRequestList(input[_BDM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_VTir] != null) {\n        entries[_VTir] = input[_VTir];\n    }\n    if (input[_SNS] != null) {\n        entries[_SNS] = input[_SNS];\n    }\n    if (input[_ESn] != null) {\n        entries[_ESn] = input[_ESn];\n    }\n    return entries;\n};\nconst se_RegisterInstanceEventNotificationAttributesRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_ITA] != null) {\n        const memberEntries = se_RegisterInstanceTagAttributeRequest(input[_ITA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceTagAttribute.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_RegisterInstanceTagAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_IATOI] != null) {\n        entries[_IATOI] = input[_IATOI];\n    }\n    if (input[_ITK] != null) {\n        const memberEntries = se_InstanceTagKeySet(input[_ITK], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceTagKey.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_RegisterTransitGatewayMulticastGroupMembersRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDI] != null) {\n        entries[_TGMDI] = input[_TGMDI];\n    }\n    if (input[_GIA] != null) {\n        entries[_GIA] = input[_GIA];\n    }\n    if (input[_NIIe] != null) {\n        const memberEntries = se_TransitGatewayNetworkInterfaceIdList(input[_NIIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_RegisterTransitGatewayMulticastGroupSourcesRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDI] != null) {\n        entries[_TGMDI] = input[_TGMDI];\n    }\n    if (input[_GIA] != null) {\n        entries[_GIA] = input[_GIA];\n    }\n    if (input[_NIIe] != null) {\n        const memberEntries = se_TransitGatewayNetworkInterfaceIdList(input[_NIIe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_RejectCapacityReservationBillingOwnershipRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_CRI] != null) {\n        entries[_CRI] = input[_CRI];\n    }\n    return entries;\n};\nconst se_RejectTransitGatewayMulticastDomainAssociationsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDI] != null) {\n        entries[_TGMDI] = input[_TGMDI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_SIu] != null) {\n        const memberEntries = se_ValueStringList(input[_SIu], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SubnetIds.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_RejectTransitGatewayPeeringAttachmentRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_RejectTransitGatewayVpcAttachmentRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_RejectVpcEndpointConnectionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIe] != null) {\n        entries[_SIe] = input[_SIe];\n    }\n    if (input[_VEI] != null) {\n        const memberEntries = se_VpcEndpointIdList(input[_VEI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `VpcEndpointId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_RejectVpcPeeringConnectionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_VPCI] != null) {\n        entries[_VPCI] = input[_VPCI];\n    }\n    return entries;\n};\nconst se_ReleaseAddressRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIl] != null) {\n        entries[_AIl] = input[_AIl];\n    }\n    if (input[_PI] != null) {\n        entries[_PI] = input[_PI];\n    }\n    if (input[_NBG] != null) {\n        entries[_NBG] = input[_NBG];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ReleaseHostsRequest = (input, context) => {\n    const entries = {};\n    if (input[_HI] != null) {\n        const memberEntries = se_RequestHostIdList(input[_HI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `HostId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ReleaseIpamPoolAllocationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IPI] != null) {\n        entries[_IPI] = input[_IPI];\n    }\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_IPAI] != null) {\n        entries[_IPAI] = input[_IPAI];\n    }\n    return entries;\n};\nconst se_RemoveIpamOperatingRegion = (input, context) => {\n    const entries = {};\n    if (input[_RN] != null) {\n        entries[_RN] = input[_RN];\n    }\n    return entries;\n};\nconst se_RemoveIpamOperatingRegionSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_RemoveIpamOperatingRegion(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_RemoveIpamOrganizationalUnitExclusion = (input, context) => {\n    const entries = {};\n    if (input[_OEP] != null) {\n        entries[_OEP] = input[_OEP];\n    }\n    return entries;\n};\nconst se_RemoveIpamOrganizationalUnitExclusionSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_RemoveIpamOrganizationalUnitExclusion(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_RemovePrefixListEntries = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_RemovePrefixListEntry(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_RemovePrefixListEntry = (input, context) => {\n    const entries = {};\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    return entries;\n};\nconst se_ReplaceIamInstanceProfileAssociationRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIP] != null) {\n        const memberEntries = se_IamInstanceProfileSpecification(input[_IIP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IamInstanceProfile.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AIss] != null) {\n        entries[_AIss] = input[_AIss];\n    }\n    return entries;\n};\nconst se_ReplaceImageCriteriaInAllowedImagesSettingsRequest = (input, context) => {\n    const entries = {};\n    if (input[_ICm] != null) {\n        const memberEntries = se_ImageCriterionRequestList(input[_ICm], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ImageCriterion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ReplaceNetworkAclAssociationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_AIss] != null) {\n        entries[_AIss] = input[_AIss];\n    }\n    if (input[_NAI] != null) {\n        entries[_NAI] = input[_NAI];\n    }\n    return entries;\n};\nconst se_ReplaceNetworkAclEntryRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NAI] != null) {\n        entries[_NAI] = input[_NAI];\n    }\n    if (input[_RNu] != null) {\n        entries[_RNu] = input[_RNu];\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_RAu] != null) {\n        entries[_RAu] = input[_RAu];\n    }\n    if (input[_Eg] != null) {\n        entries[_Eg] = input[_Eg];\n    }\n    if (input[_CB] != null) {\n        entries[_CB] = input[_CB];\n    }\n    if (input[_ICB] != null) {\n        entries[_ICB] = input[_ICB];\n    }\n    if (input[_ITC] != null) {\n        const memberEntries = se_IcmpTypeCode(input[_ITC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Icmp.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PR] != null) {\n        const memberEntries = se_PortRange(input[_PR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PortRange.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ReplaceRootVolumeTaskIds = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ReplaceRootVolumeTaskId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ReplaceRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DPLI] != null) {\n        entries[_DPLI] = input[_DPLI];\n    }\n    if (input[_VEIp] != null) {\n        entries[_VEIp] = input[_VEIp];\n    }\n    if (input[_LTo] != null) {\n        entries[_LTo] = input[_LTo];\n    }\n    if (input[_TGI] != null) {\n        entries[_TGI] = input[_TGI];\n    }\n    if (input[_LGI] != null) {\n        entries[_LGI] = input[_LGI];\n    }\n    if (input[_CGI] != null) {\n        entries[_CGI] = input[_CGI];\n    }\n    if (input[_CNAo] != null) {\n        entries[_CNAo] = input[_CNAo];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_RTI] != null) {\n        entries[_RTI] = input[_RTI];\n    }\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_GI] != null) {\n        entries[_GI] = input[_GI];\n    }\n    if (input[_DICB] != null) {\n        entries[_DICB] = input[_DICB];\n    }\n    if (input[_EOIGI] != null) {\n        entries[_EOIGI] = input[_EOIGI];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_VPCI] != null) {\n        entries[_VPCI] = input[_VPCI];\n    }\n    if (input[_NGI] != null) {\n        entries[_NGI] = input[_NGI];\n    }\n    return entries;\n};\nconst se_ReplaceRouteTableAssociationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_AIss] != null) {\n        entries[_AIss] = input[_AIss];\n    }\n    if (input[_RTI] != null) {\n        entries[_RTI] = input[_RTI];\n    }\n    return entries;\n};\nconst se_ReplaceTransitGatewayRouteRequest = (input, context) => {\n    const entries = {};\n    if (input[_DCB] != null) {\n        entries[_DCB] = input[_DCB];\n    }\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_TGAI] != null) {\n        entries[_TGAI] = input[_TGAI];\n    }\n    if (input[_Bl] != null) {\n        entries[_Bl] = input[_Bl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ReplaceVpnTunnelRequest = (input, context) => {\n    const entries = {};\n    if (input[_VCI] != null) {\n        entries[_VCI] = input[_VCI];\n    }\n    if (input[_VTOIA] != null) {\n        entries[_VTOIA] = input[_VTOIA];\n    }\n    if (input[_APM] != null) {\n        entries[_APM] = input[_APM];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ReportInstanceStatusRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_In] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_In], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Statu] != null) {\n        entries[_Statu] = input[_Statu];\n    }\n    if (input[_STt] != null) {\n        entries[_STt] = __serializeDateTime(input[_STt]);\n    }\n    if (input[_ETn] != null) {\n        entries[_ETn] = __serializeDateTime(input[_ETn]);\n    }\n    if (input[_RCe] != null) {\n        const memberEntries = se_ReasonCodesList(input[_RCe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ReasonCode.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    return entries;\n};\nconst se_RequestFilterPortRange = (input, context) => {\n    const entries = {};\n    if (input[_FP] != null) {\n        entries[_FP] = input[_FP];\n    }\n    if (input[_TP] != null) {\n        entries[_TP] = input[_TP];\n    }\n    return entries;\n};\nconst se_RequestHostIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RequestHostIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RequestInstanceTypeList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RequestIpamResourceTag = (input, context) => {\n    const entries = {};\n    if (input[_Ke] != null) {\n        entries[_Ke] = input[_Ke];\n    }\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_RequestIpamResourceTagList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_RequestIpamResourceTag(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_RequestLaunchTemplateData = (input, context) => {\n    const entries = {};\n    if (input[_KI] != null) {\n        entries[_KI] = input[_KI];\n    }\n    if (input[_EO] != null) {\n        entries[_EO] = input[_EO];\n    }\n    if (input[_IIP] != null) {\n        const memberEntries = se_LaunchTemplateIamInstanceProfileSpecificationRequest(input[_IIP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IamInstanceProfile.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_BDM] != null) {\n        const memberEntries = se_LaunchTemplateBlockDeviceMappingRequestList(input[_BDM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NI] != null) {\n        const memberEntries = se_LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList(input[_NI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterface.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_KN] != null) {\n        entries[_KN] = input[_KN];\n    }\n    if (input[_Mon] != null) {\n        const memberEntries = se_LaunchTemplatesMonitoringRequest(input[_Mon], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Monitoring.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Pl] != null) {\n        const memberEntries = se_LaunchTemplatePlacementRequest(input[_Pl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Placement.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RDI] != null) {\n        entries[_RDI] = input[_RDI];\n    }\n    if (input[_DATis] != null) {\n        entries[_DATis] = input[_DATis];\n    }\n    if (input[_IISB] != null) {\n        entries[_IISB] = input[_IISB];\n    }\n    if (input[_UD] != null) {\n        entries[_UD] = input[_UD];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_LaunchTemplateTagSpecificationRequestList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EGS] != null) {\n        const memberEntries = se_ElasticGpuSpecificationList(input[_EGS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ElasticGpuSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EIA] != null) {\n        const memberEntries = se_LaunchTemplateElasticInferenceAcceleratorList(input[_EIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ElasticInferenceAccelerator.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SGI] != null) {\n        const memberEntries = se_SecurityGroupIdStringList(input[_SGI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SG] != null) {\n        const memberEntries = se_SecurityGroupStringList(input[_SG], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroup.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IMO] != null) {\n        const memberEntries = se_LaunchTemplateInstanceMarketOptionsRequest(input[_IMO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceMarketOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CSred] != null) {\n        const memberEntries = se_CreditSpecificationRequest(input[_CSred], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CreditSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_COp] != null) {\n        const memberEntries = se_LaunchTemplateCpuOptionsRequest(input[_COp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CpuOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CRSa] != null) {\n        const memberEntries = se_LaunchTemplateCapacityReservationSpecificationRequest(input[_CRSa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityReservationSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LSi] != null) {\n        const memberEntries = se_LaunchTemplateLicenseSpecificationListRequest(input[_LSi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LicenseSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_HO] != null) {\n        const memberEntries = se_LaunchTemplateHibernationOptionsRequest(input[_HO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `HibernationOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MO] != null) {\n        const memberEntries = se_LaunchTemplateInstanceMetadataOptionsRequest(input[_MO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MetadataOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EOn] != null) {\n        const memberEntries = se_LaunchTemplateEnclaveOptionsRequest(input[_EOn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnclaveOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IR] != null) {\n        const memberEntries = se_InstanceRequirementsRequest(input[_IR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceRequirements.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PDNO] != null) {\n        const memberEntries = se_LaunchTemplatePrivateDnsNameOptionsRequest(input[_PDNO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrivateDnsNameOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MOa] != null) {\n        const memberEntries = se_LaunchTemplateInstanceMaintenanceOptionsRequest(input[_MOa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MaintenanceOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DASi] != null) {\n        entries[_DASi] = input[_DASi];\n    }\n    if (input[_O] != null) {\n        const memberEntries = se_OperatorRequest(input[_O], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Operator.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NPO] != null) {\n        const memberEntries = se_LaunchTemplateNetworkPerformanceOptionsRequest(input[_NPO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkPerformanceOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_RequestSpotFleetRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SFRC] != null) {\n        const memberEntries = se_SpotFleetRequestConfigData(input[_SFRC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SpotFleetRequestConfig.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_RequestSpotInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_LSa] != null) {\n        const memberEntries = se_RequestSpotLaunchSpecification(input[_LSa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIB] != null) {\n        entries[_IIB] = input[_IIB];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SPp] != null) {\n        entries[_SPp] = input[_SPp];\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    if (input[_VF] != null) {\n        entries[_VF] = __serializeDateTime(input[_VF]);\n    }\n    if (input[_VU] != null) {\n        entries[_VU] = __serializeDateTime(input[_VU]);\n    }\n    if (input[_LG] != null) {\n        entries[_LG] = input[_LG];\n    }\n    if (input[_AZG] != null) {\n        entries[_AZG] = input[_AZG];\n    }\n    if (input[_BDMl] != null) {\n        entries[_BDMl] = input[_BDMl];\n    }\n    return entries;\n};\nconst se_RequestSpotLaunchSpecification = (input, context) => {\n    const entries = {};\n    if (input[_SGI] != null) {\n        const memberEntries = se_RequestSpotLaunchSpecificationSecurityGroupIdList(input[_SGI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SG] != null) {\n        const memberEntries = se_RequestSpotLaunchSpecificationSecurityGroupList(input[_SG], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroup.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ATd] != null) {\n        entries[_ATd] = input[_ATd];\n    }\n    if (input[_BDM] != null) {\n        const memberEntries = se_BlockDeviceMappingList(input[_BDM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EO] != null) {\n        entries[_EO] = input[_EO];\n    }\n    if (input[_IIP] != null) {\n        const memberEntries = se_IamInstanceProfileSpecification(input[_IIP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IamInstanceProfile.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_KI] != null) {\n        entries[_KI] = input[_KI];\n    }\n    if (input[_KN] != null) {\n        entries[_KN] = input[_KN];\n    }\n    if (input[_Mon] != null) {\n        const memberEntries = se_RunInstancesMonitoringEnabled(input[_Mon], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Monitoring.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NI] != null) {\n        const memberEntries = se_InstanceNetworkInterfaceSpecificationList(input[_NI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterface.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Pl] != null) {\n        const memberEntries = se_SpotPlacement(input[_Pl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Placement.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RIa] != null) {\n        entries[_RIa] = input[_RIa];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_UD] != null) {\n        entries[_UD] = input[_UD];\n    }\n    return entries;\n};\nconst se_RequestSpotLaunchSpecificationSecurityGroupIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RequestSpotLaunchSpecificationSecurityGroupList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ReservationFleetInstanceSpecification = (input, context) => {\n    const entries = {};\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_IPn] != null) {\n        entries[_IPn] = input[_IPn];\n    }\n    if (input[_W] != null) {\n        entries[_W] = __serializeFloat(input[_W]);\n    }\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_AZI] != null) {\n        entries[_AZI] = input[_AZI];\n    }\n    if (input[_EO] != null) {\n        entries[_EO] = input[_EO];\n    }\n    if (input[_Pri] != null) {\n        entries[_Pri] = input[_Pri];\n    }\n    return entries;\n};\nconst se_ReservationFleetInstanceSpecificationList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ReservationFleetInstanceSpecification(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ReservedInstanceIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ReservedInstanceId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ReservedInstanceLimitPrice = (input, context) => {\n    const entries = {};\n    if (input[_Am] != null) {\n        entries[_Am] = __serializeFloat(input[_Am]);\n    }\n    if (input[_CCu] != null) {\n        entries[_CCu] = input[_CCu];\n    }\n    return entries;\n};\nconst se_ReservedInstancesConfiguration = (input, context) => {\n    const entries = {};\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_Pla] != null) {\n        entries[_Pla] = input[_Pla];\n    }\n    if (input[_Sc] != null) {\n        entries[_Sc] = input[_Sc];\n    }\n    if (input[_AZI] != null) {\n        entries[_AZI] = input[_AZI];\n    }\n    return entries;\n};\nconst se_ReservedInstancesConfigurationList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ReservedInstancesConfiguration(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ReservedInstancesIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ReservedInstancesId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ReservedInstancesModificationIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ReservedInstancesModificationId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ReservedInstancesOfferingIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ResetAddressAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_AIl] != null) {\n        entries[_AIl] = input[_AIl];\n    }\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ResetEbsDefaultKmsKeyIdRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ResetFpgaImageAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_FII] != null) {\n        entries[_FII] = input[_FII];\n    }\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    return entries;\n};\nconst se_ResetImageAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ResetInstanceAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    return entries;\n};\nconst se_ResetNetworkInterfaceAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_SDC] != null) {\n        entries[_SDC] = input[_SDC];\n    }\n    return entries;\n};\nconst se_ResetSnapshotAttributeRequest = (input, context) => {\n    const entries = {};\n    if (input[_At] != null) {\n        entries[_At] = input[_At];\n    }\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ResourceIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ResourceList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ResourceStatementRequest = (input, context) => {\n    const entries = {};\n    if (input[_Re] != null) {\n        const memberEntries = se_ValueStringList(input[_Re], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Resource.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RTeso] != null) {\n        const memberEntries = se_ValueStringList(input[_RTeso], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ResourceType.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_RestorableByStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RestoreAddressToClassicRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PI] != null) {\n        entries[_PI] = input[_PI];\n    }\n    return entries;\n};\nconst se_RestoreImageFromRecycleBinRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_RestoreManagedPrefixListVersionRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_PLI] != null) {\n        entries[_PLI] = input[_PLI];\n    }\n    if (input[_PV] != null) {\n        entries[_PV] = input[_PV];\n    }\n    if (input[_CVu] != null) {\n        entries[_CVu] = input[_CVu];\n    }\n    return entries;\n};\nconst se_RestoreSnapshotFromRecycleBinRequest = (input, context) => {\n    const entries = {};\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_RestoreSnapshotTierRequest = (input, context) => {\n    const entries = {};\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_TRD] != null) {\n        entries[_TRD] = input[_TRD];\n    }\n    if (input[_PRer] != null) {\n        entries[_PRer] = input[_PRer];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_RevokeClientVpnIngressRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_TNC] != null) {\n        entries[_TNC] = input[_TNC];\n    }\n    if (input[_AGI] != null) {\n        entries[_AGI] = input[_AGI];\n    }\n    if (input[_RAG] != null) {\n        entries[_RAG] = input[_RAG];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_RevokeSecurityGroupEgressRequest = (input, context) => {\n    const entries = {};\n    if (input[_SGRI] != null) {\n        const memberEntries = se_SecurityGroupRuleIdList(input[_SGRI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupRuleId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_SSGN] != null) {\n        entries[_SSGN] = input[_SSGN];\n    }\n    if (input[_SSGOI] != null) {\n        entries[_SSGOI] = input[_SSGOI];\n    }\n    if (input[_IPpr] != null) {\n        entries[_IPpr] = input[_IPpr];\n    }\n    if (input[_FP] != null) {\n        entries[_FP] = input[_FP];\n    }\n    if (input[_TP] != null) {\n        entries[_TP] = input[_TP];\n    }\n    if (input[_CIi] != null) {\n        entries[_CIi] = input[_CIi];\n    }\n    if (input[_IPpe] != null) {\n        const memberEntries = se_IpPermissionList(input[_IPpe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpPermissions.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_RevokeSecurityGroupIngressRequest = (input, context) => {\n    const entries = {};\n    if (input[_CIi] != null) {\n        entries[_CIi] = input[_CIi];\n    }\n    if (input[_FP] != null) {\n        entries[_FP] = input[_FP];\n    }\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_IPpe] != null) {\n        const memberEntries = se_IpPermissionList(input[_IPpe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpPermissions.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPpr] != null) {\n        entries[_IPpr] = input[_IPpr];\n    }\n    if (input[_SSGN] != null) {\n        entries[_SSGN] = input[_SSGN];\n    }\n    if (input[_SSGOI] != null) {\n        entries[_SSGOI] = input[_SSGOI];\n    }\n    if (input[_TP] != null) {\n        entries[_TP] = input[_TP];\n    }\n    if (input[_SGRI] != null) {\n        const memberEntries = se_SecurityGroupRuleIdList(input[_SGRI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupRuleId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_RouteServerBgpOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_PAee] != null) {\n        entries[_PAee] = input[_PAee];\n    }\n    if (input[_PLD] != null) {\n        entries[_PLD] = input[_PLD];\n    }\n    return entries;\n};\nconst se_RouteServerEndpointIdsList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RouteServerIdsList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RouteServerPeerIdsList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RouteTableIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_RunInstancesMonitoringEnabled = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    return entries;\n};\nconst se_RunInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_BDM] != null) {\n        const memberEntries = se_BlockDeviceMappingRequestList(input[_BDM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_IAC] != null) {\n        entries[_IAC] = input[_IAC];\n    }\n    if (input[_IA] != null) {\n        const memberEntries = se_InstanceIpv6AddressList(input[_IA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Address.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_KI] != null) {\n        entries[_KI] = input[_KI];\n    }\n    if (input[_KN] != null) {\n        entries[_KN] = input[_KN];\n    }\n    if (input[_MCa] != null) {\n        entries[_MCa] = input[_MCa];\n    }\n    if (input[_MCi] != null) {\n        entries[_MCi] = input[_MCi];\n    }\n    if (input[_Mon] != null) {\n        const memberEntries = se_RunInstancesMonitoringEnabled(input[_Mon], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Monitoring.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Pl] != null) {\n        const memberEntries = se_Placement(input[_Pl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Placement.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RIa] != null) {\n        entries[_RIa] = input[_RIa];\n    }\n    if (input[_SGI] != null) {\n        const memberEntries = se_SecurityGroupIdStringList(input[_SGI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SG] != null) {\n        const memberEntries = se_SecurityGroupStringList(input[_SG], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroup.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_UD] != null) {\n        entries[_UD] = input[_UD];\n    }\n    if (input[_EGSl] != null) {\n        const memberEntries = se_ElasticGpuSpecifications(input[_EGSl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ElasticGpuSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EIA] != null) {\n        const memberEntries = se_ElasticInferenceAccelerators(input[_EIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ElasticInferenceAccelerator.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LTa] != null) {\n        const memberEntries = se_LaunchTemplateSpecification(input[_LTa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplate.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IMO] != null) {\n        const memberEntries = se_InstanceMarketOptionsRequest(input[_IMO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceMarketOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CSred] != null) {\n        const memberEntries = se_CreditSpecificationRequest(input[_CSred], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CreditSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_COp] != null) {\n        const memberEntries = se_CpuOptionsRequest(input[_COp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CpuOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CRSa] != null) {\n        const memberEntries = se_CapacityReservationSpecification(input[_CRSa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityReservationSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_HO] != null) {\n        const memberEntries = se_HibernationOptionsRequest(input[_HO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `HibernationOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LSi] != null) {\n        const memberEntries = se_LicenseSpecificationListRequest(input[_LSi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LicenseSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MO] != null) {\n        const memberEntries = se_InstanceMetadataOptionsRequest(input[_MO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MetadataOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EOn] != null) {\n        const memberEntries = se_EnclaveOptionsRequest(input[_EOn], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EnclaveOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PDNO] != null) {\n        const memberEntries = se_PrivateDnsNameOptionsRequest(input[_PDNO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrivateDnsNameOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MOa] != null) {\n        const memberEntries = se_InstanceMaintenanceOptionsRequest(input[_MOa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MaintenanceOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DASi] != null) {\n        entries[_DASi] = input[_DASi];\n    }\n    if (input[_EPI] != null) {\n        entries[_EPI] = input[_EPI];\n    }\n    if (input[_NPO] != null) {\n        const memberEntries = se_InstanceNetworkPerformanceOptionsRequest(input[_NPO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkPerformanceOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_O] != null) {\n        const memberEntries = se_OperatorRequest(input[_O], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Operator.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_DATis] != null) {\n        entries[_DATis] = input[_DATis];\n    }\n    if (input[_IISB] != null) {\n        entries[_IISB] = input[_IISB];\n    }\n    if (input[_PIAr] != null) {\n        entries[_PIAr] = input[_PIAr];\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_AId] != null) {\n        entries[_AId] = input[_AId];\n    }\n    if (input[_NI] != null) {\n        const memberEntries = se_InstanceNetworkInterfaceSpecificationList(input[_NI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterface.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIP] != null) {\n        const memberEntries = se_IamInstanceProfileSpecification(input[_IIP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IamInstanceProfile.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EO] != null) {\n        entries[_EO] = input[_EO];\n    }\n    return entries;\n};\nconst se_RunScheduledInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    if (input[_LSa] != null) {\n        const memberEntries = se_ScheduledInstancesLaunchSpecification(input[_LSa], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchSpecification.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SIIch] != null) {\n        entries[_SIIch] = input[_SIIch];\n    }\n    return entries;\n};\nconst se_S3ObjectTag = (input, context) => {\n    const entries = {};\n    if (input[_Ke] != null) {\n        entries[_Ke] = input[_Ke];\n    }\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_S3ObjectTagList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_S3ObjectTag(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_S3Storage = (input, context) => {\n    const entries = {};\n    if (input[_AWSAKI] != null) {\n        entries[_AWSAKI] = input[_AWSAKI];\n    }\n    if (input[_B] != null) {\n        entries[_B] = input[_B];\n    }\n    if (input[_Pr] != null) {\n        entries[_Pr] = input[_Pr];\n    }\n    if (input[_UP] != null) {\n        entries[_UP] = context.base64Encoder(input[_UP]);\n    }\n    if (input[_UPS] != null) {\n        entries[_UPS] = input[_UPS];\n    }\n    return entries;\n};\nconst se_ScheduledInstanceIdRequestSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ScheduledInstanceId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ScheduledInstanceRecurrenceRequest = (input, context) => {\n    const entries = {};\n    if (input[_Fre] != null) {\n        entries[_Fre] = input[_Fre];\n    }\n    if (input[_Int] != null) {\n        entries[_Int] = input[_Int];\n    }\n    if (input[_OD] != null) {\n        const memberEntries = se_OccurrenceDayRequestSet(input[_OD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `OccurrenceDay.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ORTE] != null) {\n        entries[_ORTE] = input[_ORTE];\n    }\n    if (input[_OU] != null) {\n        entries[_OU] = input[_OU];\n    }\n    return entries;\n};\nconst se_ScheduledInstancesBlockDeviceMapping = (input, context) => {\n    const entries = {};\n    if (input[_DN] != null) {\n        entries[_DN] = input[_DN];\n    }\n    if (input[_E] != null) {\n        const memberEntries = se_ScheduledInstancesEbs(input[_E], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ebs.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ND] != null) {\n        entries[_ND] = input[_ND];\n    }\n    if (input[_VN] != null) {\n        entries[_VN] = input[_VN];\n    }\n    return entries;\n};\nconst se_ScheduledInstancesBlockDeviceMappingSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ScheduledInstancesBlockDeviceMapping(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`BlockDeviceMapping.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ScheduledInstancesEbs = (input, context) => {\n    const entries = {};\n    if (input[_DOT] != null) {\n        entries[_DOT] = input[_DOT];\n    }\n    if (input[_Enc] != null) {\n        entries[_Enc] = input[_Enc];\n    }\n    if (input[_Io] != null) {\n        entries[_Io] = input[_Io];\n    }\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_VS] != null) {\n        entries[_VS] = input[_VS];\n    }\n    if (input[_VT] != null) {\n        entries[_VT] = input[_VT];\n    }\n    return entries;\n};\nconst se_ScheduledInstancesIamInstanceProfile = (input, context) => {\n    const entries = {};\n    if (input[_Ar] != null) {\n        entries[_Ar] = input[_Ar];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    return entries;\n};\nconst se_ScheduledInstancesIpv6Address = (input, context) => {\n    const entries = {};\n    if (input[_IApv] != null) {\n        entries[_IApv] = input[_IApv];\n    }\n    return entries;\n};\nconst se_ScheduledInstancesIpv6AddressList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ScheduledInstancesIpv6Address(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Ipv6Address.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ScheduledInstancesLaunchSpecification = (input, context) => {\n    const entries = {};\n    if (input[_BDM] != null) {\n        const memberEntries = se_ScheduledInstancesBlockDeviceMappingSet(input[_BDM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EO] != null) {\n        entries[_EO] = input[_EO];\n    }\n    if (input[_IIP] != null) {\n        const memberEntries = se_ScheduledInstancesIamInstanceProfile(input[_IIP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IamInstanceProfile.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_KI] != null) {\n        entries[_KI] = input[_KI];\n    }\n    if (input[_KN] != null) {\n        entries[_KN] = input[_KN];\n    }\n    if (input[_Mon] != null) {\n        const memberEntries = se_ScheduledInstancesMonitoring(input[_Mon], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Monitoring.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NI] != null) {\n        const memberEntries = se_ScheduledInstancesNetworkInterfaceSet(input[_NI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterface.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Pl] != null) {\n        const memberEntries = se_ScheduledInstancesPlacement(input[_Pl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Placement.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RIa] != null) {\n        entries[_RIa] = input[_RIa];\n    }\n    if (input[_SGI] != null) {\n        const memberEntries = se_ScheduledInstancesSecurityGroupIdSet(input[_SGI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_UD] != null) {\n        entries[_UD] = input[_UD];\n    }\n    return entries;\n};\nconst se_ScheduledInstancesMonitoring = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    return entries;\n};\nconst se_ScheduledInstancesNetworkInterface = (input, context) => {\n    const entries = {};\n    if (input[_APIAs] != null) {\n        entries[_APIAs] = input[_APIAs];\n    }\n    if (input[_DOT] != null) {\n        entries[_DOT] = input[_DOT];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_DIev] != null) {\n        entries[_DIev] = input[_DIev];\n    }\n    if (input[_G] != null) {\n        const memberEntries = se_ScheduledInstancesSecurityGroupIdSet(input[_G], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Group.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IAC] != null) {\n        entries[_IAC] = input[_IAC];\n    }\n    if (input[_IA] != null) {\n        const memberEntries = se_ScheduledInstancesIpv6AddressList(input[_IA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Address.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_PIAr] != null) {\n        entries[_PIAr] = input[_PIAr];\n    }\n    if (input[_PIACr] != null) {\n        const memberEntries = se_PrivateIpAddressConfigSet(input[_PIACr], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrivateIpAddressConfig.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPIAC] != null) {\n        entries[_SPIAC] = input[_SPIAC];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    return entries;\n};\nconst se_ScheduledInstancesNetworkInterfaceSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ScheduledInstancesNetworkInterface(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`NetworkInterface.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ScheduledInstancesPlacement = (input, context) => {\n    const entries = {};\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    return entries;\n};\nconst se_ScheduledInstancesPrivateIpAddressConfig = (input, context) => {\n    const entries = {};\n    if (input[_Prim] != null) {\n        entries[_Prim] = input[_Prim];\n    }\n    if (input[_PIAr] != null) {\n        entries[_PIAr] = input[_PIAr];\n    }\n    return entries;\n};\nconst se_ScheduledInstancesSecurityGroupIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`SecurityGroupId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_SearchLocalGatewayRoutesRequest = (input, context) => {\n    const entries = {};\n    if (input[_LGRTI] != null) {\n        entries[_LGRTI] = input[_LGRTI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_SearchTransitGatewayMulticastGroupsRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGMDI] != null) {\n        entries[_TGMDI] = input[_TGMDI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_SearchTransitGatewayRoutesRequest = (input, context) => {\n    const entries = {};\n    if (input[_TGRTI] != null) {\n        entries[_TGRTI] = input[_TGRTI];\n    }\n    if (input[_Fi] != null) {\n        const memberEntries = se_FilterList(input[_Fi], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Filter.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_SecurityGroupIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_SecurityGroupIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`SecurityGroupId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_SecurityGroupIdStringListRequest = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`SecurityGroupId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_SecurityGroupRuleDescription = (input, context) => {\n    const entries = {};\n    if (input[_SGRIe] != null) {\n        entries[_SGRIe] = input[_SGRIe];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    return entries;\n};\nconst se_SecurityGroupRuleDescriptionList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_SecurityGroupRuleDescription(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_SecurityGroupRuleIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_SecurityGroupRuleRequest = (input, context) => {\n    const entries = {};\n    if (input[_IPpr] != null) {\n        entries[_IPpr] = input[_IPpr];\n    }\n    if (input[_FP] != null) {\n        entries[_FP] = input[_FP];\n    }\n    if (input[_TP] != null) {\n        entries[_TP] = input[_TP];\n    }\n    if (input[_CIidr] != null) {\n        entries[_CIidr] = input[_CIidr];\n    }\n    if (input[_CIid] != null) {\n        entries[_CIid] = input[_CIid];\n    }\n    if (input[_PLI] != null) {\n        entries[_PLI] = input[_PLI];\n    }\n    if (input[_RGI] != null) {\n        entries[_RGI] = input[_RGI];\n    }\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    return entries;\n};\nconst se_SecurityGroupRuleUpdate = (input, context) => {\n    const entries = {};\n    if (input[_SGRIe] != null) {\n        entries[_SGRIe] = input[_SGRIe];\n    }\n    if (input[_SGRe] != null) {\n        const memberEntries = se_SecurityGroupRuleRequest(input[_SGRe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupRule.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_SecurityGroupRuleUpdateList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_SecurityGroupRuleUpdate(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_SecurityGroupStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`SecurityGroup.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_SendDiagnosticInterruptRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIn] != null) {\n        entries[_IIn] = input[_IIn];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ServiceLinkVirtualInterfaceIdSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_SlotDateTimeRangeRequest = (input, context) => {\n    const entries = {};\n    if (input[_ETa] != null) {\n        entries[_ETa] = __serializeDateTime(input[_ETa]);\n    }\n    if (input[_LTat] != null) {\n        entries[_LTat] = __serializeDateTime(input[_LTat]);\n    }\n    return entries;\n};\nconst se_SlotStartTimeRangeRequest = (input, context) => {\n    const entries = {};\n    if (input[_ETa] != null) {\n        entries[_ETa] = __serializeDateTime(input[_ETa]);\n    }\n    if (input[_LTat] != null) {\n        entries[_LTat] = __serializeDateTime(input[_LTat]);\n    }\n    return entries;\n};\nconst se_SnapshotDiskContainer = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_Fo] != null) {\n        entries[_Fo] = input[_Fo];\n    }\n    if (input[_U] != null) {\n        entries[_U] = input[_U];\n    }\n    if (input[_UB] != null) {\n        const memberEntries = se_UserBucket(input[_UB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `UserBucket.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_SnapshotIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`SnapshotId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_SpotCapacityRebalance = (input, context) => {\n    const entries = {};\n    if (input[_RS] != null) {\n        entries[_RS] = input[_RS];\n    }\n    if (input[_TDe] != null) {\n        entries[_TDe] = input[_TDe];\n    }\n    return entries;\n};\nconst se_SpotFleetLaunchSpecification = (input, context) => {\n    const entries = {};\n    if (input[_ATd] != null) {\n        entries[_ATd] = input[_ATd];\n    }\n    if (input[_BDM] != null) {\n        const memberEntries = se_BlockDeviceMappingList(input[_BDM], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EO] != null) {\n        entries[_EO] = input[_EO];\n    }\n    if (input[_IIP] != null) {\n        const memberEntries = se_IamInstanceProfileSpecification(input[_IIP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IamInstanceProfile.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIma] != null) {\n        entries[_IIma] = input[_IIma];\n    }\n    if (input[_IT] != null) {\n        entries[_IT] = input[_IT];\n    }\n    if (input[_KI] != null) {\n        entries[_KI] = input[_KI];\n    }\n    if (input[_KN] != null) {\n        entries[_KN] = input[_KN];\n    }\n    if (input[_Mon] != null) {\n        const memberEntries = se_SpotFleetMonitoring(input[_Mon], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Monitoring.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NI] != null) {\n        const memberEntries = se_InstanceNetworkInterfaceSpecificationList(input[_NI], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `NetworkInterfaceSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Pl] != null) {\n        const memberEntries = se_SpotPlacement(input[_Pl], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Placement.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_RIa] != null) {\n        entries[_RIa] = input[_RIa];\n    }\n    if (input[_SPp] != null) {\n        entries[_SPp] = input[_SPp];\n    }\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_UD] != null) {\n        entries[_UD] = input[_UD];\n    }\n    if (input[_WCe] != null) {\n        entries[_WCe] = __serializeFloat(input[_WCe]);\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_SpotFleetTagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecificationSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IR] != null) {\n        const memberEntries = se_InstanceRequirements(input[_IR], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceRequirements.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SG] != null) {\n        const memberEntries = se_GroupIdentifierList(input[_SG], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `GroupSet.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_SpotFleetMonitoring = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    return entries;\n};\nconst se_SpotFleetRequestConfigData = (input, context) => {\n    const entries = {};\n    if (input[_AS] != null) {\n        entries[_AS] = input[_AS];\n    }\n    if (input[_ODAS] != null) {\n        entries[_ODAS] = input[_ODAS];\n    }\n    if (input[_SMS] != null) {\n        const memberEntries = se_SpotMaintenanceStrategies(input[_SMS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SpotMaintenanceStrategies.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    if (input[_ECTP] != null) {\n        entries[_ECTP] = input[_ECTP];\n    }\n    if (input[_FC] != null) {\n        entries[_FC] = __serializeFloat(input[_FC]);\n    }\n    if (input[_ODFC] != null) {\n        entries[_ODFC] = __serializeFloat(input[_ODFC]);\n    }\n    if (input[_IFR] != null) {\n        entries[_IFR] = input[_IFR];\n    }\n    if (input[_LSau] != null) {\n        const memberEntries = se_LaunchSpecsList(input[_LSau], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchSpecifications.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LTC] != null) {\n        const memberEntries = se_LaunchTemplateConfigList(input[_LTC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LaunchTemplateConfigs.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SPp] != null) {\n        entries[_SPp] = input[_SPp];\n    }\n    if (input[_TCa] != null) {\n        entries[_TCa] = input[_TCa];\n    }\n    if (input[_ODTC] != null) {\n        entries[_ODTC] = input[_ODTC];\n    }\n    if (input[_ODMTP] != null) {\n        entries[_ODMTP] = input[_ODMTP];\n    }\n    if (input[_SMTP] != null) {\n        entries[_SMTP] = input[_SMTP];\n    }\n    if (input[_TIWE] != null) {\n        entries[_TIWE] = input[_TIWE];\n    }\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    if (input[_VF] != null) {\n        entries[_VF] = __serializeDateTime(input[_VF]);\n    }\n    if (input[_VU] != null) {\n        entries[_VU] = __serializeDateTime(input[_VU]);\n    }\n    if (input[_RUI] != null) {\n        entries[_RUI] = input[_RUI];\n    }\n    if (input[_IIB] != null) {\n        entries[_IIB] = input[_IIB];\n    }\n    if (input[_LBC] != null) {\n        const memberEntries = se_LoadBalancersConfig(input[_LBC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LoadBalancersConfig.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IPTUC] != null) {\n        entries[_IPTUC] = input[_IPTUC];\n    }\n    if (input[_Con] != null) {\n        entries[_Con] = input[_Con];\n    }\n    if (input[_TCUT] != null) {\n        entries[_TCUT] = input[_TCUT];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_SpotFleetRequestIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_SpotFleetTagSpecification = (input, context) => {\n    const entries = {};\n    if (input[_RT] != null) {\n        entries[_RT] = input[_RT];\n    }\n    if (input[_Ta] != null) {\n        const memberEntries = se_TagList(input[_Ta], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Tag.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_SpotFleetTagSpecificationList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_SpotFleetTagSpecification(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_SpotInstanceRequestIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`SpotInstanceRequestId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_SpotMaintenanceStrategies = (input, context) => {\n    const entries = {};\n    if (input[_CRap] != null) {\n        const memberEntries = se_SpotCapacityRebalance(input[_CRap], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CapacityRebalance.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_SpotMarketOptions = (input, context) => {\n    const entries = {};\n    if (input[_MPa] != null) {\n        entries[_MPa] = input[_MPa];\n    }\n    if (input[_SIT] != null) {\n        entries[_SIT] = input[_SIT];\n    }\n    if (input[_BDMl] != null) {\n        entries[_BDMl] = input[_BDMl];\n    }\n    if (input[_VU] != null) {\n        entries[_VU] = __serializeDateTime(input[_VU]);\n    }\n    if (input[_IIB] != null) {\n        entries[_IIB] = input[_IIB];\n    }\n    return entries;\n};\nconst se_SpotOptionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_AS] != null) {\n        entries[_AS] = input[_AS];\n    }\n    if (input[_MS] != null) {\n        const memberEntries = se_FleetSpotMaintenanceStrategiesRequest(input[_MS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MaintenanceStrategies.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IIB] != null) {\n        entries[_IIB] = input[_IIB];\n    }\n    if (input[_IPTUC] != null) {\n        entries[_IPTUC] = input[_IPTUC];\n    }\n    if (input[_SITi] != null) {\n        entries[_SITi] = input[_SITi];\n    }\n    if (input[_SAZ] != null) {\n        entries[_SAZ] = input[_SAZ];\n    }\n    if (input[_MTC] != null) {\n        entries[_MTC] = input[_MTC];\n    }\n    if (input[_MTP] != null) {\n        entries[_MTP] = input[_MTP];\n    }\n    return entries;\n};\nconst se_SpotPlacement = (input, context) => {\n    const entries = {};\n    if (input[_AZ] != null) {\n        entries[_AZ] = input[_AZ];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_Te] != null) {\n        entries[_Te] = input[_Te];\n    }\n    return entries;\n};\nconst se_StartDeclarativePoliciesReportRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SB] != null) {\n        entries[_SB] = input[_SB];\n    }\n    if (input[_SP] != null) {\n        entries[_SP] = input[_SP];\n    }\n    if (input[_TIa] != null) {\n        entries[_TIa] = input[_TIa];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_StartInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AId] != null) {\n        entries[_AId] = input[_AId];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_StartNetworkInsightsAccessScopeAnalysisRequest = (input, context) => {\n    const entries = {};\n    if (input[_NIASI] != null) {\n        entries[_NIASI] = input[_NIASI];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_StartNetworkInsightsAnalysisRequest = (input, context) => {\n    const entries = {};\n    if (input[_NIPI] != null) {\n        entries[_NIPI] = input[_NIPI];\n    }\n    if (input[_AAd] != null) {\n        const memberEntries = se_ValueStringList(input[_AAd], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AdditionalAccount.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_FIA] != null) {\n        const memberEntries = se_ArnList(input[_FIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `FilterInArn.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_FOA] != null) {\n        const memberEntries = se_ArnList(input[_FOA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `FilterOutArn.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_TS] != null) {\n        const memberEntries = se_TagSpecificationList(input[_TS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagSpecification.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CTl] === undefined) {\n        input[_CTl] = generateIdempotencyToken();\n    }\n    if (input[_CTl] != null) {\n        entries[_CTl] = input[_CTl];\n    }\n    return entries;\n};\nconst se_StartVpcEndpointServicePrivateDnsVerificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_SIe] != null) {\n        entries[_SIe] = input[_SIe];\n    }\n    return entries;\n};\nconst se_StopInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Hi] != null) {\n        entries[_Hi] = input[_Hi];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_F] != null) {\n        entries[_F] = input[_F];\n    }\n    return entries;\n};\nconst se_Storage = (input, context) => {\n    const entries = {};\n    if (input[_S_] != null) {\n        const memberEntries = se_S3Storage(input[_S_], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `S3.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_StorageLocation = (input, context) => {\n    const entries = {};\n    if (input[_B] != null) {\n        entries[_B] = input[_B];\n    }\n    if (input[_Ke] != null) {\n        entries[_Ke] = input[_Ke];\n    }\n    return entries;\n};\nconst se_SubnetConfiguration = (input, context) => {\n    const entries = {};\n    if (input[_SIub] != null) {\n        entries[_SIub] = input[_SIub];\n    }\n    if (input[_Ip] != null) {\n        entries[_Ip] = input[_Ip];\n    }\n    if (input[_Ipv] != null) {\n        entries[_Ipv] = input[_Ipv];\n    }\n    return entries;\n};\nconst se_SubnetConfigurationsList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_SubnetConfiguration(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_SubnetIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`SubnetId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_Tag = (input, context) => {\n    const entries = {};\n    if (input[_Ke] != null) {\n        entries[_Ke] = input[_Ke];\n    }\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_TagList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Tag(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_TagSpecification = (input, context) => {\n    const entries = {};\n    if (input[_RT] != null) {\n        entries[_RT] = input[_RT];\n    }\n    if (input[_Ta] != null) {\n        const memberEntries = se_TagList(input[_Ta], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Tag.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_TagSpecificationList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_TagSpecification(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_TargetCapacitySpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_TTC] != null) {\n        entries[_TTC] = input[_TTC];\n    }\n    if (input[_ODTC] != null) {\n        entries[_ODTC] = input[_ODTC];\n    }\n    if (input[_STC] != null) {\n        entries[_STC] = input[_STC];\n    }\n    if (input[_DTCT] != null) {\n        entries[_DTCT] = input[_DTCT];\n    }\n    if (input[_TCUT] != null) {\n        entries[_TCUT] = input[_TCUT];\n    }\n    return entries;\n};\nconst se_TargetConfigurationRequest = (input, context) => {\n    const entries = {};\n    if (input[_IC] != null) {\n        entries[_IC] = input[_IC];\n    }\n    if (input[_OI] != null) {\n        entries[_OI] = input[_OI];\n    }\n    return entries;\n};\nconst se_TargetConfigurationRequestSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_TargetConfigurationRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`TargetConfigurationRequest.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_TargetGroup = (input, context) => {\n    const entries = {};\n    if (input[_Ar] != null) {\n        entries[_Ar] = input[_Ar];\n    }\n    return entries;\n};\nconst se_TargetGroups = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_TargetGroup(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_TargetGroupsConfig = (input, context) => {\n    const entries = {};\n    if (input[_TG] != null) {\n        const memberEntries = se_TargetGroups(input[_TG], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TargetGroups.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_TerminateClientVpnConnectionsRequest = (input, context) => {\n    const entries = {};\n    if (input[_CVEI] != null) {\n        entries[_CVEI] = input[_CVEI];\n    }\n    if (input[_CIo] != null) {\n        entries[_CIo] = input[_CIo];\n    }\n    if (input[_Us] != null) {\n        entries[_Us] = input[_Us];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_TerminateInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ThroughResourcesStatementRequest = (input, context) => {\n    const entries = {};\n    if (input[_RSe] != null) {\n        const memberEntries = se_ResourceStatementRequest(input[_RSe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ResourceStatement.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ThroughResourcesStatementRequestList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ThroughResourcesStatementRequest(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_TotalLocalStorageGB = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = __serializeFloat(input[_M]);\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = __serializeFloat(input[_Ma]);\n    }\n    return entries;\n};\nconst se_TotalLocalStorageGBRequest = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = __serializeFloat(input[_M]);\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = __serializeFloat(input[_Ma]);\n    }\n    return entries;\n};\nconst se_TrafficMirrorFilterIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TrafficMirrorFilterRuleFieldList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TrafficMirrorFilterRuleIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TrafficMirrorNetworkServiceList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TrafficMirrorPortRangeRequest = (input, context) => {\n    const entries = {};\n    if (input[_FP] != null) {\n        entries[_FP] = input[_FP];\n    }\n    if (input[_TP] != null) {\n        entries[_TP] = input[_TP];\n    }\n    return entries;\n};\nconst se_TrafficMirrorSessionFieldList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TrafficMirrorSessionIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TrafficMirrorTargetIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TransitGatewayAttachmentIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TransitGatewayCidrBlockStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TransitGatewayConnectPeerIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TransitGatewayConnectRequestBgpOptions = (input, context) => {\n    const entries = {};\n    if (input[_PAee] != null) {\n        entries[_PAee] = input[_PAee];\n    }\n    return entries;\n};\nconst se_TransitGatewayIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TransitGatewayMulticastDomainIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TransitGatewayNetworkInterfaceIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TransitGatewayPolicyTableIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TransitGatewayRequestOptions = (input, context) => {\n    const entries = {};\n    if (input[_ASA] != null) {\n        entries[_ASA] = input[_ASA];\n    }\n    if (input[_AASAu] != null) {\n        entries[_AASAu] = input[_AASAu];\n    }\n    if (input[_DRTA] != null) {\n        entries[_DRTA] = input[_DRTA];\n    }\n    if (input[_DRTP] != null) {\n        entries[_DRTP] = input[_DRTP];\n    }\n    if (input[_VES] != null) {\n        entries[_VES] = input[_VES];\n    }\n    if (input[_DSns] != null) {\n        entries[_DSns] = input[_DSns];\n    }\n    if (input[_SGRS] != null) {\n        entries[_SGRS] = input[_SGRS];\n    }\n    if (input[_MSu] != null) {\n        entries[_MSu] = input[_MSu];\n    }\n    if (input[_TGCB] != null) {\n        const memberEntries = se_TransitGatewayCidrBlockStringList(input[_TGCB], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TransitGatewayCidrBlocks.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_TransitGatewayRouteTableAnnouncementIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TransitGatewayRouteTableIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TransitGatewaySubnetIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TrunkInterfaceAssociationIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_UnassignIpv6AddressesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IP] != null) {\n        const memberEntries = se_IpPrefixList(input[_IP], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Prefix.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_IA] != null) {\n        const memberEntries = se_Ipv6AddressList(input[_IA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv6Addresses.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_UnassignPrivateIpAddressesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IPp] != null) {\n        const memberEntries = se_IpPrefixList(input[_IPp], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Ipv4Prefix.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NII] != null) {\n        entries[_NII] = input[_NII];\n    }\n    if (input[_PIA] != null) {\n        const memberEntries = se_PrivateIpAddressStringList(input[_PIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrivateIpAddress.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_UnassignPrivateNatGatewayAddressRequest = (input, context) => {\n    const entries = {};\n    if (input[_NGI] != null) {\n        entries[_NGI] = input[_NGI];\n    }\n    if (input[_PIA] != null) {\n        const memberEntries = se_IpList(input[_PIA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `PrivateIpAddress.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MDDS] != null) {\n        entries[_MDDS] = input[_MDDS];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_UnlockSnapshotRequest = (input, context) => {\n    const entries = {};\n    if (input[_SIn] != null) {\n        entries[_SIn] = input[_SIn];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_UnmonitorInstancesRequest = (input, context) => {\n    const entries = {};\n    if (input[_IIns] != null) {\n        const memberEntries = se_InstanceIdStringList(input[_IIns], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InstanceId.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_UpdateSecurityGroupRuleDescriptionsEgressRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_IPpe] != null) {\n        const memberEntries = se_IpPermissionList(input[_IPpe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpPermissions.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SGRD] != null) {\n        const memberEntries = se_SecurityGroupRuleDescriptionList(input[_SGRD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupRuleDescription.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_UpdateSecurityGroupRuleDescriptionsIngressRequest = (input, context) => {\n    const entries = {};\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_IPpe] != null) {\n        const memberEntries = se_IpPermissionList(input[_IPpe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IpPermissions.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SGRD] != null) {\n        const memberEntries = se_SecurityGroupRuleDescriptionList(input[_SGRD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SecurityGroupRuleDescription.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_UserBucket = (input, context) => {\n    const entries = {};\n    if (input[_SB] != null) {\n        entries[_SB] = input[_SB];\n    }\n    if (input[_SK] != null) {\n        entries[_SK] = input[_SK];\n    }\n    return entries;\n};\nconst se_UserData = (input, context) => {\n    const entries = {};\n    if (input[_Da] != null) {\n        entries[_Da] = input[_Da];\n    }\n    return entries;\n};\nconst se_UserGroupStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`UserGroup.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_UserIdGroupPair = (input, context) => {\n    const entries = {};\n    if (input[_De] != null) {\n        entries[_De] = input[_De];\n    }\n    if (input[_UIs] != null) {\n        entries[_UIs] = input[_UIs];\n    }\n    if (input[_GN] != null) {\n        entries[_GN] = input[_GN];\n    }\n    if (input[_GIr] != null) {\n        entries[_GIr] = input[_GIr];\n    }\n    if (input[_VI] != null) {\n        entries[_VI] = input[_VI];\n    }\n    if (input[_VPCI] != null) {\n        entries[_VPCI] = input[_VPCI];\n    }\n    if (input[_PSe] != null) {\n        entries[_PSe] = input[_PSe];\n    }\n    return entries;\n};\nconst se_UserIdGroupPairList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_UserIdGroupPair(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Item.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_UserIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`UserId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ValueStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VCpuCountRange = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_VCpuCountRangeRequest = (input, context) => {\n    const entries = {};\n    if (input[_M] != null) {\n        entries[_M] = input[_M];\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = input[_Ma];\n    }\n    return entries;\n};\nconst se_VerifiedAccessEndpointIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VerifiedAccessGroupIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VerifiedAccessInstanceIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VerifiedAccessLogCloudWatchLogsDestinationOptions = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    if (input[_LGo] != null) {\n        entries[_LGo] = input[_LGo];\n    }\n    return entries;\n};\nconst se_VerifiedAccessLogKinesisDataFirehoseDestinationOptions = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    if (input[_DSel] != null) {\n        entries[_DSel] = input[_DSel];\n    }\n    return entries;\n};\nconst se_VerifiedAccessLogOptions = (input, context) => {\n    const entries = {};\n    if (input[_S_] != null) {\n        const memberEntries = se_VerifiedAccessLogS3DestinationOptions(input[_S_], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `S3.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_CWL] != null) {\n        const memberEntries = se_VerifiedAccessLogCloudWatchLogsDestinationOptions(input[_CWL], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CloudWatchLogs.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_KDF] != null) {\n        const memberEntries = se_VerifiedAccessLogKinesisDataFirehoseDestinationOptions(input[_KDF], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `KinesisDataFirehose.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LV] != null) {\n        entries[_LV] = input[_LV];\n    }\n    if (input[_ITCn] != null) {\n        entries[_ITCn] = input[_ITCn];\n    }\n    return entries;\n};\nconst se_VerifiedAccessLogS3DestinationOptions = (input, context) => {\n    const entries = {};\n    if (input[_En] != null) {\n        entries[_En] = input[_En];\n    }\n    if (input[_BN] != null) {\n        entries[_BN] = input[_BN];\n    }\n    if (input[_Pr] != null) {\n        entries[_Pr] = input[_Pr];\n    }\n    if (input[_BOu] != null) {\n        entries[_BOu] = input[_BOu];\n    }\n    return entries;\n};\nconst se_VerifiedAccessSseSpecificationRequest = (input, context) => {\n    const entries = {};\n    if (input[_CMKE] != null) {\n        entries[_CMKE] = input[_CMKE];\n    }\n    if (input[_KKA] != null) {\n        entries[_KKA] = input[_KKA];\n    }\n    return entries;\n};\nconst se_VerifiedAccessTrustProviderIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VersionStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VirtualizationTypeSet = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VolumeDetail = (input, context) => {\n    const entries = {};\n    if (input[_Siz] != null) {\n        entries[_Siz] = input[_Siz];\n    }\n    return entries;\n};\nconst se_VolumeIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`VolumeId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpcBlockPublicAccessExclusionIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpcClassicLinkIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`VpcId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpcEndpointIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpcEndpointRouteTableIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpcEndpointSecurityGroupIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpcEndpointServiceIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpcEndpointSubnetIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpcIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`VpcId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpcPeeringConnectionIdList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`Item.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpnConnectionIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`VpnConnectionId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpnConnectionOptionsSpecification = (input, context) => {\n    const entries = {};\n    if (input[_EA] != null) {\n        entries[_EA] = input[_EA];\n    }\n    if (input[_TIIV] != null) {\n        entries[_TIIV] = input[_TIIV];\n    }\n    if (input[_TO] != null) {\n        const memberEntries = se_VpnTunnelOptionsSpecificationsList(input[_TO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TunnelOptions.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_LINC] != null) {\n        entries[_LINC] = input[_LINC];\n    }\n    if (input[_RINC] != null) {\n        entries[_RINC] = input[_RINC];\n    }\n    if (input[_LINCo] != null) {\n        entries[_LINCo] = input[_LINCo];\n    }\n    if (input[_RINCe] != null) {\n        entries[_RINCe] = input[_RINCe];\n    }\n    if (input[_OIAT] != null) {\n        entries[_OIAT] = input[_OIAT];\n    }\n    if (input[_TTGAI] != null) {\n        entries[_TTGAI] = input[_TTGAI];\n    }\n    if (input[_SRO] != null) {\n        entries[_SRO] = input[_SRO];\n    }\n    return entries;\n};\nconst se_VpnGatewayIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`VpnGatewayId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_VpnTunnelLogOptionsSpecification = (input, context) => {\n    const entries = {};\n    if (input[_CWLO] != null) {\n        const memberEntries = se_CloudWatchLogOptionsSpecification(input[_CWLO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `CloudWatchLogOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_VpnTunnelOptionsSpecification = (input, context) => {\n    const entries = {};\n    if (input[_TIC] != null) {\n        entries[_TIC] = input[_TIC];\n    }\n    if (input[_TIIC] != null) {\n        entries[_TIIC] = input[_TIIC];\n    }\n    if (input[_PSK] != null) {\n        entries[_PSK] = input[_PSK];\n    }\n    if (input[_PLS] != null) {\n        entries[_PLS] = input[_PLS];\n    }\n    if (input[_PLSh] != null) {\n        entries[_PLSh] = input[_PLSh];\n    }\n    if (input[_RMTS] != null) {\n        entries[_RMTS] = input[_RMTS];\n    }\n    if (input[_RFP] != null) {\n        entries[_RFP] = input[_RFP];\n    }\n    if (input[_RWS] != null) {\n        entries[_RWS] = input[_RWS];\n    }\n    if (input[_DPDTS] != null) {\n        entries[_DPDTS] = input[_DPDTS];\n    }\n    if (input[_DPDTA] != null) {\n        entries[_DPDTA] = input[_DPDTA];\n    }\n    if (input[_PEA] != null) {\n        const memberEntries = se_Phase1EncryptionAlgorithmsRequestList(input[_PEA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase1EncryptionAlgorithm.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PEAh] != null) {\n        const memberEntries = se_Phase2EncryptionAlgorithmsRequestList(input[_PEAh], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase2EncryptionAlgorithm.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PIAh] != null) {\n        const memberEntries = se_Phase1IntegrityAlgorithmsRequestList(input[_PIAh], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase1IntegrityAlgorithm.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PIAha] != null) {\n        const memberEntries = se_Phase2IntegrityAlgorithmsRequestList(input[_PIAha], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase2IntegrityAlgorithm.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PDHGN] != null) {\n        const memberEntries = se_Phase1DHGroupNumbersRequestList(input[_PDHGN], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase1DHGroupNumber.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_PDHGNh] != null) {\n        const memberEntries = se_Phase2DHGroupNumbersRequestList(input[_PDHGNh], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Phase2DHGroupNumber.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IKEVe] != null) {\n        const memberEntries = se_IKEVersionsRequestList(input[_IKEVe], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IKEVersion.${key.substring(key.indexOf(\".\") + 1)}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SA] != null) {\n        entries[_SA] = input[_SA];\n    }\n    if (input[_LO] != null) {\n        const memberEntries = se_VpnTunnelLogOptionsSpecification(input[_LO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LogOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ETLC] != null) {\n        entries[_ETLC] = input[_ETLC];\n    }\n    return entries;\n};\nconst se_VpnTunnelOptionsSpecificationsList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_VpnTunnelOptionsSpecification(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`Member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_WithdrawByoipCidrRequest = (input, context) => {\n    const entries = {};\n    if (input[_C] != null) {\n        entries[_C] = input[_C];\n    }\n    if (input[_DRr] != null) {\n        entries[_DRr] = input[_DRr];\n    }\n    return entries;\n};\nconst se_ZoneIdStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ZoneId.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_ZoneNameStringList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`ZoneName.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst de_AcceleratorCount = (output, context) => {\n    const contents = {};\n    if (output[_m] != null) {\n        contents[_M] = __strictParseInt32(output[_m]);\n    }\n    if (output[_ma] != null) {\n        contents[_Ma] = __strictParseInt32(output[_ma]);\n    }\n    return contents;\n};\nconst de_AcceleratorManufacturerSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_AcceleratorNameSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_AcceleratorTotalMemoryMiB = (output, context) => {\n    const contents = {};\n    if (output[_m] != null) {\n        contents[_M] = __strictParseInt32(output[_m]);\n    }\n    if (output[_ma] != null) {\n        contents[_Ma] = __strictParseInt32(output[_ma]);\n    }\n    return contents;\n};\nconst de_AcceleratorTypeSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_AcceptAddressTransferResult = (output, context) => {\n    const contents = {};\n    if (output[_aT] != null) {\n        contents[_ATdd] = de_AddressTransfer(output[_aT], context);\n    }\n    return contents;\n};\nconst de_AcceptCapacityReservationBillingOwnershipResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_AcceptReservedInstancesExchangeQuoteResult = (output, context) => {\n    const contents = {};\n    if (output[_eI] != null) {\n        contents[_EIxch] = __expectString(output[_eI]);\n    }\n    return contents;\n};\nconst de_AcceptTransitGatewayMulticastDomainAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output[_a] != null) {\n        contents[_Ass] = de_TransitGatewayMulticastDomainAssociations(output[_a], context);\n    }\n    return contents;\n};\nconst de_AcceptTransitGatewayPeeringAttachmentResult = (output, context) => {\n    const contents = {};\n    if (output[_tGPA] != null) {\n        contents[_TGPA] = de_TransitGatewayPeeringAttachment(output[_tGPA], context);\n    }\n    return contents;\n};\nconst de_AcceptTransitGatewayVpcAttachmentResult = (output, context) => {\n    const contents = {};\n    if (output[_tGVA] != null) {\n        contents[_TGVA] = de_TransitGatewayVpcAttachment(output[_tGVA], context);\n    }\n    return contents;\n};\nconst de_AcceptVpcEndpointConnectionsResult = (output, context) => {\n    const contents = {};\n    if (output.unsuccessful === \"\") {\n        contents[_Un] = [];\n    }\n    else if (output[_u] != null && output[_u][_i] != null) {\n        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);\n    }\n    return contents;\n};\nconst de_AcceptVpcPeeringConnectionResult = (output, context) => {\n    const contents = {};\n    if (output[_vPC] != null) {\n        contents[_VPC] = de_VpcPeeringConnection(output[_vPC], context);\n    }\n    return contents;\n};\nconst de_AccessScopeAnalysisFinding = (output, context) => {\n    const contents = {};\n    if (output[_nIASAI] != null) {\n        contents[_NIASAI] = __expectString(output[_nIASAI]);\n    }\n    if (output[_nIASI] != null) {\n        contents[_NIASI] = __expectString(output[_nIASI]);\n    }\n    if (output[_fI] != null) {\n        contents[_FIi] = __expectString(output[_fI]);\n    }\n    if (output.findingComponentSet === \"\") {\n        contents[_FCi] = [];\n    }\n    else if (output[_fCS] != null && output[_fCS][_i] != null) {\n        contents[_FCi] = de_PathComponentList(__getArrayIfSingleItem(output[_fCS][_i]), context);\n    }\n    return contents;\n};\nconst de_AccessScopeAnalysisFindingList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AccessScopeAnalysisFinding(entry, context);\n    });\n};\nconst de_AccessScopePath = (output, context) => {\n    const contents = {};\n    if (output[_s] != null) {\n        contents[_S] = de_PathStatement(output[_s], context);\n    }\n    if (output[_d] != null) {\n        contents[_D] = de_PathStatement(output[_d], context);\n    }\n    if (output.throughResourceSet === \"\") {\n        contents[_TR] = [];\n    }\n    else if (output[_tRS] != null && output[_tRS][_i] != null) {\n        contents[_TR] = de_ThroughResourcesStatementList(__getArrayIfSingleItem(output[_tRS][_i]), context);\n    }\n    return contents;\n};\nconst de_AccessScopePathList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AccessScopePath(entry, context);\n    });\n};\nconst de_AccountAttribute = (output, context) => {\n    const contents = {};\n    if (output[_aN] != null) {\n        contents[_ANt] = __expectString(output[_aN]);\n    }\n    if (output.attributeValueSet === \"\") {\n        contents[_AVt] = [];\n    }\n    else if (output[_aVS] != null && output[_aVS][_i] != null) {\n        contents[_AVt] = de_AccountAttributeValueList(__getArrayIfSingleItem(output[_aVS][_i]), context);\n    }\n    return contents;\n};\nconst de_AccountAttributeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AccountAttribute(entry, context);\n    });\n};\nconst de_AccountAttributeValue = (output, context) => {\n    const contents = {};\n    if (output[_aV] != null) {\n        contents[_AVtt] = __expectString(output[_aV]);\n    }\n    return contents;\n};\nconst de_AccountAttributeValueList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AccountAttributeValue(entry, context);\n    });\n};\nconst de_ActiveInstance = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_sIRI] != null) {\n        contents[_SIRIp] = __expectString(output[_sIRI]);\n    }\n    if (output[_iH] != null) {\n        contents[_IH] = __expectString(output[_iH]);\n    }\n    return contents;\n};\nconst de_ActiveInstanceSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ActiveInstance(entry, context);\n    });\n};\nconst de_ActiveVpnTunnelStatus = (output, context) => {\n    const contents = {};\n    if (output[_pEA] != null) {\n        contents[_PEAha] = __expectString(output[_pEA]);\n    }\n    if (output[_pEAh] != null) {\n        contents[_PEAhas] = __expectString(output[_pEAh]);\n    }\n    if (output[_pIA] != null) {\n        contents[_PIAhas] = __expectString(output[_pIA]);\n    }\n    if (output[_pIAh] != null) {\n        contents[_PIAhase] = __expectString(output[_pIAh]);\n    }\n    if (output[_pDHG] != null) {\n        contents[_PDHG] = __strictParseInt32(output[_pDHG]);\n    }\n    if (output[_pDHGh] != null) {\n        contents[_PDHGh] = __strictParseInt32(output[_pDHGh]);\n    }\n    if (output[_iV] != null) {\n        contents[_IVk] = __expectString(output[_iV]);\n    }\n    if (output[_pS] != null) {\n        contents[_PSr] = __expectString(output[_pS]);\n    }\n    if (output[_pSR] != null) {\n        contents[_PSR] = __expectString(output[_pSR]);\n    }\n    return contents;\n};\nconst de_AddedPrincipal = (output, context) => {\n    const contents = {};\n    if (output[_pT] != null) {\n        contents[_PTr] = __expectString(output[_pT]);\n    }\n    if (output[_p] != null) {\n        contents[_Prin] = __expectString(output[_p]);\n    }\n    if (output[_sPI] != null) {\n        contents[_SPI] = __expectString(output[_sPI]);\n    }\n    if (output[_sI] != null) {\n        contents[_SIe] = __expectString(output[_sI]);\n    }\n    return contents;\n};\nconst de_AddedPrincipalSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AddedPrincipal(entry, context);\n    });\n};\nconst de_AdditionalDetail = (output, context) => {\n    const contents = {};\n    if (output[_aDT] != null) {\n        contents[_ADT] = __expectString(output[_aDT]);\n    }\n    if (output[_c] != null) {\n        contents[_Com] = de_AnalysisComponent(output[_c], context);\n    }\n    if (output[_vES] != null) {\n        contents[_VESp] = de_AnalysisComponent(output[_vES], context);\n    }\n    if (output.ruleOptionSet === \"\") {\n        contents[_ROu] = [];\n    }\n    else if (output[_rOS] != null && output[_rOS][_i] != null) {\n        contents[_ROu] = de_RuleOptionList(__getArrayIfSingleItem(output[_rOS][_i]), context);\n    }\n    if (output.ruleGroupTypePairSet === \"\") {\n        contents[_RGTP] = [];\n    }\n    else if (output[_rGTPS] != null && output[_rGTPS][_i] != null) {\n        contents[_RGTP] = de_RuleGroupTypePairList(__getArrayIfSingleItem(output[_rGTPS][_i]), context);\n    }\n    if (output.ruleGroupRuleOptionsPairSet === \"\") {\n        contents[_RGROP] = [];\n    }\n    else if (output[_rGROPS] != null && output[_rGROPS][_i] != null) {\n        contents[_RGROP] = de_RuleGroupRuleOptionsPairList(__getArrayIfSingleItem(output[_rGROPS][_i]), context);\n    }\n    if (output[_sN] != null) {\n        contents[_SNe] = __expectString(output[_sN]);\n    }\n    if (output.loadBalancerSet === \"\") {\n        contents[_LB] = [];\n    }\n    else if (output[_lBS] != null && output[_lBS][_i] != null) {\n        contents[_LB] = de_AnalysisComponentList(__getArrayIfSingleItem(output[_lBS][_i]), context);\n    }\n    return contents;\n};\nconst de_AdditionalDetailList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AdditionalDetail(entry, context);\n    });\n};\nconst de_Address = (output, context) => {\n    const contents = {};\n    if (output[_aI] != null) {\n        contents[_AIl] = __expectString(output[_aI]);\n    }\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_do] != null) {\n        contents[_Do] = __expectString(output[_do]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_nIOI] != null) {\n        contents[_NIOI] = __expectString(output[_nIOI]);\n    }\n    if (output[_pIAr] != null) {\n        contents[_PIAr] = __expectString(output[_pIAr]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_pIP] != null) {\n        contents[_PIP] = __expectString(output[_pIP]);\n    }\n    if (output[_nBG] != null) {\n        contents[_NBG] = __expectString(output[_nBG]);\n    }\n    if (output[_cOI] != null) {\n        contents[_COI] = __expectString(output[_cOI]);\n    }\n    if (output[_cOIP] != null) {\n        contents[_COIP] = __expectString(output[_cOIP]);\n    }\n    if (output[_cI] != null) {\n        contents[_CIa] = __expectString(output[_cI]);\n    }\n    if (output[_sM] != null) {\n        contents[_SM] = __expectString(output[_sM]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_pI] != null) {\n        contents[_PI] = __expectString(output[_pI]);\n    }\n    return contents;\n};\nconst de_AddressAttribute = (output, context) => {\n    const contents = {};\n    if (output[_pI] != null) {\n        contents[_PI] = __expectString(output[_pI]);\n    }\n    if (output[_aI] != null) {\n        contents[_AIl] = __expectString(output[_aI]);\n    }\n    if (output[_pR] != null) {\n        contents[_PRt] = __expectString(output[_pR]);\n    }\n    if (output[_pRU] != null) {\n        contents[_PRU] = de_PtrUpdateStatus(output[_pRU], context);\n    }\n    return contents;\n};\nconst de_AddressList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Address(entry, context);\n    });\n};\nconst de_AddressSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AddressAttribute(entry, context);\n    });\n};\nconst de_AddressTransfer = (output, context) => {\n    const contents = {};\n    if (output[_pI] != null) {\n        contents[_PI] = __expectString(output[_pI]);\n    }\n    if (output[_aI] != null) {\n        contents[_AIl] = __expectString(output[_aI]);\n    }\n    if (output[_tAI] != null) {\n        contents[_TAI] = __expectString(output[_tAI]);\n    }\n    if (output[_tOET] != null) {\n        contents[_TOET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tOET]));\n    }\n    if (output[_tOAT] != null) {\n        contents[_TOAT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tOAT]));\n    }\n    if (output[_aTS] != null) {\n        contents[_ATS] = __expectString(output[_aTS]);\n    }\n    return contents;\n};\nconst de_AddressTransferList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AddressTransfer(entry, context);\n    });\n};\nconst de_AdvertiseByoipCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_bC] != null) {\n        contents[_BC] = de_ByoipCidr(output[_bC], context);\n    }\n    return contents;\n};\nconst de_AllocateAddressResult = (output, context) => {\n    const contents = {};\n    if (output[_aI] != null) {\n        contents[_AIl] = __expectString(output[_aI]);\n    }\n    if (output[_pIP] != null) {\n        contents[_PIP] = __expectString(output[_pIP]);\n    }\n    if (output[_nBG] != null) {\n        contents[_NBG] = __expectString(output[_nBG]);\n    }\n    if (output[_do] != null) {\n        contents[_Do] = __expectString(output[_do]);\n    }\n    if (output[_cOI] != null) {\n        contents[_COI] = __expectString(output[_cOI]);\n    }\n    if (output[_cOIP] != null) {\n        contents[_COIP] = __expectString(output[_cOIP]);\n    }\n    if (output[_cI] != null) {\n        contents[_CIa] = __expectString(output[_cI]);\n    }\n    if (output[_pI] != null) {\n        contents[_PI] = __expectString(output[_pI]);\n    }\n    return contents;\n};\nconst de_AllocateHostsResult = (output, context) => {\n    const contents = {};\n    if (output.hostIdSet === \"\") {\n        contents[_HI] = [];\n    }\n    else if (output[_hIS] != null && output[_hIS][_i] != null) {\n        contents[_HI] = de_ResponseHostIdList(__getArrayIfSingleItem(output[_hIS][_i]), context);\n    }\n    return contents;\n};\nconst de_AllocateIpamPoolCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_iPA] != null) {\n        contents[_IPA] = de_IpamPoolAllocation(output[_iPA], context);\n    }\n    return contents;\n};\nconst de_AllowedInstanceTypeSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_AllowedPrincipal = (output, context) => {\n    const contents = {};\n    if (output[_pT] != null) {\n        contents[_PTr] = __expectString(output[_pT]);\n    }\n    if (output[_p] != null) {\n        contents[_Prin] = __expectString(output[_p]);\n    }\n    if (output[_sPI] != null) {\n        contents[_SPI] = __expectString(output[_sPI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_sI] != null) {\n        contents[_SIe] = __expectString(output[_sI]);\n    }\n    return contents;\n};\nconst de_AllowedPrincipalSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AllowedPrincipal(entry, context);\n    });\n};\nconst de_AlternatePathHint = (output, context) => {\n    const contents = {};\n    if (output[_cIo] != null) {\n        contents[_CIom] = __expectString(output[_cIo]);\n    }\n    if (output[_cA] != null) {\n        contents[_CAo] = __expectString(output[_cA]);\n    }\n    return contents;\n};\nconst de_AlternatePathHintList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AlternatePathHint(entry, context);\n    });\n};\nconst de_AnalysisAclRule = (output, context) => {\n    const contents = {};\n    if (output[_ci] != null) {\n        contents[_C] = __expectString(output[_ci]);\n    }\n    if (output[_e] != null) {\n        contents[_Eg] = __parseBoolean(output[_e]);\n    }\n    if (output[_pRo] != null) {\n        contents[_PR] = de_PortRange(output[_pRo], context);\n    }\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    if (output[_rA] != null) {\n        contents[_RAu] = __expectString(output[_rA]);\n    }\n    if (output[_rN] != null) {\n        contents[_RNu] = __strictParseInt32(output[_rN]);\n    }\n    return contents;\n};\nconst de_AnalysisComponent = (output, context) => {\n    const contents = {};\n    if (output[_id] != null) {\n        contents[_Id] = __expectString(output[_id]);\n    }\n    if (output[_ar] != null) {\n        contents[_Ar] = __expectString(output[_ar]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    return contents;\n};\nconst de_AnalysisComponentList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AnalysisComponent(entry, context);\n    });\n};\nconst de_AnalysisLoadBalancerListener = (output, context) => {\n    const contents = {};\n    if (output[_lBP] != null) {\n        contents[_LBP] = __strictParseInt32(output[_lBP]);\n    }\n    if (output[_iP] != null) {\n        contents[_IPns] = __strictParseInt32(output[_iP]);\n    }\n    return contents;\n};\nconst de_AnalysisLoadBalancerTarget = (output, context) => {\n    const contents = {};\n    if (output[_ad] != null) {\n        contents[_Ad] = __expectString(output[_ad]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    if (output[_in] != null) {\n        contents[_Ins] = de_AnalysisComponent(output[_in], context);\n    }\n    if (output[_po] != null) {\n        contents[_Po] = __strictParseInt32(output[_po]);\n    }\n    return contents;\n};\nconst de_AnalysisPacketHeader = (output, context) => {\n    const contents = {};\n    if (output.destinationAddressSet === \"\") {\n        contents[_DAes] = [];\n    }\n    else if (output[_dAS] != null && output[_dAS][_i] != null) {\n        contents[_DAes] = de_IpAddressList(__getArrayIfSingleItem(output[_dAS][_i]), context);\n    }\n    if (output.destinationPortRangeSet === \"\") {\n        contents[_DPRe] = [];\n    }\n    else if (output[_dPRS] != null && output[_dPRS][_i] != null) {\n        contents[_DPRe] = de_PortRangeList(__getArrayIfSingleItem(output[_dPRS][_i]), context);\n    }\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    if (output.sourceAddressSet === \"\") {\n        contents[_SAo] = [];\n    }\n    else if (output[_sAS] != null && output[_sAS][_i] != null) {\n        contents[_SAo] = de_IpAddressList(__getArrayIfSingleItem(output[_sAS][_i]), context);\n    }\n    if (output.sourcePortRangeSet === \"\") {\n        contents[_SPRo] = [];\n    }\n    else if (output[_sPRS] != null && output[_sPRS][_i] != null) {\n        contents[_SPRo] = de_PortRangeList(__getArrayIfSingleItem(output[_sPRS][_i]), context);\n    }\n    return contents;\n};\nconst de_AnalysisRouteTableRoute = (output, context) => {\n    const contents = {};\n    if (output[_dC] != null) {\n        contents[_DCe] = __expectString(output[_dC]);\n    }\n    if (output[_dPLI] != null) {\n        contents[_DPLI] = __expectString(output[_dPLI]);\n    }\n    if (output[_eOIGI] != null) {\n        contents[_EOIGI] = __expectString(output[_eOIGI]);\n    }\n    if (output[_gI] != null) {\n        contents[_GI] = __expectString(output[_gI]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_nGI] != null) {\n        contents[_NGI] = __expectString(output[_nGI]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_o] != null) {\n        contents[_Or] = __expectString(output[_o]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_vPCI] != null) {\n        contents[_VPCI] = __expectString(output[_vPCI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_cGI] != null) {\n        contents[_CGI] = __expectString(output[_cGI]);\n    }\n    if (output[_cNA] != null) {\n        contents[_CNAo] = __expectString(output[_cNA]);\n    }\n    if (output[_lGI] != null) {\n        contents[_LGI] = __expectString(output[_lGI]);\n    }\n    return contents;\n};\nconst de_AnalysisSecurityGroupRule = (output, context) => {\n    const contents = {};\n    if (output[_ci] != null) {\n        contents[_C] = __expectString(output[_ci]);\n    }\n    if (output[_di] != null) {\n        contents[_Di] = __expectString(output[_di]);\n    }\n    if (output[_sGI] != null) {\n        contents[_SGIe] = __expectString(output[_sGI]);\n    }\n    if (output[_pRo] != null) {\n        contents[_PR] = de_PortRange(output[_pRo], context);\n    }\n    if (output[_pLI] != null) {\n        contents[_PLI] = __expectString(output[_pLI]);\n    }\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    return contents;\n};\nconst de_ApplySecurityGroupsToClientVpnTargetNetworkResult = (output, context) => {\n    const contents = {};\n    if (output.securityGroupIds === \"\") {\n        contents[_SGI] = [];\n    }\n    else if (output[_sGIe] != null && output[_sGIe][_i] != null) {\n        contents[_SGI] = de_ClientVpnSecurityGroupIdSet(__getArrayIfSingleItem(output[_sGIe][_i]), context);\n    }\n    return contents;\n};\nconst de_ArchitectureTypeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_ArnList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_AsnAssociation = (output, context) => {\n    const contents = {};\n    if (output[_as] != null) {\n        contents[_As] = __expectString(output[_as]);\n    }\n    if (output[_ci] != null) {\n        contents[_C] = __expectString(output[_ci]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_AsnAssociationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AsnAssociation(entry, context);\n    });\n};\nconst de_AsPath = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_AssignedPrivateIpAddress = (output, context) => {\n    const contents = {};\n    if (output[_pIAr] != null) {\n        contents[_PIAr] = __expectString(output[_pIAr]);\n    }\n    return contents;\n};\nconst de_AssignedPrivateIpAddressList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AssignedPrivateIpAddress(entry, context);\n    });\n};\nconst de_AssignIpv6AddressesResult = (output, context) => {\n    const contents = {};\n    if (output.assignedIpv6Addresses === \"\") {\n        contents[_AIAs] = [];\n    }\n    else if (output[_aIA] != null && output[_aIA][_i] != null) {\n        contents[_AIAs] = de_Ipv6AddressList(__getArrayIfSingleItem(output[_aIA][_i]), context);\n    }\n    if (output.assignedIpv6PrefixSet === \"\") {\n        contents[_AIP] = [];\n    }\n    else if (output[_aIPS] != null && output[_aIPS][_i] != null) {\n        contents[_AIP] = de_IpPrefixList(__getArrayIfSingleItem(output[_aIPS][_i]), context);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    return contents;\n};\nconst de_AssignPrivateIpAddressesResult = (output, context) => {\n    const contents = {};\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output.assignedPrivateIpAddressesSet === \"\") {\n        contents[_APIAss] = [];\n    }\n    else if (output[_aPIAS] != null && output[_aPIAS][_i] != null) {\n        contents[_APIAss] = de_AssignedPrivateIpAddressList(__getArrayIfSingleItem(output[_aPIAS][_i]), context);\n    }\n    if (output.assignedIpv4PrefixSet === \"\") {\n        contents[_AIPs] = [];\n    }\n    else if (output[_aIPSs] != null && output[_aIPSs][_i] != null) {\n        contents[_AIPs] = de_Ipv4PrefixesList(__getArrayIfSingleItem(output[_aIPSs][_i]), context);\n    }\n    return contents;\n};\nconst de_AssignPrivateNatGatewayAddressResult = (output, context) => {\n    const contents = {};\n    if (output[_nGI] != null) {\n        contents[_NGI] = __expectString(output[_nGI]);\n    }\n    if (output.natGatewayAddressSet === \"\") {\n        contents[_NGA] = [];\n    }\n    else if (output[_nGAS] != null && output[_nGAS][_i] != null) {\n        contents[_NGA] = de_NatGatewayAddressList(__getArrayIfSingleItem(output[_nGAS][_i]), context);\n    }\n    return contents;\n};\nconst de_AssociateAddressResult = (output, context) => {\n    const contents = {};\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    return contents;\n};\nconst de_AssociateCapacityReservationBillingOwnerResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_AssociateClientVpnTargetNetworkResult = (output, context) => {\n    const contents = {};\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_AssociationStatus(output[_sta], context);\n    }\n    return contents;\n};\nconst de_AssociatedRole = (output, context) => {\n    const contents = {};\n    if (output[_aRA] != null) {\n        contents[_ARA] = __expectString(output[_aRA]);\n    }\n    if (output[_cSBN] != null) {\n        contents[_CSBN] = __expectString(output[_cSBN]);\n    }\n    if (output[_cSOK] != null) {\n        contents[_CSOK] = __expectString(output[_cSOK]);\n    }\n    if (output[_eKKI] != null) {\n        contents[_EKKI] = __expectString(output[_eKKI]);\n    }\n    return contents;\n};\nconst de_AssociatedRolesList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AssociatedRole(entry, context);\n    });\n};\nconst de_AssociatedTargetNetwork = (output, context) => {\n    const contents = {};\n    if (output[_nI] != null) {\n        contents[_NIe] = __expectString(output[_nI]);\n    }\n    if (output[_nT] != null) {\n        contents[_NTe] = __expectString(output[_nT]);\n    }\n    return contents;\n};\nconst de_AssociatedTargetNetworkSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AssociatedTargetNetwork(entry, context);\n    });\n};\nconst de_AssociateEnclaveCertificateIamRoleResult = (output, context) => {\n    const contents = {};\n    if (output[_cSBN] != null) {\n        contents[_CSBN] = __expectString(output[_cSBN]);\n    }\n    if (output[_cSOK] != null) {\n        contents[_CSOK] = __expectString(output[_cSOK]);\n    }\n    if (output[_eKKI] != null) {\n        contents[_EKKI] = __expectString(output[_eKKI]);\n    }\n    return contents;\n};\nconst de_AssociateIamInstanceProfileResult = (output, context) => {\n    const contents = {};\n    if (output[_iIPA] != null) {\n        contents[_IIPA] = de_IamInstanceProfileAssociation(output[_iIPA], context);\n    }\n    return contents;\n};\nconst de_AssociateInstanceEventWindowResult = (output, context) => {\n    const contents = {};\n    if (output[_iEW] != null) {\n        contents[_IEW] = de_InstanceEventWindow(output[_iEW], context);\n    }\n    return contents;\n};\nconst de_AssociateIpamByoasnResult = (output, context) => {\n    const contents = {};\n    if (output[_aA] != null) {\n        contents[_AAsn] = de_AsnAssociation(output[_aA], context);\n    }\n    return contents;\n};\nconst de_AssociateIpamResourceDiscoveryResult = (output, context) => {\n    const contents = {};\n    if (output[_iRDA] != null) {\n        contents[_IRDA] = de_IpamResourceDiscoveryAssociation(output[_iRDA], context);\n    }\n    return contents;\n};\nconst de_AssociateNatGatewayAddressResult = (output, context) => {\n    const contents = {};\n    if (output[_nGI] != null) {\n        contents[_NGI] = __expectString(output[_nGI]);\n    }\n    if (output.natGatewayAddressSet === \"\") {\n        contents[_NGA] = [];\n    }\n    else if (output[_nGAS] != null && output[_nGAS][_i] != null) {\n        contents[_NGA] = de_NatGatewayAddressList(__getArrayIfSingleItem(output[_nGAS][_i]), context);\n    }\n    return contents;\n};\nconst de_AssociateRouteServerResult = (output, context) => {\n    const contents = {};\n    if (output[_rSA] != null) {\n        contents[_RSAo] = de_RouteServerAssociation(output[_rSA], context);\n    }\n    return contents;\n};\nconst de_AssociateRouteTableResult = (output, context) => {\n    const contents = {};\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_aS] != null) {\n        contents[_ASs] = de_RouteTableAssociationState(output[_aS], context);\n    }\n    return contents;\n};\nconst de_AssociateSecurityGroupVpcResult = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_AssociateSubnetCidrBlockResult = (output, context) => {\n    const contents = {};\n    if (output[_iCBA] != null) {\n        contents[_ICBA] = de_SubnetIpv6CidrBlockAssociation(output[_iCBA], context);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    return contents;\n};\nconst de_AssociateTransitGatewayMulticastDomainResult = (output, context) => {\n    const contents = {};\n    if (output[_a] != null) {\n        contents[_Ass] = de_TransitGatewayMulticastDomainAssociations(output[_a], context);\n    }\n    return contents;\n};\nconst de_AssociateTransitGatewayPolicyTableResult = (output, context) => {\n    const contents = {};\n    if (output[_ass] != null) {\n        contents[_Asso] = de_TransitGatewayPolicyTableAssociation(output[_ass], context);\n    }\n    return contents;\n};\nconst de_AssociateTransitGatewayRouteTableResult = (output, context) => {\n    const contents = {};\n    if (output[_ass] != null) {\n        contents[_Asso] = de_TransitGatewayAssociation(output[_ass], context);\n    }\n    return contents;\n};\nconst de_AssociateTrunkInterfaceResult = (output, context) => {\n    const contents = {};\n    if (output[_iA] != null) {\n        contents[_IAn] = de_TrunkInterfaceAssociation(output[_iA], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_AssociateVpcCidrBlockResult = (output, context) => {\n    const contents = {};\n    if (output[_iCBA] != null) {\n        contents[_ICBA] = de_VpcIpv6CidrBlockAssociation(output[_iCBA], context);\n    }\n    if (output[_cBA] != null) {\n        contents[_CBA] = de_VpcCidrBlockAssociation(output[_cBA], context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    return contents;\n};\nconst de_AssociationStatus = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_AttachClassicLinkVpcResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_AttachmentEnaSrdSpecification = (output, context) => {\n    const contents = {};\n    if (output[_eSE] != null) {\n        contents[_ESE] = __parseBoolean(output[_eSE]);\n    }\n    if (output[_eSUS] != null) {\n        contents[_ESUS] = de_AttachmentEnaSrdUdpSpecification(output[_eSUS], context);\n    }\n    return contents;\n};\nconst de_AttachmentEnaSrdUdpSpecification = (output, context) => {\n    const contents = {};\n    if (output[_eSUE] != null) {\n        contents[_ESUE] = __parseBoolean(output[_eSUE]);\n    }\n    return contents;\n};\nconst de_AttachNetworkInterfaceResult = (output, context) => {\n    const contents = {};\n    if (output[_aIt] != null) {\n        contents[_AIt] = __expectString(output[_aIt]);\n    }\n    if (output[_nCI] != null) {\n        contents[_NCI] = __strictParseInt32(output[_nCI]);\n    }\n    return contents;\n};\nconst de_AttachVerifiedAccessTrustProviderResult = (output, context) => {\n    const contents = {};\n    if (output[_vATP] != null) {\n        contents[_VATP] = de_VerifiedAccessTrustProvider(output[_vATP], context);\n    }\n    if (output[_vAI] != null) {\n        contents[_VAI] = de_VerifiedAccessInstance(output[_vAI], context);\n    }\n    return contents;\n};\nconst de_AttachVpnGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_at] != null) {\n        contents[_VA] = de_VpcAttachment(output[_at], context);\n    }\n    return contents;\n};\nconst de_AttributeBooleanValue = (output, context) => {\n    const contents = {};\n    if (output[_v] != null) {\n        contents[_Va] = __parseBoolean(output[_v]);\n    }\n    return contents;\n};\nconst de_AttributeSummary = (output, context) => {\n    const contents = {};\n    if (output[_aN] != null) {\n        contents[_ANt] = __expectString(output[_aN]);\n    }\n    if (output[_mFV] != null) {\n        contents[_MFV] = __expectString(output[_mFV]);\n    }\n    if (output[_nOMA] != null) {\n        contents[_NOMA] = __strictParseInt32(output[_nOMA]);\n    }\n    if (output[_nOUA] != null) {\n        contents[_NOUA] = __strictParseInt32(output[_nOUA]);\n    }\n    if (output.regionalSummarySet === \"\") {\n        contents[_RSeg] = [];\n    }\n    else if (output[_rSS] != null && output[_rSS][_i] != null) {\n        contents[_RSeg] = de_RegionalSummaryList(__getArrayIfSingleItem(output[_rSS][_i]), context);\n    }\n    return contents;\n};\nconst de_AttributeSummaryList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AttributeSummary(entry, context);\n    });\n};\nconst de_AttributeValue = (output, context) => {\n    const contents = {};\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    return contents;\n};\nconst de_AuthorizationRule = (output, context) => {\n    const contents = {};\n    if (output[_cVEI] != null) {\n        contents[_CVEI] = __expectString(output[_cVEI]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output[_aAc] != null) {\n        contents[_AAc] = __parseBoolean(output[_aAc]);\n    }\n    if (output[_dC] != null) {\n        contents[_DCe] = __expectString(output[_dC]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientVpnAuthorizationRuleStatus(output[_sta], context);\n    }\n    return contents;\n};\nconst de_AuthorizationRuleSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AuthorizationRule(entry, context);\n    });\n};\nconst de_AuthorizeClientVpnIngressResult = (output, context) => {\n    const contents = {};\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientVpnAuthorizationRuleStatus(output[_sta], context);\n    }\n    return contents;\n};\nconst de_AuthorizeSecurityGroupEgressResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    if (output.securityGroupRuleSet === \"\") {\n        contents[_SGR] = [];\n    }\n    else if (output[_sGRS] != null && output[_sGRS][_i] != null) {\n        contents[_SGR] = de_SecurityGroupRuleList(__getArrayIfSingleItem(output[_sGRS][_i]), context);\n    }\n    return contents;\n};\nconst de_AuthorizeSecurityGroupIngressResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    if (output.securityGroupRuleSet === \"\") {\n        contents[_SGR] = [];\n    }\n    else if (output[_sGRS] != null && output[_sGRS][_i] != null) {\n        contents[_SGR] = de_SecurityGroupRuleList(__getArrayIfSingleItem(output[_sGRS][_i]), context);\n    }\n    return contents;\n};\nconst de_AvailabilityZone = (output, context) => {\n    const contents = {};\n    if (output[_oIS] != null) {\n        contents[_OIS] = __expectString(output[_oIS]);\n    }\n    if (output.messageSet === \"\") {\n        contents[_Mes] = [];\n    }\n    else if (output[_mS] != null && output[_mS][_i] != null) {\n        contents[_Mes] = de_AvailabilityZoneMessageList(__getArrayIfSingleItem(output[_mS][_i]), context);\n    }\n    if (output[_rNe] != null) {\n        contents[_RN] = __expectString(output[_rNe]);\n    }\n    if (output[_zN] != null) {\n        contents[_ZNo] = __expectString(output[_zN]);\n    }\n    if (output[_zI] != null) {\n        contents[_ZIo] = __expectString(output[_zI]);\n    }\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    if (output[_nBG] != null) {\n        contents[_NBG] = __expectString(output[_nBG]);\n    }\n    if (output[_zT] != null) {\n        contents[_ZT] = __expectString(output[_zT]);\n    }\n    if (output[_pZN] != null) {\n        contents[_PZN] = __expectString(output[_pZN]);\n    }\n    if (output[_pZI] != null) {\n        contents[_PZI] = __expectString(output[_pZI]);\n    }\n    if (output[_gLN] != null) {\n        contents[_GLN] = __expectString(output[_gLN]);\n    }\n    if (output[_zS] != null) {\n        contents[_Stat] = __expectString(output[_zS]);\n    }\n    return contents;\n};\nconst de_AvailabilityZoneList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AvailabilityZone(entry, context);\n    });\n};\nconst de_AvailabilityZoneMessage = (output, context) => {\n    const contents = {};\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_AvailabilityZoneMessageList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AvailabilityZoneMessage(entry, context);\n    });\n};\nconst de_AvailableCapacity = (output, context) => {\n    const contents = {};\n    if (output.availableInstanceCapacity === \"\") {\n        contents[_AIC] = [];\n    }\n    else if (output[_aIC] != null && output[_aIC][_i] != null) {\n        contents[_AIC] = de_AvailableInstanceCapacityList(__getArrayIfSingleItem(output[_aIC][_i]), context);\n    }\n    if (output[_aVC] != null) {\n        contents[_AVC] = __strictParseInt32(output[_aVC]);\n    }\n    return contents;\n};\nconst de_AvailableInstanceCapacityList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceCapacity(entry, context);\n    });\n};\nconst de_BandwidthWeightingTypeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_BaselineEbsBandwidthMbps = (output, context) => {\n    const contents = {};\n    if (output[_m] != null) {\n        contents[_M] = __strictParseInt32(output[_m]);\n    }\n    if (output[_ma] != null) {\n        contents[_Ma] = __strictParseInt32(output[_ma]);\n    }\n    return contents;\n};\nconst de_BaselinePerformanceFactors = (output, context) => {\n    const contents = {};\n    if (output[_cp] != null) {\n        contents[_Cp] = de_CpuPerformanceFactor(output[_cp], context);\n    }\n    return contents;\n};\nconst de_BlockDeviceMapping = (output, context) => {\n    const contents = {};\n    if (output[_eb] != null) {\n        contents[_E] = de_EbsBlockDevice(output[_eb], context);\n    }\n    if (output[_nD] != null) {\n        contents[_ND] = __expectString(output[_nD]);\n    }\n    if (output[_dN] != null) {\n        contents[_DN] = __expectString(output[_dN]);\n    }\n    if (output[_vN] != null) {\n        contents[_VN] = __expectString(output[_vN]);\n    }\n    return contents;\n};\nconst de_BlockDeviceMappingList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_BlockDeviceMapping(entry, context);\n    });\n};\nconst de_BlockDeviceMappingResponse = (output, context) => {\n    const contents = {};\n    if (output[_dN] != null) {\n        contents[_DN] = __expectString(output[_dN]);\n    }\n    if (output[_vN] != null) {\n        contents[_VN] = __expectString(output[_vN]);\n    }\n    if (output[_eb] != null) {\n        contents[_E] = de_EbsBlockDeviceResponse(output[_eb], context);\n    }\n    if (output[_nD] != null) {\n        contents[_ND] = __expectString(output[_nD]);\n    }\n    return contents;\n};\nconst de_BlockDeviceMappingResponseList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_BlockDeviceMappingResponse(entry, context);\n    });\n};\nconst de_BlockPublicAccessStates = (output, context) => {\n    const contents = {};\n    if (output[_iGBM] != null) {\n        contents[_IGBM] = __expectString(output[_iGBM]);\n    }\n    return contents;\n};\nconst de_BootModeTypeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_BundleInstanceResult = (output, context) => {\n    const contents = {};\n    if (output[_bIT] != null) {\n        contents[_BTu] = de_BundleTask(output[_bIT], context);\n    }\n    return contents;\n};\nconst de_BundleTask = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_bI] != null) {\n        contents[_BIu] = __expectString(output[_bI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sT] != null) {\n        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));\n    }\n    if (output[_uT] != null) {\n        contents[_UTp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uT]));\n    }\n    if (output[_sto] != null) {\n        contents[_St] = de_Storage(output[_sto], context);\n    }\n    if (output[_pro] != null) {\n        contents[_Prog] = __expectString(output[_pro]);\n    }\n    if (output[_er] != null) {\n        contents[_BTE] = de_BundleTaskError(output[_er], context);\n    }\n    return contents;\n};\nconst de_BundleTaskError = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_BundleTaskList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_BundleTask(entry, context);\n    });\n};\nconst de_Byoasn = (output, context) => {\n    const contents = {};\n    if (output[_as] != null) {\n        contents[_As] = __expectString(output[_as]);\n    }\n    if (output[_iIp] != null) {\n        contents[_IIp] = __expectString(output[_iIp]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_ByoasnSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Byoasn(entry, context);\n    });\n};\nconst de_ByoipCidr = (output, context) => {\n    const contents = {};\n    if (output[_ci] != null) {\n        contents[_C] = __expectString(output[_ci]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.asnAssociationSet === \"\") {\n        contents[_AAsns] = [];\n    }\n    else if (output[_aAS] != null && output[_aAS][_i] != null) {\n        contents[_AAsns] = de_AsnAssociationSet(__getArrayIfSingleItem(output[_aAS][_i]), context);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_nBG] != null) {\n        contents[_NBG] = __expectString(output[_nBG]);\n    }\n    return contents;\n};\nconst de_ByoipCidrSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ByoipCidr(entry, context);\n    });\n};\nconst de_CancelBundleTaskResult = (output, context) => {\n    const contents = {};\n    if (output[_bIT] != null) {\n        contents[_BTu] = de_BundleTask(output[_bIT], context);\n    }\n    return contents;\n};\nconst de_CancelCapacityReservationFleetError = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_CancelCapacityReservationFleetsResult = (output, context) => {\n    const contents = {};\n    if (output.successfulFleetCancellationSet === \"\") {\n        contents[_SFC] = [];\n    }\n    else if (output[_sFCS] != null && output[_sFCS][_i] != null) {\n        contents[_SFC] = de_CapacityReservationFleetCancellationStateSet(__getArrayIfSingleItem(output[_sFCS][_i]), context);\n    }\n    if (output.failedFleetCancellationSet === \"\") {\n        contents[_FFC] = [];\n    }\n    else if (output[_fFCS] != null && output[_fFCS][_i] != null) {\n        contents[_FFC] = de_FailedCapacityReservationFleetCancellationResultSet(__getArrayIfSingleItem(output[_fFCS][_i]), context);\n    }\n    return contents;\n};\nconst de_CancelCapacityReservationResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_CancelDeclarativePoliciesReportResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_CancelImageLaunchPermissionResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_CancelImportTaskResult = (output, context) => {\n    const contents = {};\n    if (output[_iTI] != null) {\n        contents[_ITI] = __expectString(output[_iTI]);\n    }\n    if (output[_pSr] != null) {\n        contents[_PSre] = __expectString(output[_pSr]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_CancelledSpotInstanceRequest = (output, context) => {\n    const contents = {};\n    if (output[_sIRI] != null) {\n        contents[_SIRIp] = __expectString(output[_sIRI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_CancelledSpotInstanceRequestList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CancelledSpotInstanceRequest(entry, context);\n    });\n};\nconst de_CancelReservedInstancesListingResult = (output, context) => {\n    const contents = {};\n    if (output.reservedInstancesListingsSet === \"\") {\n        contents[_RIL] = [];\n    }\n    else if (output[_rILS] != null && output[_rILS][_i] != null) {\n        contents[_RIL] = de_ReservedInstancesListingList(__getArrayIfSingleItem(output[_rILS][_i]), context);\n    }\n    return contents;\n};\nconst de_CancelSpotFleetRequestsError = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_CancelSpotFleetRequestsErrorItem = (output, context) => {\n    const contents = {};\n    if (output[_er] != null) {\n        contents[_Er] = de_CancelSpotFleetRequestsError(output[_er], context);\n    }\n    if (output[_sFRI] != null) {\n        contents[_SFRIp] = __expectString(output[_sFRI]);\n    }\n    return contents;\n};\nconst de_CancelSpotFleetRequestsErrorSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CancelSpotFleetRequestsErrorItem(entry, context);\n    });\n};\nconst de_CancelSpotFleetRequestsResponse = (output, context) => {\n    const contents = {};\n    if (output.successfulFleetRequestSet === \"\") {\n        contents[_SFR] = [];\n    }\n    else if (output[_sFRS] != null && output[_sFRS][_i] != null) {\n        contents[_SFR] = de_CancelSpotFleetRequestsSuccessSet(__getArrayIfSingleItem(output[_sFRS][_i]), context);\n    }\n    if (output.unsuccessfulFleetRequestSet === \"\") {\n        contents[_UFR] = [];\n    }\n    else if (output[_uFRS] != null && output[_uFRS][_i] != null) {\n        contents[_UFR] = de_CancelSpotFleetRequestsErrorSet(__getArrayIfSingleItem(output[_uFRS][_i]), context);\n    }\n    return contents;\n};\nconst de_CancelSpotFleetRequestsSuccessItem = (output, context) => {\n    const contents = {};\n    if (output[_cSFRS] != null) {\n        contents[_CSFRS] = __expectString(output[_cSFRS]);\n    }\n    if (output[_pSFRS] != null) {\n        contents[_PSFRS] = __expectString(output[_pSFRS]);\n    }\n    if (output[_sFRI] != null) {\n        contents[_SFRIp] = __expectString(output[_sFRI]);\n    }\n    return contents;\n};\nconst de_CancelSpotFleetRequestsSuccessSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CancelSpotFleetRequestsSuccessItem(entry, context);\n    });\n};\nconst de_CancelSpotInstanceRequestsResult = (output, context) => {\n    const contents = {};\n    if (output.spotInstanceRequestSet === \"\") {\n        contents[_CSIRa] = [];\n    }\n    else if (output[_sIRS] != null && output[_sIRS][_i] != null) {\n        contents[_CSIRa] = de_CancelledSpotInstanceRequestList(__getArrayIfSingleItem(output[_sIRS][_i]), context);\n    }\n    return contents;\n};\nconst de_CapacityAllocation = (output, context) => {\n    const contents = {};\n    if (output[_aTl] != null) {\n        contents[_ATl] = __expectString(output[_aTl]);\n    }\n    if (output[_cou] != null) {\n        contents[_Cou] = __strictParseInt32(output[_cou]);\n    }\n    return contents;\n};\nconst de_CapacityAllocations = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CapacityAllocation(entry, context);\n    });\n};\nconst de_CapacityBlockExtension = (output, context) => {\n    const contents = {};\n    if (output[_cRI] != null) {\n        contents[_CRI] = __expectString(output[_cRI]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_iC] != null) {\n        contents[_IC] = __strictParseInt32(output[_iC]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    if (output[_cBEOI] != null) {\n        contents[_CBEOI] = __expectString(output[_cBEOI]);\n    }\n    if (output[_cBEDH] != null) {\n        contents[_CBEDH] = __strictParseInt32(output[_cBEDH]);\n    }\n    if (output[_cBES] != null) {\n        contents[_CBES] = __expectString(output[_cBES]);\n    }\n    if (output[_cBEPD] != null) {\n        contents[_CBEPD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cBEPD]));\n    }\n    if (output[_cBESD] != null) {\n        contents[_CBESD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cBESD]));\n    }\n    if (output[_cBEED] != null) {\n        contents[_CBEED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cBEED]));\n    }\n    if (output[_uF] != null) {\n        contents[_UF] = __expectString(output[_uF]);\n    }\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    return contents;\n};\nconst de_CapacityBlockExtensionOffering = (output, context) => {\n    const contents = {};\n    if (output[_cBEOI] != null) {\n        contents[_CBEOI] = __expectString(output[_cBEOI]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_iC] != null) {\n        contents[_IC] = __strictParseInt32(output[_iC]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    if (output[_sD] != null) {\n        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));\n    }\n    if (output[_cBESD] != null) {\n        contents[_CBESD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cBESD]));\n    }\n    if (output[_cBEED] != null) {\n        contents[_CBEED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cBEED]));\n    }\n    if (output[_cBEDH] != null) {\n        contents[_CBEDH] = __strictParseInt32(output[_cBEDH]);\n    }\n    if (output[_uF] != null) {\n        contents[_UF] = __expectString(output[_uF]);\n    }\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    if (output[_t] != null) {\n        contents[_Te] = __expectString(output[_t]);\n    }\n    return contents;\n};\nconst de_CapacityBlockExtensionOfferingSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CapacityBlockExtensionOffering(entry, context);\n    });\n};\nconst de_CapacityBlockExtensionSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CapacityBlockExtension(entry, context);\n    });\n};\nconst de_CapacityBlockOffering = (output, context) => {\n    const contents = {};\n    if (output[_cBOI] != null) {\n        contents[_CBOI] = __expectString(output[_cBOI]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_iC] != null) {\n        contents[_IC] = __strictParseInt32(output[_iC]);\n    }\n    if (output[_sD] != null) {\n        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));\n    }\n    if (output[_eD] != null) {\n        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));\n    }\n    if (output[_cBDH] != null) {\n        contents[_CBDH] = __strictParseInt32(output[_cBDH]);\n    }\n    if (output[_uF] != null) {\n        contents[_UF] = __expectString(output[_uF]);\n    }\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    if (output[_t] != null) {\n        contents[_Te] = __expectString(output[_t]);\n    }\n    if (output[_cBDM] != null) {\n        contents[_CBDM] = __strictParseInt32(output[_cBDM]);\n    }\n    return contents;\n};\nconst de_CapacityBlockOfferingSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CapacityBlockOffering(entry, context);\n    });\n};\nconst de_CapacityReservation = (output, context) => {\n    const contents = {};\n    if (output[_cRI] != null) {\n        contents[_CRI] = __expectString(output[_cRI]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_cRA] != null) {\n        contents[_CRA] = __expectString(output[_cRA]);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_iPn] != null) {\n        contents[_IPn] = __expectString(output[_iPn]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_t] != null) {\n        contents[_Te] = __expectString(output[_t]);\n    }\n    if (output[_tIC] != null) {\n        contents[_TICo] = __strictParseInt32(output[_tIC]);\n    }\n    if (output[_aICv] != null) {\n        contents[_AICv] = __strictParseInt32(output[_aICv]);\n    }\n    if (output[_eO] != null) {\n        contents[_EO] = __parseBoolean(output[_eO]);\n    }\n    if (output[_eS] != null) {\n        contents[_ES] = __parseBoolean(output[_eS]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sD] != null) {\n        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));\n    }\n    if (output[_eD] != null) {\n        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));\n    }\n    if (output[_eDT] != null) {\n        contents[_EDT] = __expectString(output[_eDT]);\n    }\n    if (output[_iMC] != null) {\n        contents[_IMC] = __expectString(output[_iMC]);\n    }\n    if (output[_cD] != null) {\n        contents[_CDr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cD]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_cRFI] != null) {\n        contents[_CRFIa] = __expectString(output[_cRFI]);\n    }\n    if (output[_pGA] != null) {\n        contents[_PGA] = __expectString(output[_pGA]);\n    }\n    if (output.capacityAllocationSet === \"\") {\n        contents[_CAa] = [];\n    }\n    else if (output[_cAS] != null && output[_cAS][_i] != null) {\n        contents[_CAa] = de_CapacityAllocations(__getArrayIfSingleItem(output[_cAS][_i]), context);\n    }\n    if (output[_rT] != null) {\n        contents[_RTe] = __expectString(output[_rT]);\n    }\n    if (output[_uRBOI] != null) {\n        contents[_URBOI] = __expectString(output[_uRBOI]);\n    }\n    if (output[_cIom] != null) {\n        contents[_CIomm] = de_CapacityReservationCommitmentInfo(output[_cIom], context);\n    }\n    if (output[_dP] != null) {\n        contents[_DP] = __expectString(output[_dP]);\n    }\n    return contents;\n};\nconst de_CapacityReservationBillingRequest = (output, context) => {\n    const contents = {};\n    if (output[_cRI] != null) {\n        contents[_CRI] = __expectString(output[_cRI]);\n    }\n    if (output[_rB] != null) {\n        contents[_RB] = __expectString(output[_rB]);\n    }\n    if (output[_uRBOI] != null) {\n        contents[_URBOI] = __expectString(output[_uRBOI]);\n    }\n    if (output[_lUT] != null) {\n        contents[_LUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lUT]));\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_cRIa] != null) {\n        contents[_CRIap] = de_CapacityReservationInfo(output[_cRIa], context);\n    }\n    return contents;\n};\nconst de_CapacityReservationBillingRequestSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CapacityReservationBillingRequest(entry, context);\n    });\n};\nconst de_CapacityReservationCommitmentInfo = (output, context) => {\n    const contents = {};\n    if (output[_cIC] != null) {\n        contents[_CIC] = __strictParseInt32(output[_cIC]);\n    }\n    if (output[_cED] != null) {\n        contents[_CED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cED]));\n    }\n    return contents;\n};\nconst de_CapacityReservationFleet = (output, context) => {\n    const contents = {};\n    if (output[_cRFI] != null) {\n        contents[_CRFIa] = __expectString(output[_cRFI]);\n    }\n    if (output[_cRFA] != null) {\n        contents[_CRFA] = __expectString(output[_cRFA]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_tTC] != null) {\n        contents[_TTC] = __strictParseInt32(output[_tTC]);\n    }\n    if (output[_tFC] != null) {\n        contents[_TFC] = __strictParseFloat(output[_tFC]);\n    }\n    if (output[_t] != null) {\n        contents[_Te] = __expectString(output[_t]);\n    }\n    if (output[_eD] != null) {\n        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));\n    }\n    if (output[_cTr] != null) {\n        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));\n    }\n    if (output[_iMC] != null) {\n        contents[_IMC] = __expectString(output[_iMC]);\n    }\n    if (output[_aSl] != null) {\n        contents[_AS] = __expectString(output[_aSl]);\n    }\n    if (output.instanceTypeSpecificationSet === \"\") {\n        contents[_ITS] = [];\n    }\n    else if (output[_iTSS] != null && output[_iTSS][_i] != null) {\n        contents[_ITS] = de_FleetCapacityReservationSet(__getArrayIfSingleItem(output[_iTSS][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_CapacityReservationFleetCancellationState = (output, context) => {\n    const contents = {};\n    if (output[_cFS] != null) {\n        contents[_CFS] = __expectString(output[_cFS]);\n    }\n    if (output[_pFS] != null) {\n        contents[_PFS] = __expectString(output[_pFS]);\n    }\n    if (output[_cRFI] != null) {\n        contents[_CRFIa] = __expectString(output[_cRFI]);\n    }\n    return contents;\n};\nconst de_CapacityReservationFleetCancellationStateSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CapacityReservationFleetCancellationState(entry, context);\n    });\n};\nconst de_CapacityReservationFleetSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CapacityReservationFleet(entry, context);\n    });\n};\nconst de_CapacityReservationGroup = (output, context) => {\n    const contents = {};\n    if (output[_gA] != null) {\n        contents[_GA] = __expectString(output[_gA]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    return contents;\n};\nconst de_CapacityReservationGroupSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CapacityReservationGroup(entry, context);\n    });\n};\nconst de_CapacityReservationInfo = (output, context) => {\n    const contents = {};\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_t] != null) {\n        contents[_Te] = __expectString(output[_t]);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    return contents;\n};\nconst de_CapacityReservationOptions = (output, context) => {\n    const contents = {};\n    if (output[_uS] != null) {\n        contents[_USs] = __expectString(output[_uS]);\n    }\n    return contents;\n};\nconst de_CapacityReservationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CapacityReservation(entry, context);\n    });\n};\nconst de_CapacityReservationSpecificationResponse = (output, context) => {\n    const contents = {};\n    if (output[_cRP] != null) {\n        contents[_CRP] = __expectString(output[_cRP]);\n    }\n    if (output[_cRT] != null) {\n        contents[_CRTa] = de_CapacityReservationTargetResponse(output[_cRT], context);\n    }\n    return contents;\n};\nconst de_CapacityReservationTargetResponse = (output, context) => {\n    const contents = {};\n    if (output[_cRI] != null) {\n        contents[_CRI] = __expectString(output[_cRI]);\n    }\n    if (output[_cRRGA] != null) {\n        contents[_CRRGA] = __expectString(output[_cRRGA]);\n    }\n    return contents;\n};\nconst de_CarrierGateway = (output, context) => {\n    const contents = {};\n    if (output[_cGI] != null) {\n        contents[_CGI] = __expectString(output[_cGI]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_CarrierGatewaySet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CarrierGateway(entry, context);\n    });\n};\nconst de_CertificateAuthentication = (output, context) => {\n    const contents = {};\n    if (output[_cRCC] != null) {\n        contents[_CRCC] = __expectString(output[_cRCC]);\n    }\n    return contents;\n};\nconst de_CidrBlock = (output, context) => {\n    const contents = {};\n    if (output[_cB] != null) {\n        contents[_CB] = __expectString(output[_cB]);\n    }\n    return contents;\n};\nconst de_CidrBlockSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CidrBlock(entry, context);\n    });\n};\nconst de_ClassicLinkDnsSupport = (output, context) => {\n    const contents = {};\n    if (output[_cLDS] != null) {\n        contents[_CLDS] = __parseBoolean(output[_cLDS]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    return contents;\n};\nconst de_ClassicLinkDnsSupportList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ClassicLinkDnsSupport(entry, context);\n    });\n};\nconst de_ClassicLinkInstance = (output, context) => {\n    const contents = {};\n    if (output.groupSet === \"\") {\n        contents[_G] = [];\n    }\n    else if (output[_gS] != null && output[_gS][_i] != null) {\n        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    return contents;\n};\nconst de_ClassicLinkInstanceList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ClassicLinkInstance(entry, context);\n    });\n};\nconst de_ClassicLoadBalancer = (output, context) => {\n    const contents = {};\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    return contents;\n};\nconst de_ClassicLoadBalancers = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ClassicLoadBalancer(entry, context);\n    });\n};\nconst de_ClassicLoadBalancersConfig = (output, context) => {\n    const contents = {};\n    if (output.classicLoadBalancers === \"\") {\n        contents[_CLB] = [];\n    }\n    else if (output[_cLB] != null && output[_cLB][_i] != null) {\n        contents[_CLB] = de_ClassicLoadBalancers(__getArrayIfSingleItem(output[_cLB][_i]), context);\n    }\n    return contents;\n};\nconst de_ClientCertificateRevocationListStatus = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_ClientConnectResponseOptions = (output, context) => {\n    const contents = {};\n    if (output[_en] != null) {\n        contents[_En] = __parseBoolean(output[_en]);\n    }\n    if (output[_lFA] != null) {\n        contents[_LFA] = __expectString(output[_lFA]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientVpnEndpointAttributeStatus(output[_sta], context);\n    }\n    return contents;\n};\nconst de_ClientLoginBannerResponseOptions = (output, context) => {\n    const contents = {};\n    if (output[_en] != null) {\n        contents[_En] = __parseBoolean(output[_en]);\n    }\n    if (output[_bT] != null) {\n        contents[_BT] = __expectString(output[_bT]);\n    }\n    return contents;\n};\nconst de_ClientRouteEnforcementResponseOptions = (output, context) => {\n    const contents = {};\n    if (output[_enf] != null) {\n        contents[_Enf] = __parseBoolean(output[_enf]);\n    }\n    return contents;\n};\nconst de_ClientVpnAuthentication = (output, context) => {\n    const contents = {};\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_aD] != null) {\n        contents[_AD] = de_DirectoryServiceAuthentication(output[_aD], context);\n    }\n    if (output[_mA] != null) {\n        contents[_MA] = de_CertificateAuthentication(output[_mA], context);\n    }\n    if (output[_fA] != null) {\n        contents[_FA] = de_FederatedAuthentication(output[_fA], context);\n    }\n    return contents;\n};\nconst de_ClientVpnAuthenticationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ClientVpnAuthentication(entry, context);\n    });\n};\nconst de_ClientVpnAuthorizationRuleStatus = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_ClientVpnConnection = (output, context) => {\n    const contents = {};\n    if (output[_cVEI] != null) {\n        contents[_CVEI] = __expectString(output[_cVEI]);\n    }\n    if (output[_ti] != null) {\n        contents[_Tim] = __expectString(output[_ti]);\n    }\n    if (output[_cIon] != null) {\n        contents[_CIo] = __expectString(output[_cIon]);\n    }\n    if (output[_us] != null) {\n        contents[_Us] = __expectString(output[_us]);\n    }\n    if (output[_cET] != null) {\n        contents[_CETo] = __expectString(output[_cET]);\n    }\n    if (output[_iB] != null) {\n        contents[_IB] = __expectString(output[_iB]);\n    }\n    if (output[_eB] != null) {\n        contents[_EB] = __expectString(output[_eB]);\n    }\n    if (output[_iPng] != null) {\n        contents[_IPng] = __expectString(output[_iPng]);\n    }\n    if (output[_eP] != null) {\n        contents[_EPg] = __expectString(output[_eP]);\n    }\n    if (output[_cIl] != null) {\n        contents[_CIli] = __expectString(output[_cIl]);\n    }\n    if (output[_cN] != null) {\n        contents[_CN] = __expectString(output[_cN]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientVpnConnectionStatus(output[_sta], context);\n    }\n    if (output[_cETo] != null) {\n        contents[_CETon] = __expectString(output[_cETo]);\n    }\n    if (output.postureComplianceStatusSet === \"\") {\n        contents[_PCS] = [];\n    }\n    else if (output[_pCSS] != null && output[_pCSS][_i] != null) {\n        contents[_PCS] = de_ValueStringList(__getArrayIfSingleItem(output[_pCSS][_i]), context);\n    }\n    return contents;\n};\nconst de_ClientVpnConnectionSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ClientVpnConnection(entry, context);\n    });\n};\nconst de_ClientVpnConnectionStatus = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_ClientVpnEndpoint = (output, context) => {\n    const contents = {};\n    if (output[_cVEI] != null) {\n        contents[_CVEI] = __expectString(output[_cVEI]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientVpnEndpointStatus(output[_sta], context);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectString(output[_cTre]);\n    }\n    if (output[_dT] != null) {\n        contents[_DTel] = __expectString(output[_dT]);\n    }\n    if (output[_dNn] != null) {\n        contents[_DNn] = __expectString(output[_dNn]);\n    }\n    if (output[_cCB] != null) {\n        contents[_CCB] = __expectString(output[_cCB]);\n    }\n    if (output.dnsServer === \"\") {\n        contents[_DSn] = [];\n    }\n    else if (output[_dS] != null && output[_dS][_i] != null) {\n        contents[_DSn] = de_ValueStringList(__getArrayIfSingleItem(output[_dS][_i]), context);\n    }\n    if (output[_sTp] != null) {\n        contents[_ST] = __parseBoolean(output[_sTp]);\n    }\n    if (output[_vP] != null) {\n        contents[_VPp] = __expectString(output[_vP]);\n    }\n    if (output[_tP] != null) {\n        contents[_TPr] = __expectString(output[_tP]);\n    }\n    if (output[_vPp] != null) {\n        contents[_VP] = __strictParseInt32(output[_vPp]);\n    }\n    if (output.associatedTargetNetwork === \"\") {\n        contents[_ATN] = [];\n    }\n    else if (output[_aTN] != null && output[_aTN][_i] != null) {\n        contents[_ATN] = de_AssociatedTargetNetworkSet(__getArrayIfSingleItem(output[_aTN][_i]), context);\n    }\n    if (output[_sCA] != null) {\n        contents[_SCA] = __expectString(output[_sCA]);\n    }\n    if (output.authenticationOptions === \"\") {\n        contents[_AO] = [];\n    }\n    else if (output[_aO] != null && output[_aO][_i] != null) {\n        contents[_AO] = de_ClientVpnAuthenticationList(__getArrayIfSingleItem(output[_aO][_i]), context);\n    }\n    if (output[_cLO] != null) {\n        contents[_CLO] = de_ConnectionLogResponseOptions(output[_cLO], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output.securityGroupIdSet === \"\") {\n        contents[_SGI] = [];\n    }\n    else if (output[_sGIS] != null && output[_sGIS][_i] != null) {\n        contents[_SGI] = de_ClientVpnSecurityGroupIdSet(__getArrayIfSingleItem(output[_sGIS][_i]), context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_sSPU] != null) {\n        contents[_SSPU] = __expectString(output[_sSPU]);\n    }\n    if (output[_cCO] != null) {\n        contents[_CCO] = de_ClientConnectResponseOptions(output[_cCO], context);\n    }\n    if (output[_sTH] != null) {\n        contents[_STH] = __strictParseInt32(output[_sTH]);\n    }\n    if (output[_cLBO] != null) {\n        contents[_CLBO] = de_ClientLoginBannerResponseOptions(output[_cLBO], context);\n    }\n    if (output[_cREO] != null) {\n        contents[_CREO] = de_ClientRouteEnforcementResponseOptions(output[_cREO], context);\n    }\n    if (output[_dOST] != null) {\n        contents[_DOST] = __parseBoolean(output[_dOST]);\n    }\n    return contents;\n};\nconst de_ClientVpnEndpointAttributeStatus = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_ClientVpnEndpointStatus = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_ClientVpnRoute = (output, context) => {\n    const contents = {};\n    if (output[_cVEI] != null) {\n        contents[_CVEI] = __expectString(output[_cVEI]);\n    }\n    if (output[_dC] != null) {\n        contents[_DCe] = __expectString(output[_dC]);\n    }\n    if (output[_tSa] != null) {\n        contents[_TSa] = __expectString(output[_tSa]);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_o] != null) {\n        contents[_Or] = __expectString(output[_o]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientVpnRouteStatus(output[_sta], context);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    return contents;\n};\nconst de_ClientVpnRouteSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ClientVpnRoute(entry, context);\n    });\n};\nconst de_ClientVpnRouteStatus = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_ClientVpnSecurityGroupIdSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_CloudWatchLogOptions = (output, context) => {\n    const contents = {};\n    if (output[_lE] != null) {\n        contents[_LE] = __parseBoolean(output[_lE]);\n    }\n    if (output[_lGA] != null) {\n        contents[_LGA] = __expectString(output[_lGA]);\n    }\n    if (output[_lOF] != null) {\n        contents[_LOF] = __expectString(output[_lOF]);\n    }\n    return contents;\n};\nconst de_CoipAddressUsage = (output, context) => {\n    const contents = {};\n    if (output[_aI] != null) {\n        contents[_AIl] = __expectString(output[_aI]);\n    }\n    if (output[_aAI] != null) {\n        contents[_AAI] = __expectString(output[_aAI]);\n    }\n    if (output[_aSw] != null) {\n        contents[_ASw] = __expectString(output[_aSw]);\n    }\n    if (output[_cIop] != null) {\n        contents[_CIop] = __expectString(output[_cIop]);\n    }\n    return contents;\n};\nconst de_CoipAddressUsageSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CoipAddressUsage(entry, context);\n    });\n};\nconst de_CoipCidr = (output, context) => {\n    const contents = {};\n    if (output[_ci] != null) {\n        contents[_C] = __expectString(output[_ci]);\n    }\n    if (output[_cPI] != null) {\n        contents[_CPIo] = __expectString(output[_cPI]);\n    }\n    if (output[_lGRTI] != null) {\n        contents[_LGRTI] = __expectString(output[_lGRTI]);\n    }\n    return contents;\n};\nconst de_CoipPool = (output, context) => {\n    const contents = {};\n    if (output[_pIo] != null) {\n        contents[_PIo] = __expectString(output[_pIo]);\n    }\n    if (output.poolCidrSet === \"\") {\n        contents[_PCo] = [];\n    }\n    else if (output[_pCS] != null && output[_pCS][_i] != null) {\n        contents[_PCo] = de_ValueStringList(__getArrayIfSingleItem(output[_pCS][_i]), context);\n    }\n    if (output[_lGRTI] != null) {\n        contents[_LGRTI] = __expectString(output[_lGRTI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_pA] != null) {\n        contents[_PAo] = __expectString(output[_pA]);\n    }\n    return contents;\n};\nconst de_CoipPoolSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CoipPool(entry, context);\n    });\n};\nconst de_ConfirmProductInstanceResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    return contents;\n};\nconst de_ConnectionLogResponseOptions = (output, context) => {\n    const contents = {};\n    if (output[_En] != null) {\n        contents[_En] = __parseBoolean(output[_En]);\n    }\n    if (output[_CLG] != null) {\n        contents[_CLG] = __expectString(output[_CLG]);\n    }\n    if (output[_CLS] != null) {\n        contents[_CLS] = __expectString(output[_CLS]);\n    }\n    return contents;\n};\nconst de_ConnectionNotification = (output, context) => {\n    const contents = {};\n    if (output[_cNI] != null) {\n        contents[_CNIon] = __expectString(output[_cNI]);\n    }\n    if (output[_sI] != null) {\n        contents[_SIe] = __expectString(output[_sI]);\n    }\n    if (output[_vEI] != null) {\n        contents[_VEIp] = __expectString(output[_vEI]);\n    }\n    if (output[_cNT] != null) {\n        contents[_CNT] = __expectString(output[_cNT]);\n    }\n    if (output[_cNAo] != null) {\n        contents[_CNAon] = __expectString(output[_cNAo]);\n    }\n    if (output.connectionEvents === \"\") {\n        contents[_CEo] = [];\n    }\n    else if (output[_cE] != null && output[_cE][_i] != null) {\n        contents[_CEo] = de_ValueStringList(__getArrayIfSingleItem(output[_cE][_i]), context);\n    }\n    if (output[_cNS] != null) {\n        contents[_CNS] = __expectString(output[_cNS]);\n    }\n    if (output[_sR] != null) {\n        contents[_SRe] = __expectString(output[_sR]);\n    }\n    return contents;\n};\nconst de_ConnectionNotificationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ConnectionNotification(entry, context);\n    });\n};\nconst de_ConnectionTrackingConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_tET] != null) {\n        contents[_TET] = __strictParseInt32(output[_tET]);\n    }\n    if (output[_uST] != null) {\n        contents[_UST] = __strictParseInt32(output[_uST]);\n    }\n    if (output[_uTd] != null) {\n        contents[_UT] = __strictParseInt32(output[_uTd]);\n    }\n    return contents;\n};\nconst de_ConnectionTrackingSpecification = (output, context) => {\n    const contents = {};\n    if (output[_tET] != null) {\n        contents[_TET] = __strictParseInt32(output[_tET]);\n    }\n    if (output[_uTd] != null) {\n        contents[_UT] = __strictParseInt32(output[_uTd]);\n    }\n    if (output[_uST] != null) {\n        contents[_UST] = __strictParseInt32(output[_uST]);\n    }\n    return contents;\n};\nconst de_ConnectionTrackingSpecificationRequest = (output, context) => {\n    const contents = {};\n    if (output[_TET] != null) {\n        contents[_TET] = __strictParseInt32(output[_TET]);\n    }\n    if (output[_UST] != null) {\n        contents[_UST] = __strictParseInt32(output[_UST]);\n    }\n    if (output[_UT] != null) {\n        contents[_UT] = __strictParseInt32(output[_UT]);\n    }\n    return contents;\n};\nconst de_ConnectionTrackingSpecificationResponse = (output, context) => {\n    const contents = {};\n    if (output[_tET] != null) {\n        contents[_TET] = __strictParseInt32(output[_tET]);\n    }\n    if (output[_uST] != null) {\n        contents[_UST] = __strictParseInt32(output[_uST]);\n    }\n    if (output[_uTd] != null) {\n        contents[_UT] = __strictParseInt32(output[_uTd]);\n    }\n    return contents;\n};\nconst de_ConversionTask = (output, context) => {\n    const contents = {};\n    if (output[_cTI] != null) {\n        contents[_CTI] = __expectString(output[_cTI]);\n    }\n    if (output[_eT] != null) {\n        contents[_ETx] = __expectString(output[_eT]);\n    }\n    if (output[_iIm] != null) {\n        contents[_IIm] = de_ImportInstanceTaskDetails(output[_iIm], context);\n    }\n    if (output[_iVm] != null) {\n        contents[_IV] = de_ImportVolumeTaskDetails(output[_iVm], context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_CopyFpgaImageResult = (output, context) => {\n    const contents = {};\n    if (output[_fII] != null) {\n        contents[_FII] = __expectString(output[_fII]);\n    }\n    return contents;\n};\nconst de_CopyImageResult = (output, context) => {\n    const contents = {};\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    return contents;\n};\nconst de_CopySnapshotResult = (output, context) => {\n    const contents = {};\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    return contents;\n};\nconst de_CoreCountList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __strictParseInt32(entry);\n    });\n};\nconst de_CpuManufacturerSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_CpuOptions = (output, context) => {\n    const contents = {};\n    if (output[_cCo] != null) {\n        contents[_CC] = __strictParseInt32(output[_cCo]);\n    }\n    if (output[_tPC] != null) {\n        contents[_TPC] = __strictParseInt32(output[_tPC]);\n    }\n    if (output[_aSS] != null) {\n        contents[_ASS] = __expectString(output[_aSS]);\n    }\n    return contents;\n};\nconst de_CpuPerformanceFactor = (output, context) => {\n    const contents = {};\n    if (output.referenceSet === \"\") {\n        contents[_R] = [];\n    }\n    else if (output[_rS] != null && output[_rS][_i] != null) {\n        contents[_R] = de_PerformanceFactorReferenceSet(__getArrayIfSingleItem(output[_rS][_i]), context);\n    }\n    return contents;\n};\nconst de_CreateCapacityReservationBySplittingResult = (output, context) => {\n    const contents = {};\n    if (output[_sCR] != null) {\n        contents[_SCR] = de_CapacityReservation(output[_sCR], context);\n    }\n    if (output[_dCR] != null) {\n        contents[_DCRe] = de_CapacityReservation(output[_dCR], context);\n    }\n    if (output[_iC] != null) {\n        contents[_IC] = __strictParseInt32(output[_iC]);\n    }\n    return contents;\n};\nconst de_CreateCapacityReservationFleetResult = (output, context) => {\n    const contents = {};\n    if (output[_cRFI] != null) {\n        contents[_CRFIa] = __expectString(output[_cRFI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_tTC] != null) {\n        contents[_TTC] = __strictParseInt32(output[_tTC]);\n    }\n    if (output[_tFC] != null) {\n        contents[_TFC] = __strictParseFloat(output[_tFC]);\n    }\n    if (output[_iMC] != null) {\n        contents[_IMC] = __expectString(output[_iMC]);\n    }\n    if (output[_aSl] != null) {\n        contents[_AS] = __expectString(output[_aSl]);\n    }\n    if (output[_cTr] != null) {\n        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));\n    }\n    if (output[_eD] != null) {\n        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));\n    }\n    if (output[_t] != null) {\n        contents[_Te] = __expectString(output[_t]);\n    }\n    if (output.fleetCapacityReservationSet === \"\") {\n        contents[_FCR] = [];\n    }\n    else if (output[_fCRS] != null && output[_fCRS][_i] != null) {\n        contents[_FCR] = de_FleetCapacityReservationSet(__getArrayIfSingleItem(output[_fCRS][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_CreateCapacityReservationResult = (output, context) => {\n    const contents = {};\n    if (output[_cR] != null) {\n        contents[_CRapa] = de_CapacityReservation(output[_cR], context);\n    }\n    return contents;\n};\nconst de_CreateCarrierGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_cG] != null) {\n        contents[_CG] = de_CarrierGateway(output[_cG], context);\n    }\n    return contents;\n};\nconst de_CreateClientVpnEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_cVEI] != null) {\n        contents[_CVEI] = __expectString(output[_cVEI]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientVpnEndpointStatus(output[_sta], context);\n    }\n    if (output[_dNn] != null) {\n        contents[_DNn] = __expectString(output[_dNn]);\n    }\n    return contents;\n};\nconst de_CreateClientVpnRouteResult = (output, context) => {\n    const contents = {};\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientVpnRouteStatus(output[_sta], context);\n    }\n    return contents;\n};\nconst de_CreateCoipCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_cCoi] != null) {\n        contents[_CCo] = de_CoipCidr(output[_cCoi], context);\n    }\n    return contents;\n};\nconst de_CreateCoipPoolResult = (output, context) => {\n    const contents = {};\n    if (output[_cP] != null) {\n        contents[_CP] = de_CoipPool(output[_cP], context);\n    }\n    return contents;\n};\nconst de_CreateCustomerGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_cGu] != null) {\n        contents[_CGu] = de_CustomerGateway(output[_cGu], context);\n    }\n    return contents;\n};\nconst de_CreateDefaultSubnetResult = (output, context) => {\n    const contents = {};\n    if (output[_su] != null) {\n        contents[_Su] = de_Subnet(output[_su], context);\n    }\n    return contents;\n};\nconst de_CreateDefaultVpcResult = (output, context) => {\n    const contents = {};\n    if (output[_vp] != null) {\n        contents[_Vp] = de_Vpc(output[_vp], context);\n    }\n    return contents;\n};\nconst de_CreateDelegateMacVolumeOwnershipTaskResult = (output, context) => {\n    const contents = {};\n    if (output[_mMT] != null) {\n        contents[_MMT] = de_MacModificationTask(output[_mMT], context);\n    }\n    return contents;\n};\nconst de_CreateDhcpOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_dO] != null) {\n        contents[_DOh] = de_DhcpOptions(output[_dO], context);\n    }\n    return contents;\n};\nconst de_CreateEgressOnlyInternetGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    if (output[_eOIG] != null) {\n        contents[_EOIG] = de_EgressOnlyInternetGateway(output[_eOIG], context);\n    }\n    return contents;\n};\nconst de_CreateFleetError = (output, context) => {\n    const contents = {};\n    if (output[_lTAO] != null) {\n        contents[_LTAO] = de_LaunchTemplateAndOverridesResponse(output[_lTAO], context);\n    }\n    if (output[_l] != null) {\n        contents[_Li] = __expectString(output[_l]);\n    }\n    if (output[_eC] != null) {\n        contents[_EC] = __expectString(output[_eC]);\n    }\n    if (output[_eM] != null) {\n        contents[_EM] = __expectString(output[_eM]);\n    }\n    return contents;\n};\nconst de_CreateFleetErrorsSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CreateFleetError(entry, context);\n    });\n};\nconst de_CreateFleetInstance = (output, context) => {\n    const contents = {};\n    if (output[_lTAO] != null) {\n        contents[_LTAO] = de_LaunchTemplateAndOverridesResponse(output[_lTAO], context);\n    }\n    if (output[_l] != null) {\n        contents[_Li] = __expectString(output[_l]);\n    }\n    if (output.instanceIds === \"\") {\n        contents[_IIns] = [];\n    }\n    else if (output[_iIn] != null && output[_iIn][_i] != null) {\n        contents[_IIns] = de_InstanceIdsSet(__getArrayIfSingleItem(output[_iIn][_i]), context);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_pl] != null) {\n        contents[_Pla] = __expectString(output[_pl]);\n    }\n    return contents;\n};\nconst de_CreateFleetInstancesSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CreateFleetInstance(entry, context);\n    });\n};\nconst de_CreateFleetResult = (output, context) => {\n    const contents = {};\n    if (output[_fIl] != null) {\n        contents[_FIl] = __expectString(output[_fIl]);\n    }\n    if (output.errorSet === \"\") {\n        contents[_Err] = [];\n    }\n    else if (output[_eSr] != null && output[_eSr][_i] != null) {\n        contents[_Err] = de_CreateFleetErrorsSet(__getArrayIfSingleItem(output[_eSr][_i]), context);\n    }\n    if (output.fleetInstanceSet === \"\") {\n        contents[_In] = [];\n    }\n    else if (output[_fIS] != null && output[_fIS][_i] != null) {\n        contents[_In] = de_CreateFleetInstancesSet(__getArrayIfSingleItem(output[_fIS][_i]), context);\n    }\n    return contents;\n};\nconst de_CreateFlowLogsResult = (output, context) => {\n    const contents = {};\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    if (output.flowLogIdSet === \"\") {\n        contents[_FLI] = [];\n    }\n    else if (output[_fLIS] != null && output[_fLIS][_i] != null) {\n        contents[_FLI] = de_ValueStringList(__getArrayIfSingleItem(output[_fLIS][_i]), context);\n    }\n    if (output.unsuccessful === \"\") {\n        contents[_Un] = [];\n    }\n    else if (output[_u] != null && output[_u][_i] != null) {\n        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);\n    }\n    return contents;\n};\nconst de_CreateFpgaImageResult = (output, context) => {\n    const contents = {};\n    if (output[_fII] != null) {\n        contents[_FII] = __expectString(output[_fII]);\n    }\n    if (output[_fIGI] != null) {\n        contents[_FIGI] = __expectString(output[_fIGI]);\n    }\n    return contents;\n};\nconst de_CreateImageResult = (output, context) => {\n    const contents = {};\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    return contents;\n};\nconst de_CreateInstanceConnectEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_iCE] != null) {\n        contents[_ICE] = de_Ec2InstanceConnectEndpoint(output[_iCE], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_CreateInstanceEventWindowResult = (output, context) => {\n    const contents = {};\n    if (output[_iEW] != null) {\n        contents[_IEW] = de_InstanceEventWindow(output[_iEW], context);\n    }\n    return contents;\n};\nconst de_CreateInstanceExportTaskResult = (output, context) => {\n    const contents = {};\n    if (output[_eTx] != null) {\n        contents[_ETxp] = de_ExportTask(output[_eTx], context);\n    }\n    return contents;\n};\nconst de_CreateInternetGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_iG] != null) {\n        contents[_IGn] = de_InternetGateway(output[_iG], context);\n    }\n    return contents;\n};\nconst de_CreateIpamExternalResourceVerificationTokenResult = (output, context) => {\n    const contents = {};\n    if (output[_iERVT] != null) {\n        contents[_IERVT] = de_IpamExternalResourceVerificationToken(output[_iERVT], context);\n    }\n    return contents;\n};\nconst de_CreateIpamPoolResult = (output, context) => {\n    const contents = {};\n    if (output[_iPp] != null) {\n        contents[_IPpa] = de_IpamPool(output[_iPp], context);\n    }\n    return contents;\n};\nconst de_CreateIpamResourceDiscoveryResult = (output, context) => {\n    const contents = {};\n    if (output[_iRD] != null) {\n        contents[_IRD] = de_IpamResourceDiscovery(output[_iRD], context);\n    }\n    return contents;\n};\nconst de_CreateIpamResult = (output, context) => {\n    const contents = {};\n    if (output[_ip] != null) {\n        contents[_Ipa] = de_Ipam(output[_ip], context);\n    }\n    return contents;\n};\nconst de_CreateIpamScopeResult = (output, context) => {\n    const contents = {};\n    if (output[_iS] != null) {\n        contents[_ISpa] = de_IpamScope(output[_iS], context);\n    }\n    return contents;\n};\nconst de_CreateLaunchTemplateResult = (output, context) => {\n    const contents = {};\n    if (output[_lT] != null) {\n        contents[_LTa] = de_LaunchTemplate(output[_lT], context);\n    }\n    if (output[_w] != null) {\n        contents[_Wa] = de_ValidationWarning(output[_w], context);\n    }\n    return contents;\n};\nconst de_CreateLaunchTemplateVersionResult = (output, context) => {\n    const contents = {};\n    if (output[_lTV] != null) {\n        contents[_LTV] = de_LaunchTemplateVersion(output[_lTV], context);\n    }\n    if (output[_w] != null) {\n        contents[_Wa] = de_ValidationWarning(output[_w], context);\n    }\n    return contents;\n};\nconst de_CreateLocalGatewayRouteResult = (output, context) => {\n    const contents = {};\n    if (output[_ro] != null) {\n        contents[_Rou] = de_LocalGatewayRoute(output[_ro], context);\n    }\n    return contents;\n};\nconst de_CreateLocalGatewayRouteTableResult = (output, context) => {\n    const contents = {};\n    if (output[_lGRT] != null) {\n        contents[_LGRT] = de_LocalGatewayRouteTable(output[_lGRT], context);\n    }\n    return contents;\n};\nconst de_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult = (output, context) => {\n    const contents = {};\n    if (output[_lGRTVIGA] != null) {\n        contents[_LGRTVIGA] = de_LocalGatewayRouteTableVirtualInterfaceGroupAssociation(output[_lGRTVIGA], context);\n    }\n    return contents;\n};\nconst de_CreateLocalGatewayRouteTableVpcAssociationResult = (output, context) => {\n    const contents = {};\n    if (output[_lGRTVA] != null) {\n        contents[_LGRTVA] = de_LocalGatewayRouteTableVpcAssociation(output[_lGRTVA], context);\n    }\n    return contents;\n};\nconst de_CreateLocalGatewayVirtualInterfaceGroupResult = (output, context) => {\n    const contents = {};\n    if (output[_lGVIG] != null) {\n        contents[_LGVIG] = de_LocalGatewayVirtualInterfaceGroup(output[_lGVIG], context);\n    }\n    return contents;\n};\nconst de_CreateLocalGatewayVirtualInterfaceResult = (output, context) => {\n    const contents = {};\n    if (output[_lGVI] != null) {\n        contents[_LGVI] = de_LocalGatewayVirtualInterface(output[_lGVI], context);\n    }\n    return contents;\n};\nconst de_CreateMacSystemIntegrityProtectionModificationTaskResult = (output, context) => {\n    const contents = {};\n    if (output[_mMT] != null) {\n        contents[_MMT] = de_MacModificationTask(output[_mMT], context);\n    }\n    return contents;\n};\nconst de_CreateManagedPrefixListResult = (output, context) => {\n    const contents = {};\n    if (output[_pL] != null) {\n        contents[_PLr] = de_ManagedPrefixList(output[_pL], context);\n    }\n    return contents;\n};\nconst de_CreateNatGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    if (output[_nG] != null) {\n        contents[_NG] = de_NatGateway(output[_nG], context);\n    }\n    return contents;\n};\nconst de_CreateNetworkAclResult = (output, context) => {\n    const contents = {};\n    if (output[_nA] != null) {\n        contents[_NA] = de_NetworkAcl(output[_nA], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_CreateNetworkInsightsAccessScopeResult = (output, context) => {\n    const contents = {};\n    if (output[_nIAS] != null) {\n        contents[_NIAS] = de_NetworkInsightsAccessScope(output[_nIAS], context);\n    }\n    if (output[_nIASC] != null) {\n        contents[_NIASC] = de_NetworkInsightsAccessScopeContent(output[_nIASC], context);\n    }\n    return contents;\n};\nconst de_CreateNetworkInsightsPathResult = (output, context) => {\n    const contents = {};\n    if (output[_nIP] != null) {\n        contents[_NIP] = de_NetworkInsightsPath(output[_nIP], context);\n    }\n    return contents;\n};\nconst de_CreateNetworkInterfacePermissionResult = (output, context) => {\n    const contents = {};\n    if (output[_iPnt] != null) {\n        contents[_IPnt] = de_NetworkInterfacePermission(output[_iPnt], context);\n    }\n    return contents;\n};\nconst de_CreateNetworkInterfaceResult = (output, context) => {\n    const contents = {};\n    if (output[_nIe] != null) {\n        contents[_NIet] = de_NetworkInterface(output[_nIe], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_CreatePlacementGroupResult = (output, context) => {\n    const contents = {};\n    if (output[_pG] != null) {\n        contents[_PG] = de_PlacementGroup(output[_pG], context);\n    }\n    return contents;\n};\nconst de_CreatePublicIpv4PoolResult = (output, context) => {\n    const contents = {};\n    if (output[_pIo] != null) {\n        contents[_PIo] = __expectString(output[_pIo]);\n    }\n    return contents;\n};\nconst de_CreateReplaceRootVolumeTaskResult = (output, context) => {\n    const contents = {};\n    if (output[_rRVT] != null) {\n        contents[_RRVT] = de_ReplaceRootVolumeTask(output[_rRVT], context);\n    }\n    return contents;\n};\nconst de_CreateReservedInstancesListingResult = (output, context) => {\n    const contents = {};\n    if (output.reservedInstancesListingsSet === \"\") {\n        contents[_RIL] = [];\n    }\n    else if (output[_rILS] != null && output[_rILS][_i] != null) {\n        contents[_RIL] = de_ReservedInstancesListingList(__getArrayIfSingleItem(output[_rILS][_i]), context);\n    }\n    return contents;\n};\nconst de_CreateRestoreImageTaskResult = (output, context) => {\n    const contents = {};\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    return contents;\n};\nconst de_CreateRouteResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_CreateRouteServerEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_rSE] != null) {\n        contents[_RSE] = de_RouteServerEndpoint(output[_rSE], context);\n    }\n    return contents;\n};\nconst de_CreateRouteServerPeerResult = (output, context) => {\n    const contents = {};\n    if (output[_rSP] != null) {\n        contents[_RSP] = de_RouteServerPeer(output[_rSP], context);\n    }\n    return contents;\n};\nconst de_CreateRouteServerResult = (output, context) => {\n    const contents = {};\n    if (output[_rSo] != null) {\n        contents[_RSo] = de_RouteServer(output[_rSo], context);\n    }\n    return contents;\n};\nconst de_CreateRouteTableResult = (output, context) => {\n    const contents = {};\n    if (output[_rTo] != null) {\n        contents[_RTo] = de_RouteTable(output[_rTo], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_CreateSecurityGroupResult = (output, context) => {\n    const contents = {};\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_sGA] != null) {\n        contents[_SGA] = __expectString(output[_sGA]);\n    }\n    return contents;\n};\nconst de_CreateSnapshotsResult = (output, context) => {\n    const contents = {};\n    if (output.snapshotSet === \"\") {\n        contents[_Sn] = [];\n    }\n    else if (output[_sS] != null && output[_sS][_i] != null) {\n        contents[_Sn] = de_SnapshotSet(__getArrayIfSingleItem(output[_sS][_i]), context);\n    }\n    return contents;\n};\nconst de_CreateSpotDatafeedSubscriptionResult = (output, context) => {\n    const contents = {};\n    if (output[_sDS] != null) {\n        contents[_SDS] = de_SpotDatafeedSubscription(output[_sDS], context);\n    }\n    return contents;\n};\nconst de_CreateStoreImageTaskResult = (output, context) => {\n    const contents = {};\n    if (output[_oK] != null) {\n        contents[_OK] = __expectString(output[_oK]);\n    }\n    return contents;\n};\nconst de_CreateSubnetCidrReservationResult = (output, context) => {\n    const contents = {};\n    if (output[_sCRu] != null) {\n        contents[_SCRu] = de_SubnetCidrReservation(output[_sCRu], context);\n    }\n    return contents;\n};\nconst de_CreateSubnetResult = (output, context) => {\n    const contents = {};\n    if (output[_su] != null) {\n        contents[_Su] = de_Subnet(output[_su], context);\n    }\n    return contents;\n};\nconst de_CreateTrafficMirrorFilterResult = (output, context) => {\n    const contents = {};\n    if (output[_tMF] != null) {\n        contents[_TMF] = de_TrafficMirrorFilter(output[_tMF], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_CreateTrafficMirrorFilterRuleResult = (output, context) => {\n    const contents = {};\n    if (output[_tMFR] != null) {\n        contents[_TMFR] = de_TrafficMirrorFilterRule(output[_tMFR], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_CreateTrafficMirrorSessionResult = (output, context) => {\n    const contents = {};\n    if (output[_tMS] != null) {\n        contents[_TMS] = de_TrafficMirrorSession(output[_tMS], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_CreateTrafficMirrorTargetResult = (output, context) => {\n    const contents = {};\n    if (output[_tMT] != null) {\n        contents[_TMT] = de_TrafficMirrorTarget(output[_tMT], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_CreateTransitGatewayConnectPeerResult = (output, context) => {\n    const contents = {};\n    if (output[_tGCP] != null) {\n        contents[_TGCP] = de_TransitGatewayConnectPeer(output[_tGCP], context);\n    }\n    return contents;\n};\nconst de_CreateTransitGatewayConnectResult = (output, context) => {\n    const contents = {};\n    if (output[_tGC] != null) {\n        contents[_TGCr] = de_TransitGatewayConnect(output[_tGC], context);\n    }\n    return contents;\n};\nconst de_CreateTransitGatewayMulticastDomainResult = (output, context) => {\n    const contents = {};\n    if (output[_tGMD] != null) {\n        contents[_TGMD] = de_TransitGatewayMulticastDomain(output[_tGMD], context);\n    }\n    return contents;\n};\nconst de_CreateTransitGatewayPeeringAttachmentResult = (output, context) => {\n    const contents = {};\n    if (output[_tGPA] != null) {\n        contents[_TGPA] = de_TransitGatewayPeeringAttachment(output[_tGPA], context);\n    }\n    return contents;\n};\nconst de_CreateTransitGatewayPolicyTableResult = (output, context) => {\n    const contents = {};\n    if (output[_tGPT] != null) {\n        contents[_TGPT] = de_TransitGatewayPolicyTable(output[_tGPT], context);\n    }\n    return contents;\n};\nconst de_CreateTransitGatewayPrefixListReferenceResult = (output, context) => {\n    const contents = {};\n    if (output[_tGPLR] != null) {\n        contents[_TGPLR] = de_TransitGatewayPrefixListReference(output[_tGPLR], context);\n    }\n    return contents;\n};\nconst de_CreateTransitGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_tG] != null) {\n        contents[_TGr] = de_TransitGateway(output[_tG], context);\n    }\n    return contents;\n};\nconst de_CreateTransitGatewayRouteResult = (output, context) => {\n    const contents = {};\n    if (output[_ro] != null) {\n        contents[_Rou] = de_TransitGatewayRoute(output[_ro], context);\n    }\n    return contents;\n};\nconst de_CreateTransitGatewayRouteTableAnnouncementResult = (output, context) => {\n    const contents = {};\n    if (output[_tGRTA] != null) {\n        contents[_TGRTA] = de_TransitGatewayRouteTableAnnouncement(output[_tGRTA], context);\n    }\n    return contents;\n};\nconst de_CreateTransitGatewayRouteTableResult = (output, context) => {\n    const contents = {};\n    if (output[_tGRT] != null) {\n        contents[_TGRT] = de_TransitGatewayRouteTable(output[_tGRT], context);\n    }\n    return contents;\n};\nconst de_CreateTransitGatewayVpcAttachmentResult = (output, context) => {\n    const contents = {};\n    if (output[_tGVA] != null) {\n        contents[_TGVA] = de_TransitGatewayVpcAttachment(output[_tGVA], context);\n    }\n    return contents;\n};\nconst de_CreateVerifiedAccessEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_vAE] != null) {\n        contents[_VAE] = de_VerifiedAccessEndpoint(output[_vAE], context);\n    }\n    return contents;\n};\nconst de_CreateVerifiedAccessGroupResult = (output, context) => {\n    const contents = {};\n    if (output[_vAG] != null) {\n        contents[_VAG] = de_VerifiedAccessGroup(output[_vAG], context);\n    }\n    return contents;\n};\nconst de_CreateVerifiedAccessInstanceResult = (output, context) => {\n    const contents = {};\n    if (output[_vAI] != null) {\n        contents[_VAI] = de_VerifiedAccessInstance(output[_vAI], context);\n    }\n    return contents;\n};\nconst de_CreateVerifiedAccessTrustProviderResult = (output, context) => {\n    const contents = {};\n    if (output[_vATP] != null) {\n        contents[_VATP] = de_VerifiedAccessTrustProvider(output[_vATP], context);\n    }\n    return contents;\n};\nconst de_CreateVolumePermission = (output, context) => {\n    const contents = {};\n    if (output[_uI] != null) {\n        contents[_UIs] = __expectString(output[_uI]);\n    }\n    if (output[_g] != null) {\n        contents[_Gr] = __expectString(output[_g]);\n    }\n    return contents;\n};\nconst de_CreateVolumePermissionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CreateVolumePermission(entry, context);\n    });\n};\nconst de_CreateVpcBlockPublicAccessExclusionResult = (output, context) => {\n    const contents = {};\n    if (output[_vBPAE] != null) {\n        contents[_VBPAE] = de_VpcBlockPublicAccessExclusion(output[_vBPAE], context);\n    }\n    return contents;\n};\nconst de_CreateVpcEndpointConnectionNotificationResult = (output, context) => {\n    const contents = {};\n    if (output[_cNo] != null) {\n        contents[_CNo] = de_ConnectionNotification(output[_cNo], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_CreateVpcEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_vE] != null) {\n        contents[_VE] = de_VpcEndpoint(output[_vE], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_CreateVpcEndpointServiceConfigurationResult = (output, context) => {\n    const contents = {};\n    if (output[_sC] != null) {\n        contents[_SCe] = de_ServiceConfiguration(output[_sC], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_CreateVpcPeeringConnectionResult = (output, context) => {\n    const contents = {};\n    if (output[_vPC] != null) {\n        contents[_VPC] = de_VpcPeeringConnection(output[_vPC], context);\n    }\n    return contents;\n};\nconst de_CreateVpcResult = (output, context) => {\n    const contents = {};\n    if (output[_vp] != null) {\n        contents[_Vp] = de_Vpc(output[_vp], context);\n    }\n    return contents;\n};\nconst de_CreateVpnConnectionResult = (output, context) => {\n    const contents = {};\n    if (output[_vC] != null) {\n        contents[_VC] = de_VpnConnection(output[_vC], context);\n    }\n    return contents;\n};\nconst de_CreateVpnGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_vG] != null) {\n        contents[_VG] = de_VpnGateway(output[_vG], context);\n    }\n    return contents;\n};\nconst de_CreditSpecification = (output, context) => {\n    const contents = {};\n    if (output[_cCp] != null) {\n        contents[_CCp] = __expectString(output[_cCp]);\n    }\n    return contents;\n};\nconst de_CustomerGateway = (output, context) => {\n    const contents = {};\n    if (output[_cAe] != null) {\n        contents[_CA] = __expectString(output[_cAe]);\n    }\n    if (output[_dN] != null) {\n        contents[_DN] = __expectString(output[_dN]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_bAE] != null) {\n        contents[_BAE] = __expectString(output[_bAE]);\n    }\n    if (output[_cGIu] != null) {\n        contents[_CGIu] = __expectString(output[_cGIu]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_iAp] != null) {\n        contents[_IAp] = __expectString(output[_iAp]);\n    }\n    if (output[_bA] != null) {\n        contents[_BA] = __expectString(output[_bA]);\n    }\n    return contents;\n};\nconst de_CustomerGatewayList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CustomerGateway(entry, context);\n    });\n};\nconst de_DataResponse = (output, context) => {\n    const contents = {};\n    if (output[_id] != null) {\n        contents[_Id] = __expectString(output[_id]);\n    }\n    if (output[_s] != null) {\n        contents[_S] = __expectString(output[_s]);\n    }\n    if (output[_d] != null) {\n        contents[_D] = __expectString(output[_d]);\n    }\n    if (output[_met] != null) {\n        contents[_Met] = __expectString(output[_met]);\n    }\n    if (output[_stat] != null) {\n        contents[_Sta] = __expectString(output[_stat]);\n    }\n    if (output[_pe] != null) {\n        contents[_Per] = __expectString(output[_pe]);\n    }\n    if (output.metricPointSet === \"\") {\n        contents[_MPe] = [];\n    }\n    else if (output[_mPS] != null && output[_mPS][_i] != null) {\n        contents[_MPe] = de_MetricPoints(__getArrayIfSingleItem(output[_mPS][_i]), context);\n    }\n    return contents;\n};\nconst de_DataResponses = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DataResponse(entry, context);\n    });\n};\nconst de_DeclarativePoliciesReport = (output, context) => {\n    const contents = {};\n    if (output[_rI] != null) {\n        contents[_RIep] = __expectString(output[_rI]);\n    }\n    if (output[_sB] != null) {\n        contents[_SB] = __expectString(output[_sB]);\n    }\n    if (output[_sP] != null) {\n        contents[_SP] = __expectString(output[_sP]);\n    }\n    if (output[_tI] != null) {\n        contents[_TIa] = __expectString(output[_tI]);\n    }\n    if (output[_sT] != null) {\n        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));\n    }\n    if (output[_eTn] != null) {\n        contents[_ETn] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTn]));\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_DeclarativePoliciesReportList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DeclarativePoliciesReport(entry, context);\n    });\n};\nconst de_DedicatedHostIdList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_DeleteCarrierGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_cG] != null) {\n        contents[_CG] = de_CarrierGateway(output[_cG], context);\n    }\n    return contents;\n};\nconst de_DeleteClientVpnEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientVpnEndpointStatus(output[_sta], context);\n    }\n    return contents;\n};\nconst de_DeleteClientVpnRouteResult = (output, context) => {\n    const contents = {};\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientVpnRouteStatus(output[_sta], context);\n    }\n    return contents;\n};\nconst de_DeleteCoipCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_cCoi] != null) {\n        contents[_CCo] = de_CoipCidr(output[_cCoi], context);\n    }\n    return contents;\n};\nconst de_DeleteCoipPoolResult = (output, context) => {\n    const contents = {};\n    if (output[_cP] != null) {\n        contents[_CP] = de_CoipPool(output[_cP], context);\n    }\n    return contents;\n};\nconst de_DeleteEgressOnlyInternetGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_rC] != null) {\n        contents[_RCet] = __parseBoolean(output[_rC]);\n    }\n    return contents;\n};\nconst de_DeleteFleetError = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_DeleteFleetErrorItem = (output, context) => {\n    const contents = {};\n    if (output[_er] != null) {\n        contents[_Er] = de_DeleteFleetError(output[_er], context);\n    }\n    if (output[_fIl] != null) {\n        contents[_FIl] = __expectString(output[_fIl]);\n    }\n    return contents;\n};\nconst de_DeleteFleetErrorSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DeleteFleetErrorItem(entry, context);\n    });\n};\nconst de_DeleteFleetsResult = (output, context) => {\n    const contents = {};\n    if (output.successfulFleetDeletionSet === \"\") {\n        contents[_SFD] = [];\n    }\n    else if (output[_sFDS] != null && output[_sFDS][_i] != null) {\n        contents[_SFD] = de_DeleteFleetSuccessSet(__getArrayIfSingleItem(output[_sFDS][_i]), context);\n    }\n    if (output.unsuccessfulFleetDeletionSet === \"\") {\n        contents[_UFD] = [];\n    }\n    else if (output[_uFDS] != null && output[_uFDS][_i] != null) {\n        contents[_UFD] = de_DeleteFleetErrorSet(__getArrayIfSingleItem(output[_uFDS][_i]), context);\n    }\n    return contents;\n};\nconst de_DeleteFleetSuccessItem = (output, context) => {\n    const contents = {};\n    if (output[_cFS] != null) {\n        contents[_CFS] = __expectString(output[_cFS]);\n    }\n    if (output[_pFS] != null) {\n        contents[_PFS] = __expectString(output[_pFS]);\n    }\n    if (output[_fIl] != null) {\n        contents[_FIl] = __expectString(output[_fIl]);\n    }\n    return contents;\n};\nconst de_DeleteFleetSuccessSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DeleteFleetSuccessItem(entry, context);\n    });\n};\nconst de_DeleteFlowLogsResult = (output, context) => {\n    const contents = {};\n    if (output.unsuccessful === \"\") {\n        contents[_Un] = [];\n    }\n    else if (output[_u] != null && output[_u][_i] != null) {\n        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);\n    }\n    return contents;\n};\nconst de_DeleteFpgaImageResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_DeleteInstanceConnectEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_iCE] != null) {\n        contents[_ICE] = de_Ec2InstanceConnectEndpoint(output[_iCE], context);\n    }\n    return contents;\n};\nconst de_DeleteInstanceEventWindowResult = (output, context) => {\n    const contents = {};\n    if (output[_iEWS] != null) {\n        contents[_IEWS] = de_InstanceEventWindowStateChange(output[_iEWS], context);\n    }\n    return contents;\n};\nconst de_DeleteIpamExternalResourceVerificationTokenResult = (output, context) => {\n    const contents = {};\n    if (output[_iERVT] != null) {\n        contents[_IERVT] = de_IpamExternalResourceVerificationToken(output[_iERVT], context);\n    }\n    return contents;\n};\nconst de_DeleteIpamPoolResult = (output, context) => {\n    const contents = {};\n    if (output[_iPp] != null) {\n        contents[_IPpa] = de_IpamPool(output[_iPp], context);\n    }\n    return contents;\n};\nconst de_DeleteIpamResourceDiscoveryResult = (output, context) => {\n    const contents = {};\n    if (output[_iRD] != null) {\n        contents[_IRD] = de_IpamResourceDiscovery(output[_iRD], context);\n    }\n    return contents;\n};\nconst de_DeleteIpamResult = (output, context) => {\n    const contents = {};\n    if (output[_ip] != null) {\n        contents[_Ipa] = de_Ipam(output[_ip], context);\n    }\n    return contents;\n};\nconst de_DeleteIpamScopeResult = (output, context) => {\n    const contents = {};\n    if (output[_iS] != null) {\n        contents[_ISpa] = de_IpamScope(output[_iS], context);\n    }\n    return contents;\n};\nconst de_DeleteKeyPairResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    if (output[_kPI] != null) {\n        contents[_KPI] = __expectString(output[_kPI]);\n    }\n    return contents;\n};\nconst de_DeleteLaunchTemplateResult = (output, context) => {\n    const contents = {};\n    if (output[_lT] != null) {\n        contents[_LTa] = de_LaunchTemplate(output[_lT], context);\n    }\n    return contents;\n};\nconst de_DeleteLaunchTemplateVersionsResponseErrorItem = (output, context) => {\n    const contents = {};\n    if (output[_lTI] != null) {\n        contents[_LTI] = __expectString(output[_lTI]);\n    }\n    if (output[_lTN] != null) {\n        contents[_LTN] = __expectString(output[_lTN]);\n    }\n    if (output[_vNe] != null) {\n        contents[_VNe] = __strictParseLong(output[_vNe]);\n    }\n    if (output[_rE] != null) {\n        contents[_REes] = de_ResponseError(output[_rE], context);\n    }\n    return contents;\n};\nconst de_DeleteLaunchTemplateVersionsResponseErrorSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DeleteLaunchTemplateVersionsResponseErrorItem(entry, context);\n    });\n};\nconst de_DeleteLaunchTemplateVersionsResponseSuccessItem = (output, context) => {\n    const contents = {};\n    if (output[_lTI] != null) {\n        contents[_LTI] = __expectString(output[_lTI]);\n    }\n    if (output[_lTN] != null) {\n        contents[_LTN] = __expectString(output[_lTN]);\n    }\n    if (output[_vNe] != null) {\n        contents[_VNe] = __strictParseLong(output[_vNe]);\n    }\n    return contents;\n};\nconst de_DeleteLaunchTemplateVersionsResponseSuccessSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DeleteLaunchTemplateVersionsResponseSuccessItem(entry, context);\n    });\n};\nconst de_DeleteLaunchTemplateVersionsResult = (output, context) => {\n    const contents = {};\n    if (output.successfullyDeletedLaunchTemplateVersionSet === \"\") {\n        contents[_SDLTV] = [];\n    }\n    else if (output[_sDLTVS] != null && output[_sDLTVS][_i] != null) {\n        contents[_SDLTV] = de_DeleteLaunchTemplateVersionsResponseSuccessSet(__getArrayIfSingleItem(output[_sDLTVS][_i]), context);\n    }\n    if (output.unsuccessfullyDeletedLaunchTemplateVersionSet === \"\") {\n        contents[_UDLTV] = [];\n    }\n    else if (output[_uDLTVS] != null && output[_uDLTVS][_i] != null) {\n        contents[_UDLTV] = de_DeleteLaunchTemplateVersionsResponseErrorSet(__getArrayIfSingleItem(output[_uDLTVS][_i]), context);\n    }\n    return contents;\n};\nconst de_DeleteLocalGatewayRouteResult = (output, context) => {\n    const contents = {};\n    if (output[_ro] != null) {\n        contents[_Rou] = de_LocalGatewayRoute(output[_ro], context);\n    }\n    return contents;\n};\nconst de_DeleteLocalGatewayRouteTableResult = (output, context) => {\n    const contents = {};\n    if (output[_lGRT] != null) {\n        contents[_LGRT] = de_LocalGatewayRouteTable(output[_lGRT], context);\n    }\n    return contents;\n};\nconst de_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult = (output, context) => {\n    const contents = {};\n    if (output[_lGRTVIGA] != null) {\n        contents[_LGRTVIGA] = de_LocalGatewayRouteTableVirtualInterfaceGroupAssociation(output[_lGRTVIGA], context);\n    }\n    return contents;\n};\nconst de_DeleteLocalGatewayRouteTableVpcAssociationResult = (output, context) => {\n    const contents = {};\n    if (output[_lGRTVA] != null) {\n        contents[_LGRTVA] = de_LocalGatewayRouteTableVpcAssociation(output[_lGRTVA], context);\n    }\n    return contents;\n};\nconst de_DeleteLocalGatewayVirtualInterfaceGroupResult = (output, context) => {\n    const contents = {};\n    if (output[_lGVIG] != null) {\n        contents[_LGVIG] = de_LocalGatewayVirtualInterfaceGroup(output[_lGVIG], context);\n    }\n    return contents;\n};\nconst de_DeleteLocalGatewayVirtualInterfaceResult = (output, context) => {\n    const contents = {};\n    if (output[_lGVI] != null) {\n        contents[_LGVI] = de_LocalGatewayVirtualInterface(output[_lGVI], context);\n    }\n    return contents;\n};\nconst de_DeleteManagedPrefixListResult = (output, context) => {\n    const contents = {};\n    if (output[_pL] != null) {\n        contents[_PLr] = de_ManagedPrefixList(output[_pL], context);\n    }\n    return contents;\n};\nconst de_DeleteNatGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_nGI] != null) {\n        contents[_NGI] = __expectString(output[_nGI]);\n    }\n    return contents;\n};\nconst de_DeleteNetworkInsightsAccessScopeAnalysisResult = (output, context) => {\n    const contents = {};\n    if (output[_nIASAI] != null) {\n        contents[_NIASAI] = __expectString(output[_nIASAI]);\n    }\n    return contents;\n};\nconst de_DeleteNetworkInsightsAccessScopeResult = (output, context) => {\n    const contents = {};\n    if (output[_nIASI] != null) {\n        contents[_NIASI] = __expectString(output[_nIASI]);\n    }\n    return contents;\n};\nconst de_DeleteNetworkInsightsAnalysisResult = (output, context) => {\n    const contents = {};\n    if (output[_nIAI] != null) {\n        contents[_NIAI] = __expectString(output[_nIAI]);\n    }\n    return contents;\n};\nconst de_DeleteNetworkInsightsPathResult = (output, context) => {\n    const contents = {};\n    if (output[_nIPI] != null) {\n        contents[_NIPI] = __expectString(output[_nIPI]);\n    }\n    return contents;\n};\nconst de_DeleteNetworkInterfacePermissionResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_DeletePublicIpv4PoolResult = (output, context) => {\n    const contents = {};\n    if (output[_rV] != null) {\n        contents[_RV] = __parseBoolean(output[_rV]);\n    }\n    return contents;\n};\nconst de_DeleteQueuedReservedInstancesError = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_DeleteQueuedReservedInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.successfulQueuedPurchaseDeletionSet === \"\") {\n        contents[_SQPD] = [];\n    }\n    else if (output[_sQPDS] != null && output[_sQPDS][_i] != null) {\n        contents[_SQPD] = de_SuccessfulQueuedPurchaseDeletionSet(__getArrayIfSingleItem(output[_sQPDS][_i]), context);\n    }\n    if (output.failedQueuedPurchaseDeletionSet === \"\") {\n        contents[_FQPD] = [];\n    }\n    else if (output[_fQPDS] != null && output[_fQPDS][_i] != null) {\n        contents[_FQPD] = de_FailedQueuedPurchaseDeletionSet(__getArrayIfSingleItem(output[_fQPDS][_i]), context);\n    }\n    return contents;\n};\nconst de_DeleteRouteServerEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_rSE] != null) {\n        contents[_RSE] = de_RouteServerEndpoint(output[_rSE], context);\n    }\n    return contents;\n};\nconst de_DeleteRouteServerPeerResult = (output, context) => {\n    const contents = {};\n    if (output[_rSP] != null) {\n        contents[_RSP] = de_RouteServerPeer(output[_rSP], context);\n    }\n    return contents;\n};\nconst de_DeleteRouteServerResult = (output, context) => {\n    const contents = {};\n    if (output[_rSo] != null) {\n        contents[_RSo] = de_RouteServer(output[_rSo], context);\n    }\n    return contents;\n};\nconst de_DeleteSecurityGroupResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    return contents;\n};\nconst de_DeleteSnapshotResultSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DeleteSnapshotReturnCode(entry, context);\n    });\n};\nconst de_DeleteSnapshotReturnCode = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_rC] != null) {\n        contents[_RCet] = __expectString(output[_rC]);\n    }\n    return contents;\n};\nconst de_DeleteSubnetCidrReservationResult = (output, context) => {\n    const contents = {};\n    if (output[_dSCR] != null) {\n        contents[_DSCRe] = de_SubnetCidrReservation(output[_dSCR], context);\n    }\n    return contents;\n};\nconst de_DeleteTrafficMirrorFilterResult = (output, context) => {\n    const contents = {};\n    if (output[_tMFI] != null) {\n        contents[_TMFI] = __expectString(output[_tMFI]);\n    }\n    return contents;\n};\nconst de_DeleteTrafficMirrorFilterRuleResult = (output, context) => {\n    const contents = {};\n    if (output[_tMFRI] != null) {\n        contents[_TMFRI] = __expectString(output[_tMFRI]);\n    }\n    return contents;\n};\nconst de_DeleteTrafficMirrorSessionResult = (output, context) => {\n    const contents = {};\n    if (output[_tMSI] != null) {\n        contents[_TMSI] = __expectString(output[_tMSI]);\n    }\n    return contents;\n};\nconst de_DeleteTrafficMirrorTargetResult = (output, context) => {\n    const contents = {};\n    if (output[_tMTI] != null) {\n        contents[_TMTI] = __expectString(output[_tMTI]);\n    }\n    return contents;\n};\nconst de_DeleteTransitGatewayConnectPeerResult = (output, context) => {\n    const contents = {};\n    if (output[_tGCP] != null) {\n        contents[_TGCP] = de_TransitGatewayConnectPeer(output[_tGCP], context);\n    }\n    return contents;\n};\nconst de_DeleteTransitGatewayConnectResult = (output, context) => {\n    const contents = {};\n    if (output[_tGC] != null) {\n        contents[_TGCr] = de_TransitGatewayConnect(output[_tGC], context);\n    }\n    return contents;\n};\nconst de_DeleteTransitGatewayMulticastDomainResult = (output, context) => {\n    const contents = {};\n    if (output[_tGMD] != null) {\n        contents[_TGMD] = de_TransitGatewayMulticastDomain(output[_tGMD], context);\n    }\n    return contents;\n};\nconst de_DeleteTransitGatewayPeeringAttachmentResult = (output, context) => {\n    const contents = {};\n    if (output[_tGPA] != null) {\n        contents[_TGPA] = de_TransitGatewayPeeringAttachment(output[_tGPA], context);\n    }\n    return contents;\n};\nconst de_DeleteTransitGatewayPolicyTableResult = (output, context) => {\n    const contents = {};\n    if (output[_tGPT] != null) {\n        contents[_TGPT] = de_TransitGatewayPolicyTable(output[_tGPT], context);\n    }\n    return contents;\n};\nconst de_DeleteTransitGatewayPrefixListReferenceResult = (output, context) => {\n    const contents = {};\n    if (output[_tGPLR] != null) {\n        contents[_TGPLR] = de_TransitGatewayPrefixListReference(output[_tGPLR], context);\n    }\n    return contents;\n};\nconst de_DeleteTransitGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_tG] != null) {\n        contents[_TGr] = de_TransitGateway(output[_tG], context);\n    }\n    return contents;\n};\nconst de_DeleteTransitGatewayRouteResult = (output, context) => {\n    const contents = {};\n    if (output[_ro] != null) {\n        contents[_Rou] = de_TransitGatewayRoute(output[_ro], context);\n    }\n    return contents;\n};\nconst de_DeleteTransitGatewayRouteTableAnnouncementResult = (output, context) => {\n    const contents = {};\n    if (output[_tGRTA] != null) {\n        contents[_TGRTA] = de_TransitGatewayRouteTableAnnouncement(output[_tGRTA], context);\n    }\n    return contents;\n};\nconst de_DeleteTransitGatewayRouteTableResult = (output, context) => {\n    const contents = {};\n    if (output[_tGRT] != null) {\n        contents[_TGRT] = de_TransitGatewayRouteTable(output[_tGRT], context);\n    }\n    return contents;\n};\nconst de_DeleteTransitGatewayVpcAttachmentResult = (output, context) => {\n    const contents = {};\n    if (output[_tGVA] != null) {\n        contents[_TGVA] = de_TransitGatewayVpcAttachment(output[_tGVA], context);\n    }\n    return contents;\n};\nconst de_DeleteVerifiedAccessEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_vAE] != null) {\n        contents[_VAE] = de_VerifiedAccessEndpoint(output[_vAE], context);\n    }\n    return contents;\n};\nconst de_DeleteVerifiedAccessGroupResult = (output, context) => {\n    const contents = {};\n    if (output[_vAG] != null) {\n        contents[_VAG] = de_VerifiedAccessGroup(output[_vAG], context);\n    }\n    return contents;\n};\nconst de_DeleteVerifiedAccessInstanceResult = (output, context) => {\n    const contents = {};\n    if (output[_vAI] != null) {\n        contents[_VAI] = de_VerifiedAccessInstance(output[_vAI], context);\n    }\n    return contents;\n};\nconst de_DeleteVerifiedAccessTrustProviderResult = (output, context) => {\n    const contents = {};\n    if (output[_vATP] != null) {\n        contents[_VATP] = de_VerifiedAccessTrustProvider(output[_vATP], context);\n    }\n    return contents;\n};\nconst de_DeleteVpcBlockPublicAccessExclusionResult = (output, context) => {\n    const contents = {};\n    if (output[_vBPAE] != null) {\n        contents[_VBPAE] = de_VpcBlockPublicAccessExclusion(output[_vBPAE], context);\n    }\n    return contents;\n};\nconst de_DeleteVpcEndpointConnectionNotificationsResult = (output, context) => {\n    const contents = {};\n    if (output.unsuccessful === \"\") {\n        contents[_Un] = [];\n    }\n    else if (output[_u] != null && output[_u][_i] != null) {\n        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);\n    }\n    return contents;\n};\nconst de_DeleteVpcEndpointServiceConfigurationsResult = (output, context) => {\n    const contents = {};\n    if (output.unsuccessful === \"\") {\n        contents[_Un] = [];\n    }\n    else if (output[_u] != null && output[_u][_i] != null) {\n        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);\n    }\n    return contents;\n};\nconst de_DeleteVpcEndpointsResult = (output, context) => {\n    const contents = {};\n    if (output.unsuccessful === \"\") {\n        contents[_Un] = [];\n    }\n    else if (output[_u] != null && output[_u][_i] != null) {\n        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);\n    }\n    return contents;\n};\nconst de_DeleteVpcPeeringConnectionResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_DeprovisionByoipCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_bC] != null) {\n        contents[_BC] = de_ByoipCidr(output[_bC], context);\n    }\n    return contents;\n};\nconst de_DeprovisionedAddressSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_DeprovisionIpamByoasnResult = (output, context) => {\n    const contents = {};\n    if (output[_b] != null) {\n        contents[_Byo] = de_Byoasn(output[_b], context);\n    }\n    return contents;\n};\nconst de_DeprovisionIpamPoolCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_iPC] != null) {\n        contents[_IPCpa] = de_IpamPoolCidr(output[_iPC], context);\n    }\n    return contents;\n};\nconst de_DeprovisionPublicIpv4PoolCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_pIo] != null) {\n        contents[_PIo] = __expectString(output[_pIo]);\n    }\n    if (output.deprovisionedAddressSet === \"\") {\n        contents[_DAep] = [];\n    }\n    else if (output[_dASe] != null && output[_dASe][_i] != null) {\n        contents[_DAep] = de_DeprovisionedAddressSet(__getArrayIfSingleItem(output[_dASe][_i]), context);\n    }\n    return contents;\n};\nconst de_DeregisterImageResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    if (output.deleteSnapshotResultSet === \"\") {\n        contents[_DSR] = [];\n    }\n    else if (output[_dSRS] != null && output[_dSRS][_i] != null) {\n        contents[_DSR] = de_DeleteSnapshotResultSet(__getArrayIfSingleItem(output[_dSRS][_i]), context);\n    }\n    return contents;\n};\nconst de_DeregisterInstanceEventNotificationAttributesResult = (output, context) => {\n    const contents = {};\n    if (output[_iTA] != null) {\n        contents[_ITA] = de_InstanceTagNotificationAttribute(output[_iTA], context);\n    }\n    return contents;\n};\nconst de_DeregisterTransitGatewayMulticastGroupMembersResult = (output, context) => {\n    const contents = {};\n    if (output[_dMGM] != null) {\n        contents[_DMGM] = de_TransitGatewayMulticastDeregisteredGroupMembers(output[_dMGM], context);\n    }\n    return contents;\n};\nconst de_DeregisterTransitGatewayMulticastGroupSourcesResult = (output, context) => {\n    const contents = {};\n    if (output[_dMGS] != null) {\n        contents[_DMGS] = de_TransitGatewayMulticastDeregisteredGroupSources(output[_dMGS], context);\n    }\n    return contents;\n};\nconst de_DescribeAccountAttributesResult = (output, context) => {\n    const contents = {};\n    if (output.accountAttributeSet === \"\") {\n        contents[_AAcc] = [];\n    }\n    else if (output[_aASc] != null && output[_aASc][_i] != null) {\n        contents[_AAcc] = de_AccountAttributeList(__getArrayIfSingleItem(output[_aASc][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeAddressesAttributeResult = (output, context) => {\n    const contents = {};\n    if (output.addressSet === \"\") {\n        contents[_Addr] = [];\n    }\n    else if (output[_aSd] != null && output[_aSd][_i] != null) {\n        contents[_Addr] = de_AddressSet(__getArrayIfSingleItem(output[_aSd][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeAddressesResult = (output, context) => {\n    const contents = {};\n    if (output.addressesSet === \"\") {\n        contents[_Addr] = [];\n    }\n    else if (output[_aSdd] != null && output[_aSdd][_i] != null) {\n        contents[_Addr] = de_AddressList(__getArrayIfSingleItem(output[_aSdd][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeAddressTransfersResult = (output, context) => {\n    const contents = {};\n    if (output.addressTransferSet === \"\") {\n        contents[_ATddr] = [];\n    }\n    else if (output[_aTSd] != null && output[_aTSd][_i] != null) {\n        contents[_ATddr] = de_AddressTransferList(__getArrayIfSingleItem(output[_aTSd][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeAggregateIdFormatResult = (output, context) => {\n    const contents = {};\n    if (output[_uLIA] != null) {\n        contents[_ULIA] = __parseBoolean(output[_uLIA]);\n    }\n    if (output.statusSet === \"\") {\n        contents[_Status] = [];\n    }\n    else if (output[_sSt] != null && output[_sSt][_i] != null) {\n        contents[_Status] = de_IdFormatList(__getArrayIfSingleItem(output[_sSt][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeAvailabilityZonesResult = (output, context) => {\n    const contents = {};\n    if (output.availabilityZoneInfo === \"\") {\n        contents[_AZv] = [];\n    }\n    else if (output[_aZIv] != null && output[_aZIv][_i] != null) {\n        contents[_AZv] = de_AvailabilityZoneList(__getArrayIfSingleItem(output[_aZIv][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeAwsNetworkPerformanceMetricSubscriptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.subscriptionSet === \"\") {\n        contents[_Sub] = [];\n    }\n    else if (output[_sSu] != null && output[_sSu][_i] != null) {\n        contents[_Sub] = de_SubscriptionList(__getArrayIfSingleItem(output[_sSu][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeBundleTasksResult = (output, context) => {\n    const contents = {};\n    if (output.bundleInstanceTasksSet === \"\") {\n        contents[_BTun] = [];\n    }\n    else if (output[_bITS] != null && output[_bITS][_i] != null) {\n        contents[_BTun] = de_BundleTaskList(__getArrayIfSingleItem(output[_bITS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeByoipCidrsResult = (output, context) => {\n    const contents = {};\n    if (output.byoipCidrSet === \"\") {\n        contents[_BCy] = [];\n    }\n    else if (output[_bCS] != null && output[_bCS][_i] != null) {\n        contents[_BCy] = de_ByoipCidrSet(__getArrayIfSingleItem(output[_bCS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeCapacityBlockExtensionHistoryResult = (output, context) => {\n    const contents = {};\n    if (output.capacityBlockExtensionSet === \"\") {\n        contents[_CBE] = [];\n    }\n    else if (output[_cBESa] != null && output[_cBESa][_i] != null) {\n        contents[_CBE] = de_CapacityBlockExtensionSet(__getArrayIfSingleItem(output[_cBESa][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeCapacityBlockExtensionOfferingsResult = (output, context) => {\n    const contents = {};\n    if (output.capacityBlockExtensionOfferingSet === \"\") {\n        contents[_CBEO] = [];\n    }\n    else if (output[_cBEOS] != null && output[_cBEOS][_i] != null) {\n        contents[_CBEO] = de_CapacityBlockExtensionOfferingSet(__getArrayIfSingleItem(output[_cBEOS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeCapacityBlockOfferingsResult = (output, context) => {\n    const contents = {};\n    if (output.capacityBlockOfferingSet === \"\") {\n        contents[_CBO] = [];\n    }\n    else if (output[_cBOS] != null && output[_cBOS][_i] != null) {\n        contents[_CBO] = de_CapacityBlockOfferingSet(__getArrayIfSingleItem(output[_cBOS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeCapacityReservationBillingRequestsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.capacityReservationBillingRequestSet === \"\") {\n        contents[_CRBR] = [];\n    }\n    else if (output[_cRBRS] != null && output[_cRBRS][_i] != null) {\n        contents[_CRBR] = de_CapacityReservationBillingRequestSet(__getArrayIfSingleItem(output[_cRBRS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeCapacityReservationFleetsResult = (output, context) => {\n    const contents = {};\n    if (output.capacityReservationFleetSet === \"\") {\n        contents[_CRF] = [];\n    }\n    else if (output[_cRFS] != null && output[_cRFS][_i] != null) {\n        contents[_CRF] = de_CapacityReservationFleetSet(__getArrayIfSingleItem(output[_cRFS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeCapacityReservationsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.capacityReservationSet === \"\") {\n        contents[_CRapac] = [];\n    }\n    else if (output[_cRS] != null && output[_cRS][_i] != null) {\n        contents[_CRapac] = de_CapacityReservationSet(__getArrayIfSingleItem(output[_cRS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeCarrierGatewaysResult = (output, context) => {\n    const contents = {};\n    if (output.carrierGatewaySet === \"\") {\n        contents[_CGa] = [];\n    }\n    else if (output[_cGS] != null && output[_cGS][_i] != null) {\n        contents[_CGa] = de_CarrierGatewaySet(__getArrayIfSingleItem(output[_cGS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeClassicLinkInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.instancesSet === \"\") {\n        contents[_In] = [];\n    }\n    else if (output[_iSn] != null && output[_iSn][_i] != null) {\n        contents[_In] = de_ClassicLinkInstanceList(__getArrayIfSingleItem(output[_iSn][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeClientVpnAuthorizationRulesResult = (output, context) => {\n    const contents = {};\n    if (output.authorizationRule === \"\") {\n        contents[_ARut] = [];\n    }\n    else if (output[_aR] != null && output[_aR][_i] != null) {\n        contents[_ARut] = de_AuthorizationRuleSet(__getArrayIfSingleItem(output[_aR][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeClientVpnConnectionsResult = (output, context) => {\n    const contents = {};\n    if (output.connections === \"\") {\n        contents[_Conn] = [];\n    }\n    else if (output[_con] != null && output[_con][_i] != null) {\n        contents[_Conn] = de_ClientVpnConnectionSet(__getArrayIfSingleItem(output[_con][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeClientVpnEndpointsResult = (output, context) => {\n    const contents = {};\n    if (output.clientVpnEndpoint === \"\") {\n        contents[_CVEl] = [];\n    }\n    else if (output[_cVE] != null && output[_cVE][_i] != null) {\n        contents[_CVEl] = de_EndpointSet(__getArrayIfSingleItem(output[_cVE][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeClientVpnRoutesResult = (output, context) => {\n    const contents = {};\n    if (output.routes === \"\") {\n        contents[_Rout] = [];\n    }\n    else if (output[_rou] != null && output[_rou][_i] != null) {\n        contents[_Rout] = de_ClientVpnRouteSet(__getArrayIfSingleItem(output[_rou][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeClientVpnTargetNetworksResult = (output, context) => {\n    const contents = {};\n    if (output.clientVpnTargetNetworks === \"\") {\n        contents[_CVTN] = [];\n    }\n    else if (output[_cVTN] != null && output[_cVTN][_i] != null) {\n        contents[_CVTN] = de_TargetNetworkSet(__getArrayIfSingleItem(output[_cVTN][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeCoipPoolsResult = (output, context) => {\n    const contents = {};\n    if (output.coipPoolSet === \"\") {\n        contents[_CPo] = [];\n    }\n    else if (output[_cPS] != null && output[_cPS][_i] != null) {\n        contents[_CPo] = de_CoipPoolSet(__getArrayIfSingleItem(output[_cPS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeConversionTaskList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ConversionTask(entry, context);\n    });\n};\nconst de_DescribeConversionTasksResult = (output, context) => {\n    const contents = {};\n    if (output.conversionTasks === \"\") {\n        contents[_CTon] = [];\n    }\n    else if (output[_cTo] != null && output[_cTo][_i] != null) {\n        contents[_CTon] = de_DescribeConversionTaskList(__getArrayIfSingleItem(output[_cTo][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeCustomerGatewaysResult = (output, context) => {\n    const contents = {};\n    if (output.customerGatewaySet === \"\") {\n        contents[_CGus] = [];\n    }\n    else if (output[_cGSu] != null && output[_cGSu][_i] != null) {\n        contents[_CGus] = de_CustomerGatewayList(__getArrayIfSingleItem(output[_cGSu][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeDeclarativePoliciesReportsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.reportSet === \"\") {\n        contents[_Rep] = [];\n    }\n    else if (output[_rSe] != null && output[_rSe][_i] != null) {\n        contents[_Rep] = de_DeclarativePoliciesReportList(__getArrayIfSingleItem(output[_rSe][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeDhcpOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.dhcpOptionsSet === \"\") {\n        contents[_DOh] = [];\n    }\n    else if (output[_dOS] != null && output[_dOS][_i] != null) {\n        contents[_DOh] = de_DhcpOptionsList(__getArrayIfSingleItem(output[_dOS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeEgressOnlyInternetGatewaysResult = (output, context) => {\n    const contents = {};\n    if (output.egressOnlyInternetGatewaySet === \"\") {\n        contents[_EOIGg] = [];\n    }\n    else if (output[_eOIGS] != null && output[_eOIGS][_i] != null) {\n        contents[_EOIGg] = de_EgressOnlyInternetGatewayList(__getArrayIfSingleItem(output[_eOIGS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeElasticGpusResult = (output, context) => {\n    const contents = {};\n    if (output.elasticGpuSet === \"\") {\n        contents[_EGSla] = [];\n    }\n    else if (output[_eGS] != null && output[_eGS][_i] != null) {\n        contents[_EGSla] = de_ElasticGpuSet(__getArrayIfSingleItem(output[_eGS][_i]), context);\n    }\n    if (output[_mR] != null) {\n        contents[_MR] = __strictParseInt32(output[_mR]);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeExportImageTasksResult = (output, context) => {\n    const contents = {};\n    if (output.exportImageTaskSet === \"\") {\n        contents[_EITx] = [];\n    }\n    else if (output[_eITS] != null && output[_eITS][_i] != null) {\n        contents[_EITx] = de_ExportImageTaskList(__getArrayIfSingleItem(output[_eITS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeExportTasksResult = (output, context) => {\n    const contents = {};\n    if (output.exportTaskSet === \"\") {\n        contents[_ETxpo] = [];\n    }\n    else if (output[_eTS] != null && output[_eTS][_i] != null) {\n        contents[_ETxpo] = de_ExportTaskList(__getArrayIfSingleItem(output[_eTS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeFastLaunchImagesResult = (output, context) => {\n    const contents = {};\n    if (output.fastLaunchImageSet === \"\") {\n        contents[_FLIa] = [];\n    }\n    else if (output[_fLISa] != null && output[_fLISa][_i] != null) {\n        contents[_FLIa] = de_DescribeFastLaunchImagesSuccessSet(__getArrayIfSingleItem(output[_fLISa][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeFastLaunchImagesSuccessItem = (output, context) => {\n    const contents = {};\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_sCn] != null) {\n        contents[_SCn] = de_FastLaunchSnapshotConfigurationResponse(output[_sCn], context);\n    }\n    if (output[_lT] != null) {\n        contents[_LTa] = de_FastLaunchLaunchTemplateSpecificationResponse(output[_lT], context);\n    }\n    if (output[_mPL] != null) {\n        contents[_MPL] = __strictParseInt32(output[_mPL]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sTR] != null) {\n        contents[_STRt] = __expectString(output[_sTR]);\n    }\n    if (output[_sTT] != null) {\n        contents[_STT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sTT]));\n    }\n    return contents;\n};\nconst de_DescribeFastLaunchImagesSuccessSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DescribeFastLaunchImagesSuccessItem(entry, context);\n    });\n};\nconst de_DescribeFastSnapshotRestoresResult = (output, context) => {\n    const contents = {};\n    if (output.fastSnapshotRestoreSet === \"\") {\n        contents[_FSR] = [];\n    }\n    else if (output[_fSRS] != null && output[_fSRS][_i] != null) {\n        contents[_FSR] = de_DescribeFastSnapshotRestoreSuccessSet(__getArrayIfSingleItem(output[_fSRS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeFastSnapshotRestoreSuccessItem = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sTR] != null) {\n        contents[_STRt] = __expectString(output[_sTR]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_oAw] != null) {\n        contents[_OAw] = __expectString(output[_oAw]);\n    }\n    if (output[_eTna] != null) {\n        contents[_ETna] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTna]));\n    }\n    if (output[_oT] != null) {\n        contents[_OTpt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_oT]));\n    }\n    if (output[_eTnab] != null) {\n        contents[_ETnab] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTnab]));\n    }\n    if (output[_dTi] != null) {\n        contents[_DTi] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTi]));\n    }\n    if (output[_dTis] != null) {\n        contents[_DTis] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTis]));\n    }\n    return contents;\n};\nconst de_DescribeFastSnapshotRestoreSuccessSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DescribeFastSnapshotRestoreSuccessItem(entry, context);\n    });\n};\nconst de_DescribeFleetError = (output, context) => {\n    const contents = {};\n    if (output[_lTAO] != null) {\n        contents[_LTAO] = de_LaunchTemplateAndOverridesResponse(output[_lTAO], context);\n    }\n    if (output[_l] != null) {\n        contents[_Li] = __expectString(output[_l]);\n    }\n    if (output[_eC] != null) {\n        contents[_EC] = __expectString(output[_eC]);\n    }\n    if (output[_eM] != null) {\n        contents[_EM] = __expectString(output[_eM]);\n    }\n    return contents;\n};\nconst de_DescribeFleetHistoryResult = (output, context) => {\n    const contents = {};\n    if (output.historyRecordSet === \"\") {\n        contents[_HRi] = [];\n    }\n    else if (output[_hRS] != null && output[_hRS][_i] != null) {\n        contents[_HRi] = de_HistoryRecordSet(__getArrayIfSingleItem(output[_hRS][_i]), context);\n    }\n    if (output[_lET] != null) {\n        contents[_LET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lET]));\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output[_fIl] != null) {\n        contents[_FIl] = __expectString(output[_fIl]);\n    }\n    if (output[_sT] != null) {\n        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));\n    }\n    return contents;\n};\nconst de_DescribeFleetInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.activeInstanceSet === \"\") {\n        contents[_AIc] = [];\n    }\n    else if (output[_aIS] != null && output[_aIS][_i] != null) {\n        contents[_AIc] = de_ActiveInstanceSet(__getArrayIfSingleItem(output[_aIS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output[_fIl] != null) {\n        contents[_FIl] = __expectString(output[_fIl]);\n    }\n    return contents;\n};\nconst de_DescribeFleetsErrorSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DescribeFleetError(entry, context);\n    });\n};\nconst de_DescribeFleetsInstances = (output, context) => {\n    const contents = {};\n    if (output[_lTAO] != null) {\n        contents[_LTAO] = de_LaunchTemplateAndOverridesResponse(output[_lTAO], context);\n    }\n    if (output[_l] != null) {\n        contents[_Li] = __expectString(output[_l]);\n    }\n    if (output.instanceIds === \"\") {\n        contents[_IIns] = [];\n    }\n    else if (output[_iIn] != null && output[_iIn][_i] != null) {\n        contents[_IIns] = de_InstanceIdsSet(__getArrayIfSingleItem(output[_iIn][_i]), context);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_pl] != null) {\n        contents[_Pla] = __expectString(output[_pl]);\n    }\n    return contents;\n};\nconst de_DescribeFleetsInstancesSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DescribeFleetsInstances(entry, context);\n    });\n};\nconst de_DescribeFleetsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.fleetSet === \"\") {\n        contents[_Fl] = [];\n    }\n    else if (output[_fS] != null && output[_fS][_i] != null) {\n        contents[_Fl] = de_FleetSet(__getArrayIfSingleItem(output[_fS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeFlowLogsResult = (output, context) => {\n    const contents = {};\n    if (output.flowLogSet === \"\") {\n        contents[_FL] = [];\n    }\n    else if (output[_fLS] != null && output[_fLS][_i] != null) {\n        contents[_FL] = de_FlowLogSet(__getArrayIfSingleItem(output[_fLS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeFpgaImageAttributeResult = (output, context) => {\n    const contents = {};\n    if (output[_fIA] != null) {\n        contents[_FIAp] = de_FpgaImageAttribute(output[_fIA], context);\n    }\n    return contents;\n};\nconst de_DescribeFpgaImagesResult = (output, context) => {\n    const contents = {};\n    if (output.fpgaImageSet === \"\") {\n        contents[_FIp] = [];\n    }\n    else if (output[_fISp] != null && output[_fISp][_i] != null) {\n        contents[_FIp] = de_FpgaImageList(__getArrayIfSingleItem(output[_fISp][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeHostReservationOfferingsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.offeringSet === \"\") {\n        contents[_OS] = [];\n    }\n    else if (output[_oS] != null && output[_oS][_i] != null) {\n        contents[_OS] = de_HostOfferingSet(__getArrayIfSingleItem(output[_oS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeHostReservationsResult = (output, context) => {\n    const contents = {};\n    if (output.hostReservationSet === \"\") {\n        contents[_HRS] = [];\n    }\n    else if (output[_hRSo] != null && output[_hRSo][_i] != null) {\n        contents[_HRS] = de_HostReservationSet(__getArrayIfSingleItem(output[_hRSo][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeHostsResult = (output, context) => {\n    const contents = {};\n    if (output.hostSet === \"\") {\n        contents[_Ho] = [];\n    }\n    else if (output[_hS] != null && output[_hS][_i] != null) {\n        contents[_Ho] = de_HostList(__getArrayIfSingleItem(output[_hS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeIamInstanceProfileAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.iamInstanceProfileAssociationSet === \"\") {\n        contents[_IIPAa] = [];\n    }\n    else if (output[_iIPAS] != null && output[_iIPAS][_i] != null) {\n        contents[_IIPAa] = de_IamInstanceProfileAssociationSet(__getArrayIfSingleItem(output[_iIPAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeIdentityIdFormatResult = (output, context) => {\n    const contents = {};\n    if (output.statusSet === \"\") {\n        contents[_Status] = [];\n    }\n    else if (output[_sSt] != null && output[_sSt][_i] != null) {\n        contents[_Status] = de_IdFormatList(__getArrayIfSingleItem(output[_sSt][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeIdFormatResult = (output, context) => {\n    const contents = {};\n    if (output.statusSet === \"\") {\n        contents[_Status] = [];\n    }\n    else if (output[_sSt] != null && output[_sSt][_i] != null) {\n        contents[_Status] = de_IdFormatList(__getArrayIfSingleItem(output[_sSt][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeImagesResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.imagesSet === \"\") {\n        contents[_Ima] = [];\n    }\n    else if (output[_iSm] != null && output[_iSm][_i] != null) {\n        contents[_Ima] = de_ImageList(__getArrayIfSingleItem(output[_iSm][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeImportImageTasksResult = (output, context) => {\n    const contents = {};\n    if (output.importImageTaskSet === \"\") {\n        contents[_IIT] = [];\n    }\n    else if (output[_iITS] != null && output[_iITS][_i] != null) {\n        contents[_IIT] = de_ImportImageTaskList(__getArrayIfSingleItem(output[_iITS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeImportSnapshotTasksResult = (output, context) => {\n    const contents = {};\n    if (output.importSnapshotTaskSet === \"\") {\n        contents[_IST] = [];\n    }\n    else if (output[_iSTS] != null && output[_iSTS][_i] != null) {\n        contents[_IST] = de_ImportSnapshotTaskList(__getArrayIfSingleItem(output[_iSTS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeInstanceConnectEndpointsResult = (output, context) => {\n    const contents = {};\n    if (output.instanceConnectEndpointSet === \"\") {\n        contents[_ICEn] = [];\n    }\n    else if (output[_iCES] != null && output[_iCES][_i] != null) {\n        contents[_ICEn] = de_InstanceConnectEndpointSet(__getArrayIfSingleItem(output[_iCES][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeInstanceCreditSpecificationsResult = (output, context) => {\n    const contents = {};\n    if (output.instanceCreditSpecificationSet === \"\") {\n        contents[_ICS] = [];\n    }\n    else if (output[_iCSS] != null && output[_iCSS][_i] != null) {\n        contents[_ICS] = de_InstanceCreditSpecificationList(__getArrayIfSingleItem(output[_iCSS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeInstanceEventNotificationAttributesResult = (output, context) => {\n    const contents = {};\n    if (output[_iTA] != null) {\n        contents[_ITA] = de_InstanceTagNotificationAttribute(output[_iTA], context);\n    }\n    return contents;\n};\nconst de_DescribeInstanceEventWindowsResult = (output, context) => {\n    const contents = {};\n    if (output.instanceEventWindowSet === \"\") {\n        contents[_IEWn] = [];\n    }\n    else if (output[_iEWSn] != null && output[_iEWSn][_i] != null) {\n        contents[_IEWn] = de_InstanceEventWindowSet(__getArrayIfSingleItem(output[_iEWSn][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeInstanceImageMetadataResult = (output, context) => {\n    const contents = {};\n    if (output.instanceImageMetadataSet === \"\") {\n        contents[_IIM] = [];\n    }\n    else if (output[_iIMS] != null && output[_iIMS][_i] != null) {\n        contents[_IIM] = de_InstanceImageMetadataList(__getArrayIfSingleItem(output[_iIMS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeInstancesResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.reservationSet === \"\") {\n        contents[_Rese] = [];\n    }\n    else if (output[_rSes] != null && output[_rSes][_i] != null) {\n        contents[_Rese] = de_ReservationList(__getArrayIfSingleItem(output[_rSes][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeInstanceStatusResult = (output, context) => {\n    const contents = {};\n    if (output.instanceStatusSet === \"\") {\n        contents[_ISns] = [];\n    }\n    else if (output[_iSS] != null && output[_iSS][_i] != null) {\n        contents[_ISns] = de_InstanceStatusList(__getArrayIfSingleItem(output[_iSS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeInstanceTopologyResult = (output, context) => {\n    const contents = {};\n    if (output.instanceSet === \"\") {\n        contents[_In] = [];\n    }\n    else if (output[_iSns] != null && output[_iSns][_i] != null) {\n        contents[_In] = de_InstanceSet(__getArrayIfSingleItem(output[_iSns][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeInstanceTypeOfferingsResult = (output, context) => {\n    const contents = {};\n    if (output.instanceTypeOfferingSet === \"\") {\n        contents[_ITO] = [];\n    }\n    else if (output[_iTOS] != null && output[_iTOS][_i] != null) {\n        contents[_ITO] = de_InstanceTypeOfferingsList(__getArrayIfSingleItem(output[_iTOS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeInstanceTypesResult = (output, context) => {\n    const contents = {};\n    if (output.instanceTypeSet === \"\") {\n        contents[_ITnst] = [];\n    }\n    else if (output[_iTS] != null && output[_iTS][_i] != null) {\n        contents[_ITnst] = de_InstanceTypeInfoList(__getArrayIfSingleItem(output[_iTS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeInternetGatewaysResult = (output, context) => {\n    const contents = {};\n    if (output.internetGatewaySet === \"\") {\n        contents[_IGnt] = [];\n    }\n    else if (output[_iGS] != null && output[_iGS][_i] != null) {\n        contents[_IGnt] = de_InternetGatewayList(__getArrayIfSingleItem(output[_iGS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeIpamByoasnResult = (output, context) => {\n    const contents = {};\n    if (output.byoasnSet === \"\") {\n        contents[_Byoa] = [];\n    }\n    else if (output[_bS] != null && output[_bS][_i] != null) {\n        contents[_Byoa] = de_ByoasnSet(__getArrayIfSingleItem(output[_bS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeIpamExternalResourceVerificationTokensResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.ipamExternalResourceVerificationTokenSet === \"\") {\n        contents[_IERVTp] = [];\n    }\n    else if (output[_iERVTS] != null && output[_iERVTS][_i] != null) {\n        contents[_IERVTp] = de_IpamExternalResourceVerificationTokenSet(__getArrayIfSingleItem(output[_iERVTS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeIpamPoolsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.ipamPoolSet === \"\") {\n        contents[_IPpam] = [];\n    }\n    else if (output[_iPS] != null && output[_iPS][_i] != null) {\n        contents[_IPpam] = de_IpamPoolSet(__getArrayIfSingleItem(output[_iPS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeIpamResourceDiscoveriesResult = (output, context) => {\n    const contents = {};\n    if (output.ipamResourceDiscoverySet === \"\") {\n        contents[_IRDp] = [];\n    }\n    else if (output[_iRDS] != null && output[_iRDS][_i] != null) {\n        contents[_IRDp] = de_IpamResourceDiscoverySet(__getArrayIfSingleItem(output[_iRDS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeIpamResourceDiscoveryAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.ipamResourceDiscoveryAssociationSet === \"\") {\n        contents[_IRDAp] = [];\n    }\n    else if (output[_iRDAS] != null && output[_iRDAS][_i] != null) {\n        contents[_IRDAp] = de_IpamResourceDiscoveryAssociationSet(__getArrayIfSingleItem(output[_iRDAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeIpamScopesResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.ipamScopeSet === \"\") {\n        contents[_ISpam] = [];\n    }\n    else if (output[_iSSp] != null && output[_iSSp][_i] != null) {\n        contents[_ISpam] = de_IpamScopeSet(__getArrayIfSingleItem(output[_iSSp][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeIpamsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.ipamSet === \"\") {\n        contents[_Ipam] = [];\n    }\n    else if (output[_iSp] != null && output[_iSp][_i] != null) {\n        contents[_Ipam] = de_IpamSet(__getArrayIfSingleItem(output[_iSp][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeIpv6PoolsResult = (output, context) => {\n    const contents = {};\n    if (output.ipv6PoolSet === \"\") {\n        contents[_IPpvo] = [];\n    }\n    else if (output[_iPSp] != null && output[_iPSp][_i] != null) {\n        contents[_IPpvo] = de_Ipv6PoolSet(__getArrayIfSingleItem(output[_iPSp][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeKeyPairsResult = (output, context) => {\n    const contents = {};\n    if (output.keySet === \"\") {\n        contents[_KP] = [];\n    }\n    else if (output[_kS] != null && output[_kS][_i] != null) {\n        contents[_KP] = de_KeyPairList(__getArrayIfSingleItem(output[_kS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeLaunchTemplatesResult = (output, context) => {\n    const contents = {};\n    if (output.launchTemplates === \"\") {\n        contents[_LTau] = [];\n    }\n    else if (output[_lTa] != null && output[_lTa][_i] != null) {\n        contents[_LTau] = de_LaunchTemplateSet(__getArrayIfSingleItem(output[_lTa][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeLaunchTemplateVersionsResult = (output, context) => {\n    const contents = {};\n    if (output.launchTemplateVersionSet === \"\") {\n        contents[_LTVa] = [];\n    }\n    else if (output[_lTVS] != null && output[_lTVS][_i] != null) {\n        contents[_LTVa] = de_LaunchTemplateVersionSet(__getArrayIfSingleItem(output[_lTVS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeLocalGatewayRouteTablesResult = (output, context) => {\n    const contents = {};\n    if (output.localGatewayRouteTableSet === \"\") {\n        contents[_LGRTo] = [];\n    }\n    else if (output[_lGRTS] != null && output[_lGRTS][_i] != null) {\n        contents[_LGRTo] = de_LocalGatewayRouteTableSet(__getArrayIfSingleItem(output[_lGRTS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.localGatewayRouteTableVirtualInterfaceGroupAssociationSet === \"\") {\n        contents[_LGRTVIGAo] = [];\n    }\n    else if (output[_lGRTVIGAS] != null && output[_lGRTVIGAS][_i] != null) {\n        contents[_LGRTVIGAo] = de_LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet(__getArrayIfSingleItem(output[_lGRTVIGAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeLocalGatewayRouteTableVpcAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.localGatewayRouteTableVpcAssociationSet === \"\") {\n        contents[_LGRTVAo] = [];\n    }\n    else if (output[_lGRTVAS] != null && output[_lGRTVAS][_i] != null) {\n        contents[_LGRTVAo] = de_LocalGatewayRouteTableVpcAssociationSet(__getArrayIfSingleItem(output[_lGRTVAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeLocalGatewaysResult = (output, context) => {\n    const contents = {};\n    if (output.localGatewaySet === \"\") {\n        contents[_LGoc] = [];\n    }\n    else if (output[_lGS] != null && output[_lGS][_i] != null) {\n        contents[_LGoc] = de_LocalGatewaySet(__getArrayIfSingleItem(output[_lGS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeLocalGatewayVirtualInterfaceGroupsResult = (output, context) => {\n    const contents = {};\n    if (output.localGatewayVirtualInterfaceGroupSet === \"\") {\n        contents[_LGVIGo] = [];\n    }\n    else if (output[_lGVIGS] != null && output[_lGVIGS][_i] != null) {\n        contents[_LGVIGo] = de_LocalGatewayVirtualInterfaceGroupSet(__getArrayIfSingleItem(output[_lGVIGS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeLocalGatewayVirtualInterfacesResult = (output, context) => {\n    const contents = {};\n    if (output.localGatewayVirtualInterfaceSet === \"\") {\n        contents[_LGVIo] = [];\n    }\n    else if (output[_lGVIS] != null && output[_lGVIS][_i] != null) {\n        contents[_LGVIo] = de_LocalGatewayVirtualInterfaceSet(__getArrayIfSingleItem(output[_lGVIS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeLockedSnapshotsResult = (output, context) => {\n    const contents = {};\n    if (output.snapshotSet === \"\") {\n        contents[_Sn] = [];\n    }\n    else if (output[_sS] != null && output[_sS][_i] != null) {\n        contents[_Sn] = de_LockedSnapshotsInfoList(__getArrayIfSingleItem(output[_sS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeMacHostsResult = (output, context) => {\n    const contents = {};\n    if (output.macHostSet === \"\") {\n        contents[_MHa] = [];\n    }\n    else if (output[_mHS] != null && output[_mHS][_i] != null) {\n        contents[_MHa] = de_MacHostList(__getArrayIfSingleItem(output[_mHS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeMacModificationTasksResult = (output, context) => {\n    const contents = {};\n    if (output.macModificationTaskSet === \"\") {\n        contents[_MMTa] = [];\n    }\n    else if (output[_mMTS] != null && output[_mMTS][_i] != null) {\n        contents[_MMTa] = de_MacModificationTaskList(__getArrayIfSingleItem(output[_mMTS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeManagedPrefixListsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.prefixListSet === \"\") {\n        contents[_PLre] = [];\n    }\n    else if (output[_pLS] != null && output[_pLS][_i] != null) {\n        contents[_PLre] = de_ManagedPrefixListSet(__getArrayIfSingleItem(output[_pLS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeMovingAddressesResult = (output, context) => {\n    const contents = {};\n    if (output.movingAddressStatusSet === \"\") {\n        contents[_MAS] = [];\n    }\n    else if (output[_mASS] != null && output[_mASS][_i] != null) {\n        contents[_MAS] = de_MovingAddressStatusSet(__getArrayIfSingleItem(output[_mASS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeNatGatewaysResult = (output, context) => {\n    const contents = {};\n    if (output.natGatewaySet === \"\") {\n        contents[_NGa] = [];\n    }\n    else if (output[_nGS] != null && output[_nGS][_i] != null) {\n        contents[_NGa] = de_NatGatewayList(__getArrayIfSingleItem(output[_nGS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeNetworkAclsResult = (output, context) => {\n    const contents = {};\n    if (output.networkAclSet === \"\") {\n        contents[_NAe] = [];\n    }\n    else if (output[_nAS] != null && output[_nAS][_i] != null) {\n        contents[_NAe] = de_NetworkAclList(__getArrayIfSingleItem(output[_nAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeNetworkInsightsAccessScopeAnalysesResult = (output, context) => {\n    const contents = {};\n    if (output.networkInsightsAccessScopeAnalysisSet === \"\") {\n        contents[_NIASA] = [];\n    }\n    else if (output[_nIASAS] != null && output[_nIASAS][_i] != null) {\n        contents[_NIASA] = de_NetworkInsightsAccessScopeAnalysisList(__getArrayIfSingleItem(output[_nIASAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeNetworkInsightsAccessScopesResult = (output, context) => {\n    const contents = {};\n    if (output.networkInsightsAccessScopeSet === \"\") {\n        contents[_NIASe] = [];\n    }\n    else if (output[_nIASS] != null && output[_nIASS][_i] != null) {\n        contents[_NIASe] = de_NetworkInsightsAccessScopeList(__getArrayIfSingleItem(output[_nIASS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeNetworkInsightsAnalysesResult = (output, context) => {\n    const contents = {};\n    if (output.networkInsightsAnalysisSet === \"\") {\n        contents[_NIA] = [];\n    }\n    else if (output[_nIASe] != null && output[_nIASe][_i] != null) {\n        contents[_NIA] = de_NetworkInsightsAnalysisList(__getArrayIfSingleItem(output[_nIASe][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeNetworkInsightsPathsResult = (output, context) => {\n    const contents = {};\n    if (output.networkInsightsPathSet === \"\") {\n        contents[_NIPe] = [];\n    }\n    else if (output[_nIPS] != null && output[_nIPS][_i] != null) {\n        contents[_NIPe] = de_NetworkInsightsPathList(__getArrayIfSingleItem(output[_nIPS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeNetworkInterfaceAttributeResult = (output, context) => {\n    const contents = {};\n    if (output[_at] != null) {\n        contents[_Att] = de_NetworkInterfaceAttachment(output[_at], context);\n    }\n    if (output[_de] != null) {\n        contents[_De] = de_AttributeValue(output[_de], context);\n    }\n    if (output.groupSet === \"\") {\n        contents[_G] = [];\n    }\n    else if (output[_gS] != null && output[_gS][_i] != null) {\n        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_sDC] != null) {\n        contents[_SDC] = de_AttributeBooleanValue(output[_sDC], context);\n    }\n    if (output[_aPIA] != null) {\n        contents[_APIAs] = __parseBoolean(output[_aPIA]);\n    }\n    return contents;\n};\nconst de_DescribeNetworkInterfacePermissionsResult = (output, context) => {\n    const contents = {};\n    if (output.networkInterfacePermissions === \"\") {\n        contents[_NIPet] = [];\n    }\n    else if (output[_nIPe] != null && output[_nIPe][_i] != null) {\n        contents[_NIPet] = de_NetworkInterfacePermissionList(__getArrayIfSingleItem(output[_nIPe][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeNetworkInterfacesResult = (output, context) => {\n    const contents = {};\n    if (output.networkInterfaceSet === \"\") {\n        contents[_NI] = [];\n    }\n    else if (output[_nIS] != null && output[_nIS][_i] != null) {\n        contents[_NI] = de_NetworkInterfaceList(__getArrayIfSingleItem(output[_nIS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeOutpostLagsResult = (output, context) => {\n    const contents = {};\n    if (output.outpostLagSet === \"\") {\n        contents[_OL] = [];\n    }\n    else if (output[_oLS] != null && output[_oLS][_i] != null) {\n        contents[_OL] = de_OutpostLagSet(__getArrayIfSingleItem(output[_oLS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribePlacementGroupsResult = (output, context) => {\n    const contents = {};\n    if (output.placementGroupSet === \"\") {\n        contents[_PGl] = [];\n    }\n    else if (output[_pGS] != null && output[_pGS][_i] != null) {\n        contents[_PGl] = de_PlacementGroupList(__getArrayIfSingleItem(output[_pGS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribePrefixListsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.prefixListSet === \"\") {\n        contents[_PLre] = [];\n    }\n    else if (output[_pLS] != null && output[_pLS][_i] != null) {\n        contents[_PLre] = de_PrefixListSet(__getArrayIfSingleItem(output[_pLS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribePrincipalIdFormatResult = (output, context) => {\n    const contents = {};\n    if (output.principalSet === \"\") {\n        contents[_Princ] = [];\n    }\n    else if (output[_pSri] != null && output[_pSri][_i] != null) {\n        contents[_Princ] = de_PrincipalIdFormatList(__getArrayIfSingleItem(output[_pSri][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribePublicIpv4PoolsResult = (output, context) => {\n    const contents = {};\n    if (output.publicIpv4PoolSet === \"\") {\n        contents[_PIPu] = [];\n    }\n    else if (output[_pIPS] != null && output[_pIPS][_i] != null) {\n        contents[_PIPu] = de_PublicIpv4PoolSet(__getArrayIfSingleItem(output[_pIPS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeRegionsResult = (output, context) => {\n    const contents = {};\n    if (output.regionInfo === \"\") {\n        contents[_Reg] = [];\n    }\n    else if (output[_rIe] != null && output[_rIe][_i] != null) {\n        contents[_Reg] = de_RegionList(__getArrayIfSingleItem(output[_rIe][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeReplaceRootVolumeTasksResult = (output, context) => {\n    const contents = {};\n    if (output.replaceRootVolumeTaskSet === \"\") {\n        contents[_RRVTe] = [];\n    }\n    else if (output[_rRVTS] != null && output[_rRVTS][_i] != null) {\n        contents[_RRVTe] = de_ReplaceRootVolumeTasks(__getArrayIfSingleItem(output[_rRVTS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeReservedInstancesListingsResult = (output, context) => {\n    const contents = {};\n    if (output.reservedInstancesListingsSet === \"\") {\n        contents[_RIL] = [];\n    }\n    else if (output[_rILS] != null && output[_rILS][_i] != null) {\n        contents[_RIL] = de_ReservedInstancesListingList(__getArrayIfSingleItem(output[_rILS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeReservedInstancesModificationsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.reservedInstancesModificationsSet === \"\") {\n        contents[_RIM] = [];\n    }\n    else if (output[_rIMS] != null && output[_rIMS][_i] != null) {\n        contents[_RIM] = de_ReservedInstancesModificationList(__getArrayIfSingleItem(output[_rIMS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeReservedInstancesOfferingsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.reservedInstancesOfferingsSet === \"\") {\n        contents[_RIO] = [];\n    }\n    else if (output[_rIOS] != null && output[_rIOS][_i] != null) {\n        contents[_RIO] = de_ReservedInstancesOfferingList(__getArrayIfSingleItem(output[_rIOS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeReservedInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.reservedInstancesSet === \"\") {\n        contents[_RIese] = [];\n    }\n    else if (output[_rIS] != null && output[_rIS][_i] != null) {\n        contents[_RIese] = de_ReservedInstancesList(__getArrayIfSingleItem(output[_rIS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeRouteServerEndpointsResult = (output, context) => {\n    const contents = {};\n    if (output.routeServerEndpointSet === \"\") {\n        contents[_RSEo] = [];\n    }\n    else if (output[_rSES] != null && output[_rSES][_i] != null) {\n        contents[_RSEo] = de_RouteServerEndpointsList(__getArrayIfSingleItem(output[_rSES][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeRouteServerPeersResult = (output, context) => {\n    const contents = {};\n    if (output.routeServerPeerSet === \"\") {\n        contents[_RSPo] = [];\n    }\n    else if (output[_rSPS] != null && output[_rSPS][_i] != null) {\n        contents[_RSPo] = de_RouteServerPeersList(__getArrayIfSingleItem(output[_rSPS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeRouteServersResult = (output, context) => {\n    const contents = {};\n    if (output.routeServerSet === \"\") {\n        contents[_RSou] = [];\n    }\n    else if (output[_rSSo] != null && output[_rSSo][_i] != null) {\n        contents[_RSou] = de_RouteServersList(__getArrayIfSingleItem(output[_rSSo][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeRouteTablesResult = (output, context) => {\n    const contents = {};\n    if (output.routeTableSet === \"\") {\n        contents[_RTou] = [];\n    }\n    else if (output[_rTS] != null && output[_rTS][_i] != null) {\n        contents[_RTou] = de_RouteTableList(__getArrayIfSingleItem(output[_rTS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeScheduledInstanceAvailabilityResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.scheduledInstanceAvailabilitySet === \"\") {\n        contents[_SIAS] = [];\n    }\n    else if (output[_sIAS] != null && output[_sIAS][_i] != null) {\n        contents[_SIAS] = de_ScheduledInstanceAvailabilitySet(__getArrayIfSingleItem(output[_sIAS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeScheduledInstancesResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.scheduledInstanceSet === \"\") {\n        contents[_SIS] = [];\n    }\n    else if (output[_sIS] != null && output[_sIS][_i] != null) {\n        contents[_SIS] = de_ScheduledInstanceSet(__getArrayIfSingleItem(output[_sIS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeSecurityGroupReferencesResult = (output, context) => {\n    const contents = {};\n    if (output.securityGroupReferenceSet === \"\") {\n        contents[_SGRSe] = [];\n    }\n    else if (output[_sGRSe] != null && output[_sGRSe][_i] != null) {\n        contents[_SGRSe] = de_SecurityGroupReferences(__getArrayIfSingleItem(output[_sGRSe][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeSecurityGroupRulesResult = (output, context) => {\n    const contents = {};\n    if (output.securityGroupRuleSet === \"\") {\n        contents[_SGR] = [];\n    }\n    else if (output[_sGRS] != null && output[_sGRS][_i] != null) {\n        contents[_SGR] = de_SecurityGroupRuleList(__getArrayIfSingleItem(output[_sGRS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeSecurityGroupsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.securityGroupInfo === \"\") {\n        contents[_SG] = [];\n    }\n    else if (output[_sGIec] != null && output[_sGIec][_i] != null) {\n        contents[_SG] = de_SecurityGroupList(__getArrayIfSingleItem(output[_sGIec][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeSecurityGroupVpcAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.securityGroupVpcAssociationSet === \"\") {\n        contents[_SGVA] = [];\n    }\n    else if (output[_sGVAS] != null && output[_sGVAS][_i] != null) {\n        contents[_SGVA] = de_SecurityGroupVpcAssociationList(__getArrayIfSingleItem(output[_sGVAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeServiceLinkVirtualInterfacesResult = (output, context) => {\n    const contents = {};\n    if (output.serviceLinkVirtualInterfaceSet === \"\") {\n        contents[_SLVI] = [];\n    }\n    else if (output[_sLVIS] != null && output[_sLVIS][_i] != null) {\n        contents[_SLVI] = de_ServiceLinkVirtualInterfaceSet(__getArrayIfSingleItem(output[_sLVIS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeSnapshotAttributeResult = (output, context) => {\n    const contents = {};\n    if (output.productCodes === \"\") {\n        contents[_PCr] = [];\n    }\n    else if (output[_pC] != null && output[_pC][_i] != null) {\n        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output.createVolumePermission === \"\") {\n        contents[_CVPr] = [];\n    }\n    else if (output[_cVP] != null && output[_cVP][_i] != null) {\n        contents[_CVPr] = de_CreateVolumePermissionList(__getArrayIfSingleItem(output[_cVP][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeSnapshotsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.snapshotSet === \"\") {\n        contents[_Sn] = [];\n    }\n    else if (output[_sS] != null && output[_sS][_i] != null) {\n        contents[_Sn] = de_SnapshotList(__getArrayIfSingleItem(output[_sS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeSnapshotTierStatusResult = (output, context) => {\n    const contents = {};\n    if (output.snapshotTierStatusSet === \"\") {\n        contents[_STS] = [];\n    }\n    else if (output[_sTSS] != null && output[_sTSS][_i] != null) {\n        contents[_STS] = de_snapshotTierStatusSet(__getArrayIfSingleItem(output[_sTSS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeSpotDatafeedSubscriptionResult = (output, context) => {\n    const contents = {};\n    if (output[_sDS] != null) {\n        contents[_SDS] = de_SpotDatafeedSubscription(output[_sDS], context);\n    }\n    return contents;\n};\nconst de_DescribeSpotFleetInstancesResponse = (output, context) => {\n    const contents = {};\n    if (output.activeInstanceSet === \"\") {\n        contents[_AIc] = [];\n    }\n    else if (output[_aIS] != null && output[_aIS][_i] != null) {\n        contents[_AIc] = de_ActiveInstanceSet(__getArrayIfSingleItem(output[_aIS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output[_sFRI] != null) {\n        contents[_SFRIp] = __expectString(output[_sFRI]);\n    }\n    return contents;\n};\nconst de_DescribeSpotFleetRequestHistoryResponse = (output, context) => {\n    const contents = {};\n    if (output.historyRecordSet === \"\") {\n        contents[_HRi] = [];\n    }\n    else if (output[_hRS] != null && output[_hRS][_i] != null) {\n        contents[_HRi] = de_HistoryRecords(__getArrayIfSingleItem(output[_hRS][_i]), context);\n    }\n    if (output[_lET] != null) {\n        contents[_LET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lET]));\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output[_sFRI] != null) {\n        contents[_SFRIp] = __expectString(output[_sFRI]);\n    }\n    if (output[_sT] != null) {\n        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));\n    }\n    return contents;\n};\nconst de_DescribeSpotFleetRequestsResponse = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.spotFleetRequestConfigSet === \"\") {\n        contents[_SFRCp] = [];\n    }\n    else if (output[_sFRCS] != null && output[_sFRCS][_i] != null) {\n        contents[_SFRCp] = de_SpotFleetRequestConfigSet(__getArrayIfSingleItem(output[_sFRCS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeSpotInstanceRequestsResult = (output, context) => {\n    const contents = {};\n    if (output.spotInstanceRequestSet === \"\") {\n        contents[_SIR] = [];\n    }\n    else if (output[_sIRS] != null && output[_sIRS][_i] != null) {\n        contents[_SIR] = de_SpotInstanceRequestList(__getArrayIfSingleItem(output[_sIRS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeSpotPriceHistoryResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.spotPriceHistorySet === \"\") {\n        contents[_SPH] = [];\n    }\n    else if (output[_sPHS] != null && output[_sPHS][_i] != null) {\n        contents[_SPH] = de_SpotPriceHistoryList(__getArrayIfSingleItem(output[_sPHS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeStaleSecurityGroupsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.staleSecurityGroupSet === \"\") {\n        contents[_SSGS] = [];\n    }\n    else if (output[_sSGS] != null && output[_sSGS][_i] != null) {\n        contents[_SSGS] = de_StaleSecurityGroupSet(__getArrayIfSingleItem(output[_sSGS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeStoreImageTasksResult = (output, context) => {\n    const contents = {};\n    if (output.storeImageTaskResultSet === \"\") {\n        contents[_SITR] = [];\n    }\n    else if (output[_sITRS] != null && output[_sITRS][_i] != null) {\n        contents[_SITR] = de_StoreImageTaskResultSet(__getArrayIfSingleItem(output[_sITRS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeSubnetsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.subnetSet === \"\") {\n        contents[_Subn] = [];\n    }\n    else if (output[_sSub] != null && output[_sSub][_i] != null) {\n        contents[_Subn] = de_SubnetList(__getArrayIfSingleItem(output[_sSub][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeTagsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagDescriptionList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeTrafficMirrorFilterRulesResult = (output, context) => {\n    const contents = {};\n    if (output.trafficMirrorFilterRuleSet === \"\") {\n        contents[_TMFRr] = [];\n    }\n    else if (output[_tMFRS] != null && output[_tMFRS][_i] != null) {\n        contents[_TMFRr] = de_TrafficMirrorFilterRuleSet(__getArrayIfSingleItem(output[_tMFRS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTrafficMirrorFiltersResult = (output, context) => {\n    const contents = {};\n    if (output.trafficMirrorFilterSet === \"\") {\n        contents[_TMFr] = [];\n    }\n    else if (output[_tMFS] != null && output[_tMFS][_i] != null) {\n        contents[_TMFr] = de_TrafficMirrorFilterSet(__getArrayIfSingleItem(output[_tMFS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTrafficMirrorSessionsResult = (output, context) => {\n    const contents = {};\n    if (output.trafficMirrorSessionSet === \"\") {\n        contents[_TMSr] = [];\n    }\n    else if (output[_tMSS] != null && output[_tMSS][_i] != null) {\n        contents[_TMSr] = de_TrafficMirrorSessionSet(__getArrayIfSingleItem(output[_tMSS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTrafficMirrorTargetsResult = (output, context) => {\n    const contents = {};\n    if (output.trafficMirrorTargetSet === \"\") {\n        contents[_TMTr] = [];\n    }\n    else if (output[_tMTS] != null && output[_tMTS][_i] != null) {\n        contents[_TMTr] = de_TrafficMirrorTargetSet(__getArrayIfSingleItem(output[_tMTS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTransitGatewayAttachmentsResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayAttachments === \"\") {\n        contents[_TGAr] = [];\n    }\n    else if (output[_tGA] != null && output[_tGA][_i] != null) {\n        contents[_TGAr] = de_TransitGatewayAttachmentList(__getArrayIfSingleItem(output[_tGA][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTransitGatewayConnectPeersResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayConnectPeerSet === \"\") {\n        contents[_TGCPr] = [];\n    }\n    else if (output[_tGCPS] != null && output[_tGCPS][_i] != null) {\n        contents[_TGCPr] = de_TransitGatewayConnectPeerList(__getArrayIfSingleItem(output[_tGCPS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTransitGatewayConnectsResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayConnectSet === \"\") {\n        contents[_TGCra] = [];\n    }\n    else if (output[_tGCS] != null && output[_tGCS][_i] != null) {\n        contents[_TGCra] = de_TransitGatewayConnectList(__getArrayIfSingleItem(output[_tGCS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTransitGatewayMulticastDomainsResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayMulticastDomains === \"\") {\n        contents[_TGMDr] = [];\n    }\n    else if (output[_tGMDr] != null && output[_tGMDr][_i] != null) {\n        contents[_TGMDr] = de_TransitGatewayMulticastDomainList(__getArrayIfSingleItem(output[_tGMDr][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTransitGatewayPeeringAttachmentsResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayPeeringAttachments === \"\") {\n        contents[_TGPAr] = [];\n    }\n    else if (output[_tGPAr] != null && output[_tGPAr][_i] != null) {\n        contents[_TGPAr] = de_TransitGatewayPeeringAttachmentList(__getArrayIfSingleItem(output[_tGPAr][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTransitGatewayPolicyTablesResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayPolicyTables === \"\") {\n        contents[_TGPTr] = [];\n    }\n    else if (output[_tGPTr] != null && output[_tGPTr][_i] != null) {\n        contents[_TGPTr] = de_TransitGatewayPolicyTableList(__getArrayIfSingleItem(output[_tGPTr][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTransitGatewayRouteTableAnnouncementsResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayRouteTableAnnouncements === \"\") {\n        contents[_TGRTAr] = [];\n    }\n    else if (output[_tGRTAr] != null && output[_tGRTAr][_i] != null) {\n        contents[_TGRTAr] = de_TransitGatewayRouteTableAnnouncementList(__getArrayIfSingleItem(output[_tGRTAr][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTransitGatewayRouteTablesResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayRouteTables === \"\") {\n        contents[_TGRTr] = [];\n    }\n    else if (output[_tGRTr] != null && output[_tGRTr][_i] != null) {\n        contents[_TGRTr] = de_TransitGatewayRouteTableList(__getArrayIfSingleItem(output[_tGRTr][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTransitGatewaysResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewaySet === \"\") {\n        contents[_TGra] = [];\n    }\n    else if (output[_tGS] != null && output[_tGS][_i] != null) {\n        contents[_TGra] = de_TransitGatewayList(__getArrayIfSingleItem(output[_tGS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTransitGatewayVpcAttachmentsResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayVpcAttachments === \"\") {\n        contents[_TGVAr] = [];\n    }\n    else if (output[_tGVAr] != null && output[_tGVAr][_i] != null) {\n        contents[_TGVAr] = de_TransitGatewayVpcAttachmentList(__getArrayIfSingleItem(output[_tGVAr][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeTrunkInterfaceAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.interfaceAssociationSet === \"\") {\n        contents[_IAnt] = [];\n    }\n    else if (output[_iAS] != null && output[_iAS][_i] != null) {\n        contents[_IAnt] = de_TrunkInterfaceAssociationList(__getArrayIfSingleItem(output[_iAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVerifiedAccessEndpointsResult = (output, context) => {\n    const contents = {};\n    if (output.verifiedAccessEndpointSet === \"\") {\n        contents[_VAEe] = [];\n    }\n    else if (output[_vAES] != null && output[_vAES][_i] != null) {\n        contents[_VAEe] = de_VerifiedAccessEndpointList(__getArrayIfSingleItem(output[_vAES][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVerifiedAccessGroupsResult = (output, context) => {\n    const contents = {};\n    if (output.verifiedAccessGroupSet === \"\") {\n        contents[_VAGe] = [];\n    }\n    else if (output[_vAGS] != null && output[_vAGS][_i] != null) {\n        contents[_VAGe] = de_VerifiedAccessGroupList(__getArrayIfSingleItem(output[_vAGS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVerifiedAccessInstanceLoggingConfigurationsResult = (output, context) => {\n    const contents = {};\n    if (output.loggingConfigurationSet === \"\") {\n        contents[_LC] = [];\n    }\n    else if (output[_lCS] != null && output[_lCS][_i] != null) {\n        contents[_LC] = de_VerifiedAccessInstanceLoggingConfigurationList(__getArrayIfSingleItem(output[_lCS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVerifiedAccessInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.verifiedAccessInstanceSet === \"\") {\n        contents[_VAIe] = [];\n    }\n    else if (output[_vAIS] != null && output[_vAIS][_i] != null) {\n        contents[_VAIe] = de_VerifiedAccessInstanceList(__getArrayIfSingleItem(output[_vAIS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVerifiedAccessTrustProvidersResult = (output, context) => {\n    const contents = {};\n    if (output.verifiedAccessTrustProviderSet === \"\") {\n        contents[_VATPe] = [];\n    }\n    else if (output[_vATPS] != null && output[_vATPS][_i] != null) {\n        contents[_VATPe] = de_VerifiedAccessTrustProviderList(__getArrayIfSingleItem(output[_vATPS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVolumeAttributeResult = (output, context) => {\n    const contents = {};\n    if (output[_aEIO] != null) {\n        contents[_AEIO] = de_AttributeBooleanValue(output[_aEIO], context);\n    }\n    if (output.productCodes === \"\") {\n        contents[_PCr] = [];\n    }\n    else if (output[_pC] != null && output[_pC][_i] != null) {\n        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);\n    }\n    if (output[_vIo] != null) {\n        contents[_VIo] = __expectString(output[_vIo]);\n    }\n    return contents;\n};\nconst de_DescribeVolumesModificationsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.volumeModificationSet === \"\") {\n        contents[_VMo] = [];\n    }\n    else if (output[_vMS] != null && output[_vMS][_i] != null) {\n        contents[_VMo] = de_VolumeModificationList(__getArrayIfSingleItem(output[_vMS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeVolumesResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.volumeSet === \"\") {\n        contents[_Vol] = [];\n    }\n    else if (output[_vS] != null && output[_vS][_i] != null) {\n        contents[_Vol] = de_VolumeList(__getArrayIfSingleItem(output[_vS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeVolumeStatusResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.volumeStatusSet === \"\") {\n        contents[_VSo] = [];\n    }\n    else if (output[_vSS] != null && output[_vSS][_i] != null) {\n        contents[_VSo] = de_VolumeStatusList(__getArrayIfSingleItem(output[_vSS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeVpcAttributeResult = (output, context) => {\n    const contents = {};\n    if (output[_eDH] != null) {\n        contents[_EDH] = de_AttributeBooleanValue(output[_eDH], context);\n    }\n    if (output[_eDS] != null) {\n        contents[_EDS] = de_AttributeBooleanValue(output[_eDS], context);\n    }\n    if (output[_eNAUM] != null) {\n        contents[_ENAUM] = de_AttributeBooleanValue(output[_eNAUM], context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    return contents;\n};\nconst de_DescribeVpcBlockPublicAccessExclusionsResult = (output, context) => {\n    const contents = {};\n    if (output.vpcBlockPublicAccessExclusionSet === \"\") {\n        contents[_VBPAEp] = [];\n    }\n    else if (output[_vBPAES] != null && output[_vBPAES][_i] != null) {\n        contents[_VBPAEp] = de_VpcBlockPublicAccessExclusionList(__getArrayIfSingleItem(output[_vBPAES][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVpcBlockPublicAccessOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_vBPAO] != null) {\n        contents[_VBPAO] = de_VpcBlockPublicAccessOptions(output[_vBPAO], context);\n    }\n    return contents;\n};\nconst de_DescribeVpcClassicLinkDnsSupportResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.vpcs === \"\") {\n        contents[_Vpc] = [];\n    }\n    else if (output[_vpc] != null && output[_vpc][_i] != null) {\n        contents[_Vpc] = de_ClassicLinkDnsSupportList(__getArrayIfSingleItem(output[_vpc][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeVpcClassicLinkResult = (output, context) => {\n    const contents = {};\n    if (output.vpcSet === \"\") {\n        contents[_Vpc] = [];\n    }\n    else if (output[_vSp] != null && output[_vSp][_i] != null) {\n        contents[_Vpc] = de_VpcClassicLinkList(__getArrayIfSingleItem(output[_vSp][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeVpcEndpointAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.vpcEndpointAssociationSet === \"\") {\n        contents[_VEA] = [];\n    }\n    else if (output[_vEAS] != null && output[_vEAS][_i] != null) {\n        contents[_VEA] = de_VpcEndpointAssociationSet(__getArrayIfSingleItem(output[_vEAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVpcEndpointConnectionNotificationsResult = (output, context) => {\n    const contents = {};\n    if (output.connectionNotificationSet === \"\") {\n        contents[_CNSo] = [];\n    }\n    else if (output[_cNSo] != null && output[_cNSo][_i] != null) {\n        contents[_CNSo] = de_ConnectionNotificationSet(__getArrayIfSingleItem(output[_cNSo][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVpcEndpointConnectionsResult = (output, context) => {\n    const contents = {};\n    if (output.vpcEndpointConnectionSet === \"\") {\n        contents[_VEC] = [];\n    }\n    else if (output[_vECS] != null && output[_vECS][_i] != null) {\n        contents[_VEC] = de_VpcEndpointConnectionSet(__getArrayIfSingleItem(output[_vECS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVpcEndpointServiceConfigurationsResult = (output, context) => {\n    const contents = {};\n    if (output.serviceConfigurationSet === \"\") {\n        contents[_SCer] = [];\n    }\n    else if (output[_sCS] != null && output[_sCS][_i] != null) {\n        contents[_SCer] = de_ServiceConfigurationSet(__getArrayIfSingleItem(output[_sCS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVpcEndpointServicePermissionsResult = (output, context) => {\n    const contents = {};\n    if (output.allowedPrincipals === \"\") {\n        contents[_APl] = [];\n    }\n    else if (output[_aP] != null && output[_aP][_i] != null) {\n        contents[_APl] = de_AllowedPrincipalSet(__getArrayIfSingleItem(output[_aP][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVpcEndpointServicesResult = (output, context) => {\n    const contents = {};\n    if (output.serviceNameSet === \"\") {\n        contents[_SNer] = [];\n    }\n    else if (output[_sNS] != null && output[_sNS][_i] != null) {\n        contents[_SNer] = de_ValueStringList(__getArrayIfSingleItem(output[_sNS][_i]), context);\n    }\n    if (output.serviceDetailSet === \"\") {\n        contents[_SDe] = [];\n    }\n    else if (output[_sDSe] != null && output[_sDSe][_i] != null) {\n        contents[_SDe] = de_ServiceDetailSet(__getArrayIfSingleItem(output[_sDSe][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVpcEndpointsResult = (output, context) => {\n    const contents = {};\n    if (output.vpcEndpointSet === \"\") {\n        contents[_VEp] = [];\n    }\n    else if (output[_vESp] != null && output[_vESp][_i] != null) {\n        contents[_VEp] = de_VpcEndpointSet(__getArrayIfSingleItem(output[_vESp][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVpcPeeringConnectionsResult = (output, context) => {\n    const contents = {};\n    if (output.vpcPeeringConnectionSet === \"\") {\n        contents[_VPCp] = [];\n    }\n    else if (output[_vPCS] != null && output[_vPCS][_i] != null) {\n        contents[_VPCp] = de_VpcPeeringConnectionList(__getArrayIfSingleItem(output[_vPCS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_DescribeVpcsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.vpcSet === \"\") {\n        contents[_Vpc] = [];\n    }\n    else if (output[_vSp] != null && output[_vSp][_i] != null) {\n        contents[_Vpc] = de_VpcList(__getArrayIfSingleItem(output[_vSp][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeVpnConnectionsResult = (output, context) => {\n    const contents = {};\n    if (output.vpnConnectionSet === \"\") {\n        contents[_VCp] = [];\n    }\n    else if (output[_vCS] != null && output[_vCS][_i] != null) {\n        contents[_VCp] = de_VpnConnectionList(__getArrayIfSingleItem(output[_vCS][_i]), context);\n    }\n    return contents;\n};\nconst de_DescribeVpnGatewaysResult = (output, context) => {\n    const contents = {};\n    if (output.vpnGatewaySet === \"\") {\n        contents[_VGp] = [];\n    }\n    else if (output[_vGS] != null && output[_vGS][_i] != null) {\n        contents[_VGp] = de_VpnGatewayList(__getArrayIfSingleItem(output[_vGS][_i]), context);\n    }\n    return contents;\n};\nconst de_DestinationOptionsResponse = (output, context) => {\n    const contents = {};\n    if (output[_fF] != null) {\n        contents[_FF] = __expectString(output[_fF]);\n    }\n    if (output[_hCP] != null) {\n        contents[_HCP] = __parseBoolean(output[_hCP]);\n    }\n    if (output[_pHP] != null) {\n        contents[_PHP] = __parseBoolean(output[_pHP]);\n    }\n    return contents;\n};\nconst de_DetachClassicLinkVpcResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_DetachVerifiedAccessTrustProviderResult = (output, context) => {\n    const contents = {};\n    if (output[_vATP] != null) {\n        contents[_VATP] = de_VerifiedAccessTrustProvider(output[_vATP], context);\n    }\n    if (output[_vAI] != null) {\n        contents[_VAI] = de_VerifiedAccessInstance(output[_vAI], context);\n    }\n    return contents;\n};\nconst de_DeviceOptions = (output, context) => {\n    const contents = {};\n    if (output[_tIe] != null) {\n        contents[_TIe] = __expectString(output[_tIe]);\n    }\n    if (output[_pSKU] != null) {\n        contents[_PSKU] = __expectString(output[_pSKU]);\n    }\n    return contents;\n};\nconst de_DeviceTrustProviderTypeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_DhcpConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_k] != null) {\n        contents[_Ke] = __expectString(output[_k]);\n    }\n    if (output.valueSet === \"\") {\n        contents[_Val] = [];\n    }\n    else if (output[_vSa] != null && output[_vSa][_i] != null) {\n        contents[_Val] = de_DhcpConfigurationValueList(__getArrayIfSingleItem(output[_vSa][_i]), context);\n    }\n    return contents;\n};\nconst de_DhcpConfigurationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DhcpConfiguration(entry, context);\n    });\n};\nconst de_DhcpConfigurationValueList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AttributeValue(entry, context);\n    });\n};\nconst de_DhcpOptions = (output, context) => {\n    const contents = {};\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_dOI] != null) {\n        contents[_DOI] = __expectString(output[_dOI]);\n    }\n    if (output.dhcpConfigurationSet === \"\") {\n        contents[_DCh] = [];\n    }\n    else if (output[_dCS] != null && output[_dCS][_i] != null) {\n        contents[_DCh] = de_DhcpConfigurationList(__getArrayIfSingleItem(output[_dCS][_i]), context);\n    }\n    return contents;\n};\nconst de_DhcpOptionsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DhcpOptions(entry, context);\n    });\n};\nconst de_DirectoryServiceAuthentication = (output, context) => {\n    const contents = {};\n    if (output[_dI] != null) {\n        contents[_DIir] = __expectString(output[_dI]);\n    }\n    return contents;\n};\nconst de_DisableAddressTransferResult = (output, context) => {\n    const contents = {};\n    if (output[_aT] != null) {\n        contents[_ATdd] = de_AddressTransfer(output[_aT], context);\n    }\n    return contents;\n};\nconst de_DisableAllowedImagesSettingsResult = (output, context) => {\n    const contents = {};\n    if (output[_aISS] != null) {\n        contents[_AISS] = __expectString(output[_aISS]);\n    }\n    return contents;\n};\nconst de_DisableAwsNetworkPerformanceMetricSubscriptionResult = (output, context) => {\n    const contents = {};\n    if (output[_ou] != null) {\n        contents[_Ou] = __parseBoolean(output[_ou]);\n    }\n    return contents;\n};\nconst de_DisableEbsEncryptionByDefaultResult = (output, context) => {\n    const contents = {};\n    if (output[_eEBD] != null) {\n        contents[_EEBD] = __parseBoolean(output[_eEBD]);\n    }\n    return contents;\n};\nconst de_DisableFastLaunchResult = (output, context) => {\n    const contents = {};\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_sCn] != null) {\n        contents[_SCn] = de_FastLaunchSnapshotConfigurationResponse(output[_sCn], context);\n    }\n    if (output[_lT] != null) {\n        contents[_LTa] = de_FastLaunchLaunchTemplateSpecificationResponse(output[_lT], context);\n    }\n    if (output[_mPL] != null) {\n        contents[_MPL] = __strictParseInt32(output[_mPL]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sTR] != null) {\n        contents[_STRt] = __expectString(output[_sTR]);\n    }\n    if (output[_sTT] != null) {\n        contents[_STT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sTT]));\n    }\n    return contents;\n};\nconst de_DisableFastSnapshotRestoreErrorItem = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output.fastSnapshotRestoreStateErrorSet === \"\") {\n        contents[_FSRSE] = [];\n    }\n    else if (output[_fSRSES] != null && output[_fSRSES][_i] != null) {\n        contents[_FSRSE] = de_DisableFastSnapshotRestoreStateErrorSet(__getArrayIfSingleItem(output[_fSRSES][_i]), context);\n    }\n    return contents;\n};\nconst de_DisableFastSnapshotRestoreErrorSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DisableFastSnapshotRestoreErrorItem(entry, context);\n    });\n};\nconst de_DisableFastSnapshotRestoresResult = (output, context) => {\n    const contents = {};\n    if (output.successful === \"\") {\n        contents[_Suc] = [];\n    }\n    else if (output[_suc] != null && output[_suc][_i] != null) {\n        contents[_Suc] = de_DisableFastSnapshotRestoreSuccessSet(__getArrayIfSingleItem(output[_suc][_i]), context);\n    }\n    if (output.unsuccessful === \"\") {\n        contents[_Un] = [];\n    }\n    else if (output[_u] != null && output[_u][_i] != null) {\n        contents[_Un] = de_DisableFastSnapshotRestoreErrorSet(__getArrayIfSingleItem(output[_u][_i]), context);\n    }\n    return contents;\n};\nconst de_DisableFastSnapshotRestoreStateError = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_DisableFastSnapshotRestoreStateErrorItem = (output, context) => {\n    const contents = {};\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_er] != null) {\n        contents[_Er] = de_DisableFastSnapshotRestoreStateError(output[_er], context);\n    }\n    return contents;\n};\nconst de_DisableFastSnapshotRestoreStateErrorSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DisableFastSnapshotRestoreStateErrorItem(entry, context);\n    });\n};\nconst de_DisableFastSnapshotRestoreSuccessItem = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sTR] != null) {\n        contents[_STRt] = __expectString(output[_sTR]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_oAw] != null) {\n        contents[_OAw] = __expectString(output[_oAw]);\n    }\n    if (output[_eTna] != null) {\n        contents[_ETna] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTna]));\n    }\n    if (output[_oT] != null) {\n        contents[_OTpt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_oT]));\n    }\n    if (output[_eTnab] != null) {\n        contents[_ETnab] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTnab]));\n    }\n    if (output[_dTi] != null) {\n        contents[_DTi] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTi]));\n    }\n    if (output[_dTis] != null) {\n        contents[_DTis] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTis]));\n    }\n    return contents;\n};\nconst de_DisableFastSnapshotRestoreSuccessSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DisableFastSnapshotRestoreSuccessItem(entry, context);\n    });\n};\nconst de_DisableImageBlockPublicAccessResult = (output, context) => {\n    const contents = {};\n    if (output[_iBPAS] != null) {\n        contents[_IBPAS] = __expectString(output[_iBPAS]);\n    }\n    return contents;\n};\nconst de_DisableImageDeprecationResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_DisableImageDeregistrationProtectionResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __expectString(output[_r]);\n    }\n    return contents;\n};\nconst de_DisableImageResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_DisableIpamOrganizationAdminAccountResult = (output, context) => {\n    const contents = {};\n    if (output[_succ] != null) {\n        contents[_Succ] = __parseBoolean(output[_succ]);\n    }\n    return contents;\n};\nconst de_DisableRouteServerPropagationResult = (output, context) => {\n    const contents = {};\n    if (output[_rSPo] != null) {\n        contents[_RSPou] = de_RouteServerPropagation(output[_rSPo], context);\n    }\n    return contents;\n};\nconst de_DisableSerialConsoleAccessResult = (output, context) => {\n    const contents = {};\n    if (output[_sCAE] != null) {\n        contents[_SCAE] = __parseBoolean(output[_sCAE]);\n    }\n    return contents;\n};\nconst de_DisableSnapshotBlockPublicAccessResult = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_DisableTransitGatewayRouteTablePropagationResult = (output, context) => {\n    const contents = {};\n    if (output[_prop] != null) {\n        contents[_Prop] = de_TransitGatewayPropagation(output[_prop], context);\n    }\n    return contents;\n};\nconst de_DisableVpcClassicLinkDnsSupportResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_DisableVpcClassicLinkResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_DisassociateCapacityReservationBillingOwnerResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_DisassociateClientVpnTargetNetworkResult = (output, context) => {\n    const contents = {};\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_AssociationStatus(output[_sta], context);\n    }\n    return contents;\n};\nconst de_DisassociateEnclaveCertificateIamRoleResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_DisassociateIamInstanceProfileResult = (output, context) => {\n    const contents = {};\n    if (output[_iIPA] != null) {\n        contents[_IIPA] = de_IamInstanceProfileAssociation(output[_iIPA], context);\n    }\n    return contents;\n};\nconst de_DisassociateInstanceEventWindowResult = (output, context) => {\n    const contents = {};\n    if (output[_iEW] != null) {\n        contents[_IEW] = de_InstanceEventWindow(output[_iEW], context);\n    }\n    return contents;\n};\nconst de_DisassociateIpamByoasnResult = (output, context) => {\n    const contents = {};\n    if (output[_aA] != null) {\n        contents[_AAsn] = de_AsnAssociation(output[_aA], context);\n    }\n    return contents;\n};\nconst de_DisassociateIpamResourceDiscoveryResult = (output, context) => {\n    const contents = {};\n    if (output[_iRDA] != null) {\n        contents[_IRDA] = de_IpamResourceDiscoveryAssociation(output[_iRDA], context);\n    }\n    return contents;\n};\nconst de_DisassociateNatGatewayAddressResult = (output, context) => {\n    const contents = {};\n    if (output[_nGI] != null) {\n        contents[_NGI] = __expectString(output[_nGI]);\n    }\n    if (output.natGatewayAddressSet === \"\") {\n        contents[_NGA] = [];\n    }\n    else if (output[_nGAS] != null && output[_nGAS][_i] != null) {\n        contents[_NGA] = de_NatGatewayAddressList(__getArrayIfSingleItem(output[_nGAS][_i]), context);\n    }\n    return contents;\n};\nconst de_DisassociateRouteServerResult = (output, context) => {\n    const contents = {};\n    if (output[_rSA] != null) {\n        contents[_RSAo] = de_RouteServerAssociation(output[_rSA], context);\n    }\n    return contents;\n};\nconst de_DisassociateSecurityGroupVpcResult = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_DisassociateSubnetCidrBlockResult = (output, context) => {\n    const contents = {};\n    if (output[_iCBA] != null) {\n        contents[_ICBA] = de_SubnetIpv6CidrBlockAssociation(output[_iCBA], context);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    return contents;\n};\nconst de_DisassociateTransitGatewayMulticastDomainResult = (output, context) => {\n    const contents = {};\n    if (output[_a] != null) {\n        contents[_Ass] = de_TransitGatewayMulticastDomainAssociations(output[_a], context);\n    }\n    return contents;\n};\nconst de_DisassociateTransitGatewayPolicyTableResult = (output, context) => {\n    const contents = {};\n    if (output[_ass] != null) {\n        contents[_Asso] = de_TransitGatewayPolicyTableAssociation(output[_ass], context);\n    }\n    return contents;\n};\nconst de_DisassociateTransitGatewayRouteTableResult = (output, context) => {\n    const contents = {};\n    if (output[_ass] != null) {\n        contents[_Asso] = de_TransitGatewayAssociation(output[_ass], context);\n    }\n    return contents;\n};\nconst de_DisassociateTrunkInterfaceResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    return contents;\n};\nconst de_DisassociateVpcCidrBlockResult = (output, context) => {\n    const contents = {};\n    if (output[_iCBA] != null) {\n        contents[_ICBA] = de_VpcIpv6CidrBlockAssociation(output[_iCBA], context);\n    }\n    if (output[_cBA] != null) {\n        contents[_CBA] = de_VpcCidrBlockAssociation(output[_cBA], context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    return contents;\n};\nconst de_DiskImageDescription = (output, context) => {\n    const contents = {};\n    if (output[_ch] != null) {\n        contents[_Ch] = __expectString(output[_ch]);\n    }\n    if (output[_f] != null) {\n        contents[_Fo] = __expectString(output[_f]);\n    }\n    if (output[_iMU] != null) {\n        contents[_IMU] = __expectString(output[_iMU]);\n    }\n    if (output[_si] != null) {\n        contents[_Siz] = __strictParseLong(output[_si]);\n    }\n    return contents;\n};\nconst de_DiskImageVolumeDescription = (output, context) => {\n    const contents = {};\n    if (output[_id] != null) {\n        contents[_Id] = __expectString(output[_id]);\n    }\n    if (output[_si] != null) {\n        contents[_Siz] = __strictParseLong(output[_si]);\n    }\n    return contents;\n};\nconst de_DiskInfo = (output, context) => {\n    const contents = {};\n    if (output[_sIGB] != null) {\n        contents[_SIGB] = __strictParseLong(output[_sIGB]);\n    }\n    if (output[_cou] != null) {\n        contents[_Cou] = __strictParseInt32(output[_cou]);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    return contents;\n};\nconst de_DiskInfoList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DiskInfo(entry, context);\n    });\n};\nconst de_DnsEntry = (output, context) => {\n    const contents = {};\n    if (output[_dNn] != null) {\n        contents[_DNn] = __expectString(output[_dNn]);\n    }\n    if (output[_hZI] != null) {\n        contents[_HZI] = __expectString(output[_hZI]);\n    }\n    return contents;\n};\nconst de_DnsEntrySet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DnsEntry(entry, context);\n    });\n};\nconst de_DnsOptions = (output, context) => {\n    const contents = {};\n    if (output[_dRIT] != null) {\n        contents[_DRIT] = __expectString(output[_dRIT]);\n    }\n    if (output[_pDOFIRE] != null) {\n        contents[_PDOFIRE] = __parseBoolean(output[_pDOFIRE]);\n    }\n    return contents;\n};\nconst de_EbsBlockDevice = (output, context) => {\n    const contents = {};\n    if (output[_dOT] != null) {\n        contents[_DOT] = __parseBoolean(output[_dOT]);\n    }\n    if (output[_io] != null) {\n        contents[_Io] = __strictParseInt32(output[_io]);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_vSo] != null) {\n        contents[_VS] = __strictParseInt32(output[_vSo]);\n    }\n    if (output[_vT] != null) {\n        contents[_VT] = __expectString(output[_vT]);\n    }\n    if (output[_kKI] != null) {\n        contents[_KKI] = __expectString(output[_kKI]);\n    }\n    if (output[_th] != null) {\n        contents[_Th] = __strictParseInt32(output[_th]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_enc] != null) {\n        contents[_Enc] = __parseBoolean(output[_enc]);\n    }\n    if (output[_VIR] != null) {\n        contents[_VIR] = __strictParseInt32(output[_VIR]);\n    }\n    return contents;\n};\nconst de_EbsBlockDeviceResponse = (output, context) => {\n    const contents = {};\n    if (output[_enc] != null) {\n        contents[_Enc] = __parseBoolean(output[_enc]);\n    }\n    if (output[_dOT] != null) {\n        contents[_DOT] = __parseBoolean(output[_dOT]);\n    }\n    if (output[_io] != null) {\n        contents[_Io] = __strictParseInt32(output[_io]);\n    }\n    if (output[_th] != null) {\n        contents[_Th] = __strictParseInt32(output[_th]);\n    }\n    if (output[_kKI] != null) {\n        contents[_KKI] = __expectString(output[_kKI]);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_vSo] != null) {\n        contents[_VS] = __strictParseInt32(output[_vSo]);\n    }\n    if (output[_vT] != null) {\n        contents[_VT] = __expectString(output[_vT]);\n    }\n    return contents;\n};\nconst de_EbsInfo = (output, context) => {\n    const contents = {};\n    if (output[_eOS] != null) {\n        contents[_EOS] = __expectString(output[_eOS]);\n    }\n    if (output[_eSn] != null) {\n        contents[_ESnc] = __expectString(output[_eSn]);\n    }\n    if (output[_eOI] != null) {\n        contents[_EOI] = de_EbsOptimizedInfo(output[_eOI], context);\n    }\n    if (output[_nS] != null) {\n        contents[_NS] = __expectString(output[_nS]);\n    }\n    return contents;\n};\nconst de_EbsInstanceBlockDevice = (output, context) => {\n    const contents = {};\n    if (output[_aTt] != null) {\n        contents[_ATtt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aTt]));\n    }\n    if (output[_dOT] != null) {\n        contents[_DOT] = __parseBoolean(output[_dOT]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_vIo] != null) {\n        contents[_VIo] = __expectString(output[_vIo]);\n    }\n    if (output[_aRs] != null) {\n        contents[_ARs] = __expectString(output[_aRs]);\n    }\n    if (output[_vOI] != null) {\n        contents[_VOI] = __expectString(output[_vOI]);\n    }\n    if (output[_op] != null) {\n        contents[_O] = de_OperatorResponse(output[_op], context);\n    }\n    return contents;\n};\nconst de_EbsOptimizedInfo = (output, context) => {\n    const contents = {};\n    if (output[_bBIM] != null) {\n        contents[_BBIM] = __strictParseInt32(output[_bBIM]);\n    }\n    if (output[_bTIMB] != null) {\n        contents[_BTIMB] = __strictParseFloat(output[_bTIMB]);\n    }\n    if (output[_bIa] != null) {\n        contents[_BIa] = __strictParseInt32(output[_bIa]);\n    }\n    if (output[_mBIM] != null) {\n        contents[_MBIM] = __strictParseInt32(output[_mBIM]);\n    }\n    if (output[_mTIMB] != null) {\n        contents[_MTIMB] = __strictParseFloat(output[_mTIMB]);\n    }\n    if (output[_mI] != null) {\n        contents[_MIa] = __strictParseInt32(output[_mI]);\n    }\n    return contents;\n};\nconst de_EbsStatusDetails = (output, context) => {\n    const contents = {};\n    if (output[_iSmp] != null) {\n        contents[_ISmp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_iSmp]));\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_EbsStatusDetailsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_EbsStatusDetails(entry, context);\n    });\n};\nconst de_EbsStatusSummary = (output, context) => {\n    const contents = {};\n    if (output.details === \"\") {\n        contents[_Det] = [];\n    }\n    else if (output[_det] != null && output[_det][_i] != null) {\n        contents[_Det] = de_EbsStatusDetailsList(__getArrayIfSingleItem(output[_det][_i]), context);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_Ec2InstanceConnectEndpoint = (output, context) => {\n    const contents = {};\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_iCEI] != null) {\n        contents[_ICEI] = __expectString(output[_iCEI]);\n    }\n    if (output[_iCEA] != null) {\n        contents[_ICEA] = __expectString(output[_iCEA]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sMta] != null) {\n        contents[_SMta] = __expectString(output[_sMta]);\n    }\n    if (output[_dNn] != null) {\n        contents[_DNn] = __expectString(output[_dNn]);\n    }\n    if (output[_fDN] != null) {\n        contents[_FDN] = __expectString(output[_fDN]);\n    }\n    if (output.networkInterfaceIdSet === \"\") {\n        contents[_NIIe] = [];\n    }\n    else if (output[_nIIS] != null && output[_nIIS][_i] != null) {\n        contents[_NIIe] = de_NetworkInterfaceIdSet(__getArrayIfSingleItem(output[_nIIS][_i]), context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_cAr] != null) {\n        contents[_CAr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cAr]));\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_pCI] != null) {\n        contents[_PCI] = __parseBoolean(output[_pCI]);\n    }\n    if (output.securityGroupIdSet === \"\") {\n        contents[_SGI] = [];\n    }\n    else if (output[_sGIS] != null && output[_sGIS][_i] != null) {\n        contents[_SGI] = de_SecurityGroupIdSet(__getArrayIfSingleItem(output[_sGIS][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_EfaInfo = (output, context) => {\n    const contents = {};\n    if (output[_mEI] != null) {\n        contents[_MEI] = __strictParseInt32(output[_mEI]);\n    }\n    return contents;\n};\nconst de_EgressOnlyInternetGateway = (output, context) => {\n    const contents = {};\n    if (output.attachmentSet === \"\") {\n        contents[_Atta] = [];\n    }\n    else if (output[_aSt] != null && output[_aSt][_i] != null) {\n        contents[_Atta] = de_InternetGatewayAttachmentList(__getArrayIfSingleItem(output[_aSt][_i]), context);\n    }\n    if (output[_eOIGI] != null) {\n        contents[_EOIGI] = __expectString(output[_eOIGI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_EgressOnlyInternetGatewayList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_EgressOnlyInternetGateway(entry, context);\n    });\n};\nconst de_ElasticGpuAssociation = (output, context) => {\n    const contents = {};\n    if (output[_eGI] != null) {\n        contents[_EGIl] = __expectString(output[_eGI]);\n    }\n    if (output[_eGAI] != null) {\n        contents[_EGAI] = __expectString(output[_eGAI]);\n    }\n    if (output[_eGAS] != null) {\n        contents[_EGAS] = __expectString(output[_eGAS]);\n    }\n    if (output[_eGAT] != null) {\n        contents[_EGAT] = __expectString(output[_eGAT]);\n    }\n    return contents;\n};\nconst de_ElasticGpuAssociationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ElasticGpuAssociation(entry, context);\n    });\n};\nconst de_ElasticGpuHealth = (output, context) => {\n    const contents = {};\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_ElasticGpus = (output, context) => {\n    const contents = {};\n    if (output[_eGI] != null) {\n        contents[_EGIl] = __expectString(output[_eGI]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_eGT] != null) {\n        contents[_EGT] = __expectString(output[_eGT]);\n    }\n    if (output[_eGH] != null) {\n        contents[_EGH] = de_ElasticGpuHealth(output[_eGH], context);\n    }\n    if (output[_eGSl] != null) {\n        contents[_EGSlas] = __expectString(output[_eGSl]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_ElasticGpuSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ElasticGpus(entry, context);\n    });\n};\nconst de_ElasticGpuSpecificationResponse = (output, context) => {\n    const contents = {};\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    return contents;\n};\nconst de_ElasticGpuSpecificationResponseList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ElasticGpuSpecificationResponse(entry, context);\n    });\n};\nconst de_ElasticInferenceAcceleratorAssociation = (output, context) => {\n    const contents = {};\n    if (output[_eIAA] != null) {\n        contents[_EIAA] = __expectString(output[_eIAA]);\n    }\n    if (output[_eIAAI] != null) {\n        contents[_EIAAI] = __expectString(output[_eIAAI]);\n    }\n    if (output[_eIAAS] != null) {\n        contents[_EIAAS] = __expectString(output[_eIAAS]);\n    }\n    if (output[_eIAAT] != null) {\n        contents[_EIAAT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eIAAT]));\n    }\n    return contents;\n};\nconst de_ElasticInferenceAcceleratorAssociationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ElasticInferenceAcceleratorAssociation(entry, context);\n    });\n};\nconst de_EnableAddressTransferResult = (output, context) => {\n    const contents = {};\n    if (output[_aT] != null) {\n        contents[_ATdd] = de_AddressTransfer(output[_aT], context);\n    }\n    return contents;\n};\nconst de_EnableAllowedImagesSettingsResult = (output, context) => {\n    const contents = {};\n    if (output[_aISS] != null) {\n        contents[_AISS] = __expectString(output[_aISS]);\n    }\n    return contents;\n};\nconst de_EnableAwsNetworkPerformanceMetricSubscriptionResult = (output, context) => {\n    const contents = {};\n    if (output[_ou] != null) {\n        contents[_Ou] = __parseBoolean(output[_ou]);\n    }\n    return contents;\n};\nconst de_EnableEbsEncryptionByDefaultResult = (output, context) => {\n    const contents = {};\n    if (output[_eEBD] != null) {\n        contents[_EEBD] = __parseBoolean(output[_eEBD]);\n    }\n    return contents;\n};\nconst de_EnableFastLaunchResult = (output, context) => {\n    const contents = {};\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_sCn] != null) {\n        contents[_SCn] = de_FastLaunchSnapshotConfigurationResponse(output[_sCn], context);\n    }\n    if (output[_lT] != null) {\n        contents[_LTa] = de_FastLaunchLaunchTemplateSpecificationResponse(output[_lT], context);\n    }\n    if (output[_mPL] != null) {\n        contents[_MPL] = __strictParseInt32(output[_mPL]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sTR] != null) {\n        contents[_STRt] = __expectString(output[_sTR]);\n    }\n    if (output[_sTT] != null) {\n        contents[_STT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sTT]));\n    }\n    return contents;\n};\nconst de_EnableFastSnapshotRestoreErrorItem = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output.fastSnapshotRestoreStateErrorSet === \"\") {\n        contents[_FSRSE] = [];\n    }\n    else if (output[_fSRSES] != null && output[_fSRSES][_i] != null) {\n        contents[_FSRSE] = de_EnableFastSnapshotRestoreStateErrorSet(__getArrayIfSingleItem(output[_fSRSES][_i]), context);\n    }\n    return contents;\n};\nconst de_EnableFastSnapshotRestoreErrorSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_EnableFastSnapshotRestoreErrorItem(entry, context);\n    });\n};\nconst de_EnableFastSnapshotRestoresResult = (output, context) => {\n    const contents = {};\n    if (output.successful === \"\") {\n        contents[_Suc] = [];\n    }\n    else if (output[_suc] != null && output[_suc][_i] != null) {\n        contents[_Suc] = de_EnableFastSnapshotRestoreSuccessSet(__getArrayIfSingleItem(output[_suc][_i]), context);\n    }\n    if (output.unsuccessful === \"\") {\n        contents[_Un] = [];\n    }\n    else if (output[_u] != null && output[_u][_i] != null) {\n        contents[_Un] = de_EnableFastSnapshotRestoreErrorSet(__getArrayIfSingleItem(output[_u][_i]), context);\n    }\n    return contents;\n};\nconst de_EnableFastSnapshotRestoreStateError = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_EnableFastSnapshotRestoreStateErrorItem = (output, context) => {\n    const contents = {};\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_er] != null) {\n        contents[_Er] = de_EnableFastSnapshotRestoreStateError(output[_er], context);\n    }\n    return contents;\n};\nconst de_EnableFastSnapshotRestoreStateErrorSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_EnableFastSnapshotRestoreStateErrorItem(entry, context);\n    });\n};\nconst de_EnableFastSnapshotRestoreSuccessItem = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sTR] != null) {\n        contents[_STRt] = __expectString(output[_sTR]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_oAw] != null) {\n        contents[_OAw] = __expectString(output[_oAw]);\n    }\n    if (output[_eTna] != null) {\n        contents[_ETna] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTna]));\n    }\n    if (output[_oT] != null) {\n        contents[_OTpt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_oT]));\n    }\n    if (output[_eTnab] != null) {\n        contents[_ETnab] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTnab]));\n    }\n    if (output[_dTi] != null) {\n        contents[_DTi] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTi]));\n    }\n    if (output[_dTis] != null) {\n        contents[_DTis] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTis]));\n    }\n    return contents;\n};\nconst de_EnableFastSnapshotRestoreSuccessSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_EnableFastSnapshotRestoreSuccessItem(entry, context);\n    });\n};\nconst de_EnableImageBlockPublicAccessResult = (output, context) => {\n    const contents = {};\n    if (output[_iBPAS] != null) {\n        contents[_IBPAS] = __expectString(output[_iBPAS]);\n    }\n    return contents;\n};\nconst de_EnableImageDeprecationResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_EnableImageDeregistrationProtectionResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __expectString(output[_r]);\n    }\n    return contents;\n};\nconst de_EnableImageResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_EnableIpamOrganizationAdminAccountResult = (output, context) => {\n    const contents = {};\n    if (output[_succ] != null) {\n        contents[_Succ] = __parseBoolean(output[_succ]);\n    }\n    return contents;\n};\nconst de_EnableReachabilityAnalyzerOrganizationSharingResult = (output, context) => {\n    const contents = {};\n    if (output[_rV] != null) {\n        contents[_RV] = __parseBoolean(output[_rV]);\n    }\n    return contents;\n};\nconst de_EnableRouteServerPropagationResult = (output, context) => {\n    const contents = {};\n    if (output[_rSPo] != null) {\n        contents[_RSPou] = de_RouteServerPropagation(output[_rSPo], context);\n    }\n    return contents;\n};\nconst de_EnableSerialConsoleAccessResult = (output, context) => {\n    const contents = {};\n    if (output[_sCAE] != null) {\n        contents[_SCAE] = __parseBoolean(output[_sCAE]);\n    }\n    return contents;\n};\nconst de_EnableSnapshotBlockPublicAccessResult = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_EnableTransitGatewayRouteTablePropagationResult = (output, context) => {\n    const contents = {};\n    if (output[_prop] != null) {\n        contents[_Prop] = de_TransitGatewayPropagation(output[_prop], context);\n    }\n    return contents;\n};\nconst de_EnableVpcClassicLinkDnsSupportResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_EnableVpcClassicLinkResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_EnaSrdSpecificationRequest = (output, context) => {\n    const contents = {};\n    if (output[_ESE] != null) {\n        contents[_ESE] = __parseBoolean(output[_ESE]);\n    }\n    if (output[_ESUS] != null) {\n        contents[_ESUS] = de_EnaSrdUdpSpecificationRequest(output[_ESUS], context);\n    }\n    return contents;\n};\nconst de_EnaSrdUdpSpecificationRequest = (output, context) => {\n    const contents = {};\n    if (output[_ESUE] != null) {\n        contents[_ESUE] = __parseBoolean(output[_ESUE]);\n    }\n    return contents;\n};\nconst de_EnclaveOptions = (output, context) => {\n    const contents = {};\n    if (output[_en] != null) {\n        contents[_En] = __parseBoolean(output[_en]);\n    }\n    return contents;\n};\nconst de_EndpointSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ClientVpnEndpoint(entry, context);\n    });\n};\nconst de_ErrorSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ValidationError(entry, context);\n    });\n};\nconst de_EventInformation = (output, context) => {\n    const contents = {};\n    if (output[_eDv] != null) {\n        contents[_EDv] = __expectString(output[_eDv]);\n    }\n    if (output[_eST] != null) {\n        contents[_EST] = __expectString(output[_eST]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    return contents;\n};\nconst de_ExcludedInstanceTypeSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_Explanation = (output, context) => {\n    const contents = {};\n    if (output[_ac] != null) {\n        contents[_Acl] = de_AnalysisComponent(output[_ac], context);\n    }\n    if (output[_aRc] != null) {\n        contents[_ARcl] = de_AnalysisAclRule(output[_aRc], context);\n    }\n    if (output[_ad] != null) {\n        contents[_Ad] = __expectString(output[_ad]);\n    }\n    if (output.addressSet === \"\") {\n        contents[_Addr] = [];\n    }\n    else if (output[_aSd] != null && output[_aSd][_i] != null) {\n        contents[_Addr] = de_IpAddressList(__getArrayIfSingleItem(output[_aSd][_i]), context);\n    }\n    if (output[_aTtt] != null) {\n        contents[_ATtta] = de_AnalysisComponent(output[_aTtt], context);\n    }\n    if (output.availabilityZoneSet === \"\") {\n        contents[_AZv] = [];\n    }\n    else if (output[_aZS] != null && output[_aZS][_i] != null) {\n        contents[_AZv] = de_ValueStringList(__getArrayIfSingleItem(output[_aZS][_i]), context);\n    }\n    if (output.availabilityZoneIdSet === \"\") {\n        contents[_AZIv] = [];\n    }\n    else if (output[_aZIS] != null && output[_aZIS][_i] != null) {\n        contents[_AZIv] = de_ValueStringList(__getArrayIfSingleItem(output[_aZIS][_i]), context);\n    }\n    if (output.cidrSet === \"\") {\n        contents[_Ci] = [];\n    }\n    else if (output[_cS] != null && output[_cS][_i] != null) {\n        contents[_Ci] = de_ValueStringList(__getArrayIfSingleItem(output[_cS][_i]), context);\n    }\n    if (output[_c] != null) {\n        contents[_Com] = de_AnalysisComponent(output[_c], context);\n    }\n    if (output[_cGu] != null) {\n        contents[_CGu] = de_AnalysisComponent(output[_cGu], context);\n    }\n    if (output[_d] != null) {\n        contents[_D] = de_AnalysisComponent(output[_d], context);\n    }\n    if (output[_dV] != null) {\n        contents[_DVest] = de_AnalysisComponent(output[_dV], context);\n    }\n    if (output[_di] != null) {\n        contents[_Di] = __expectString(output[_di]);\n    }\n    if (output[_eCx] != null) {\n        contents[_ECx] = __expectString(output[_eCx]);\n    }\n    if (output[_iRT] != null) {\n        contents[_IRT] = de_AnalysisComponent(output[_iRT], context);\n    }\n    if (output[_iG] != null) {\n        contents[_IGn] = de_AnalysisComponent(output[_iG], context);\n    }\n    if (output[_lBA] != null) {\n        contents[_LBAo] = __expectString(output[_lBA]);\n    }\n    if (output[_cLBL] != null) {\n        contents[_CLBL] = de_AnalysisLoadBalancerListener(output[_cLBL], context);\n    }\n    if (output[_lBLP] != null) {\n        contents[_LBLP] = __strictParseInt32(output[_lBLP]);\n    }\n    if (output[_lBT] != null) {\n        contents[_LBT] = de_AnalysisLoadBalancerTarget(output[_lBT], context);\n    }\n    if (output[_lBTG] != null) {\n        contents[_LBTG] = de_AnalysisComponent(output[_lBTG], context);\n    }\n    if (output.loadBalancerTargetGroupSet === \"\") {\n        contents[_LBTGo] = [];\n    }\n    else if (output[_lBTGS] != null && output[_lBTGS][_i] != null) {\n        contents[_LBTGo] = de_AnalysisComponentList(__getArrayIfSingleItem(output[_lBTGS][_i]), context);\n    }\n    if (output[_lBTP] != null) {\n        contents[_LBTP] = __strictParseInt32(output[_lBTP]);\n    }\n    if (output[_eLBL] != null) {\n        contents[_ELBL] = de_AnalysisComponent(output[_eLBL], context);\n    }\n    if (output[_mC] != null) {\n        contents[_MCis] = __expectString(output[_mC]);\n    }\n    if (output[_nG] != null) {\n        contents[_NG] = de_AnalysisComponent(output[_nG], context);\n    }\n    if (output[_nIe] != null) {\n        contents[_NIet] = de_AnalysisComponent(output[_nIe], context);\n    }\n    if (output[_pF] != null) {\n        contents[_PF] = __expectString(output[_pF]);\n    }\n    if (output[_vPC] != null) {\n        contents[_VPC] = de_AnalysisComponent(output[_vPC], context);\n    }\n    if (output[_po] != null) {\n        contents[_Po] = __strictParseInt32(output[_po]);\n    }\n    if (output.portRangeSet === \"\") {\n        contents[_PRo] = [];\n    }\n    else if (output[_pRS] != null && output[_pRS][_i] != null) {\n        contents[_PRo] = de_PortRangeList(__getArrayIfSingleItem(output[_pRS][_i]), context);\n    }\n    if (output[_pL] != null) {\n        contents[_PLr] = de_AnalysisComponent(output[_pL], context);\n    }\n    if (output.protocolSet === \"\") {\n        contents[_Pro] = [];\n    }\n    else if (output[_pSro] != null && output[_pSro][_i] != null) {\n        contents[_Pro] = de_StringList(__getArrayIfSingleItem(output[_pSro][_i]), context);\n    }\n    if (output[_rTR] != null) {\n        contents[_RTR] = de_AnalysisRouteTableRoute(output[_rTR], context);\n    }\n    if (output[_rTo] != null) {\n        contents[_RTo] = de_AnalysisComponent(output[_rTo], context);\n    }\n    if (output[_sG] != null) {\n        contents[_SGe] = de_AnalysisComponent(output[_sG], context);\n    }\n    if (output[_sGR] != null) {\n        contents[_SGRe] = de_AnalysisSecurityGroupRule(output[_sGR], context);\n    }\n    if (output.securityGroupSet === \"\") {\n        contents[_SG] = [];\n    }\n    else if (output[_sGS] != null && output[_sGS][_i] != null) {\n        contents[_SG] = de_AnalysisComponentList(__getArrayIfSingleItem(output[_sGS][_i]), context);\n    }\n    if (output[_sV] != null) {\n        contents[_SVo] = de_AnalysisComponent(output[_sV], context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_su] != null) {\n        contents[_Su] = de_AnalysisComponent(output[_su], context);\n    }\n    if (output[_sRT] != null) {\n        contents[_SRT] = de_AnalysisComponent(output[_sRT], context);\n    }\n    if (output[_vp] != null) {\n        contents[_Vp] = de_AnalysisComponent(output[_vp], context);\n    }\n    if (output[_vE] != null) {\n        contents[_VE] = de_AnalysisComponent(output[_vE], context);\n    }\n    if (output[_vC] != null) {\n        contents[_VC] = de_AnalysisComponent(output[_vC], context);\n    }\n    if (output[_vG] != null) {\n        contents[_VG] = de_AnalysisComponent(output[_vG], context);\n    }\n    if (output[_tG] != null) {\n        contents[_TGr] = de_AnalysisComponent(output[_tG], context);\n    }\n    if (output[_tGRT] != null) {\n        contents[_TGRT] = de_AnalysisComponent(output[_tGRT], context);\n    }\n    if (output[_tGRTR] != null) {\n        contents[_TGRTR] = de_TransitGatewayRouteTableRoute(output[_tGRTR], context);\n    }\n    if (output[_tGAr] != null) {\n        contents[_TGAra] = de_AnalysisComponent(output[_tGAr], context);\n    }\n    if (output[_cAo] != null) {\n        contents[_CAom] = __expectString(output[_cAo]);\n    }\n    if (output[_cRo] != null) {\n        contents[_CRo] = __expectString(output[_cRo]);\n    }\n    if (output[_fSR] != null) {\n        contents[_FSRi] = de_FirewallStatelessRule(output[_fSR], context);\n    }\n    if (output[_fSRi] != null) {\n        contents[_FSRir] = de_FirewallStatefulRule(output[_fSRi], context);\n    }\n    return contents;\n};\nconst de_ExplanationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Explanation(entry, context);\n    });\n};\nconst de_ExportClientVpnClientCertificateRevocationListResult = (output, context) => {\n    const contents = {};\n    if (output[_cRL] != null) {\n        contents[_CRL] = __expectString(output[_cRL]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientCertificateRevocationListStatus(output[_sta], context);\n    }\n    return contents;\n};\nconst de_ExportClientVpnClientConfigurationResult = (output, context) => {\n    const contents = {};\n    if (output[_cCl] != null) {\n        contents[_CCl] = __expectString(output[_cCl]);\n    }\n    return contents;\n};\nconst de_ExportImageResult = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_dIF] != null) {\n        contents[_DIFi] = __expectString(output[_dIF]);\n    }\n    if (output[_eITI] != null) {\n        contents[_EITIx] = __expectString(output[_eITI]);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_rNo] != null) {\n        contents[_RNo] = __expectString(output[_rNo]);\n    }\n    if (output[_pro] != null) {\n        contents[_Prog] = __expectString(output[_pro]);\n    }\n    if (output[_sEL] != null) {\n        contents[_SEL] = de_ExportTaskS3Location(output[_sEL], context);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_ExportImageTask = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_eITI] != null) {\n        contents[_EITIx] = __expectString(output[_eITI]);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_pro] != null) {\n        contents[_Prog] = __expectString(output[_pro]);\n    }\n    if (output[_sEL] != null) {\n        contents[_SEL] = de_ExportTaskS3Location(output[_sEL], context);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_ExportImageTaskList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ExportImageTask(entry, context);\n    });\n};\nconst de_ExportTask = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_eTI] != null) {\n        contents[_ETI] = __expectString(output[_eTI]);\n    }\n    if (output[_eTSx] != null) {\n        contents[_ETST] = de_ExportToS3Task(output[_eTSx], context);\n    }\n    if (output[_iE] != null) {\n        contents[_IED] = de_InstanceExportDetails(output[_iE], context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_ExportTaskList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ExportTask(entry, context);\n    });\n};\nconst de_ExportTaskS3Location = (output, context) => {\n    const contents = {};\n    if (output[_sB] != null) {\n        contents[_SB] = __expectString(output[_sB]);\n    }\n    if (output[_sP] != null) {\n        contents[_SP] = __expectString(output[_sP]);\n    }\n    return contents;\n};\nconst de_ExportToS3Task = (output, context) => {\n    const contents = {};\n    if (output[_cF] != null) {\n        contents[_CFo] = __expectString(output[_cF]);\n    }\n    if (output[_dIF] != null) {\n        contents[_DIFi] = __expectString(output[_dIF]);\n    }\n    if (output[_sB] != null) {\n        contents[_SB] = __expectString(output[_sB]);\n    }\n    if (output[_sK] != null) {\n        contents[_SK] = __expectString(output[_sK]);\n    }\n    return contents;\n};\nconst de_ExportTransitGatewayRoutesResult = (output, context) => {\n    const contents = {};\n    if (output[_sL] != null) {\n        contents[_SLo] = __expectString(output[_sL]);\n    }\n    return contents;\n};\nconst de_ExportVerifiedAccessInstanceClientConfigurationResult = (output, context) => {\n    const contents = {};\n    if (output[_ve] != null) {\n        contents[_V] = __expectString(output[_ve]);\n    }\n    if (output[_vAII] != null) {\n        contents[_VAII] = __expectString(output[_vAII]);\n    }\n    if (output[_re] != null) {\n        contents[_Regi] = __expectString(output[_re]);\n    }\n    if (output.deviceTrustProviderSet === \"\") {\n        contents[_DTP] = [];\n    }\n    else if (output[_dTPS] != null && output[_dTPS][_i] != null) {\n        contents[_DTP] = de_DeviceTrustProviderTypeList(__getArrayIfSingleItem(output[_dTPS][_i]), context);\n    }\n    if (output[_uTP] != null) {\n        contents[_UTP] = de_VerifiedAccessInstanceUserTrustProviderClientConfiguration(output[_uTP], context);\n    }\n    if (output.openVpnConfigurationSet === \"\") {\n        contents[_OVC] = [];\n    }\n    else if (output[_oVCS] != null && output[_oVCS][_i] != null) {\n        contents[_OVC] = de_VerifiedAccessInstanceOpenVpnClientConfigurationList(__getArrayIfSingleItem(output[_oVCS][_i]), context);\n    }\n    return contents;\n};\nconst de_FailedCapacityReservationFleetCancellationResult = (output, context) => {\n    const contents = {};\n    if (output[_cRFI] != null) {\n        contents[_CRFIa] = __expectString(output[_cRFI]);\n    }\n    if (output[_cCRFE] != null) {\n        contents[_CCRFE] = de_CancelCapacityReservationFleetError(output[_cCRFE], context);\n    }\n    return contents;\n};\nconst de_FailedCapacityReservationFleetCancellationResultSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_FailedCapacityReservationFleetCancellationResult(entry, context);\n    });\n};\nconst de_FailedQueuedPurchaseDeletion = (output, context) => {\n    const contents = {};\n    if (output[_er] != null) {\n        contents[_Er] = de_DeleteQueuedReservedInstancesError(output[_er], context);\n    }\n    if (output[_rII] != null) {\n        contents[_RIIe] = __expectString(output[_rII]);\n    }\n    return contents;\n};\nconst de_FailedQueuedPurchaseDeletionSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_FailedQueuedPurchaseDeletion(entry, context);\n    });\n};\nconst de_FastLaunchLaunchTemplateSpecificationResponse = (output, context) => {\n    const contents = {};\n    if (output[_lTI] != null) {\n        contents[_LTI] = __expectString(output[_lTI]);\n    }\n    if (output[_lTN] != null) {\n        contents[_LTN] = __expectString(output[_lTN]);\n    }\n    if (output[_ve] != null) {\n        contents[_V] = __expectString(output[_ve]);\n    }\n    return contents;\n};\nconst de_FastLaunchSnapshotConfigurationResponse = (output, context) => {\n    const contents = {};\n    if (output[_tRC] != null) {\n        contents[_TRC] = __strictParseInt32(output[_tRC]);\n    }\n    return contents;\n};\nconst de_FederatedAuthentication = (output, context) => {\n    const contents = {};\n    if (output[_sPA] != null) {\n        contents[_SPA] = __expectString(output[_sPA]);\n    }\n    if (output[_sSSPA] != null) {\n        contents[_SSSPA] = __expectString(output[_sSSPA]);\n    }\n    return contents;\n};\nconst de_FilterPortRange = (output, context) => {\n    const contents = {};\n    if (output[_fP] != null) {\n        contents[_FP] = __strictParseInt32(output[_fP]);\n    }\n    if (output[_tPo] != null) {\n        contents[_TP] = __strictParseInt32(output[_tPo]);\n    }\n    return contents;\n};\nconst de_FirewallStatefulRule = (output, context) => {\n    const contents = {};\n    if (output[_rGA] != null) {\n        contents[_RGA] = __expectString(output[_rGA]);\n    }\n    if (output.sourceSet === \"\") {\n        contents[_So] = [];\n    }\n    else if (output[_sSo] != null && output[_sSo][_i] != null) {\n        contents[_So] = de_ValueStringList(__getArrayIfSingleItem(output[_sSo][_i]), context);\n    }\n    if (output.destinationSet === \"\") {\n        contents[_Des] = [];\n    }\n    else if (output[_dSe] != null && output[_dSe][_i] != null) {\n        contents[_Des] = de_ValueStringList(__getArrayIfSingleItem(output[_dSe][_i]), context);\n    }\n    if (output.sourcePortSet === \"\") {\n        contents[_SPo] = [];\n    }\n    else if (output[_sPS] != null && output[_sPS][_i] != null) {\n        contents[_SPo] = de_PortRangeList(__getArrayIfSingleItem(output[_sPS][_i]), context);\n    }\n    if (output.destinationPortSet === \"\") {\n        contents[_DPes] = [];\n    }\n    else if (output[_dPS] != null && output[_dPS][_i] != null) {\n        contents[_DPes] = de_PortRangeList(__getArrayIfSingleItem(output[_dPS][_i]), context);\n    }\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    if (output[_rA] != null) {\n        contents[_RAu] = __expectString(output[_rA]);\n    }\n    if (output[_di] != null) {\n        contents[_Di] = __expectString(output[_di]);\n    }\n    return contents;\n};\nconst de_FirewallStatelessRule = (output, context) => {\n    const contents = {};\n    if (output[_rGA] != null) {\n        contents[_RGA] = __expectString(output[_rGA]);\n    }\n    if (output.sourceSet === \"\") {\n        contents[_So] = [];\n    }\n    else if (output[_sSo] != null && output[_sSo][_i] != null) {\n        contents[_So] = de_ValueStringList(__getArrayIfSingleItem(output[_sSo][_i]), context);\n    }\n    if (output.destinationSet === \"\") {\n        contents[_Des] = [];\n    }\n    else if (output[_dSe] != null && output[_dSe][_i] != null) {\n        contents[_Des] = de_ValueStringList(__getArrayIfSingleItem(output[_dSe][_i]), context);\n    }\n    if (output.sourcePortSet === \"\") {\n        contents[_SPo] = [];\n    }\n    else if (output[_sPS] != null && output[_sPS][_i] != null) {\n        contents[_SPo] = de_PortRangeList(__getArrayIfSingleItem(output[_sPS][_i]), context);\n    }\n    if (output.destinationPortSet === \"\") {\n        contents[_DPes] = [];\n    }\n    else if (output[_dPS] != null && output[_dPS][_i] != null) {\n        contents[_DPes] = de_PortRangeList(__getArrayIfSingleItem(output[_dPS][_i]), context);\n    }\n    if (output.protocolSet === \"\") {\n        contents[_Pro] = [];\n    }\n    else if (output[_pSro] != null && output[_pSro][_i] != null) {\n        contents[_Pro] = de_ProtocolIntList(__getArrayIfSingleItem(output[_pSro][_i]), context);\n    }\n    if (output[_rA] != null) {\n        contents[_RAu] = __expectString(output[_rA]);\n    }\n    if (output[_pri] != null) {\n        contents[_Pri] = __strictParseInt32(output[_pri]);\n    }\n    return contents;\n};\nconst de_FleetCapacityReservation = (output, context) => {\n    const contents = {};\n    if (output[_cRI] != null) {\n        contents[_CRI] = __expectString(output[_cRI]);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_iPn] != null) {\n        contents[_IPn] = __expectString(output[_iPn]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_tIC] != null) {\n        contents[_TICo] = __strictParseInt32(output[_tIC]);\n    }\n    if (output[_fC] != null) {\n        contents[_FC] = __strictParseFloat(output[_fC]);\n    }\n    if (output[_eO] != null) {\n        contents[_EO] = __parseBoolean(output[_eO]);\n    }\n    if (output[_cD] != null) {\n        contents[_CDr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cD]));\n    }\n    if (output[_we] != null) {\n        contents[_W] = __strictParseFloat(output[_we]);\n    }\n    if (output[_pri] != null) {\n        contents[_Pri] = __strictParseInt32(output[_pri]);\n    }\n    return contents;\n};\nconst de_FleetCapacityReservationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_FleetCapacityReservation(entry, context);\n    });\n};\nconst de_FleetData = (output, context) => {\n    const contents = {};\n    if (output[_aSc] != null) {\n        contents[_ASc] = __expectString(output[_aSc]);\n    }\n    if (output[_cTr] != null) {\n        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));\n    }\n    if (output[_fIl] != null) {\n        contents[_FIl] = __expectString(output[_fIl]);\n    }\n    if (output[_fSl] != null) {\n        contents[_FS] = __expectString(output[_fSl]);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    if (output[_eCTP] != null) {\n        contents[_ECTP] = __expectString(output[_eCTP]);\n    }\n    if (output[_fC] != null) {\n        contents[_FC] = __strictParseFloat(output[_fC]);\n    }\n    if (output[_fODC] != null) {\n        contents[_FODC] = __strictParseFloat(output[_fODC]);\n    }\n    if (output.launchTemplateConfigs === \"\") {\n        contents[_LTC] = [];\n    }\n    else if (output[_lTC] != null && output[_lTC][_i] != null) {\n        contents[_LTC] = de_FleetLaunchTemplateConfigList(__getArrayIfSingleItem(output[_lTC][_i]), context);\n    }\n    if (output[_tCS] != null) {\n        contents[_TCS] = de_TargetCapacitySpecification(output[_tCS], context);\n    }\n    if (output[_tIWE] != null) {\n        contents[_TIWE] = __parseBoolean(output[_tIWE]);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_vF] != null) {\n        contents[_VF] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vF]));\n    }\n    if (output[_vU] != null) {\n        contents[_VU] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vU]));\n    }\n    if (output[_rUI] != null) {\n        contents[_RUI] = __parseBoolean(output[_rUI]);\n    }\n    if (output[_sO] != null) {\n        contents[_SO] = de_SpotOptions(output[_sO], context);\n    }\n    if (output[_oDO] != null) {\n        contents[_ODO] = de_OnDemandOptions(output[_oDO], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output.errorSet === \"\") {\n        contents[_Err] = [];\n    }\n    else if (output[_eSr] != null && output[_eSr][_i] != null) {\n        contents[_Err] = de_DescribeFleetsErrorSet(__getArrayIfSingleItem(output[_eSr][_i]), context);\n    }\n    if (output.fleetInstanceSet === \"\") {\n        contents[_In] = [];\n    }\n    else if (output[_fIS] != null && output[_fIS][_i] != null) {\n        contents[_In] = de_DescribeFleetsInstancesSet(__getArrayIfSingleItem(output[_fIS][_i]), context);\n    }\n    if (output[_cont] != null) {\n        contents[_Con] = __expectString(output[_cont]);\n    }\n    return contents;\n};\nconst de_FleetLaunchTemplateConfig = (output, context) => {\n    const contents = {};\n    if (output[_lTS] != null) {\n        contents[_LTS] = de_FleetLaunchTemplateSpecification(output[_lTS], context);\n    }\n    if (output.overrides === \"\") {\n        contents[_Ov] = [];\n    }\n    else if (output[_ov] != null && output[_ov][_i] != null) {\n        contents[_Ov] = de_FleetLaunchTemplateOverridesList(__getArrayIfSingleItem(output[_ov][_i]), context);\n    }\n    return contents;\n};\nconst de_FleetLaunchTemplateConfigList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_FleetLaunchTemplateConfig(entry, context);\n    });\n};\nconst de_FleetLaunchTemplateOverrides = (output, context) => {\n    const contents = {};\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_mP] != null) {\n        contents[_MPa] = __expectString(output[_mP]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_wC] != null) {\n        contents[_WCe] = __strictParseFloat(output[_wC]);\n    }\n    if (output[_pri] != null) {\n        contents[_Pri] = __strictParseFloat(output[_pri]);\n    }\n    if (output[_pla] != null) {\n        contents[_Pl] = de_PlacementResponse(output[_pla], context);\n    }\n    if (output[_iR] != null) {\n        contents[_IR] = de_InstanceRequirements(output[_iR], context);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output.blockDeviceMappingSet === \"\") {\n        contents[_BDM] = [];\n    }\n    else if (output[_bDMS] != null && output[_bDMS][_i] != null) {\n        contents[_BDM] = de_BlockDeviceMappingResponseList(__getArrayIfSingleItem(output[_bDMS][_i]), context);\n    }\n    return contents;\n};\nconst de_FleetLaunchTemplateOverridesList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_FleetLaunchTemplateOverrides(entry, context);\n    });\n};\nconst de_FleetLaunchTemplateSpecification = (output, context) => {\n    const contents = {};\n    if (output[_lTI] != null) {\n        contents[_LTI] = __expectString(output[_lTI]);\n    }\n    if (output[_lTN] != null) {\n        contents[_LTN] = __expectString(output[_lTN]);\n    }\n    if (output[_ve] != null) {\n        contents[_V] = __expectString(output[_ve]);\n    }\n    return contents;\n};\nconst de_FleetSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_FleetData(entry, context);\n    });\n};\nconst de_FleetSpotCapacityRebalance = (output, context) => {\n    const contents = {};\n    if (output[_rSep] != null) {\n        contents[_RS] = __expectString(output[_rSep]);\n    }\n    if (output[_tD] != null) {\n        contents[_TDe] = __strictParseInt32(output[_tD]);\n    }\n    return contents;\n};\nconst de_FleetSpotMaintenanceStrategies = (output, context) => {\n    const contents = {};\n    if (output[_cRa] != null) {\n        contents[_CRap] = de_FleetSpotCapacityRebalance(output[_cRa], context);\n    }\n    return contents;\n};\nconst de_FlowLog = (output, context) => {\n    const contents = {};\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));\n    }\n    if (output[_dLEM] != null) {\n        contents[_DLEM] = __expectString(output[_dLEM]);\n    }\n    if (output[_dLPA] != null) {\n        contents[_DLPA] = __expectString(output[_dLPA]);\n    }\n    if (output[_dCAR] != null) {\n        contents[_DCAR] = __expectString(output[_dCAR]);\n    }\n    if (output[_dLS] != null) {\n        contents[_DLSe] = __expectString(output[_dLS]);\n    }\n    if (output[_fLI] != null) {\n        contents[_FLIl] = __expectString(output[_fLI]);\n    }\n    if (output[_fLSl] != null) {\n        contents[_FLS] = __expectString(output[_fLSl]);\n    }\n    if (output[_lGN] != null) {\n        contents[_LGN] = __expectString(output[_lGN]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_tT] != null) {\n        contents[_TT] = __expectString(output[_tT]);\n    }\n    if (output[_lDT] != null) {\n        contents[_LDT] = __expectString(output[_lDT]);\n    }\n    if (output[_lD] != null) {\n        contents[_LD] = __expectString(output[_lD]);\n    }\n    if (output[_lF] != null) {\n        contents[_LF] = __expectString(output[_lF]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_mAI] != null) {\n        contents[_MAI] = __strictParseInt32(output[_mAI]);\n    }\n    if (output[_dOe] != null) {\n        contents[_DO] = de_DestinationOptionsResponse(output[_dOe], context);\n    }\n    return contents;\n};\nconst de_FlowLogSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_FlowLog(entry, context);\n    });\n};\nconst de_FpgaDeviceInfo = (output, context) => {\n    const contents = {};\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_man] != null) {\n        contents[_Man] = __expectString(output[_man]);\n    }\n    if (output[_cou] != null) {\n        contents[_Cou] = __strictParseInt32(output[_cou]);\n    }\n    if (output[_mIe] != null) {\n        contents[_MIe] = de_FpgaDeviceMemoryInfo(output[_mIe], context);\n    }\n    return contents;\n};\nconst de_FpgaDeviceInfoList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_FpgaDeviceInfo(entry, context);\n    });\n};\nconst de_FpgaDeviceMemoryInfo = (output, context) => {\n    const contents = {};\n    if (output[_sIMB] != null) {\n        contents[_SIMB] = __strictParseInt32(output[_sIMB]);\n    }\n    return contents;\n};\nconst de_FpgaImage = (output, context) => {\n    const contents = {};\n    if (output[_fII] != null) {\n        contents[_FII] = __expectString(output[_fII]);\n    }\n    if (output[_fIGI] != null) {\n        contents[_FIGI] = __expectString(output[_fIGI]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_sVh] != null) {\n        contents[_SVh] = __expectString(output[_sVh]);\n    }\n    if (output[_pIc] != null) {\n        contents[_PIc] = de_PciId(output[_pIc], context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = de_FpgaImageState(output[_st], context);\n    }\n    if (output[_cTr] != null) {\n        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));\n    }\n    if (output[_uT] != null) {\n        contents[_UTp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uT]));\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_oAw] != null) {\n        contents[_OAw] = __expectString(output[_oAw]);\n    }\n    if (output.productCodes === \"\") {\n        contents[_PCr] = [];\n    }\n    else if (output[_pC] != null && output[_pC][_i] != null) {\n        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);\n    }\n    if (output.tags === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_ta] != null && output[_ta][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_ta][_i]), context);\n    }\n    if (output[_pu] != null) {\n        contents[_Pu] = __parseBoolean(output[_pu]);\n    }\n    if (output[_dRS] != null) {\n        contents[_DRSa] = __parseBoolean(output[_dRS]);\n    }\n    if (output.instanceTypes === \"\") {\n        contents[_ITnst] = [];\n    }\n    else if (output[_iTn] != null && output[_iTn][_i] != null) {\n        contents[_ITnst] = de_InstanceTypesList(__getArrayIfSingleItem(output[_iTn][_i]), context);\n    }\n    return contents;\n};\nconst de_FpgaImageAttribute = (output, context) => {\n    const contents = {};\n    if (output[_fII] != null) {\n        contents[_FII] = __expectString(output[_fII]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.loadPermissions === \"\") {\n        contents[_LPo] = [];\n    }\n    else if (output[_lP] != null && output[_lP][_i] != null) {\n        contents[_LPo] = de_LoadPermissionList(__getArrayIfSingleItem(output[_lP][_i]), context);\n    }\n    if (output.productCodes === \"\") {\n        contents[_PCr] = [];\n    }\n    else if (output[_pC] != null && output[_pC][_i] != null) {\n        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);\n    }\n    return contents;\n};\nconst de_FpgaImageList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_FpgaImage(entry, context);\n    });\n};\nconst de_FpgaImageState = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_FpgaInfo = (output, context) => {\n    const contents = {};\n    if (output.fpgas === \"\") {\n        contents[_Fp] = [];\n    }\n    else if (output[_fp] != null && output[_fp][_i] != null) {\n        contents[_Fp] = de_FpgaDeviceInfoList(__getArrayIfSingleItem(output[_fp][_i]), context);\n    }\n    if (output[_tFMIMB] != null) {\n        contents[_TFMIMB] = __strictParseInt32(output[_tFMIMB]);\n    }\n    return contents;\n};\nconst de_GetActiveVpnTunnelStatusResult = (output, context) => {\n    const contents = {};\n    if (output[_aVTS] != null) {\n        contents[_AVTS] = de_ActiveVpnTunnelStatus(output[_aVTS], context);\n    }\n    return contents;\n};\nconst de_GetAllowedImagesSettingsResult = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.imageCriterionSet === \"\") {\n        contents[_ICm] = [];\n    }\n    else if (output[_iCS] != null && output[_iCS][_i] != null) {\n        contents[_ICm] = de_ImageCriterionList(__getArrayIfSingleItem(output[_iCS][_i]), context);\n    }\n    if (output[_mB] != null) {\n        contents[_MB] = __expectString(output[_mB]);\n    }\n    return contents;\n};\nconst de_GetAssociatedEnclaveCertificateIamRolesResult = (output, context) => {\n    const contents = {};\n    if (output.associatedRoleSet === \"\") {\n        contents[_ARss] = [];\n    }\n    else if (output[_aRS] != null && output[_aRS][_i] != null) {\n        contents[_ARss] = de_AssociatedRolesList(__getArrayIfSingleItem(output[_aRS][_i]), context);\n    }\n    return contents;\n};\nconst de_GetAssociatedIpv6PoolCidrsResult = (output, context) => {\n    const contents = {};\n    if (output.ipv6CidrAssociationSet === \"\") {\n        contents[_ICA] = [];\n    }\n    else if (output[_iCAS] != null && output[_iCAS][_i] != null) {\n        contents[_ICA] = de_Ipv6CidrAssociationSet(__getArrayIfSingleItem(output[_iCAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetAwsNetworkPerformanceDataResult = (output, context) => {\n    const contents = {};\n    if (output.dataResponseSet === \"\") {\n        contents[_DRa] = [];\n    }\n    else if (output[_dRSa] != null && output[_dRSa][_i] != null) {\n        contents[_DRa] = de_DataResponses(__getArrayIfSingleItem(output[_dRSa][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetCapacityReservationUsageResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output[_cRI] != null) {\n        contents[_CRI] = __expectString(output[_cRI]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_tIC] != null) {\n        contents[_TICo] = __strictParseInt32(output[_tIC]);\n    }\n    if (output[_aICv] != null) {\n        contents[_AICv] = __strictParseInt32(output[_aICv]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.instanceUsageSet === \"\") {\n        contents[_IU] = [];\n    }\n    else if (output[_iUS] != null && output[_iUS][_i] != null) {\n        contents[_IU] = de_InstanceUsageSet(__getArrayIfSingleItem(output[_iUS][_i]), context);\n    }\n    return contents;\n};\nconst de_GetCoipPoolUsageResult = (output, context) => {\n    const contents = {};\n    if (output[_cPI] != null) {\n        contents[_CPIo] = __expectString(output[_cPI]);\n    }\n    if (output.coipAddressUsageSet === \"\") {\n        contents[_CAU] = [];\n    }\n    else if (output[_cAUS] != null && output[_cAUS][_i] != null) {\n        contents[_CAU] = de_CoipAddressUsageSet(__getArrayIfSingleItem(output[_cAUS][_i]), context);\n    }\n    if (output[_lGRTI] != null) {\n        contents[_LGRTI] = __expectString(output[_lGRTI]);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetConsoleOutputResult = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_ti] != null) {\n        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));\n    }\n    if (output[_ou] != null) {\n        contents[_Ou] = __expectString(output[_ou]);\n    }\n    return contents;\n};\nconst de_GetConsoleScreenshotResult = (output, context) => {\n    const contents = {};\n    if (output[_iD] != null) {\n        contents[_IDm] = __expectString(output[_iD]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    return contents;\n};\nconst de_GetDeclarativePoliciesReportSummaryResult = (output, context) => {\n    const contents = {};\n    if (output[_rI] != null) {\n        contents[_RIep] = __expectString(output[_rI]);\n    }\n    if (output[_sB] != null) {\n        contents[_SB] = __expectString(output[_sB]);\n    }\n    if (output[_sP] != null) {\n        contents[_SP] = __expectString(output[_sP]);\n    }\n    if (output[_tI] != null) {\n        contents[_TIa] = __expectString(output[_tI]);\n    }\n    if (output[_sT] != null) {\n        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));\n    }\n    if (output[_eTn] != null) {\n        contents[_ETn] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTn]));\n    }\n    if (output[_nOA] != null) {\n        contents[_NOA] = __strictParseInt32(output[_nOA]);\n    }\n    if (output[_nOFA] != null) {\n        contents[_NOFA] = __strictParseInt32(output[_nOFA]);\n    }\n    if (output.attributeSummarySet === \"\") {\n        contents[_ASt] = [];\n    }\n    else if (output[_aSSt] != null && output[_aSSt][_i] != null) {\n        contents[_ASt] = de_AttributeSummaryList(__getArrayIfSingleItem(output[_aSSt][_i]), context);\n    }\n    return contents;\n};\nconst de_GetDefaultCreditSpecificationResult = (output, context) => {\n    const contents = {};\n    if (output[_iFCS] != null) {\n        contents[_IFCS] = de_InstanceFamilyCreditSpecification(output[_iFCS], context);\n    }\n    return contents;\n};\nconst de_GetEbsDefaultKmsKeyIdResult = (output, context) => {\n    const contents = {};\n    if (output[_kKI] != null) {\n        contents[_KKI] = __expectString(output[_kKI]);\n    }\n    return contents;\n};\nconst de_GetEbsEncryptionByDefaultResult = (output, context) => {\n    const contents = {};\n    if (output[_eEBD] != null) {\n        contents[_EEBD] = __parseBoolean(output[_eEBD]);\n    }\n    if (output[_sTs] != null) {\n        contents[_STs] = __expectString(output[_sTs]);\n    }\n    return contents;\n};\nconst de_GetFlowLogsIntegrationTemplateResult = (output, context) => {\n    const contents = {};\n    if (output[_res] != null) {\n        contents[_Resu] = __expectString(output[_res]);\n    }\n    return contents;\n};\nconst de_GetGroupsForCapacityReservationResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.capacityReservationGroupSet === \"\") {\n        contents[_CRG] = [];\n    }\n    else if (output[_cRGS] != null && output[_cRGS][_i] != null) {\n        contents[_CRG] = de_CapacityReservationGroupSet(__getArrayIfSingleItem(output[_cRGS][_i]), context);\n    }\n    return contents;\n};\nconst de_GetHostReservationPurchasePreviewResult = (output, context) => {\n    const contents = {};\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    if (output.purchase === \"\") {\n        contents[_Pur] = [];\n    }\n    else if (output[_pur] != null && output[_pur][_i] != null) {\n        contents[_Pur] = de_PurchaseSet(__getArrayIfSingleItem(output[_pur][_i]), context);\n    }\n    if (output[_tHP] != null) {\n        contents[_THP] = __expectString(output[_tHP]);\n    }\n    if (output[_tUP] != null) {\n        contents[_TUP] = __expectString(output[_tUP]);\n    }\n    return contents;\n};\nconst de_GetImageBlockPublicAccessStateResult = (output, context) => {\n    const contents = {};\n    if (output[_iBPAS] != null) {\n        contents[_IBPAS] = __expectString(output[_iBPAS]);\n    }\n    if (output[_mB] != null) {\n        contents[_MB] = __expectString(output[_mB]);\n    }\n    return contents;\n};\nconst de_GetInstanceMetadataDefaultsResult = (output, context) => {\n    const contents = {};\n    if (output[_aL] != null) {\n        contents[_ALc] = de_InstanceMetadataDefaultsResponse(output[_aL], context);\n    }\n    return contents;\n};\nconst de_GetInstanceTpmEkPubResult = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_kT] != null) {\n        contents[_KT] = __expectString(output[_kT]);\n    }\n    if (output[_kF] != null) {\n        contents[_KF] = __expectString(output[_kF]);\n    }\n    if (output[_kV] != null) {\n        contents[_KV] = __expectString(output[_kV]);\n    }\n    return contents;\n};\nconst de_GetInstanceTypesFromInstanceRequirementsResult = (output, context) => {\n    const contents = {};\n    if (output.instanceTypeSet === \"\") {\n        contents[_ITnst] = [];\n    }\n    else if (output[_iTS] != null && output[_iTS][_i] != null) {\n        contents[_ITnst] = de_InstanceTypeInfoFromInstanceRequirementsSet(__getArrayIfSingleItem(output[_iTS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetInstanceUefiDataResult = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_uD] != null) {\n        contents[_UDe] = __expectString(output[_uD]);\n    }\n    return contents;\n};\nconst de_GetIpamAddressHistoryResult = (output, context) => {\n    const contents = {};\n    if (output.historyRecordSet === \"\") {\n        contents[_HRi] = [];\n    }\n    else if (output[_hRS] != null && output[_hRS][_i] != null) {\n        contents[_HRi] = de_IpamAddressHistoryRecordSet(__getArrayIfSingleItem(output[_hRS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetIpamDiscoveredAccountsResult = (output, context) => {\n    const contents = {};\n    if (output.ipamDiscoveredAccountSet === \"\") {\n        contents[_IDA] = [];\n    }\n    else if (output[_iDAS] != null && output[_iDAS][_i] != null) {\n        contents[_IDA] = de_IpamDiscoveredAccountSet(__getArrayIfSingleItem(output[_iDAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetIpamDiscoveredPublicAddressesResult = (output, context) => {\n    const contents = {};\n    if (output.ipamDiscoveredPublicAddressSet === \"\") {\n        contents[_IDPA] = [];\n    }\n    else if (output[_iDPAS] != null && output[_iDPAS][_i] != null) {\n        contents[_IDPA] = de_IpamDiscoveredPublicAddressSet(__getArrayIfSingleItem(output[_iDPAS][_i]), context);\n    }\n    if (output[_oST] != null) {\n        contents[_OST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_oST]));\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetIpamDiscoveredResourceCidrsResult = (output, context) => {\n    const contents = {};\n    if (output.ipamDiscoveredResourceCidrSet === \"\") {\n        contents[_IDRC] = [];\n    }\n    else if (output[_iDRCS] != null && output[_iDRCS][_i] != null) {\n        contents[_IDRC] = de_IpamDiscoveredResourceCidrSet(__getArrayIfSingleItem(output[_iDRCS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetIpamPoolAllocationsResult = (output, context) => {\n    const contents = {};\n    if (output.ipamPoolAllocationSet === \"\") {\n        contents[_IPAp] = [];\n    }\n    else if (output[_iPAS] != null && output[_iPAS][_i] != null) {\n        contents[_IPAp] = de_IpamPoolAllocationSet(__getArrayIfSingleItem(output[_iPAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetIpamPoolCidrsResult = (output, context) => {\n    const contents = {};\n    if (output.ipamPoolCidrSet === \"\") {\n        contents[_IPCpam] = [];\n    }\n    else if (output[_iPCS] != null && output[_iPCS][_i] != null) {\n        contents[_IPCpam] = de_IpamPoolCidrSet(__getArrayIfSingleItem(output[_iPCS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetIpamResourceCidrsResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.ipamResourceCidrSet === \"\") {\n        contents[_IRC] = [];\n    }\n    else if (output[_iRCS] != null && output[_iRCS][_i] != null) {\n        contents[_IRC] = de_IpamResourceCidrSet(__getArrayIfSingleItem(output[_iRCS][_i]), context);\n    }\n    return contents;\n};\nconst de_GetLaunchTemplateDataResult = (output, context) => {\n    const contents = {};\n    if (output[_lTD] != null) {\n        contents[_LTD] = de_ResponseLaunchTemplateData(output[_lTD], context);\n    }\n    return contents;\n};\nconst de_GetManagedPrefixListAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.prefixListAssociationSet === \"\") {\n        contents[_PLA] = [];\n    }\n    else if (output[_pLAS] != null && output[_pLAS][_i] != null) {\n        contents[_PLA] = de_PrefixListAssociationSet(__getArrayIfSingleItem(output[_pLAS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetManagedPrefixListEntriesResult = (output, context) => {\n    const contents = {};\n    if (output.entrySet === \"\") {\n        contents[_Ent] = [];\n    }\n    else if (output[_eSnt] != null && output[_eSnt][_i] != null) {\n        contents[_Ent] = de_PrefixListEntrySet(__getArrayIfSingleItem(output[_eSnt][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetNetworkInsightsAccessScopeAnalysisFindingsResult = (output, context) => {\n    const contents = {};\n    if (output[_nIASAI] != null) {\n        contents[_NIASAI] = __expectString(output[_nIASAI]);\n    }\n    if (output[_aSn] != null) {\n        contents[_ASn] = __expectString(output[_aSn]);\n    }\n    if (output.analysisFindingSet === \"\") {\n        contents[_AFn] = [];\n    }\n    else if (output[_aFS] != null && output[_aFS][_i] != null) {\n        contents[_AFn] = de_AccessScopeAnalysisFindingList(__getArrayIfSingleItem(output[_aFS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetNetworkInsightsAccessScopeContentResult = (output, context) => {\n    const contents = {};\n    if (output[_nIASC] != null) {\n        contents[_NIASC] = de_NetworkInsightsAccessScopeContent(output[_nIASC], context);\n    }\n    return contents;\n};\nconst de_GetPasswordDataResult = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_ti] != null) {\n        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));\n    }\n    if (output[_pD] != null) {\n        contents[_PDa] = __expectString(output[_pD]);\n    }\n    return contents;\n};\nconst de_GetReservedInstancesExchangeQuoteResult = (output, context) => {\n    const contents = {};\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    if (output[_iVE] != null) {\n        contents[_IVE] = __parseBoolean(output[_iVE]);\n    }\n    if (output[_oRIWEA] != null) {\n        contents[_ORIWEA] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_oRIWEA]));\n    }\n    if (output[_pDa] != null) {\n        contents[_PDay] = __expectString(output[_pDa]);\n    }\n    if (output[_rIVR] != null) {\n        contents[_RIVR] = de_ReservationValue(output[_rIVR], context);\n    }\n    if (output.reservedInstanceValueSet === \"\") {\n        contents[_RIVS] = [];\n    }\n    else if (output[_rIVS] != null && output[_rIVS][_i] != null) {\n        contents[_RIVS] = de_ReservedInstanceReservationValueSet(__getArrayIfSingleItem(output[_rIVS][_i]), context);\n    }\n    if (output[_tCVR] != null) {\n        contents[_TCVR] = de_ReservationValue(output[_tCVR], context);\n    }\n    if (output.targetConfigurationValueSet === \"\") {\n        contents[_TCVS] = [];\n    }\n    else if (output[_tCVS] != null && output[_tCVS][_i] != null) {\n        contents[_TCVS] = de_TargetReservationValueSet(__getArrayIfSingleItem(output[_tCVS][_i]), context);\n    }\n    if (output[_vFR] != null) {\n        contents[_VFR] = __expectString(output[_vFR]);\n    }\n    return contents;\n};\nconst de_GetRouteServerAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.routeServerAssociationSet === \"\") {\n        contents[_RSAou] = [];\n    }\n    else if (output[_rSAS] != null && output[_rSAS][_i] != null) {\n        contents[_RSAou] = de_RouteServerAssociationsList(__getArrayIfSingleItem(output[_rSAS][_i]), context);\n    }\n    return contents;\n};\nconst de_GetRouteServerPropagationsResult = (output, context) => {\n    const contents = {};\n    if (output.routeServerPropagationSet === \"\") {\n        contents[_RSPout] = [];\n    }\n    else if (output[_rSPSo] != null && output[_rSPSo][_i] != null) {\n        contents[_RSPout] = de_RouteServerPropagationsList(__getArrayIfSingleItem(output[_rSPSo][_i]), context);\n    }\n    return contents;\n};\nconst de_GetRouteServerRoutingDatabaseResult = (output, context) => {\n    const contents = {};\n    if (output[_aRP] != null) {\n        contents[_ARP] = __parseBoolean(output[_aRP]);\n    }\n    if (output.routeSet === \"\") {\n        contents[_Rout] = [];\n    }\n    else if (output[_rSou] != null && output[_rSou][_i] != null) {\n        contents[_Rout] = de_RouteServerRouteList(__getArrayIfSingleItem(output[_rSou][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetSecurityGroupsForVpcResult = (output, context) => {\n    const contents = {};\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    if (output.securityGroupForVpcSet === \"\") {\n        contents[_SGFV] = [];\n    }\n    else if (output[_sGFVS] != null && output[_sGFVS][_i] != null) {\n        contents[_SGFV] = de_SecurityGroupForVpcList(__getArrayIfSingleItem(output[_sGFVS][_i]), context);\n    }\n    return contents;\n};\nconst de_GetSerialConsoleAccessStatusResult = (output, context) => {\n    const contents = {};\n    if (output[_sCAE] != null) {\n        contents[_SCAE] = __parseBoolean(output[_sCAE]);\n    }\n    if (output[_mB] != null) {\n        contents[_MB] = __expectString(output[_mB]);\n    }\n    return contents;\n};\nconst de_GetSnapshotBlockPublicAccessStateResult = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_mB] != null) {\n        contents[_MB] = __expectString(output[_mB]);\n    }\n    return contents;\n};\nconst de_GetSpotPlacementScoresResult = (output, context) => {\n    const contents = {};\n    if (output.spotPlacementScoreSet === \"\") {\n        contents[_SPS] = [];\n    }\n    else if (output[_sPSS] != null && output[_sPSS][_i] != null) {\n        contents[_SPS] = de_SpotPlacementScores(__getArrayIfSingleItem(output[_sPSS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetSubnetCidrReservationsResult = (output, context) => {\n    const contents = {};\n    if (output.subnetIpv4CidrReservationSet === \"\") {\n        contents[_SICR] = [];\n    }\n    else if (output[_sICRS] != null && output[_sICRS][_i] != null) {\n        contents[_SICR] = de_SubnetCidrReservationList(__getArrayIfSingleItem(output[_sICRS][_i]), context);\n    }\n    if (output.subnetIpv6CidrReservationSet === \"\") {\n        contents[_SICRu] = [];\n    }\n    else if (output[_sICRSu] != null && output[_sICRSu][_i] != null) {\n        contents[_SICRu] = de_SubnetCidrReservationList(__getArrayIfSingleItem(output[_sICRSu][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetTransitGatewayAttachmentPropagationsResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayAttachmentPropagations === \"\") {\n        contents[_TGAP] = [];\n    }\n    else if (output[_tGAP] != null && output[_tGAP][_i] != null) {\n        contents[_TGAP] = de_TransitGatewayAttachmentPropagationList(__getArrayIfSingleItem(output[_tGAP][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetTransitGatewayMulticastDomainAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.multicastDomainAssociations === \"\") {\n        contents[_MDA] = [];\n    }\n    else if (output[_mDA] != null && output[_mDA][_i] != null) {\n        contents[_MDA] = de_TransitGatewayMulticastDomainAssociationList(__getArrayIfSingleItem(output[_mDA][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetTransitGatewayPolicyTableAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.associations === \"\") {\n        contents[_Ass] = [];\n    }\n    else if (output[_a] != null && output[_a][_i] != null) {\n        contents[_Ass] = de_TransitGatewayPolicyTableAssociationList(__getArrayIfSingleItem(output[_a][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetTransitGatewayPolicyTableEntriesResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayPolicyTableEntries === \"\") {\n        contents[_TGPTE] = [];\n    }\n    else if (output[_tGPTE] != null && output[_tGPTE][_i] != null) {\n        contents[_TGPTE] = de_TransitGatewayPolicyTableEntryList(__getArrayIfSingleItem(output[_tGPTE][_i]), context);\n    }\n    return contents;\n};\nconst de_GetTransitGatewayPrefixListReferencesResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayPrefixListReferenceSet === \"\") {\n        contents[_TGPLRr] = [];\n    }\n    else if (output[_tGPLRS] != null && output[_tGPLRS][_i] != null) {\n        contents[_TGPLRr] = de_TransitGatewayPrefixListReferenceSet(__getArrayIfSingleItem(output[_tGPLRS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetTransitGatewayRouteTableAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output.associations === \"\") {\n        contents[_Ass] = [];\n    }\n    else if (output[_a] != null && output[_a][_i] != null) {\n        contents[_Ass] = de_TransitGatewayRouteTableAssociationList(__getArrayIfSingleItem(output[_a][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetTransitGatewayRouteTablePropagationsResult = (output, context) => {\n    const contents = {};\n    if (output.transitGatewayRouteTablePropagations === \"\") {\n        contents[_TGRTP] = [];\n    }\n    else if (output[_tGRTP] != null && output[_tGRTP][_i] != null) {\n        contents[_TGRTP] = de_TransitGatewayRouteTablePropagationList(__getArrayIfSingleItem(output[_tGRTP][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetVerifiedAccessEndpointPolicyResult = (output, context) => {\n    const contents = {};\n    if (output[_pE] != null) {\n        contents[_PE] = __parseBoolean(output[_pE]);\n    }\n    if (output[_pDo] != null) {\n        contents[_PD] = __expectString(output[_pDo]);\n    }\n    return contents;\n};\nconst de_GetVerifiedAccessEndpointTargetsResult = (output, context) => {\n    const contents = {};\n    if (output.verifiedAccessEndpointTargetSet === \"\") {\n        contents[_VAET] = [];\n    }\n    else if (output[_vAETS] != null && output[_vAETS][_i] != null) {\n        contents[_VAET] = de_VerifiedAccessEndpointTargetList(__getArrayIfSingleItem(output[_vAETS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetVerifiedAccessGroupPolicyResult = (output, context) => {\n    const contents = {};\n    if (output[_pE] != null) {\n        contents[_PE] = __parseBoolean(output[_pE]);\n    }\n    if (output[_pDo] != null) {\n        contents[_PD] = __expectString(output[_pDo]);\n    }\n    return contents;\n};\nconst de_GetVpnConnectionDeviceSampleConfigurationResult = (output, context) => {\n    const contents = {};\n    if (output[_vCDSC] != null) {\n        contents[_VCDSC] = __expectString(output[_vCDSC]);\n    }\n    return contents;\n};\nconst de_GetVpnConnectionDeviceTypesResult = (output, context) => {\n    const contents = {};\n    if (output.vpnConnectionDeviceTypeSet === \"\") {\n        contents[_VCDT] = [];\n    }\n    else if (output[_vCDTS] != null && output[_vCDTS][_i] != null) {\n        contents[_VCDT] = de_VpnConnectionDeviceTypeList(__getArrayIfSingleItem(output[_vCDTS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_GetVpnTunnelReplacementStatusResult = (output, context) => {\n    const contents = {};\n    if (output[_vCI] != null) {\n        contents[_VCI] = __expectString(output[_vCI]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_cGIu] != null) {\n        contents[_CGIu] = __expectString(output[_cGIu]);\n    }\n    if (output[_vGI] != null) {\n        contents[_VGI] = __expectString(output[_vGI]);\n    }\n    if (output[_vTOIA] != null) {\n        contents[_VTOIA] = __expectString(output[_vTOIA]);\n    }\n    if (output[_mD] != null) {\n        contents[_MDa] = de_MaintenanceDetails(output[_mD], context);\n    }\n    return contents;\n};\nconst de_GpuDeviceInfo = (output, context) => {\n    const contents = {};\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_man] != null) {\n        contents[_Man] = __expectString(output[_man]);\n    }\n    if (output[_cou] != null) {\n        contents[_Cou] = __strictParseInt32(output[_cou]);\n    }\n    if (output[_mIe] != null) {\n        contents[_MIe] = de_GpuDeviceMemoryInfo(output[_mIe], context);\n    }\n    return contents;\n};\nconst de_GpuDeviceInfoList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_GpuDeviceInfo(entry, context);\n    });\n};\nconst de_GpuDeviceMemoryInfo = (output, context) => {\n    const contents = {};\n    if (output[_sIMB] != null) {\n        contents[_SIMB] = __strictParseInt32(output[_sIMB]);\n    }\n    return contents;\n};\nconst de_GpuInfo = (output, context) => {\n    const contents = {};\n    if (output.gpus === \"\") {\n        contents[_Gp] = [];\n    }\n    else if (output[_gp] != null && output[_gp][_i] != null) {\n        contents[_Gp] = de_GpuDeviceInfoList(__getArrayIfSingleItem(output[_gp][_i]), context);\n    }\n    if (output[_tGMIMB] != null) {\n        contents[_TGMIMB] = __strictParseInt32(output[_tGMIMB]);\n    }\n    return contents;\n};\nconst de_GroupIdentifier = (output, context) => {\n    const contents = {};\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    return contents;\n};\nconst de_GroupIdentifierList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_GroupIdentifier(entry, context);\n    });\n};\nconst de_GroupIdentifierSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SecurityGroupIdentifier(entry, context);\n    });\n};\nconst de_GroupIdStringList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_HibernationOptions = (output, context) => {\n    const contents = {};\n    if (output[_conf] != null) {\n        contents[_Conf] = __parseBoolean(output[_conf]);\n    }\n    return contents;\n};\nconst de_HistoryRecord = (output, context) => {\n    const contents = {};\n    if (output[_eIv] != null) {\n        contents[_EIv] = de_EventInformation(output[_eIv], context);\n    }\n    if (output[_eTv] != null) {\n        contents[_ETv] = __expectString(output[_eTv]);\n    }\n    if (output[_ti] != null) {\n        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));\n    }\n    return contents;\n};\nconst de_HistoryRecordEntry = (output, context) => {\n    const contents = {};\n    if (output[_eIv] != null) {\n        contents[_EIv] = de_EventInformation(output[_eIv], context);\n    }\n    if (output[_eTv] != null) {\n        contents[_ETv] = __expectString(output[_eTv]);\n    }\n    if (output[_ti] != null) {\n        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));\n    }\n    return contents;\n};\nconst de_HistoryRecords = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_HistoryRecord(entry, context);\n    });\n};\nconst de_HistoryRecordSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_HistoryRecordEntry(entry, context);\n    });\n};\nconst de_Host = (output, context) => {\n    const contents = {};\n    if (output[_aPu] != null) {\n        contents[_AP] = __expectString(output[_aPu]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_aC] != null) {\n        contents[_ACv] = de_AvailableCapacity(output[_aC], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    if (output[_hI] != null) {\n        contents[_HIo] = __expectString(output[_hI]);\n    }\n    if (output[_hP] != null) {\n        contents[_HP] = de_HostProperties(output[_hP], context);\n    }\n    if (output[_hRI] != null) {\n        contents[_HRI] = __expectString(output[_hRI]);\n    }\n    if (output.instances === \"\") {\n        contents[_In] = [];\n    }\n    else if (output[_ins] != null && output[_ins][_i] != null) {\n        contents[_In] = de_HostInstanceList(__getArrayIfSingleItem(output[_ins][_i]), context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_aTll] != null) {\n        contents[_ATll] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aTll]));\n    }\n    if (output[_rTel] != null) {\n        contents[_RTel] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rTel]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_hR] != null) {\n        contents[_HR] = __expectString(output[_hR]);\n    }\n    if (output[_aMIT] != null) {\n        contents[_AMIT] = __expectString(output[_aMIT]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    if (output[_mOSLRG] != null) {\n        contents[_MOSLRG] = __parseBoolean(output[_mOSLRG]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_hM] != null) {\n        contents[_HM] = __expectString(output[_hM]);\n    }\n    if (output[_aIss] != null) {\n        contents[_AIsse] = __expectString(output[_aIss]);\n    }\n    return contents;\n};\nconst de_HostInstance = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    return contents;\n};\nconst de_HostInstanceList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_HostInstance(entry, context);\n    });\n};\nconst de_HostList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Host(entry, context);\n    });\n};\nconst de_HostOffering = (output, context) => {\n    const contents = {};\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    if (output[_du] != null) {\n        contents[_Du] = __strictParseInt32(output[_du]);\n    }\n    if (output[_hPo] != null) {\n        contents[_HPo] = __expectString(output[_hPo]);\n    }\n    if (output[_iF] != null) {\n        contents[_IF] = __expectString(output[_iF]);\n    }\n    if (output[_oIf] != null) {\n        contents[_OI] = __expectString(output[_oIf]);\n    }\n    if (output[_pO] != null) {\n        contents[_PO] = __expectString(output[_pO]);\n    }\n    if (output[_uP] != null) {\n        contents[_UPp] = __expectString(output[_uP]);\n    }\n    return contents;\n};\nconst de_HostOfferingSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_HostOffering(entry, context);\n    });\n};\nconst de_HostProperties = (output, context) => {\n    const contents = {};\n    if (output[_cor] != null) {\n        contents[_Cor] = __strictParseInt32(output[_cor]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_iF] != null) {\n        contents[_IF] = __expectString(output[_iF]);\n    }\n    if (output[_so] != null) {\n        contents[_Soc] = __strictParseInt32(output[_so]);\n    }\n    if (output[_tVC] != null) {\n        contents[_TVC] = __strictParseInt32(output[_tVC]);\n    }\n    return contents;\n};\nconst de_HostReservation = (output, context) => {\n    const contents = {};\n    if (output[_cou] != null) {\n        contents[_Cou] = __strictParseInt32(output[_cou]);\n    }\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    if (output[_du] != null) {\n        contents[_Du] = __strictParseInt32(output[_du]);\n    }\n    if (output[_end] != null) {\n        contents[_End] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_end]));\n    }\n    if (output.hostIdSet === \"\") {\n        contents[_HIS] = [];\n    }\n    else if (output[_hIS] != null && output[_hIS][_i] != null) {\n        contents[_HIS] = de_ResponseHostIdSet(__getArrayIfSingleItem(output[_hIS][_i]), context);\n    }\n    if (output[_hRI] != null) {\n        contents[_HRI] = __expectString(output[_hRI]);\n    }\n    if (output[_hPo] != null) {\n        contents[_HPo] = __expectString(output[_hPo]);\n    }\n    if (output[_iF] != null) {\n        contents[_IF] = __expectString(output[_iF]);\n    }\n    if (output[_oIf] != null) {\n        contents[_OI] = __expectString(output[_oIf]);\n    }\n    if (output[_pO] != null) {\n        contents[_PO] = __expectString(output[_pO]);\n    }\n    if (output[_star] != null) {\n        contents[_Star] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_star]));\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_uP] != null) {\n        contents[_UPp] = __expectString(output[_uP]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_HostReservationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_HostReservation(entry, context);\n    });\n};\nconst de_IamInstanceProfile = (output, context) => {\n    const contents = {};\n    if (output[_ar] != null) {\n        contents[_Ar] = __expectString(output[_ar]);\n    }\n    if (output[_id] != null) {\n        contents[_Id] = __expectString(output[_id]);\n    }\n    return contents;\n};\nconst de_IamInstanceProfileAssociation = (output, context) => {\n    const contents = {};\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_iIP] != null) {\n        contents[_IIP] = de_IamInstanceProfile(output[_iIP], context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_ti] != null) {\n        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));\n    }\n    return contents;\n};\nconst de_IamInstanceProfileAssociationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IamInstanceProfileAssociation(entry, context);\n    });\n};\nconst de_IamInstanceProfileSpecification = (output, context) => {\n    const contents = {};\n    if (output[_ar] != null) {\n        contents[_Ar] = __expectString(output[_ar]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    return contents;\n};\nconst de_IcmpTypeCode = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __strictParseInt32(output[_co]);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __strictParseInt32(output[_ty]);\n    }\n    return contents;\n};\nconst de_IdFormat = (output, context) => {\n    const contents = {};\n    if (output[_dea] != null) {\n        contents[_Dea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dea]));\n    }\n    if (output[_reso] != null) {\n        contents[_Res] = __expectString(output[_reso]);\n    }\n    if (output[_uLI] != null) {\n        contents[_ULI] = __parseBoolean(output[_uLI]);\n    }\n    return contents;\n};\nconst de_IdFormatList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IdFormat(entry, context);\n    });\n};\nconst de_IKEVersionsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IKEVersionsListValue(entry, context);\n    });\n};\nconst de_IKEVersionsListValue = (output, context) => {\n    const contents = {};\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    return contents;\n};\nconst de_Image = (output, context) => {\n    const contents = {};\n    if (output[_pDl] != null) {\n        contents[_PDl] = __expectString(output[_pDl]);\n    }\n    if (output[_uO] != null) {\n        contents[_UO] = __expectString(output[_uO]);\n    }\n    if (output.blockDeviceMapping === \"\") {\n        contents[_BDM] = [];\n    }\n    else if (output[_bDM] != null && output[_bDM][_i] != null) {\n        contents[_BDM] = de_BlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_eSna] != null) {\n        contents[_ESn] = __parseBoolean(output[_eSna]);\n    }\n    if (output[_h] != null) {\n        contents[_H] = __expectString(output[_h]);\n    }\n    if (output[_iOA] != null) {\n        contents[_IOA] = __expectString(output[_iOA]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_rDN] != null) {\n        contents[_RDN] = __expectString(output[_rDN]);\n    }\n    if (output[_rDT] != null) {\n        contents[_RDT] = __expectString(output[_rDT]);\n    }\n    if (output[_sNSr] != null) {\n        contents[_SNS] = __expectString(output[_sNSr]);\n    }\n    if (output[_sRt] != null) {\n        contents[_SRt] = de_StateReason(output[_sRt], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vTi] != null) {\n        contents[_VTir] = __expectString(output[_vTi]);\n    }\n    if (output[_bM] != null) {\n        contents[_BM] = __expectString(output[_bM]);\n    }\n    if (output[_tSp] != null) {\n        contents[_TSp] = __expectString(output[_tSp]);\n    }\n    if (output[_dTe] != null) {\n        contents[_DTep] = __expectString(output[_dTe]);\n    }\n    if (output[_iSmd] != null) {\n        contents[_ISm] = __expectString(output[_iSmd]);\n    }\n    if (output[_sII] != null) {\n        contents[_SIIo] = __expectString(output[_sII]);\n    }\n    if (output[_dPe] != null) {\n        contents[_DPer] = __expectString(output[_dPe]);\n    }\n    if (output[_lLT] != null) {\n        contents[_LLT] = __expectString(output[_lLT]);\n    }\n    if (output[_iAm] != null) {\n        contents[_IAm] = __parseBoolean(output[_iAm]);\n    }\n    if (output[_sIIo] != null) {\n        contents[_SII] = __expectString(output[_sIIo]);\n    }\n    if (output[_sIR] != null) {\n        contents[_SIRo] = __expectString(output[_sIR]);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_iL] != null) {\n        contents[_IL] = __expectString(output[_iL]);\n    }\n    if (output[_iSma] != null) {\n        contents[_Stat] = __expectString(output[_iSma]);\n    }\n    if (output[_iOI] != null) {\n        contents[_OIwn] = __expectString(output[_iOI]);\n    }\n    if (output[_cDr] != null) {\n        contents[_CDre] = __expectString(output[_cDr]);\n    }\n    if (output[_iPs] != null) {\n        contents[_Pu] = __parseBoolean(output[_iPs]);\n    }\n    if (output.productCodes === \"\") {\n        contents[_PCr] = [];\n    }\n    else if (output[_pC] != null && output[_pC][_i] != null) {\n        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);\n    }\n    if (output[_arc] != null) {\n        contents[_Arc] = __expectString(output[_arc]);\n    }\n    if (output[_iTm] != null) {\n        contents[_ITm] = __expectString(output[_iTm]);\n    }\n    if (output[_kI] != null) {\n        contents[_KI] = __expectString(output[_kI]);\n    }\n    if (output[_rIa] != null) {\n        contents[_RIa] = __expectString(output[_rIa]);\n    }\n    if (output[_pl] != null) {\n        contents[_Pla] = __expectString(output[_pl]);\n    }\n    return contents;\n};\nconst de_ImageAttribute = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = de_AttributeValue(output[_de], context);\n    }\n    if (output[_ke] != null) {\n        contents[_KI] = de_AttributeValue(output[_ke], context);\n    }\n    if (output[_ra] != null) {\n        contents[_RIa] = de_AttributeValue(output[_ra], context);\n    }\n    if (output[_sNSr] != null) {\n        contents[_SNS] = de_AttributeValue(output[_sNSr], context);\n    }\n    if (output[_bM] != null) {\n        contents[_BM] = de_AttributeValue(output[_bM], context);\n    }\n    if (output[_tSp] != null) {\n        contents[_TSp] = de_AttributeValue(output[_tSp], context);\n    }\n    if (output[_uD] != null) {\n        contents[_UDe] = de_AttributeValue(output[_uD], context);\n    }\n    if (output[_lLT] != null) {\n        contents[_LLT] = de_AttributeValue(output[_lLT], context);\n    }\n    if (output[_iSmd] != null) {\n        contents[_ISm] = de_AttributeValue(output[_iSmd], context);\n    }\n    if (output[_dPe] != null) {\n        contents[_DPer] = de_AttributeValue(output[_dPe], context);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output.launchPermission === \"\") {\n        contents[_LPau] = [];\n    }\n    else if (output[_lPa] != null && output[_lPa][_i] != null) {\n        contents[_LPau] = de_LaunchPermissionList(__getArrayIfSingleItem(output[_lPa][_i]), context);\n    }\n    if (output.productCodes === \"\") {\n        contents[_PCr] = [];\n    }\n    else if (output[_pC] != null && output[_pC][_i] != null) {\n        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);\n    }\n    if (output.blockDeviceMapping === \"\") {\n        contents[_BDM] = [];\n    }\n    else if (output[_bDM] != null && output[_bDM][_i] != null) {\n        contents[_BDM] = de_BlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);\n    }\n    return contents;\n};\nconst de_ImageCriterion = (output, context) => {\n    const contents = {};\n    if (output.imageProviderSet === \"\") {\n        contents[_IPm] = [];\n    }\n    else if (output[_iPSm] != null && output[_iPSm][_i] != null) {\n        contents[_IPm] = de_ImageProviderList(__getArrayIfSingleItem(output[_iPSm][_i]), context);\n    }\n    return contents;\n};\nconst de_ImageCriterionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ImageCriterion(entry, context);\n    });\n};\nconst de_ImageList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Image(entry, context);\n    });\n};\nconst de_ImageMetadata = (output, context) => {\n    const contents = {};\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_iOI] != null) {\n        contents[_OIwn] = __expectString(output[_iOI]);\n    }\n    if (output[_iSma] != null) {\n        contents[_Stat] = __expectString(output[_iSma]);\n    }\n    if (output[_iOA] != null) {\n        contents[_IOA] = __expectString(output[_iOA]);\n    }\n    if (output[_cDr] != null) {\n        contents[_CDre] = __expectString(output[_cDr]);\n    }\n    if (output[_dTe] != null) {\n        contents[_DTep] = __expectString(output[_dTe]);\n    }\n    if (output[_iAm] != null) {\n        contents[_IAm] = __parseBoolean(output[_iAm]);\n    }\n    if (output[_iPs] != null) {\n        contents[_IPs] = __parseBoolean(output[_iPs]);\n    }\n    return contents;\n};\nconst de_ImageProviderList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_ImageRecycleBinInfo = (output, context) => {\n    const contents = {};\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_rBET] != null) {\n        contents[_RBET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rBET]));\n    }\n    if (output[_rBETe] != null) {\n        contents[_RBETe] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rBETe]));\n    }\n    return contents;\n};\nconst de_ImageRecycleBinInfoList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ImageRecycleBinInfo(entry, context);\n    });\n};\nconst de_ImportClientVpnClientCertificateRevocationListResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ImportImageLicenseConfigurationResponse = (output, context) => {\n    const contents = {};\n    if (output[_lCA] != null) {\n        contents[_LCA] = __expectString(output[_lCA]);\n    }\n    return contents;\n};\nconst de_ImportImageLicenseSpecificationListResponse = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ImportImageLicenseConfigurationResponse(entry, context);\n    });\n};\nconst de_ImportImageResult = (output, context) => {\n    const contents = {};\n    if (output[_arc] != null) {\n        contents[_Arc] = __expectString(output[_arc]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_enc] != null) {\n        contents[_Enc] = __parseBoolean(output[_enc]);\n    }\n    if (output[_h] != null) {\n        contents[_H] = __expectString(output[_h]);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_iTI] != null) {\n        contents[_ITI] = __expectString(output[_iTI]);\n    }\n    if (output[_kKI] != null) {\n        contents[_KKI] = __expectString(output[_kKI]);\n    }\n    if (output[_lTi] != null) {\n        contents[_LTi] = __expectString(output[_lTi]);\n    }\n    if (output[_pl] != null) {\n        contents[_Pla] = __expectString(output[_pl]);\n    }\n    if (output[_pro] != null) {\n        contents[_Prog] = __expectString(output[_pro]);\n    }\n    if (output.snapshotDetailSet === \"\") {\n        contents[_SDn] = [];\n    }\n    else if (output[_sDSn] != null && output[_sDSn][_i] != null) {\n        contents[_SDn] = de_SnapshotDetailList(__getArrayIfSingleItem(output[_sDSn][_i]), context);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output.licenseSpecifications === \"\") {\n        contents[_LSi] = [];\n    }\n    else if (output[_lS] != null && output[_lS][_i] != null) {\n        contents[_LSi] = de_ImportImageLicenseSpecificationListResponse(__getArrayIfSingleItem(output[_lS][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_uO] != null) {\n        contents[_UO] = __expectString(output[_uO]);\n    }\n    return contents;\n};\nconst de_ImportImageTask = (output, context) => {\n    const contents = {};\n    if (output[_arc] != null) {\n        contents[_Arc] = __expectString(output[_arc]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_enc] != null) {\n        contents[_Enc] = __parseBoolean(output[_enc]);\n    }\n    if (output[_h] != null) {\n        contents[_H] = __expectString(output[_h]);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_iTI] != null) {\n        contents[_ITI] = __expectString(output[_iTI]);\n    }\n    if (output[_kKI] != null) {\n        contents[_KKI] = __expectString(output[_kKI]);\n    }\n    if (output[_lTi] != null) {\n        contents[_LTi] = __expectString(output[_lTi]);\n    }\n    if (output[_pl] != null) {\n        contents[_Pla] = __expectString(output[_pl]);\n    }\n    if (output[_pro] != null) {\n        contents[_Prog] = __expectString(output[_pro]);\n    }\n    if (output.snapshotDetailSet === \"\") {\n        contents[_SDn] = [];\n    }\n    else if (output[_sDSn] != null && output[_sDSn][_i] != null) {\n        contents[_SDn] = de_SnapshotDetailList(__getArrayIfSingleItem(output[_sDSn][_i]), context);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output.licenseSpecifications === \"\") {\n        contents[_LSi] = [];\n    }\n    else if (output[_lS] != null && output[_lS][_i] != null) {\n        contents[_LSi] = de_ImportImageLicenseSpecificationListResponse(__getArrayIfSingleItem(output[_lS][_i]), context);\n    }\n    if (output[_uO] != null) {\n        contents[_UO] = __expectString(output[_uO]);\n    }\n    if (output[_bM] != null) {\n        contents[_BM] = __expectString(output[_bM]);\n    }\n    return contents;\n};\nconst de_ImportImageTaskList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ImportImageTask(entry, context);\n    });\n};\nconst de_ImportInstanceResult = (output, context) => {\n    const contents = {};\n    if (output[_cTon] != null) {\n        contents[_CTonv] = de_ConversionTask(output[_cTon], context);\n    }\n    return contents;\n};\nconst de_ImportInstanceTaskDetails = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_pl] != null) {\n        contents[_Pla] = __expectString(output[_pl]);\n    }\n    if (output.volumes === \"\") {\n        contents[_Vol] = [];\n    }\n    else if (output[_vo] != null && output[_vo][_i] != null) {\n        contents[_Vol] = de_ImportInstanceVolumeDetailSet(__getArrayIfSingleItem(output[_vo][_i]), context);\n    }\n    return contents;\n};\nconst de_ImportInstanceVolumeDetailItem = (output, context) => {\n    const contents = {};\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_bCy] != null) {\n        contents[_BCyt] = __strictParseLong(output[_bCy]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_im] != null) {\n        contents[_Im] = de_DiskImageDescription(output[_im], context);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_vol] != null) {\n        contents[_Vo] = de_DiskImageVolumeDescription(output[_vol], context);\n    }\n    return contents;\n};\nconst de_ImportInstanceVolumeDetailSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ImportInstanceVolumeDetailItem(entry, context);\n    });\n};\nconst de_ImportKeyPairResult = (output, context) => {\n    const contents = {};\n    if (output[_kFe] != null) {\n        contents[_KFe] = __expectString(output[_kFe]);\n    }\n    if (output[_kN] != null) {\n        contents[_KN] = __expectString(output[_kN]);\n    }\n    if (output[_kPI] != null) {\n        contents[_KPI] = __expectString(output[_kPI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_ImportSnapshotResult = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_iTI] != null) {\n        contents[_ITI] = __expectString(output[_iTI]);\n    }\n    if (output[_sTD] != null) {\n        contents[_STD] = de_SnapshotTaskDetail(output[_sTD], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_ImportSnapshotTask = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_iTI] != null) {\n        contents[_ITI] = __expectString(output[_iTI]);\n    }\n    if (output[_sTD] != null) {\n        contents[_STD] = de_SnapshotTaskDetail(output[_sTD], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_ImportSnapshotTaskList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ImportSnapshotTask(entry, context);\n    });\n};\nconst de_ImportVolumeResult = (output, context) => {\n    const contents = {};\n    if (output[_cTon] != null) {\n        contents[_CTonv] = de_ConversionTask(output[_cTon], context);\n    }\n    return contents;\n};\nconst de_ImportVolumeTaskDetails = (output, context) => {\n    const contents = {};\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_bCy] != null) {\n        contents[_BCyt] = __strictParseLong(output[_bCy]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_im] != null) {\n        contents[_Im] = de_DiskImageDescription(output[_im], context);\n    }\n    if (output[_vol] != null) {\n        contents[_Vo] = de_DiskImageVolumeDescription(output[_vol], context);\n    }\n    return contents;\n};\nconst de_InferenceAcceleratorInfo = (output, context) => {\n    const contents = {};\n    if (output.accelerators === \"\") {\n        contents[_Acc] = [];\n    }\n    else if (output[_acc] != null && output[_acc][_mem] != null) {\n        contents[_Acc] = de_InferenceDeviceInfoList(__getArrayIfSingleItem(output[_acc][_mem]), context);\n    }\n    if (output[_tIMIMB] != null) {\n        contents[_TIMIMB] = __strictParseInt32(output[_tIMIMB]);\n    }\n    return contents;\n};\nconst de_InferenceDeviceInfo = (output, context) => {\n    const contents = {};\n    if (output[_cou] != null) {\n        contents[_Cou] = __strictParseInt32(output[_cou]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_man] != null) {\n        contents[_Man] = __expectString(output[_man]);\n    }\n    if (output[_mIe] != null) {\n        contents[_MIe] = de_InferenceDeviceMemoryInfo(output[_mIe], context);\n    }\n    return contents;\n};\nconst de_InferenceDeviceInfoList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InferenceDeviceInfo(entry, context);\n    });\n};\nconst de_InferenceDeviceMemoryInfo = (output, context) => {\n    const contents = {};\n    if (output[_sIMB] != null) {\n        contents[_SIMB] = __strictParseInt32(output[_sIMB]);\n    }\n    return contents;\n};\nconst de_InsideCidrBlocksStringList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_Instance = (output, context) => {\n    const contents = {};\n    if (output[_arc] != null) {\n        contents[_Arc] = __expectString(output[_arc]);\n    }\n    if (output.blockDeviceMapping === \"\") {\n        contents[_BDM] = [];\n    }\n    else if (output[_bDM] != null && output[_bDM][_i] != null) {\n        contents[_BDM] = de_InstanceBlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    if (output[_eO] != null) {\n        contents[_EO] = __parseBoolean(output[_eO]);\n    }\n    if (output[_eSna] != null) {\n        contents[_ESn] = __parseBoolean(output[_eSna]);\n    }\n    if (output[_h] != null) {\n        contents[_H] = __expectString(output[_h]);\n    }\n    if (output[_iIP] != null) {\n        contents[_IIP] = de_IamInstanceProfile(output[_iIP], context);\n    }\n    if (output[_iLn] != null) {\n        contents[_ILn] = __expectString(output[_iLn]);\n    }\n    if (output.elasticGpuAssociationSet === \"\") {\n        contents[_EGA] = [];\n    }\n    else if (output[_eGASl] != null && output[_eGASl][_i] != null) {\n        contents[_EGA] = de_ElasticGpuAssociationList(__getArrayIfSingleItem(output[_eGASl][_i]), context);\n    }\n    if (output.elasticInferenceAcceleratorAssociationSet === \"\") {\n        contents[_EIAAl] = [];\n    }\n    else if (output[_eIAASl] != null && output[_eIAASl][_i] != null) {\n        contents[_EIAAl] = de_ElasticInferenceAcceleratorAssociationList(__getArrayIfSingleItem(output[_eIAASl][_i]), context);\n    }\n    if (output.networkInterfaceSet === \"\") {\n        contents[_NI] = [];\n    }\n    else if (output[_nIS] != null && output[_nIS][_i] != null) {\n        contents[_NI] = de_InstanceNetworkInterfaceList(__getArrayIfSingleItem(output[_nIS][_i]), context);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_rDN] != null) {\n        contents[_RDN] = __expectString(output[_rDN]);\n    }\n    if (output[_rDT] != null) {\n        contents[_RDT] = __expectString(output[_rDT]);\n    }\n    if (output.groupSet === \"\") {\n        contents[_SG] = [];\n    }\n    else if (output[_gS] != null && output[_gS][_i] != null) {\n        contents[_SG] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);\n    }\n    if (output[_sDC] != null) {\n        contents[_SDC] = __parseBoolean(output[_sDC]);\n    }\n    if (output[_sIRI] != null) {\n        contents[_SIRIp] = __expectString(output[_sIRI]);\n    }\n    if (output[_sNSr] != null) {\n        contents[_SNS] = __expectString(output[_sNSr]);\n    }\n    if (output[_sRt] != null) {\n        contents[_SRt] = de_StateReason(output[_sRt], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vTi] != null) {\n        contents[_VTir] = __expectString(output[_vTi]);\n    }\n    if (output[_cO] != null) {\n        contents[_COp] = de_CpuOptions(output[_cO], context);\n    }\n    if (output[_cRI] != null) {\n        contents[_CRI] = __expectString(output[_cRI]);\n    }\n    if (output[_cRSa] != null) {\n        contents[_CRSa] = de_CapacityReservationSpecificationResponse(output[_cRSa], context);\n    }\n    if (output[_hO] != null) {\n        contents[_HO] = de_HibernationOptions(output[_hO], context);\n    }\n    if (output.licenseSet === \"\") {\n        contents[_Lic] = [];\n    }\n    else if (output[_lSi] != null && output[_lSi][_i] != null) {\n        contents[_Lic] = de_LicenseList(__getArrayIfSingleItem(output[_lSi][_i]), context);\n    }\n    if (output[_mO] != null) {\n        contents[_MO] = de_InstanceMetadataOptionsResponse(output[_mO], context);\n    }\n    if (output[_eOn] != null) {\n        contents[_EOn] = de_EnclaveOptions(output[_eOn], context);\n    }\n    if (output[_bM] != null) {\n        contents[_BM] = __expectString(output[_bM]);\n    }\n    if (output[_pDl] != null) {\n        contents[_PDl] = __expectString(output[_pDl]);\n    }\n    if (output[_uO] != null) {\n        contents[_UO] = __expectString(output[_uO]);\n    }\n    if (output[_uOUT] != null) {\n        contents[_UOUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uOUT]));\n    }\n    if (output[_pDNO] != null) {\n        contents[_PDNO] = de_PrivateDnsNameOptionsResponse(output[_pDNO], context);\n    }\n    if (output[_iApv] != null) {\n        contents[_IApv] = __expectString(output[_iApv]);\n    }\n    if (output[_tSp] != null) {\n        contents[_TSp] = __expectString(output[_tSp]);\n    }\n    if (output[_mOa] != null) {\n        contents[_MOa] = de_InstanceMaintenanceOptions(output[_mOa], context);\n    }\n    if (output[_cIBM] != null) {\n        contents[_CIBM] = __expectString(output[_cIBM]);\n    }\n    if (output[_nPO] != null) {\n        contents[_NPO] = de_InstanceNetworkPerformanceOptions(output[_nPO], context);\n    }\n    if (output[_op] != null) {\n        contents[_O] = de_OperatorResponse(output[_op], context);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_iSnst] != null) {\n        contents[_Stat] = de_InstanceState(output[_iSnst], context);\n    }\n    if (output[_pDN] != null) {\n        contents[_PDN] = __expectString(output[_pDN]);\n    }\n    if (output[_dNn] != null) {\n        contents[_PDNu] = __expectString(output[_dNn]);\n    }\n    if (output[_rea] != null) {\n        contents[_STRt] = __expectString(output[_rea]);\n    }\n    if (output[_kN] != null) {\n        contents[_KN] = __expectString(output[_kN]);\n    }\n    if (output[_aLI] != null) {\n        contents[_ALI] = __strictParseInt32(output[_aLI]);\n    }\n    if (output.productCodes === \"\") {\n        contents[_PCr] = [];\n    }\n    else if (output[_pC] != null && output[_pC][_i] != null) {\n        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_lTau] != null) {\n        contents[_LTaun] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lTau]));\n    }\n    if (output[_pla] != null) {\n        contents[_Pl] = de_Placement(output[_pla], context);\n    }\n    if (output[_kI] != null) {\n        contents[_KI] = __expectString(output[_kI]);\n    }\n    if (output[_rIa] != null) {\n        contents[_RIa] = __expectString(output[_rIa]);\n    }\n    if (output[_pl] != null) {\n        contents[_Pla] = __expectString(output[_pl]);\n    }\n    if (output[_mo] != null) {\n        contents[_Mon] = de_Monitoring(output[_mo], context);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_pIAr] != null) {\n        contents[_PIAr] = __expectString(output[_pIAr]);\n    }\n    if (output[_iAp] != null) {\n        contents[_PIAu] = __expectString(output[_iAp]);\n    }\n    return contents;\n};\nconst de_InstanceAttachmentEnaSrdSpecification = (output, context) => {\n    const contents = {};\n    if (output[_eSE] != null) {\n        contents[_ESE] = __parseBoolean(output[_eSE]);\n    }\n    if (output[_eSUS] != null) {\n        contents[_ESUS] = de_InstanceAttachmentEnaSrdUdpSpecification(output[_eSUS], context);\n    }\n    return contents;\n};\nconst de_InstanceAttachmentEnaSrdUdpSpecification = (output, context) => {\n    const contents = {};\n    if (output[_eSUE] != null) {\n        contents[_ESUE] = __parseBoolean(output[_eSUE]);\n    }\n    return contents;\n};\nconst de_InstanceAttribute = (output, context) => {\n    const contents = {};\n    if (output.blockDeviceMapping === \"\") {\n        contents[_BDM] = [];\n    }\n    else if (output[_bDM] != null && output[_bDM][_i] != null) {\n        contents[_BDM] = de_InstanceBlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);\n    }\n    if (output[_dAT] != null) {\n        contents[_DATis] = de_AttributeBooleanValue(output[_dAT], context);\n    }\n    if (output[_eSna] != null) {\n        contents[_ESn] = de_AttributeBooleanValue(output[_eSna], context);\n    }\n    if (output[_eOn] != null) {\n        contents[_EOn] = de_EnclaveOptions(output[_eOn], context);\n    }\n    if (output[_eO] != null) {\n        contents[_EO] = de_AttributeBooleanValue(output[_eO], context);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_iISB] != null) {\n        contents[_IISB] = de_AttributeValue(output[_iISB], context);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = de_AttributeValue(output[_iT], context);\n    }\n    if (output[_ke] != null) {\n        contents[_KI] = de_AttributeValue(output[_ke], context);\n    }\n    if (output.productCodes === \"\") {\n        contents[_PCr] = [];\n    }\n    else if (output[_pC] != null && output[_pC][_i] != null) {\n        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);\n    }\n    if (output[_ra] != null) {\n        contents[_RIa] = de_AttributeValue(output[_ra], context);\n    }\n    if (output[_rDN] != null) {\n        contents[_RDN] = de_AttributeValue(output[_rDN], context);\n    }\n    if (output[_sDC] != null) {\n        contents[_SDC] = de_AttributeBooleanValue(output[_sDC], context);\n    }\n    if (output[_sNSr] != null) {\n        contents[_SNS] = de_AttributeValue(output[_sNSr], context);\n    }\n    if (output[_uDs] != null) {\n        contents[_UD] = de_AttributeValue(output[_uDs], context);\n    }\n    if (output[_dASi] != null) {\n        contents[_DASi] = de_AttributeBooleanValue(output[_dASi], context);\n    }\n    if (output.groupSet === \"\") {\n        contents[_G] = [];\n    }\n    else if (output[_gS] != null && output[_gS][_i] != null) {\n        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);\n    }\n    return contents;\n};\nconst de_InstanceBlockDeviceMapping = (output, context) => {\n    const contents = {};\n    if (output[_dN] != null) {\n        contents[_DN] = __expectString(output[_dN]);\n    }\n    if (output[_eb] != null) {\n        contents[_E] = de_EbsInstanceBlockDevice(output[_eb], context);\n    }\n    return contents;\n};\nconst de_InstanceBlockDeviceMappingList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceBlockDeviceMapping(entry, context);\n    });\n};\nconst de_InstanceCapacity = (output, context) => {\n    const contents = {};\n    if (output[_aC] != null) {\n        contents[_ACv] = __strictParseInt32(output[_aC]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_tC] != null) {\n        contents[_TCo] = __strictParseInt32(output[_tC]);\n    }\n    return contents;\n};\nconst de_InstanceConnectEndpointSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ec2InstanceConnectEndpoint(entry, context);\n    });\n};\nconst de_InstanceCount = (output, context) => {\n    const contents = {};\n    if (output[_iC] != null) {\n        contents[_IC] = __strictParseInt32(output[_iC]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_InstanceCountList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceCount(entry, context);\n    });\n};\nconst de_InstanceCreditSpecification = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_cCp] != null) {\n        contents[_CCp] = __expectString(output[_cCp]);\n    }\n    return contents;\n};\nconst de_InstanceCreditSpecificationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceCreditSpecification(entry, context);\n    });\n};\nconst de_InstanceEventWindow = (output, context) => {\n    const contents = {};\n    if (output[_iEWI] != null) {\n        contents[_IEWI] = __expectString(output[_iEWI]);\n    }\n    if (output.timeRangeSet === \"\") {\n        contents[_TRi] = [];\n    }\n    else if (output[_tRSi] != null && output[_tRSi][_i] != null) {\n        contents[_TRi] = de_InstanceEventWindowTimeRangeList(__getArrayIfSingleItem(output[_tRSi][_i]), context);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_cEr] != null) {\n        contents[_CE] = __expectString(output[_cEr]);\n    }\n    if (output[_aTs] != null) {\n        contents[_AT] = de_InstanceEventWindowAssociationTarget(output[_aTs], context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_InstanceEventWindowAssociationTarget = (output, context) => {\n    const contents = {};\n    if (output.instanceIdSet === \"\") {\n        contents[_IIns] = [];\n    }\n    else if (output[_iIS] != null && output[_iIS][_i] != null) {\n        contents[_IIns] = de_InstanceIdList(__getArrayIfSingleItem(output[_iIS][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output.dedicatedHostIdSet === \"\") {\n        contents[_DHI] = [];\n    }\n    else if (output[_dHIS] != null && output[_dHIS][_i] != null) {\n        contents[_DHI] = de_DedicatedHostIdList(__getArrayIfSingleItem(output[_dHIS][_i]), context);\n    }\n    return contents;\n};\nconst de_InstanceEventWindowSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceEventWindow(entry, context);\n    });\n};\nconst de_InstanceEventWindowStateChange = (output, context) => {\n    const contents = {};\n    if (output[_iEWI] != null) {\n        contents[_IEWI] = __expectString(output[_iEWI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_InstanceEventWindowTimeRange = (output, context) => {\n    const contents = {};\n    if (output[_sWD] != null) {\n        contents[_SWD] = __expectString(output[_sWD]);\n    }\n    if (output[_sH] != null) {\n        contents[_SH] = __strictParseInt32(output[_sH]);\n    }\n    if (output[_eWD] != null) {\n        contents[_EWD] = __expectString(output[_eWD]);\n    }\n    if (output[_eH] != null) {\n        contents[_EH] = __strictParseInt32(output[_eH]);\n    }\n    return contents;\n};\nconst de_InstanceEventWindowTimeRangeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceEventWindowTimeRange(entry, context);\n    });\n};\nconst de_InstanceExportDetails = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_tE] != null) {\n        contents[_TE] = __expectString(output[_tE]);\n    }\n    return contents;\n};\nconst de_InstanceFamilyCreditSpecification = (output, context) => {\n    const contents = {};\n    if (output[_iF] != null) {\n        contents[_IF] = __expectString(output[_iF]);\n    }\n    if (output[_cCp] != null) {\n        contents[_CCp] = __expectString(output[_cCp]);\n    }\n    return contents;\n};\nconst de_InstanceGenerationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_InstanceIdList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_InstanceIdSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_InstanceIdsSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_InstanceImageMetadata = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_lTau] != null) {\n        contents[_LTaun] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lTau]));\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_zI] != null) {\n        contents[_ZIo] = __expectString(output[_zI]);\n    }\n    if (output[_iSnst] != null) {\n        contents[_Stat] = de_InstanceState(output[_iSnst], context);\n    }\n    if (output[_iOIn] != null) {\n        contents[_OIwn] = __expectString(output[_iOIn]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_iM] != null) {\n        contents[_IMm] = de_ImageMetadata(output[_iM], context);\n    }\n    if (output[_op] != null) {\n        contents[_O] = de_OperatorResponse(output[_op], context);\n    }\n    return contents;\n};\nconst de_InstanceImageMetadataList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceImageMetadata(entry, context);\n    });\n};\nconst de_InstanceIpv4Prefix = (output, context) => {\n    const contents = {};\n    if (output[_iPpv] != null) {\n        contents[_IPpvr] = __expectString(output[_iPpv]);\n    }\n    return contents;\n};\nconst de_InstanceIpv4PrefixList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceIpv4Prefix(entry, context);\n    });\n};\nconst de_InstanceIpv6Address = (output, context) => {\n    const contents = {};\n    if (output[_iApv] != null) {\n        contents[_IApv] = __expectString(output[_iApv]);\n    }\n    if (output[_iPI] != null) {\n        contents[_IPIs] = __parseBoolean(output[_iPI]);\n    }\n    return contents;\n};\nconst de_InstanceIpv6AddressList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceIpv6Address(entry, context);\n    });\n};\nconst de_InstanceIpv6Prefix = (output, context) => {\n    const contents = {};\n    if (output[_iPpvr] != null) {\n        contents[_IPpvre] = __expectString(output[_iPpvr]);\n    }\n    return contents;\n};\nconst de_InstanceIpv6PrefixList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceIpv6Prefix(entry, context);\n    });\n};\nconst de_InstanceList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Instance(entry, context);\n    });\n};\nconst de_InstanceMaintenanceOptions = (output, context) => {\n    const contents = {};\n    if (output[_aRu] != null) {\n        contents[_ARu] = __expectString(output[_aRu]);\n    }\n    if (output[_rM] != null) {\n        contents[_RMe] = __expectString(output[_rM]);\n    }\n    return contents;\n};\nconst de_InstanceMetadataDefaultsResponse = (output, context) => {\n    const contents = {};\n    if (output[_hT] != null) {\n        contents[_HT] = __expectString(output[_hT]);\n    }\n    if (output[_hPRHL] != null) {\n        contents[_HPRHL] = __strictParseInt32(output[_hPRHL]);\n    }\n    if (output[_hE] != null) {\n        contents[_HE] = __expectString(output[_hE]);\n    }\n    if (output[_iMT] != null) {\n        contents[_IMT] = __expectString(output[_iMT]);\n    }\n    if (output[_mB] != null) {\n        contents[_MB] = __expectString(output[_mB]);\n    }\n    if (output[_mEM] != null) {\n        contents[_MEM] = __expectString(output[_mEM]);\n    }\n    return contents;\n};\nconst de_InstanceMetadataOptionsResponse = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_hT] != null) {\n        contents[_HT] = __expectString(output[_hT]);\n    }\n    if (output[_hPRHL] != null) {\n        contents[_HPRHL] = __strictParseInt32(output[_hPRHL]);\n    }\n    if (output[_hE] != null) {\n        contents[_HE] = __expectString(output[_hE]);\n    }\n    if (output[_hPI] != null) {\n        contents[_HPI] = __expectString(output[_hPI]);\n    }\n    if (output[_iMT] != null) {\n        contents[_IMT] = __expectString(output[_iMT]);\n    }\n    return contents;\n};\nconst de_InstanceMonitoring = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_mo] != null) {\n        contents[_Mon] = de_Monitoring(output[_mo], context);\n    }\n    return contents;\n};\nconst de_InstanceMonitoringList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceMonitoring(entry, context);\n    });\n};\nconst de_InstanceNetworkInterface = (output, context) => {\n    const contents = {};\n    if (output[_ass] != null) {\n        contents[_Asso] = de_InstanceNetworkInterfaceAssociation(output[_ass], context);\n    }\n    if (output[_at] != null) {\n        contents[_Att] = de_InstanceNetworkInterfaceAttachment(output[_at], context);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.groupSet === \"\") {\n        contents[_G] = [];\n    }\n    else if (output[_gS] != null && output[_gS][_i] != null) {\n        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);\n    }\n    if (output.ipv6AddressesSet === \"\") {\n        contents[_IA] = [];\n    }\n    else if (output[_iASp] != null && output[_iASp][_i] != null) {\n        contents[_IA] = de_InstanceIpv6AddressList(__getArrayIfSingleItem(output[_iASp][_i]), context);\n    }\n    if (output[_mAa] != null) {\n        contents[_MAa] = __expectString(output[_mAa]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_pDN] != null) {\n        contents[_PDN] = __expectString(output[_pDN]);\n    }\n    if (output[_pIAr] != null) {\n        contents[_PIAr] = __expectString(output[_pIAr]);\n    }\n    if (output.privateIpAddressesSet === \"\") {\n        contents[_PIA] = [];\n    }\n    else if (output[_pIAS] != null && output[_pIAS][_i] != null) {\n        contents[_PIA] = de_InstancePrivateIpAddressList(__getArrayIfSingleItem(output[_pIAS][_i]), context);\n    }\n    if (output[_sDC] != null) {\n        contents[_SDC] = __parseBoolean(output[_sDC]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_iTnt] != null) {\n        contents[_ITn] = __expectString(output[_iTnt]);\n    }\n    if (output.ipv4PrefixSet === \"\") {\n        contents[_IPp] = [];\n    }\n    else if (output[_iPSpv] != null && output[_iPSpv][_i] != null) {\n        contents[_IPp] = de_InstanceIpv4PrefixList(__getArrayIfSingleItem(output[_iPSpv][_i]), context);\n    }\n    if (output.ipv6PrefixSet === \"\") {\n        contents[_IP] = [];\n    }\n    else if (output[_iPSpvr] != null && output[_iPSpvr][_i] != null) {\n        contents[_IP] = de_InstanceIpv6PrefixList(__getArrayIfSingleItem(output[_iPSpvr][_i]), context);\n    }\n    if (output[_cTC] != null) {\n        contents[_CTC] = de_ConnectionTrackingSpecificationResponse(output[_cTC], context);\n    }\n    if (output[_op] != null) {\n        contents[_O] = de_OperatorResponse(output[_op], context);\n    }\n    return contents;\n};\nconst de_InstanceNetworkInterfaceAssociation = (output, context) => {\n    const contents = {};\n    if (output[_cI] != null) {\n        contents[_CIa] = __expectString(output[_cI]);\n    }\n    if (output[_cOI] != null) {\n        contents[_COI] = __expectString(output[_cOI]);\n    }\n    if (output[_iOIp] != null) {\n        contents[_IOI] = __expectString(output[_iOIp]);\n    }\n    if (output[_pDNu] != null) {\n        contents[_PDNu] = __expectString(output[_pDNu]);\n    }\n    if (output[_pI] != null) {\n        contents[_PI] = __expectString(output[_pI]);\n    }\n    return contents;\n};\nconst de_InstanceNetworkInterfaceAttachment = (output, context) => {\n    const contents = {};\n    if (output[_aTt] != null) {\n        contents[_ATtt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aTt]));\n    }\n    if (output[_aIt] != null) {\n        contents[_AIt] = __expectString(output[_aIt]);\n    }\n    if (output[_dOT] != null) {\n        contents[_DOT] = __parseBoolean(output[_dOT]);\n    }\n    if (output[_dIe] != null) {\n        contents[_DIev] = __strictParseInt32(output[_dIe]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_nCI] != null) {\n        contents[_NCI] = __strictParseInt32(output[_nCI]);\n    }\n    if (output[_eSS] != null) {\n        contents[_ESS] = de_InstanceAttachmentEnaSrdSpecification(output[_eSS], context);\n    }\n    if (output[_eQC] != null) {\n        contents[_EQC] = __strictParseInt32(output[_eQC]);\n    }\n    return contents;\n};\nconst de_InstanceNetworkInterfaceList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceNetworkInterface(entry, context);\n    });\n};\nconst de_InstanceNetworkInterfaceSpecification = (output, context) => {\n    const contents = {};\n    if (output[_aPIA] != null) {\n        contents[_APIAs] = __parseBoolean(output[_aPIA]);\n    }\n    if (output[_dOT] != null) {\n        contents[_DOT] = __parseBoolean(output[_dOT]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_dIe] != null) {\n        contents[_DIev] = __strictParseInt32(output[_dIe]);\n    }\n    if (output.SecurityGroupId === \"\") {\n        contents[_G] = [];\n    }\n    else if (output[_SGIe] != null && output[_SGIe][_SGIe] != null) {\n        contents[_G] = de_SecurityGroupIdStringList(__getArrayIfSingleItem(output[_SGIe][_SGIe]), context);\n    }\n    if (output[_iAC] != null) {\n        contents[_IAC] = __strictParseInt32(output[_iAC]);\n    }\n    if (output.ipv6AddressesSet === \"\") {\n        contents[_IA] = [];\n    }\n    else if (output[_iASp] != null && output[_iASp][_i] != null) {\n        contents[_IA] = de_InstanceIpv6AddressList(__getArrayIfSingleItem(output[_iASp][_i]), context);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_pIAr] != null) {\n        contents[_PIAr] = __expectString(output[_pIAr]);\n    }\n    if (output.privateIpAddressesSet === \"\") {\n        contents[_PIA] = [];\n    }\n    else if (output[_pIAS] != null && output[_pIAS][_i] != null) {\n        contents[_PIA] = de_PrivateIpAddressSpecificationList(__getArrayIfSingleItem(output[_pIAS][_i]), context);\n    }\n    if (output[_sPIAC] != null) {\n        contents[_SPIAC] = __strictParseInt32(output[_sPIAC]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_ACIA] != null) {\n        contents[_ACIA] = __parseBoolean(output[_ACIA]);\n    }\n    if (output[_ITn] != null) {\n        contents[_ITn] = __expectString(output[_ITn]);\n    }\n    if (output[_NCI] != null) {\n        contents[_NCI] = __strictParseInt32(output[_NCI]);\n    }\n    if (output.Ipv4Prefix === \"\") {\n        contents[_IPp] = [];\n    }\n    else if (output[_IPpvr] != null && output[_IPpvr][_i] != null) {\n        contents[_IPp] = de_Ipv4PrefixList(__getArrayIfSingleItem(output[_IPpvr][_i]), context);\n    }\n    if (output[_IPCp] != null) {\n        contents[_IPCp] = __strictParseInt32(output[_IPCp]);\n    }\n    if (output.Ipv6Prefix === \"\") {\n        contents[_IP] = [];\n    }\n    else if (output[_IPpvre] != null && output[_IPpvre][_i] != null) {\n        contents[_IP] = de_Ipv6PrefixList(__getArrayIfSingleItem(output[_IPpvre][_i]), context);\n    }\n    if (output[_IPC] != null) {\n        contents[_IPC] = __strictParseInt32(output[_IPC]);\n    }\n    if (output[_PIr] != null) {\n        contents[_PIr] = __parseBoolean(output[_PIr]);\n    }\n    if (output[_ESS] != null) {\n        contents[_ESS] = de_EnaSrdSpecificationRequest(output[_ESS], context);\n    }\n    if (output[_CTS] != null) {\n        contents[_CTS] = de_ConnectionTrackingSpecificationRequest(output[_CTS], context);\n    }\n    if (output[_EQC] != null) {\n        contents[_EQC] = __strictParseInt32(output[_EQC]);\n    }\n    return contents;\n};\nconst de_InstanceNetworkInterfaceSpecificationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceNetworkInterfaceSpecification(entry, context);\n    });\n};\nconst de_InstanceNetworkPerformanceOptions = (output, context) => {\n    const contents = {};\n    if (output[_bW] != null) {\n        contents[_BW] = __expectString(output[_bW]);\n    }\n    return contents;\n};\nconst de_InstancePrivateIpAddress = (output, context) => {\n    const contents = {};\n    if (output[_ass] != null) {\n        contents[_Asso] = de_InstanceNetworkInterfaceAssociation(output[_ass], context);\n    }\n    if (output[_prim] != null) {\n        contents[_Prim] = __parseBoolean(output[_prim]);\n    }\n    if (output[_pDN] != null) {\n        contents[_PDN] = __expectString(output[_pDN]);\n    }\n    if (output[_pIAr] != null) {\n        contents[_PIAr] = __expectString(output[_pIAr]);\n    }\n    return contents;\n};\nconst de_InstancePrivateIpAddressList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstancePrivateIpAddress(entry, context);\n    });\n};\nconst de_InstanceRequirements = (output, context) => {\n    const contents = {};\n    if (output[_vCC] != null) {\n        contents[_VCC] = de_VCpuCountRange(output[_vCC], context);\n    }\n    if (output[_mMB] != null) {\n        contents[_MMB] = de_MemoryMiB(output[_mMB], context);\n    }\n    if (output.cpuManufacturerSet === \"\") {\n        contents[_CM] = [];\n    }\n    else if (output[_cMS] != null && output[_cMS][_i] != null) {\n        contents[_CM] = de_CpuManufacturerSet(__getArrayIfSingleItem(output[_cMS][_i]), context);\n    }\n    if (output[_mGBPVC] != null) {\n        contents[_MGBPVC] = de_MemoryGiBPerVCpu(output[_mGBPVC], context);\n    }\n    if (output.excludedInstanceTypeSet === \"\") {\n        contents[_EIT] = [];\n    }\n    else if (output[_eITSx] != null && output[_eITSx][_i] != null) {\n        contents[_EIT] = de_ExcludedInstanceTypeSet(__getArrayIfSingleItem(output[_eITSx][_i]), context);\n    }\n    if (output.instanceGenerationSet === \"\") {\n        contents[_IG] = [];\n    }\n    else if (output[_iGSn] != null && output[_iGSn][_i] != null) {\n        contents[_IG] = de_InstanceGenerationSet(__getArrayIfSingleItem(output[_iGSn][_i]), context);\n    }\n    if (output[_sMPPOLP] != null) {\n        contents[_SMPPOLP] = __strictParseInt32(output[_sMPPOLP]);\n    }\n    if (output[_oDMPPOLP] != null) {\n        contents[_ODMPPOLP] = __strictParseInt32(output[_oDMPPOLP]);\n    }\n    if (output[_bMa] != null) {\n        contents[_BMa] = __expectString(output[_bMa]);\n    }\n    if (output[_bP] != null) {\n        contents[_BP] = __expectString(output[_bP]);\n    }\n    if (output[_rHS] != null) {\n        contents[_RHS] = __parseBoolean(output[_rHS]);\n    }\n    if (output[_nIC] != null) {\n        contents[_NIC] = de_NetworkInterfaceCount(output[_nIC], context);\n    }\n    if (output[_lSo] != null) {\n        contents[_LSo] = __expectString(output[_lSo]);\n    }\n    if (output.localStorageTypeSet === \"\") {\n        contents[_LST] = [];\n    }\n    else if (output[_lSTS] != null && output[_lSTS][_i] != null) {\n        contents[_LST] = de_LocalStorageTypeSet(__getArrayIfSingleItem(output[_lSTS][_i]), context);\n    }\n    if (output[_tLSGB] != null) {\n        contents[_TLSGB] = de_TotalLocalStorageGB(output[_tLSGB], context);\n    }\n    if (output[_bEBM] != null) {\n        contents[_BEBM] = de_BaselineEbsBandwidthMbps(output[_bEBM], context);\n    }\n    if (output.acceleratorTypeSet === \"\") {\n        contents[_ATc] = [];\n    }\n    else if (output[_aTSc] != null && output[_aTSc][_i] != null) {\n        contents[_ATc] = de_AcceleratorTypeSet(__getArrayIfSingleItem(output[_aTSc][_i]), context);\n    }\n    if (output[_aCc] != null) {\n        contents[_ACc] = de_AcceleratorCount(output[_aCc], context);\n    }\n    if (output.acceleratorManufacturerSet === \"\") {\n        contents[_AM] = [];\n    }\n    else if (output[_aMS] != null && output[_aMS][_i] != null) {\n        contents[_AM] = de_AcceleratorManufacturerSet(__getArrayIfSingleItem(output[_aMS][_i]), context);\n    }\n    if (output.acceleratorNameSet === \"\") {\n        contents[_ANc] = [];\n    }\n    else if (output[_aNS] != null && output[_aNS][_i] != null) {\n        contents[_ANc] = de_AcceleratorNameSet(__getArrayIfSingleItem(output[_aNS][_i]), context);\n    }\n    if (output[_aTMMB] != null) {\n        contents[_ATMMB] = de_AcceleratorTotalMemoryMiB(output[_aTMMB], context);\n    }\n    if (output[_nBGe] != null) {\n        contents[_NBGe] = de_NetworkBandwidthGbps(output[_nBGe], context);\n    }\n    if (output.allowedInstanceTypeSet === \"\") {\n        contents[_AIT] = [];\n    }\n    else if (output[_aITS] != null && output[_aITS][_i] != null) {\n        contents[_AIT] = de_AllowedInstanceTypeSet(__getArrayIfSingleItem(output[_aITS][_i]), context);\n    }\n    if (output[_mSPAPOOODP] != null) {\n        contents[_MSPAPOOODP] = __strictParseInt32(output[_mSPAPOOODP]);\n    }\n    if (output[_bPF] != null) {\n        contents[_BPF] = de_BaselinePerformanceFactors(output[_bPF], context);\n    }\n    return contents;\n};\nconst de_InstanceSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceTopology(entry, context);\n    });\n};\nconst de_InstanceState = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __strictParseInt32(output[_co]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    return contents;\n};\nconst de_InstanceStateChange = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_cSu] != null) {\n        contents[_CSu] = de_InstanceState(output[_cSu], context);\n    }\n    if (output[_pSr] != null) {\n        contents[_PSre] = de_InstanceState(output[_pSr], context);\n    }\n    return contents;\n};\nconst de_InstanceStateChangeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceStateChange(entry, context);\n    });\n};\nconst de_InstanceStatus = (output, context) => {\n    const contents = {};\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_op] != null) {\n        contents[_O] = de_OperatorResponse(output[_op], context);\n    }\n    if (output.eventsSet === \"\") {\n        contents[_Ev] = [];\n    }\n    else if (output[_eSv] != null && output[_eSv][_i] != null) {\n        contents[_Ev] = de_InstanceStatusEventList(__getArrayIfSingleItem(output[_eSv][_i]), context);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_iSnst] != null) {\n        contents[_ISnst] = de_InstanceState(output[_iSnst], context);\n    }\n    if (output[_iSnsta] != null) {\n        contents[_ISnsta] = de_InstanceStatusSummary(output[_iSnsta], context);\n    }\n    if (output[_sSy] != null) {\n        contents[_SSy] = de_InstanceStatusSummary(output[_sSy], context);\n    }\n    if (output[_aES] != null) {\n        contents[_AES] = de_EbsStatusSummary(output[_aES], context);\n    }\n    return contents;\n};\nconst de_InstanceStatusDetails = (output, context) => {\n    const contents = {};\n    if (output[_iSmp] != null) {\n        contents[_ISmp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_iSmp]));\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_InstanceStatusDetailsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceStatusDetails(entry, context);\n    });\n};\nconst de_InstanceStatusEvent = (output, context) => {\n    const contents = {};\n    if (output[_iEI] != null) {\n        contents[_IEI] = __expectString(output[_iEI]);\n    }\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_nAo] != null) {\n        contents[_NAo] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nAo]));\n    }\n    if (output[_nB] != null) {\n        contents[_NB] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nB]));\n    }\n    if (output[_nBD] != null) {\n        contents[_NBD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nBD]));\n    }\n    return contents;\n};\nconst de_InstanceStatusEventList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceStatusEvent(entry, context);\n    });\n};\nconst de_InstanceStatusList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceStatus(entry, context);\n    });\n};\nconst de_InstanceStatusSummary = (output, context) => {\n    const contents = {};\n    if (output.details === \"\") {\n        contents[_Det] = [];\n    }\n    else if (output[_det] != null && output[_det][_i] != null) {\n        contents[_Det] = de_InstanceStatusDetailsList(__getArrayIfSingleItem(output[_det][_i]), context);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_InstanceStorageInfo = (output, context) => {\n    const contents = {};\n    if (output[_tSIGB] != null) {\n        contents[_TSIGB] = __strictParseLong(output[_tSIGB]);\n    }\n    if (output.disks === \"\") {\n        contents[_Dis] = [];\n    }\n    else if (output[_dis] != null && output[_dis][_i] != null) {\n        contents[_Dis] = de_DiskInfoList(__getArrayIfSingleItem(output[_dis][_i]), context);\n    }\n    if (output[_nS] != null) {\n        contents[_NS] = __expectString(output[_nS]);\n    }\n    if (output[_eSn] != null) {\n        contents[_ESnc] = __expectString(output[_eSn]);\n    }\n    return contents;\n};\nconst de_InstanceTagKeySet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_InstanceTagNotificationAttribute = (output, context) => {\n    const contents = {};\n    if (output.instanceTagKeySet === \"\") {\n        contents[_ITK] = [];\n    }\n    else if (output[_iTKS] != null && output[_iTKS][_i] != null) {\n        contents[_ITK] = de_InstanceTagKeySet(__getArrayIfSingleItem(output[_iTKS][_i]), context);\n    }\n    if (output[_iATOI] != null) {\n        contents[_IATOI] = __parseBoolean(output[_iATOI]);\n    }\n    return contents;\n};\nconst de_InstanceTopology = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    if (output.networkNodeSet === \"\") {\n        contents[_NN] = [];\n    }\n    else if (output[_nNS] != null && output[_nNS][_i] != null) {\n        contents[_NN] = de_NetworkNodesList(__getArrayIfSingleItem(output[_nNS][_i]), context);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_zI] != null) {\n        contents[_ZIo] = __expectString(output[_zI]);\n    }\n    return contents;\n};\nconst de_InstanceTypeInfo = (output, context) => {\n    const contents = {};\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_cGur] != null) {\n        contents[_CGur] = __parseBoolean(output[_cGur]);\n    }\n    if (output[_fTE] != null) {\n        contents[_FTE] = __parseBoolean(output[_fTE]);\n    }\n    if (output.supportedUsageClasses === \"\") {\n        contents[_SUC] = [];\n    }\n    else if (output[_sUC] != null && output[_sUC][_i] != null) {\n        contents[_SUC] = de_UsageClassTypeList(__getArrayIfSingleItem(output[_sUC][_i]), context);\n    }\n    if (output.supportedRootDeviceTypes === \"\") {\n        contents[_SRDT] = [];\n    }\n    else if (output[_sRDT] != null && output[_sRDT][_i] != null) {\n        contents[_SRDT] = de_RootDeviceTypeList(__getArrayIfSingleItem(output[_sRDT][_i]), context);\n    }\n    if (output.supportedVirtualizationTypes === \"\") {\n        contents[_SVT] = [];\n    }\n    else if (output[_sVT] != null && output[_sVT][_i] != null) {\n        contents[_SVT] = de_VirtualizationTypeList(__getArrayIfSingleItem(output[_sVT][_i]), context);\n    }\n    if (output[_bMa] != null) {\n        contents[_BMa] = __parseBoolean(output[_bMa]);\n    }\n    if (output[_h] != null) {\n        contents[_H] = __expectString(output[_h]);\n    }\n    if (output[_pIr] != null) {\n        contents[_PIro] = de_ProcessorInfo(output[_pIr], context);\n    }\n    if (output[_vCIp] != null) {\n        contents[_VCIpu] = de_VCpuInfo(output[_vCIp], context);\n    }\n    if (output[_mIe] != null) {\n        contents[_MIe] = de_MemoryInfo(output[_mIe], context);\n    }\n    if (output[_iSSn] != null) {\n        contents[_ISS] = __parseBoolean(output[_iSSn]);\n    }\n    if (output[_iSI] != null) {\n        contents[_ISIn] = de_InstanceStorageInfo(output[_iSI], context);\n    }\n    if (output[_eIb] != null) {\n        contents[_EIb] = de_EbsInfo(output[_eIb], context);\n    }\n    if (output[_nIet] != null) {\n        contents[_NIetw] = de_NetworkInfo(output[_nIet], context);\n    }\n    if (output[_gIp] != null) {\n        contents[_GIp] = de_GpuInfo(output[_gIp], context);\n    }\n    if (output[_fIp] != null) {\n        contents[_FIpg] = de_FpgaInfo(output[_fIp], context);\n    }\n    if (output[_pGI] != null) {\n        contents[_PGI] = de_PlacementGroupInfo(output[_pGI], context);\n    }\n    if (output[_iAI] != null) {\n        contents[_IAIn] = de_InferenceAcceleratorInfo(output[_iAI], context);\n    }\n    if (output[_hSi] != null) {\n        contents[_HS] = __parseBoolean(output[_hSi]);\n    }\n    if (output[_bPS] != null) {\n        contents[_BPS] = __parseBoolean(output[_bPS]);\n    }\n    if (output[_dHS] != null) {\n        contents[_DHS] = __parseBoolean(output[_dHS]);\n    }\n    if (output[_aRSu] != null) {\n        contents[_ARSu] = __parseBoolean(output[_aRSu]);\n    }\n    if (output.supportedBootModes === \"\") {\n        contents[_SBM] = [];\n    }\n    else if (output[_sBM] != null && output[_sBM][_i] != null) {\n        contents[_SBM] = de_BootModeTypeList(__getArrayIfSingleItem(output[_sBM][_i]), context);\n    }\n    if (output[_nES] != null) {\n        contents[_NES] = __expectString(output[_nES]);\n    }\n    if (output[_nTS] != null) {\n        contents[_NTS] = __expectString(output[_nTS]);\n    }\n    if (output[_nTI] != null) {\n        contents[_NTI] = de_NitroTpmInfo(output[_nTI], context);\n    }\n    if (output[_mAIe] != null) {\n        contents[_MAIe] = de_MediaAcceleratorInfo(output[_mAIe], context);\n    }\n    if (output[_nIeu] != null) {\n        contents[_NIeu] = de_NeuronInfo(output[_nIeu], context);\n    }\n    if (output[_pSh] != null) {\n        contents[_PSh] = __expectString(output[_pSh]);\n    }\n    if (output[_rMS] != null) {\n        contents[_RMS] = __expectString(output[_rMS]);\n    }\n    return contents;\n};\nconst de_InstanceTypeInfoFromInstanceRequirements = (output, context) => {\n    const contents = {};\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    return contents;\n};\nconst de_InstanceTypeInfoFromInstanceRequirementsSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceTypeInfoFromInstanceRequirements(entry, context);\n    });\n};\nconst de_InstanceTypeInfoList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceTypeInfo(entry, context);\n    });\n};\nconst de_InstanceTypeOffering = (output, context) => {\n    const contents = {};\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_lTo] != null) {\n        contents[_LT] = __expectString(output[_lTo]);\n    }\n    if (output[_lo] != null) {\n        contents[_Lo] = __expectString(output[_lo]);\n    }\n    return contents;\n};\nconst de_InstanceTypeOfferingsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceTypeOffering(entry, context);\n    });\n};\nconst de_InstanceTypesList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_InstanceUsage = (output, context) => {\n    const contents = {};\n    if (output[_aIc] != null) {\n        contents[_AIcc] = __expectString(output[_aIc]);\n    }\n    if (output[_uIC] != null) {\n        contents[_UIC] = __strictParseInt32(output[_uIC]);\n    }\n    return contents;\n};\nconst de_InstanceUsageSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InstanceUsage(entry, context);\n    });\n};\nconst de_InternetGateway = (output, context) => {\n    const contents = {};\n    if (output.attachmentSet === \"\") {\n        contents[_Atta] = [];\n    }\n    else if (output[_aSt] != null && output[_aSt][_i] != null) {\n        contents[_Atta] = de_InternetGatewayAttachmentList(__getArrayIfSingleItem(output[_aSt][_i]), context);\n    }\n    if (output[_iGI] != null) {\n        contents[_IGI] = __expectString(output[_iGI]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_InternetGatewayAttachment = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    return contents;\n};\nconst de_InternetGatewayAttachmentList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InternetGatewayAttachment(entry, context);\n    });\n};\nconst de_InternetGatewayList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InternetGateway(entry, context);\n    });\n};\nconst de_IpAddressList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_Ipam = (output, context) => {\n    const contents = {};\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_iIp] != null) {\n        contents[_IIp] = __expectString(output[_iIp]);\n    }\n    if (output[_iApa] != null) {\n        contents[_IApa] = __expectString(output[_iApa]);\n    }\n    if (output[_iRp] != null) {\n        contents[_IRpa] = __expectString(output[_iRp]);\n    }\n    if (output[_pDSI] != null) {\n        contents[_PDSI] = __expectString(output[_pDSI]);\n    }\n    if (output[_pDSIr] != null) {\n        contents[_PDSIr] = __expectString(output[_pDSIr]);\n    }\n    if (output[_sCc] != null) {\n        contents[_SCc] = __strictParseInt32(output[_sCc]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.operatingRegionSet === \"\") {\n        contents[_OR] = [];\n    }\n    else if (output[_oRS] != null && output[_oRS][_i] != null) {\n        contents[_OR] = de_IpamOperatingRegionSet(__getArrayIfSingleItem(output[_oRS][_i]), context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_dRDI] != null) {\n        contents[_DRDI] = __expectString(output[_dRDI]);\n    }\n    if (output[_dRDAI] != null) {\n        contents[_DRDAI] = __expectString(output[_dRDAI]);\n    }\n    if (output[_rDAC] != null) {\n        contents[_RDAC] = __strictParseInt32(output[_rDAC]);\n    }\n    if (output[_sMta] != null) {\n        contents[_SMta] = __expectString(output[_sMta]);\n    }\n    if (output[_tie] != null) {\n        contents[_Ti] = __expectString(output[_tie]);\n    }\n    if (output[_ePG] != null) {\n        contents[_EPG] = __parseBoolean(output[_ePG]);\n    }\n    if (output[_mAe] != null) {\n        contents[_MAe] = __expectString(output[_mAe]);\n    }\n    return contents;\n};\nconst de_IpamAddressHistoryRecord = (output, context) => {\n    const contents = {};\n    if (output[_rOI] != null) {\n        contents[_ROI] = __expectString(output[_rOI]);\n    }\n    if (output[_rR] != null) {\n        contents[_RRe] = __expectString(output[_rR]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rCe] != null) {\n        contents[_RC] = __expectString(output[_rCe]);\n    }\n    if (output[_rNes] != null) {\n        contents[_RNes] = __expectString(output[_rNes]);\n    }\n    if (output[_rCS] != null) {\n        contents[_RCS] = __expectString(output[_rCS]);\n    }\n    if (output[_rOSe] != null) {\n        contents[_ROS] = __expectString(output[_rOSe]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_sST] != null) {\n        contents[_SST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sST]));\n    }\n    if (output[_sET] != null) {\n        contents[_SET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sET]));\n    }\n    return contents;\n};\nconst de_IpamAddressHistoryRecordSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamAddressHistoryRecord(entry, context);\n    });\n};\nconst de_IpamDiscoveredAccount = (output, context) => {\n    const contents = {};\n    if (output[_aIc] != null) {\n        contents[_AIcc] = __expectString(output[_aIc]);\n    }\n    if (output[_dR] != null) {\n        contents[_DRi] = __expectString(output[_dR]);\n    }\n    if (output[_fR] != null) {\n        contents[_FR] = de_IpamDiscoveryFailureReason(output[_fR], context);\n    }\n    if (output[_lADT] != null) {\n        contents[_LADT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lADT]));\n    }\n    if (output[_lSDT] != null) {\n        contents[_LSDT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lSDT]));\n    }\n    if (output[_oUI] != null) {\n        contents[_OUI] = __expectString(output[_oUI]);\n    }\n    return contents;\n};\nconst de_IpamDiscoveredAccountSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamDiscoveredAccount(entry, context);\n    });\n};\nconst de_IpamDiscoveredPublicAddress = (output, context) => {\n    const contents = {};\n    if (output[_iRDI] != null) {\n        contents[_IRDI] = __expectString(output[_iRDI]);\n    }\n    if (output[_aRd] != null) {\n        contents[_ARd] = __expectString(output[_aRd]);\n    }\n    if (output[_ad] != null) {\n        contents[_Ad] = __expectString(output[_ad]);\n    }\n    if (output[_aOI] != null) {\n        contents[_AOI] = __expectString(output[_aOI]);\n    }\n    if (output[_aAId] != null) {\n        contents[_AAId] = __expectString(output[_aAId]);\n    }\n    if (output[_aSs] != null) {\n        contents[_ASss] = __expectString(output[_aSs]);\n    }\n    if (output[_aTd] != null) {\n        contents[_ATddre] = __expectString(output[_aTd]);\n    }\n    if (output[_se] != null) {\n        contents[_Se] = __expectString(output[_se]);\n    }\n    if (output[_sRe] != null) {\n        contents[_SRerv] = __expectString(output[_sRe]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_pIPI] != null) {\n        contents[_PIPI] = __expectString(output[_pIPI]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_nID] != null) {\n        contents[_NID] = __expectString(output[_nID]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_ta] != null) {\n        contents[_Ta] = de_IpamPublicAddressTags(output[_ta], context);\n    }\n    if (output[_nBG] != null) {\n        contents[_NBG] = __expectString(output[_nBG]);\n    }\n    if (output.securityGroupSet === \"\") {\n        contents[_SG] = [];\n    }\n    else if (output[_sGS] != null && output[_sGS][_i] != null) {\n        contents[_SG] = de_IpamPublicAddressSecurityGroupList(__getArrayIfSingleItem(output[_sGS][_i]), context);\n    }\n    if (output[_sTa] != null) {\n        contents[_STam] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sTa]));\n    }\n    return contents;\n};\nconst de_IpamDiscoveredPublicAddressSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamDiscoveredPublicAddress(entry, context);\n    });\n};\nconst de_IpamDiscoveredResourceCidr = (output, context) => {\n    const contents = {};\n    if (output[_iRDI] != null) {\n        contents[_IRDI] = __expectString(output[_iRDI]);\n    }\n    if (output[_rR] != null) {\n        contents[_RRe] = __expectString(output[_rR]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rOI] != null) {\n        contents[_ROI] = __expectString(output[_rOI]);\n    }\n    if (output[_rCe] != null) {\n        contents[_RC] = __expectString(output[_rCe]);\n    }\n    if (output[_iSpo] != null) {\n        contents[_ISpo] = __expectString(output[_iSpo]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output.resourceTagSet === \"\") {\n        contents[_RTesou] = [];\n    }\n    else if (output[_rTSe] != null && output[_rTSe][_i] != null) {\n        contents[_RTesou] = de_IpamResourceTagList(__getArrayIfSingleItem(output[_rTSe][_i]), context);\n    }\n    if (output[_iU] != null) {\n        contents[_IUp] = __strictParseFloat(output[_iU]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_nIASet] != null) {\n        contents[_NIASet] = __expectString(output[_nIASet]);\n    }\n    if (output[_sTa] != null) {\n        contents[_STam] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sTa]));\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    return contents;\n};\nconst de_IpamDiscoveredResourceCidrSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamDiscoveredResourceCidr(entry, context);\n    });\n};\nconst de_IpamDiscoveryFailureReason = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_IpamExternalResourceVerificationToken = (output, context) => {\n    const contents = {};\n    if (output[_iERVTI] != null) {\n        contents[_IERVTI] = __expectString(output[_iERVTI]);\n    }\n    if (output[_iERVTA] != null) {\n        contents[_IERVTA] = __expectString(output[_iERVTA]);\n    }\n    if (output[_iIp] != null) {\n        contents[_IIp] = __expectString(output[_iIp]);\n    }\n    if (output[_iApa] != null) {\n        contents[_IApa] = __expectString(output[_iApa]);\n    }\n    if (output[_iRp] != null) {\n        contents[_IRpa] = __expectString(output[_iRp]);\n    }\n    if (output[_tV] != null) {\n        contents[_TVo] = __expectString(output[_tV]);\n    }\n    if (output[_tN] != null) {\n        contents[_TN] = __expectString(output[_tN]);\n    }\n    if (output[_nAo] != null) {\n        contents[_NAo] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nAo]));\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_IpamExternalResourceVerificationTokenSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamExternalResourceVerificationToken(entry, context);\n    });\n};\nconst de_IpamOperatingRegion = (output, context) => {\n    const contents = {};\n    if (output[_rNe] != null) {\n        contents[_RN] = __expectString(output[_rNe]);\n    }\n    return contents;\n};\nconst de_IpamOperatingRegionSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamOperatingRegion(entry, context);\n    });\n};\nconst de_IpamOrganizationalUnitExclusion = (output, context) => {\n    const contents = {};\n    if (output[_oEP] != null) {\n        contents[_OEP] = __expectString(output[_oEP]);\n    }\n    return contents;\n};\nconst de_IpamOrganizationalUnitExclusionSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamOrganizationalUnitExclusion(entry, context);\n    });\n};\nconst de_IpamPool = (output, context) => {\n    const contents = {};\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_iPIp] != null) {\n        contents[_IPI] = __expectString(output[_iPIp]);\n    }\n    if (output[_sIPI] != null) {\n        contents[_SIPI] = __expectString(output[_sIPI]);\n    }\n    if (output[_iPAp] != null) {\n        contents[_IPApa] = __expectString(output[_iPAp]);\n    }\n    if (output[_iSA] != null) {\n        contents[_ISA] = __expectString(output[_iSA]);\n    }\n    if (output[_iST] != null) {\n        contents[_ISTp] = __expectString(output[_iST]);\n    }\n    if (output[_iApa] != null) {\n        contents[_IApa] = __expectString(output[_iApa]);\n    }\n    if (output[_iRp] != null) {\n        contents[_IRpa] = __expectString(output[_iRp]);\n    }\n    if (output[_loc] != null) {\n        contents[_L] = __expectString(output[_loc]);\n    }\n    if (output[_pDoo] != null) {\n        contents[_PDo] = __strictParseInt32(output[_pDoo]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sMta] != null) {\n        contents[_SMta] = __expectString(output[_sMta]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_aIu] != null) {\n        contents[_AIu] = __parseBoolean(output[_aIu]);\n    }\n    if (output[_pAu] != null) {\n        contents[_PA] = __parseBoolean(output[_pAu]);\n    }\n    if (output[_aF] != null) {\n        contents[_AF] = __expectString(output[_aF]);\n    }\n    if (output[_aMNL] != null) {\n        contents[_AMNL] = __strictParseInt32(output[_aMNL]);\n    }\n    if (output[_aMNLl] != null) {\n        contents[_AMNLl] = __strictParseInt32(output[_aMNLl]);\n    }\n    if (output[_aDNL] != null) {\n        contents[_ADNL] = __strictParseInt32(output[_aDNL]);\n    }\n    if (output.allocationResourceTagSet === \"\") {\n        contents[_ARTl] = [];\n    }\n    else if (output[_aRTS] != null && output[_aRTS][_i] != null) {\n        contents[_ARTl] = de_IpamResourceTagList(__getArrayIfSingleItem(output[_aRTS][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_aSw] != null) {\n        contents[_ASw] = __expectString(output[_aSw]);\n    }\n    if (output[_pIS] != null) {\n        contents[_PIS] = __expectString(output[_pIS]);\n    }\n    if (output[_sRo] != null) {\n        contents[_SRo] = de_IpamPoolSourceResource(output[_sRo], context);\n    }\n    return contents;\n};\nconst de_IpamPoolAllocation = (output, context) => {\n    const contents = {};\n    if (output[_ci] != null) {\n        contents[_C] = __expectString(output[_ci]);\n    }\n    if (output[_iPAI] != null) {\n        contents[_IPAI] = __expectString(output[_iPAI]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_rR] != null) {\n        contents[_RRe] = __expectString(output[_rR]);\n    }\n    if (output[_rO] != null) {\n        contents[_ROe] = __expectString(output[_rO]);\n    }\n    return contents;\n};\nconst de_IpamPoolAllocationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamPoolAllocation(entry, context);\n    });\n};\nconst de_IpamPoolCidr = (output, context) => {\n    const contents = {};\n    if (output[_ci] != null) {\n        contents[_C] = __expectString(output[_ci]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_fR] != null) {\n        contents[_FR] = de_IpamPoolCidrFailureReason(output[_fR], context);\n    }\n    if (output[_iPCI] != null) {\n        contents[_IPCI] = __expectString(output[_iPCI]);\n    }\n    if (output[_nL] != null) {\n        contents[_NL] = __strictParseInt32(output[_nL]);\n    }\n    return contents;\n};\nconst de_IpamPoolCidrFailureReason = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_IpamPoolCidrSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamPoolCidr(entry, context);\n    });\n};\nconst de_IpamPoolSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamPool(entry, context);\n    });\n};\nconst de_IpamPoolSourceResource = (output, context) => {\n    const contents = {};\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_rR] != null) {\n        contents[_RRe] = __expectString(output[_rR]);\n    }\n    if (output[_rO] != null) {\n        contents[_ROe] = __expectString(output[_rO]);\n    }\n    return contents;\n};\nconst de_IpamPublicAddressSecurityGroup = (output, context) => {\n    const contents = {};\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    return contents;\n};\nconst de_IpamPublicAddressSecurityGroupList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamPublicAddressSecurityGroup(entry, context);\n    });\n};\nconst de_IpamPublicAddressTag = (output, context) => {\n    const contents = {};\n    if (output[_k] != null) {\n        contents[_Ke] = __expectString(output[_k]);\n    }\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    return contents;\n};\nconst de_IpamPublicAddressTagList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamPublicAddressTag(entry, context);\n    });\n};\nconst de_IpamPublicAddressTags = (output, context) => {\n    const contents = {};\n    if (output.eipTagSet === \"\") {\n        contents[_ETi] = [];\n    }\n    else if (output[_eTSi] != null && output[_eTSi][_i] != null) {\n        contents[_ETi] = de_IpamPublicAddressTagList(__getArrayIfSingleItem(output[_eTSi][_i]), context);\n    }\n    return contents;\n};\nconst de_IpamResourceCidr = (output, context) => {\n    const contents = {};\n    if (output[_iIp] != null) {\n        contents[_IIp] = __expectString(output[_iIp]);\n    }\n    if (output[_iSIp] != null) {\n        contents[_ISI] = __expectString(output[_iSIp]);\n    }\n    if (output[_iPIp] != null) {\n        contents[_IPI] = __expectString(output[_iPIp]);\n    }\n    if (output[_rR] != null) {\n        contents[_RRe] = __expectString(output[_rR]);\n    }\n    if (output[_rOI] != null) {\n        contents[_ROI] = __expectString(output[_rOI]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rNes] != null) {\n        contents[_RNes] = __expectString(output[_rNes]);\n    }\n    if (output[_rCe] != null) {\n        contents[_RC] = __expectString(output[_rCe]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output.resourceTagSet === \"\") {\n        contents[_RTesou] = [];\n    }\n    else if (output[_rTSe] != null && output[_rTSe][_i] != null) {\n        contents[_RTesou] = de_IpamResourceTagList(__getArrayIfSingleItem(output[_rTSe][_i]), context);\n    }\n    if (output[_iU] != null) {\n        contents[_IUp] = __strictParseFloat(output[_iU]);\n    }\n    if (output[_cSo] != null) {\n        contents[_CSo] = __expectString(output[_cSo]);\n    }\n    if (output[_mSa] != null) {\n        contents[_MSa] = __expectString(output[_mSa]);\n    }\n    if (output[_oSv] != null) {\n        contents[_OSv] = __expectString(output[_oSv]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    return contents;\n};\nconst de_IpamResourceCidrSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamResourceCidr(entry, context);\n    });\n};\nconst de_IpamResourceDiscovery = (output, context) => {\n    const contents = {};\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_iRDI] != null) {\n        contents[_IRDI] = __expectString(output[_iRDI]);\n    }\n    if (output[_iRDAp] != null) {\n        contents[_IRDApa] = __expectString(output[_iRDAp]);\n    }\n    if (output[_iRDR] != null) {\n        contents[_IRDR] = __expectString(output[_iRDR]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.operatingRegionSet === \"\") {\n        contents[_OR] = [];\n    }\n    else if (output[_oRS] != null && output[_oRS][_i] != null) {\n        contents[_OR] = de_IpamOperatingRegionSet(__getArrayIfSingleItem(output[_oRS][_i]), context);\n    }\n    if (output[_iDs] != null) {\n        contents[_IDs] = __parseBoolean(output[_iDs]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output.organizationalUnitExclusionSet === \"\") {\n        contents[_OUE] = [];\n    }\n    else if (output[_oUES] != null && output[_oUES][_i] != null) {\n        contents[_OUE] = de_IpamOrganizationalUnitExclusionSet(__getArrayIfSingleItem(output[_oUES][_i]), context);\n    }\n    return contents;\n};\nconst de_IpamResourceDiscoveryAssociation = (output, context) => {\n    const contents = {};\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_iRDAI] != null) {\n        contents[_IRDAIp] = __expectString(output[_iRDAI]);\n    }\n    if (output[_iRDAA] != null) {\n        contents[_IRDAA] = __expectString(output[_iRDAA]);\n    }\n    if (output[_iRDI] != null) {\n        contents[_IRDI] = __expectString(output[_iRDI]);\n    }\n    if (output[_iIp] != null) {\n        contents[_IIp] = __expectString(output[_iIp]);\n    }\n    if (output[_iApa] != null) {\n        contents[_IApa] = __expectString(output[_iApa]);\n    }\n    if (output[_iRp] != null) {\n        contents[_IRpa] = __expectString(output[_iRp]);\n    }\n    if (output[_iDs] != null) {\n        contents[_IDs] = __parseBoolean(output[_iDs]);\n    }\n    if (output[_rDS] != null) {\n        contents[_RDS] = __expectString(output[_rDS]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_IpamResourceDiscoveryAssociationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamResourceDiscoveryAssociation(entry, context);\n    });\n};\nconst de_IpamResourceDiscoverySet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamResourceDiscovery(entry, context);\n    });\n};\nconst de_IpamResourceTag = (output, context) => {\n    const contents = {};\n    if (output[_k] != null) {\n        contents[_Ke] = __expectString(output[_k]);\n    }\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    return contents;\n};\nconst de_IpamResourceTagList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamResourceTag(entry, context);\n    });\n};\nconst de_IpamScope = (output, context) => {\n    const contents = {};\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_iSIp] != null) {\n        contents[_ISI] = __expectString(output[_iSIp]);\n    }\n    if (output[_iSA] != null) {\n        contents[_ISA] = __expectString(output[_iSA]);\n    }\n    if (output[_iApa] != null) {\n        contents[_IApa] = __expectString(output[_iApa]);\n    }\n    if (output[_iRp] != null) {\n        contents[_IRpa] = __expectString(output[_iRp]);\n    }\n    if (output[_iST] != null) {\n        contents[_ISTp] = __expectString(output[_iST]);\n    }\n    if (output[_iDs] != null) {\n        contents[_IDs] = __parseBoolean(output[_iDs]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_pCo] != null) {\n        contents[_PCoo] = __strictParseInt32(output[_pCo]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_IpamScopeSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpamScope(entry, context);\n    });\n};\nconst de_IpamSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ipam(entry, context);\n    });\n};\nconst de_IpPermission = (output, context) => {\n    const contents = {};\n    if (output[_iPpr] != null) {\n        contents[_IPpr] = __expectString(output[_iPpr]);\n    }\n    if (output[_fP] != null) {\n        contents[_FP] = __strictParseInt32(output[_fP]);\n    }\n    if (output[_tPo] != null) {\n        contents[_TP] = __strictParseInt32(output[_tPo]);\n    }\n    if (output.groups === \"\") {\n        contents[_UIGP] = [];\n    }\n    else if (output[_gr] != null && output[_gr][_i] != null) {\n        contents[_UIGP] = de_UserIdGroupPairList(__getArrayIfSingleItem(output[_gr][_i]), context);\n    }\n    if (output.ipRanges === \"\") {\n        contents[_IRp] = [];\n    }\n    else if (output[_iRpa] != null && output[_iRpa][_i] != null) {\n        contents[_IRp] = de_IpRangeList(__getArrayIfSingleItem(output[_iRpa][_i]), context);\n    }\n    if (output.ipv6Ranges === \"\") {\n        contents[_IRpv] = [];\n    }\n    else if (output[_iRpv] != null && output[_iRpv][_i] != null) {\n        contents[_IRpv] = de_Ipv6RangeList(__getArrayIfSingleItem(output[_iRpv][_i]), context);\n    }\n    if (output.prefixListIds === \"\") {\n        contents[_PLIr] = [];\n    }\n    else if (output[_pLIr] != null && output[_pLIr][_i] != null) {\n        contents[_PLIr] = de_PrefixListIdList(__getArrayIfSingleItem(output[_pLIr][_i]), context);\n    }\n    return contents;\n};\nconst de_IpPermissionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpPermission(entry, context);\n    });\n};\nconst de_IpPrefixList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_IpRange = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_cIi] != null) {\n        contents[_CIi] = __expectString(output[_cIi]);\n    }\n    return contents;\n};\nconst de_IpRangeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_IpRange(entry, context);\n    });\n};\nconst de_IpRanges = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_Ipv4PrefixesList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ipv4PrefixSpecification(entry, context);\n    });\n};\nconst de_Ipv4PrefixList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ipv4PrefixSpecificationRequest(entry, context);\n    });\n};\nconst de_Ipv4PrefixListResponse = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ipv4PrefixSpecificationResponse(entry, context);\n    });\n};\nconst de_Ipv4PrefixSpecification = (output, context) => {\n    const contents = {};\n    if (output[_iPpv] != null) {\n        contents[_IPpvr] = __expectString(output[_iPpv]);\n    }\n    return contents;\n};\nconst de_Ipv4PrefixSpecificationRequest = (output, context) => {\n    const contents = {};\n    if (output[_IPpvr] != null) {\n        contents[_IPpvr] = __expectString(output[_IPpvr]);\n    }\n    return contents;\n};\nconst de_Ipv4PrefixSpecificationResponse = (output, context) => {\n    const contents = {};\n    if (output[_iPpv] != null) {\n        contents[_IPpvr] = __expectString(output[_iPpv]);\n    }\n    return contents;\n};\nconst de_Ipv6AddressList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_Ipv6CidrAssociation = (output, context) => {\n    const contents = {};\n    if (output[_iCp] != null) {\n        contents[_ICp] = __expectString(output[_iCp]);\n    }\n    if (output[_aRs] != null) {\n        contents[_ARs] = __expectString(output[_aRs]);\n    }\n    return contents;\n};\nconst de_Ipv6CidrAssociationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ipv6CidrAssociation(entry, context);\n    });\n};\nconst de_Ipv6CidrBlock = (output, context) => {\n    const contents = {};\n    if (output[_iCB] != null) {\n        contents[_ICB] = __expectString(output[_iCB]);\n    }\n    return contents;\n};\nconst de_Ipv6CidrBlockSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ipv6CidrBlock(entry, context);\n    });\n};\nconst de_Ipv6Pool = (output, context) => {\n    const contents = {};\n    if (output[_pIo] != null) {\n        contents[_PIo] = __expectString(output[_pIo]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.poolCidrBlockSet === \"\") {\n        contents[_PCBo] = [];\n    }\n    else if (output[_pCBS] != null && output[_pCBS][_i] != null) {\n        contents[_PCBo] = de_PoolCidrBlocksSet(__getArrayIfSingleItem(output[_pCBS][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_Ipv6PoolSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ipv6Pool(entry, context);\n    });\n};\nconst de_Ipv6PrefixesList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ipv6PrefixSpecification(entry, context);\n    });\n};\nconst de_Ipv6PrefixList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ipv6PrefixSpecificationRequest(entry, context);\n    });\n};\nconst de_Ipv6PrefixListResponse = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ipv6PrefixSpecificationResponse(entry, context);\n    });\n};\nconst de_Ipv6PrefixSpecification = (output, context) => {\n    const contents = {};\n    if (output[_iPpvr] != null) {\n        contents[_IPpvre] = __expectString(output[_iPpvr]);\n    }\n    return contents;\n};\nconst de_Ipv6PrefixSpecificationRequest = (output, context) => {\n    const contents = {};\n    if (output[_IPpvre] != null) {\n        contents[_IPpvre] = __expectString(output[_IPpvre]);\n    }\n    return contents;\n};\nconst de_Ipv6PrefixSpecificationResponse = (output, context) => {\n    const contents = {};\n    if (output[_iPpvr] != null) {\n        contents[_IPpvre] = __expectString(output[_iPpvr]);\n    }\n    return contents;\n};\nconst de_Ipv6Range = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_cIid] != null) {\n        contents[_CIid] = __expectString(output[_cIid]);\n    }\n    return contents;\n};\nconst de_Ipv6RangeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Ipv6Range(entry, context);\n    });\n};\nconst de_KeyPair = (output, context) => {\n    const contents = {};\n    if (output[_kPI] != null) {\n        contents[_KPI] = __expectString(output[_kPI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_kN] != null) {\n        contents[_KN] = __expectString(output[_kN]);\n    }\n    if (output[_kFe] != null) {\n        contents[_KFe] = __expectString(output[_kFe]);\n    }\n    if (output[_kM] != null) {\n        contents[_KM] = __expectString(output[_kM]);\n    }\n    return contents;\n};\nconst de_KeyPairInfo = (output, context) => {\n    const contents = {};\n    if (output[_kPI] != null) {\n        contents[_KPI] = __expectString(output[_kPI]);\n    }\n    if (output[_kT] != null) {\n        contents[_KT] = __expectString(output[_kT]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_pK] != null) {\n        contents[_PK] = __expectString(output[_pK]);\n    }\n    if (output[_cTr] != null) {\n        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));\n    }\n    if (output[_kN] != null) {\n        contents[_KN] = __expectString(output[_kN]);\n    }\n    if (output[_kFe] != null) {\n        contents[_KFe] = __expectString(output[_kFe]);\n    }\n    return contents;\n};\nconst de_KeyPairList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_KeyPairInfo(entry, context);\n    });\n};\nconst de_LastError = (output, context) => {\n    const contents = {};\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    return contents;\n};\nconst de_LaunchPermission = (output, context) => {\n    const contents = {};\n    if (output[_oAr] != null) {\n        contents[_OAr] = __expectString(output[_oAr]);\n    }\n    if (output[_oUA] != null) {\n        contents[_OUA] = __expectString(output[_oUA]);\n    }\n    if (output[_uI] != null) {\n        contents[_UIs] = __expectString(output[_uI]);\n    }\n    if (output[_g] != null) {\n        contents[_Gr] = __expectString(output[_g]);\n    }\n    return contents;\n};\nconst de_LaunchPermissionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LaunchPermission(entry, context);\n    });\n};\nconst de_LaunchSpecification = (output, context) => {\n    const contents = {};\n    if (output[_uDs] != null) {\n        contents[_UD] = __expectString(output[_uDs]);\n    }\n    if (output[_aTdd] != null) {\n        contents[_ATd] = __expectString(output[_aTdd]);\n    }\n    if (output.blockDeviceMapping === \"\") {\n        contents[_BDM] = [];\n    }\n    else if (output[_bDM] != null && output[_bDM][_i] != null) {\n        contents[_BDM] = de_BlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);\n    }\n    if (output[_eO] != null) {\n        contents[_EO] = __parseBoolean(output[_eO]);\n    }\n    if (output[_iIP] != null) {\n        contents[_IIP] = de_IamInstanceProfileSpecification(output[_iIP], context);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_kI] != null) {\n        contents[_KI] = __expectString(output[_kI]);\n    }\n    if (output[_kN] != null) {\n        contents[_KN] = __expectString(output[_kN]);\n    }\n    if (output.networkInterfaceSet === \"\") {\n        contents[_NI] = [];\n    }\n    else if (output[_nIS] != null && output[_nIS][_i] != null) {\n        contents[_NI] = de_InstanceNetworkInterfaceSpecificationList(__getArrayIfSingleItem(output[_nIS][_i]), context);\n    }\n    if (output[_pla] != null) {\n        contents[_Pl] = de_SpotPlacement(output[_pla], context);\n    }\n    if (output[_rIa] != null) {\n        contents[_RIa] = __expectString(output[_rIa]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output.groupSet === \"\") {\n        contents[_SG] = [];\n    }\n    else if (output[_gS] != null && output[_gS][_i] != null) {\n        contents[_SG] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);\n    }\n    if (output[_mo] != null) {\n        contents[_Mon] = de_RunInstancesMonitoringEnabled(output[_mo], context);\n    }\n    return contents;\n};\nconst de_LaunchSpecsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SpotFleetLaunchSpecification(entry, context);\n    });\n};\nconst de_LaunchTemplate = (output, context) => {\n    const contents = {};\n    if (output[_lTI] != null) {\n        contents[_LTI] = __expectString(output[_lTI]);\n    }\n    if (output[_lTN] != null) {\n        contents[_LTN] = __expectString(output[_lTN]);\n    }\n    if (output[_cTr] != null) {\n        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));\n    }\n    if (output[_cBr] != null) {\n        contents[_CBr] = __expectString(output[_cBr]);\n    }\n    if (output[_dVN] != null) {\n        contents[_DVN] = __strictParseLong(output[_dVN]);\n    }\n    if (output[_lVN] != null) {\n        contents[_LVN] = __strictParseLong(output[_lVN]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_op] != null) {\n        contents[_O] = de_OperatorResponse(output[_op], context);\n    }\n    return contents;\n};\nconst de_LaunchTemplateAndOverridesResponse = (output, context) => {\n    const contents = {};\n    if (output[_lTS] != null) {\n        contents[_LTS] = de_FleetLaunchTemplateSpecification(output[_lTS], context);\n    }\n    if (output[_ov] != null) {\n        contents[_Ov] = de_FleetLaunchTemplateOverrides(output[_ov], context);\n    }\n    return contents;\n};\nconst de_LaunchTemplateBlockDeviceMapping = (output, context) => {\n    const contents = {};\n    if (output[_dN] != null) {\n        contents[_DN] = __expectString(output[_dN]);\n    }\n    if (output[_vN] != null) {\n        contents[_VN] = __expectString(output[_vN]);\n    }\n    if (output[_eb] != null) {\n        contents[_E] = de_LaunchTemplateEbsBlockDevice(output[_eb], context);\n    }\n    if (output[_nD] != null) {\n        contents[_ND] = __expectString(output[_nD]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateBlockDeviceMappingList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LaunchTemplateBlockDeviceMapping(entry, context);\n    });\n};\nconst de_LaunchTemplateCapacityReservationSpecificationResponse = (output, context) => {\n    const contents = {};\n    if (output[_cRP] != null) {\n        contents[_CRP] = __expectString(output[_cRP]);\n    }\n    if (output[_cRT] != null) {\n        contents[_CRTa] = de_CapacityReservationTargetResponse(output[_cRT], context);\n    }\n    return contents;\n};\nconst de_LaunchTemplateConfig = (output, context) => {\n    const contents = {};\n    if (output[_lTS] != null) {\n        contents[_LTS] = de_FleetLaunchTemplateSpecification(output[_lTS], context);\n    }\n    if (output.overrides === \"\") {\n        contents[_Ov] = [];\n    }\n    else if (output[_ov] != null && output[_ov][_i] != null) {\n        contents[_Ov] = de_LaunchTemplateOverridesList(__getArrayIfSingleItem(output[_ov][_i]), context);\n    }\n    return contents;\n};\nconst de_LaunchTemplateConfigList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LaunchTemplateConfig(entry, context);\n    });\n};\nconst de_LaunchTemplateCpuOptions = (output, context) => {\n    const contents = {};\n    if (output[_cCo] != null) {\n        contents[_CC] = __strictParseInt32(output[_cCo]);\n    }\n    if (output[_tPC] != null) {\n        contents[_TPC] = __strictParseInt32(output[_tPC]);\n    }\n    if (output[_aSS] != null) {\n        contents[_ASS] = __expectString(output[_aSS]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateEbsBlockDevice = (output, context) => {\n    const contents = {};\n    if (output[_enc] != null) {\n        contents[_Enc] = __parseBoolean(output[_enc]);\n    }\n    if (output[_dOT] != null) {\n        contents[_DOT] = __parseBoolean(output[_dOT]);\n    }\n    if (output[_io] != null) {\n        contents[_Io] = __strictParseInt32(output[_io]);\n    }\n    if (output[_kKI] != null) {\n        contents[_KKI] = __expectString(output[_kKI]);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_vSo] != null) {\n        contents[_VS] = __strictParseInt32(output[_vSo]);\n    }\n    if (output[_vT] != null) {\n        contents[_VT] = __expectString(output[_vT]);\n    }\n    if (output[_th] != null) {\n        contents[_Th] = __strictParseInt32(output[_th]);\n    }\n    if (output[_vIR] != null) {\n        contents[_VIR] = __strictParseInt32(output[_vIR]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateElasticInferenceAcceleratorResponse = (output, context) => {\n    const contents = {};\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_cou] != null) {\n        contents[_Cou] = __strictParseInt32(output[_cou]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateElasticInferenceAcceleratorResponseList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LaunchTemplateElasticInferenceAcceleratorResponse(entry, context);\n    });\n};\nconst de_LaunchTemplateEnaSrdSpecification = (output, context) => {\n    const contents = {};\n    if (output[_eSE] != null) {\n        contents[_ESE] = __parseBoolean(output[_eSE]);\n    }\n    if (output[_eSUS] != null) {\n        contents[_ESUS] = de_LaunchTemplateEnaSrdUdpSpecification(output[_eSUS], context);\n    }\n    return contents;\n};\nconst de_LaunchTemplateEnaSrdUdpSpecification = (output, context) => {\n    const contents = {};\n    if (output[_eSUE] != null) {\n        contents[_ESUE] = __parseBoolean(output[_eSUE]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateEnclaveOptions = (output, context) => {\n    const contents = {};\n    if (output[_en] != null) {\n        contents[_En] = __parseBoolean(output[_en]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateHibernationOptions = (output, context) => {\n    const contents = {};\n    if (output[_conf] != null) {\n        contents[_Conf] = __parseBoolean(output[_conf]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateIamInstanceProfileSpecification = (output, context) => {\n    const contents = {};\n    if (output[_ar] != null) {\n        contents[_Ar] = __expectString(output[_ar]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateInstanceMaintenanceOptions = (output, context) => {\n    const contents = {};\n    if (output[_aRu] != null) {\n        contents[_ARu] = __expectString(output[_aRu]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateInstanceMarketOptions = (output, context) => {\n    const contents = {};\n    if (output[_mT] != null) {\n        contents[_MT] = __expectString(output[_mT]);\n    }\n    if (output[_sO] != null) {\n        contents[_SO] = de_LaunchTemplateSpotMarketOptions(output[_sO], context);\n    }\n    return contents;\n};\nconst de_LaunchTemplateInstanceMetadataOptions = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_hT] != null) {\n        contents[_HT] = __expectString(output[_hT]);\n    }\n    if (output[_hPRHL] != null) {\n        contents[_HPRHL] = __strictParseInt32(output[_hPRHL]);\n    }\n    if (output[_hE] != null) {\n        contents[_HE] = __expectString(output[_hE]);\n    }\n    if (output[_hPI] != null) {\n        contents[_HPI] = __expectString(output[_hPI]);\n    }\n    if (output[_iMT] != null) {\n        contents[_IMT] = __expectString(output[_iMT]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateInstanceNetworkInterfaceSpecification = (output, context) => {\n    const contents = {};\n    if (output[_aCIA] != null) {\n        contents[_ACIA] = __parseBoolean(output[_aCIA]);\n    }\n    if (output[_aPIA] != null) {\n        contents[_APIAs] = __parseBoolean(output[_aPIA]);\n    }\n    if (output[_dOT] != null) {\n        contents[_DOT] = __parseBoolean(output[_dOT]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_dIe] != null) {\n        contents[_DIev] = __strictParseInt32(output[_dIe]);\n    }\n    if (output.groupSet === \"\") {\n        contents[_G] = [];\n    }\n    else if (output[_gS] != null && output[_gS][_gIr] != null) {\n        contents[_G] = de_GroupIdStringList(__getArrayIfSingleItem(output[_gS][_gIr]), context);\n    }\n    if (output[_iTnt] != null) {\n        contents[_ITn] = __expectString(output[_iTnt]);\n    }\n    if (output[_iAC] != null) {\n        contents[_IAC] = __strictParseInt32(output[_iAC]);\n    }\n    if (output.ipv6AddressesSet === \"\") {\n        contents[_IA] = [];\n    }\n    else if (output[_iASp] != null && output[_iASp][_i] != null) {\n        contents[_IA] = de_InstanceIpv6AddressList(__getArrayIfSingleItem(output[_iASp][_i]), context);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_pIAr] != null) {\n        contents[_PIAr] = __expectString(output[_pIAr]);\n    }\n    if (output.privateIpAddressesSet === \"\") {\n        contents[_PIA] = [];\n    }\n    else if (output[_pIAS] != null && output[_pIAS][_i] != null) {\n        contents[_PIA] = de_PrivateIpAddressSpecificationList(__getArrayIfSingleItem(output[_pIAS][_i]), context);\n    }\n    if (output[_sPIAC] != null) {\n        contents[_SPIAC] = __strictParseInt32(output[_sPIAC]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_nCI] != null) {\n        contents[_NCI] = __strictParseInt32(output[_nCI]);\n    }\n    if (output.ipv4PrefixSet === \"\") {\n        contents[_IPp] = [];\n    }\n    else if (output[_iPSpv] != null && output[_iPSpv][_i] != null) {\n        contents[_IPp] = de_Ipv4PrefixListResponse(__getArrayIfSingleItem(output[_iPSpv][_i]), context);\n    }\n    if (output[_iPCp] != null) {\n        contents[_IPCp] = __strictParseInt32(output[_iPCp]);\n    }\n    if (output.ipv6PrefixSet === \"\") {\n        contents[_IP] = [];\n    }\n    else if (output[_iPSpvr] != null && output[_iPSpvr][_i] != null) {\n        contents[_IP] = de_Ipv6PrefixListResponse(__getArrayIfSingleItem(output[_iPSpvr][_i]), context);\n    }\n    if (output[_iPCpv] != null) {\n        contents[_IPC] = __strictParseInt32(output[_iPCpv]);\n    }\n    if (output[_pIri] != null) {\n        contents[_PIr] = __parseBoolean(output[_pIri]);\n    }\n    if (output[_eSS] != null) {\n        contents[_ESS] = de_LaunchTemplateEnaSrdSpecification(output[_eSS], context);\n    }\n    if (output[_cTS] != null) {\n        contents[_CTS] = de_ConnectionTrackingSpecification(output[_cTS], context);\n    }\n    if (output[_eQC] != null) {\n        contents[_EQC] = __strictParseInt32(output[_eQC]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateInstanceNetworkInterfaceSpecificationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LaunchTemplateInstanceNetworkInterfaceSpecification(entry, context);\n    });\n};\nconst de_LaunchTemplateLicenseConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_lCA] != null) {\n        contents[_LCA] = __expectString(output[_lCA]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateLicenseList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LaunchTemplateLicenseConfiguration(entry, context);\n    });\n};\nconst de_LaunchTemplateNetworkPerformanceOptions = (output, context) => {\n    const contents = {};\n    if (output[_bW] != null) {\n        contents[_BW] = __expectString(output[_bW]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateOverrides = (output, context) => {\n    const contents = {};\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_sPp] != null) {\n        contents[_SPp] = __expectString(output[_sPp]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_wC] != null) {\n        contents[_WCe] = __strictParseFloat(output[_wC]);\n    }\n    if (output[_pri] != null) {\n        contents[_Pri] = __strictParseFloat(output[_pri]);\n    }\n    if (output[_iR] != null) {\n        contents[_IR] = de_InstanceRequirements(output[_iR], context);\n    }\n    return contents;\n};\nconst de_LaunchTemplateOverridesList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LaunchTemplateOverrides(entry, context);\n    });\n};\nconst de_LaunchTemplatePlacement = (output, context) => {\n    const contents = {};\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_af] != null) {\n        contents[_Af] = __expectString(output[_af]);\n    }\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    if (output[_hI] != null) {\n        contents[_HIo] = __expectString(output[_hI]);\n    }\n    if (output[_t] != null) {\n        contents[_Te] = __expectString(output[_t]);\n    }\n    if (output[_sDp] != null) {\n        contents[_SDp] = __expectString(output[_sDp]);\n    }\n    if (output[_hRGA] != null) {\n        contents[_HRGA] = __expectString(output[_hRGA]);\n    }\n    if (output[_pN] != null) {\n        contents[_PN] = __strictParseInt32(output[_pN]);\n    }\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    return contents;\n};\nconst de_LaunchTemplatePrivateDnsNameOptions = (output, context) => {\n    const contents = {};\n    if (output[_hTo] != null) {\n        contents[_HTo] = __expectString(output[_hTo]);\n    }\n    if (output[_eRNDAR] != null) {\n        contents[_ERNDAR] = __parseBoolean(output[_eRNDAR]);\n    }\n    if (output[_eRNDAAAAR] != null) {\n        contents[_ERNDAAAAR] = __parseBoolean(output[_eRNDAAAAR]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LaunchTemplate(entry, context);\n    });\n};\nconst de_LaunchTemplatesMonitoring = (output, context) => {\n    const contents = {};\n    if (output[_en] != null) {\n        contents[_En] = __parseBoolean(output[_en]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateSpotMarketOptions = (output, context) => {\n    const contents = {};\n    if (output[_mP] != null) {\n        contents[_MPa] = __expectString(output[_mP]);\n    }\n    if (output[_sIT] != null) {\n        contents[_SIT] = __expectString(output[_sIT]);\n    }\n    if (output[_bDMl] != null) {\n        contents[_BDMl] = __strictParseInt32(output[_bDMl]);\n    }\n    if (output[_vU] != null) {\n        contents[_VU] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vU]));\n    }\n    if (output[_iIB] != null) {\n        contents[_IIB] = __expectString(output[_iIB]);\n    }\n    return contents;\n};\nconst de_LaunchTemplateTagSpecification = (output, context) => {\n    const contents = {};\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_LaunchTemplateTagSpecificationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LaunchTemplateTagSpecification(entry, context);\n    });\n};\nconst de_LaunchTemplateVersion = (output, context) => {\n    const contents = {};\n    if (output[_lTI] != null) {\n        contents[_LTI] = __expectString(output[_lTI]);\n    }\n    if (output[_lTN] != null) {\n        contents[_LTN] = __expectString(output[_lTN]);\n    }\n    if (output[_vNe] != null) {\n        contents[_VNe] = __strictParseLong(output[_vNe]);\n    }\n    if (output[_vD] != null) {\n        contents[_VD] = __expectString(output[_vD]);\n    }\n    if (output[_cTr] != null) {\n        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));\n    }\n    if (output[_cBr] != null) {\n        contents[_CBr] = __expectString(output[_cBr]);\n    }\n    if (output[_dVe] != null) {\n        contents[_DVef] = __parseBoolean(output[_dVe]);\n    }\n    if (output[_lTD] != null) {\n        contents[_LTD] = de_ResponseLaunchTemplateData(output[_lTD], context);\n    }\n    if (output[_op] != null) {\n        contents[_O] = de_OperatorResponse(output[_op], context);\n    }\n    return contents;\n};\nconst de_LaunchTemplateVersionSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LaunchTemplateVersion(entry, context);\n    });\n};\nconst de_LicenseConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_lCA] != null) {\n        contents[_LCA] = __expectString(output[_lCA]);\n    }\n    return contents;\n};\nconst de_LicenseList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LicenseConfiguration(entry, context);\n    });\n};\nconst de_ListImagesInRecycleBinResult = (output, context) => {\n    const contents = {};\n    if (output.imageSet === \"\") {\n        contents[_Ima] = [];\n    }\n    else if (output[_iSmag] != null && output[_iSmag][_i] != null) {\n        contents[_Ima] = de_ImageRecycleBinInfoList(__getArrayIfSingleItem(output[_iSmag][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_ListSnapshotsInRecycleBinResult = (output, context) => {\n    const contents = {};\n    if (output.snapshotSet === \"\") {\n        contents[_Sn] = [];\n    }\n    else if (output[_sS] != null && output[_sS][_i] != null) {\n        contents[_Sn] = de_SnapshotRecycleBinInfoList(__getArrayIfSingleItem(output[_sS][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_LoadBalancersConfig = (output, context) => {\n    const contents = {};\n    if (output[_cLBC] != null) {\n        contents[_CLBC] = de_ClassicLoadBalancersConfig(output[_cLBC], context);\n    }\n    if (output[_tGCa] != null) {\n        contents[_TGC] = de_TargetGroupsConfig(output[_tGCa], context);\n    }\n    return contents;\n};\nconst de_LoadPermission = (output, context) => {\n    const contents = {};\n    if (output[_uI] != null) {\n        contents[_UIs] = __expectString(output[_uI]);\n    }\n    if (output[_g] != null) {\n        contents[_Gr] = __expectString(output[_g]);\n    }\n    return contents;\n};\nconst de_LoadPermissionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LoadPermission(entry, context);\n    });\n};\nconst de_LocalGateway = (output, context) => {\n    const contents = {};\n    if (output[_lGI] != null) {\n        contents[_LGI] = __expectString(output[_lGI]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_LocalGatewayRoute = (output, context) => {\n    const contents = {};\n    if (output[_dCB] != null) {\n        contents[_DCB] = __expectString(output[_dCB]);\n    }\n    if (output[_lGVIGI] != null) {\n        contents[_LGVIGI] = __expectString(output[_lGVIGI]);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_lGRTI] != null) {\n        contents[_LGRTI] = __expectString(output[_lGRTI]);\n    }\n    if (output[_lGRTA] != null) {\n        contents[_LGRTA] = __expectString(output[_lGRTA]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_cPI] != null) {\n        contents[_CPIo] = __expectString(output[_cPI]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_dPLI] != null) {\n        contents[_DPLI] = __expectString(output[_dPLI]);\n    }\n    return contents;\n};\nconst de_LocalGatewayRouteList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LocalGatewayRoute(entry, context);\n    });\n};\nconst de_LocalGatewayRouteTable = (output, context) => {\n    const contents = {};\n    if (output[_lGRTI] != null) {\n        contents[_LGRTI] = __expectString(output[_lGRTI]);\n    }\n    if (output[_lGRTA] != null) {\n        contents[_LGRTA] = __expectString(output[_lGRTA]);\n    }\n    if (output[_lGI] != null) {\n        contents[_LGI] = __expectString(output[_lGI]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_mod] != null) {\n        contents[_Mo] = __expectString(output[_mod]);\n    }\n    if (output[_sRt] != null) {\n        contents[_SRt] = de_StateReason(output[_sRt], context);\n    }\n    return contents;\n};\nconst de_LocalGatewayRouteTableSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LocalGatewayRouteTable(entry, context);\n    });\n};\nconst de_LocalGatewayRouteTableVirtualInterfaceGroupAssociation = (output, context) => {\n    const contents = {};\n    if (output[_lGRTVIGAI] != null) {\n        contents[_LGRTVIGAI] = __expectString(output[_lGRTVIGAI]);\n    }\n    if (output[_lGVIGI] != null) {\n        contents[_LGVIGI] = __expectString(output[_lGVIGI]);\n    }\n    if (output[_lGI] != null) {\n        contents[_LGI] = __expectString(output[_lGI]);\n    }\n    if (output[_lGRTI] != null) {\n        contents[_LGRTI] = __expectString(output[_lGRTI]);\n    }\n    if (output[_lGRTA] != null) {\n        contents[_LGRTA] = __expectString(output[_lGRTA]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LocalGatewayRouteTableVirtualInterfaceGroupAssociation(entry, context);\n    });\n};\nconst de_LocalGatewayRouteTableVpcAssociation = (output, context) => {\n    const contents = {};\n    if (output[_lGRTVAI] != null) {\n        contents[_LGRTVAI] = __expectString(output[_lGRTVAI]);\n    }\n    if (output[_lGRTI] != null) {\n        contents[_LGRTI] = __expectString(output[_lGRTI]);\n    }\n    if (output[_lGRTA] != null) {\n        contents[_LGRTA] = __expectString(output[_lGRTA]);\n    }\n    if (output[_lGI] != null) {\n        contents[_LGI] = __expectString(output[_lGI]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_LocalGatewayRouteTableVpcAssociationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LocalGatewayRouteTableVpcAssociation(entry, context);\n    });\n};\nconst de_LocalGatewaySet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LocalGateway(entry, context);\n    });\n};\nconst de_LocalGatewayVirtualInterface = (output, context) => {\n    const contents = {};\n    if (output[_lGVII] != null) {\n        contents[_LGVII] = __expectString(output[_lGVII]);\n    }\n    if (output[_lGI] != null) {\n        contents[_LGI] = __expectString(output[_lGI]);\n    }\n    if (output[_lGVIGI] != null) {\n        contents[_LGVIGI] = __expectString(output[_lGVIGI]);\n    }\n    if (output[_lGVIA] != null) {\n        contents[_LGVIA] = __expectString(output[_lGVIA]);\n    }\n    if (output[_oLI] != null) {\n        contents[_OLI] = __expectString(output[_oLI]);\n    }\n    if (output[_vl] != null) {\n        contents[_Vl] = __strictParseInt32(output[_vl]);\n    }\n    if (output[_lA] != null) {\n        contents[_LA] = __expectString(output[_lA]);\n    }\n    if (output[_pAe] != null) {\n        contents[_PAe] = __expectString(output[_pAe]);\n    }\n    if (output[_lBAo] != null) {\n        contents[_LBA] = __strictParseInt32(output[_lBAo]);\n    }\n    if (output[_pBA] != null) {\n        contents[_PBA] = __strictParseInt32(output[_pBA]);\n    }\n    if (output[_pBAE] != null) {\n        contents[_PBAE] = __strictParseLong(output[_pBAE]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_cSon] != null) {\n        contents[_CSon] = __expectString(output[_cSon]);\n    }\n    return contents;\n};\nconst de_LocalGatewayVirtualInterfaceGroup = (output, context) => {\n    const contents = {};\n    if (output[_lGVIGI] != null) {\n        contents[_LGVIGI] = __expectString(output[_lGVIGI]);\n    }\n    if (output.localGatewayVirtualInterfaceIdSet === \"\") {\n        contents[_LGVIIo] = [];\n    }\n    else if (output[_lGVIIS] != null && output[_lGVIIS][_i] != null) {\n        contents[_LGVIIo] = de_LocalGatewayVirtualInterfaceIdSet(__getArrayIfSingleItem(output[_lGVIIS][_i]), context);\n    }\n    if (output[_lGI] != null) {\n        contents[_LGI] = __expectString(output[_lGI]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_lBAo] != null) {\n        contents[_LBA] = __strictParseInt32(output[_lBAo]);\n    }\n    if (output[_lBAE] != null) {\n        contents[_LBAE] = __strictParseLong(output[_lBAE]);\n    }\n    if (output[_lGVIGA] != null) {\n        contents[_LGVIGA] = __expectString(output[_lGVIGA]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_cSon] != null) {\n        contents[_CSon] = __expectString(output[_cSon]);\n    }\n    return contents;\n};\nconst de_LocalGatewayVirtualInterfaceGroupSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LocalGatewayVirtualInterfaceGroup(entry, context);\n    });\n};\nconst de_LocalGatewayVirtualInterfaceIdSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_LocalGatewayVirtualInterfaceSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LocalGatewayVirtualInterface(entry, context);\n    });\n};\nconst de_LocalStorageTypeSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_LockedSnapshotsInfo = (output, context) => {\n    const contents = {};\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_lSoc] != null) {\n        contents[_LSoc] = __expectString(output[_lSoc]);\n    }\n    if (output[_lDo] != null) {\n        contents[_LDo] = __strictParseInt32(output[_lDo]);\n    }\n    if (output[_cOP] != null) {\n        contents[_COP] = __strictParseInt32(output[_cOP]);\n    }\n    if (output[_cOPEO] != null) {\n        contents[_COPEO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cOPEO]));\n    }\n    if (output[_lCO] != null) {\n        contents[_LCO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lCO]));\n    }\n    if (output[_lDST] != null) {\n        contents[_LDST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lDST]));\n    }\n    if (output[_lEO] != null) {\n        contents[_LEO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lEO]));\n    }\n    return contents;\n};\nconst de_LockedSnapshotsInfoList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_LockedSnapshotsInfo(entry, context);\n    });\n};\nconst de_LockSnapshotResult = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_lSoc] != null) {\n        contents[_LSoc] = __expectString(output[_lSoc]);\n    }\n    if (output[_lDo] != null) {\n        contents[_LDo] = __strictParseInt32(output[_lDo]);\n    }\n    if (output[_cOP] != null) {\n        contents[_COP] = __strictParseInt32(output[_cOP]);\n    }\n    if (output[_cOPEO] != null) {\n        contents[_COPEO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cOPEO]));\n    }\n    if (output[_lCO] != null) {\n        contents[_LCO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lCO]));\n    }\n    if (output[_lEO] != null) {\n        contents[_LEO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lEO]));\n    }\n    if (output[_lDST] != null) {\n        contents[_LDST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lDST]));\n    }\n    return contents;\n};\nconst de_MacHost = (output, context) => {\n    const contents = {};\n    if (output[_hI] != null) {\n        contents[_HIo] = __expectString(output[_hI]);\n    }\n    if (output.macOSLatestSupportedVersionSet === \"\") {\n        contents[_MOSLSV] = [];\n    }\n    else if (output[_mOSLSVS] != null && output[_mOSLSVS][_i] != null) {\n        contents[_MOSLSV] = de_MacOSVersionStringList(__getArrayIfSingleItem(output[_mOSLSVS][_i]), context);\n    }\n    return contents;\n};\nconst de_MacHostList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MacHost(entry, context);\n    });\n};\nconst de_MacModificationTask = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_mMTI] != null) {\n        contents[_MMTIa] = __expectString(output[_mMTI]);\n    }\n    if (output[_mSIPC] != null) {\n        contents[_MSIPCa] = de_MacSystemIntegrityProtectionConfiguration(output[_mSIPC], context);\n    }\n    if (output[_sT] != null) {\n        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_tSas] != null) {\n        contents[_TSas] = __expectString(output[_tSas]);\n    }\n    if (output[_tTa] != null) {\n        contents[_TTa] = __expectString(output[_tTa]);\n    }\n    return contents;\n};\nconst de_MacModificationTaskList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MacModificationTask(entry, context);\n    });\n};\nconst de_MacOSVersionStringList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_MacSystemIntegrityProtectionConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_aIp] != null) {\n        contents[_AIp] = __expectString(output[_aIp]);\n    }\n    if (output[_bSa] != null) {\n        contents[_BS] = __expectString(output[_bSa]);\n    }\n    if (output[_dRe] != null) {\n        contents[_DReb] = __expectString(output[_dRe]);\n    }\n    if (output[_dTR] != null) {\n        contents[_DTR] = __expectString(output[_dTR]);\n    }\n    if (output[_fPi] != null) {\n        contents[_FPi] = __expectString(output[_fPi]);\n    }\n    if (output[_kSe] != null) {\n        contents[_KS] = __expectString(output[_kSe]);\n    }\n    if (output[_nP] != null) {\n        contents[_NP] = __expectString(output[_nP]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_MaintenanceDetails = (output, context) => {\n    const contents = {};\n    if (output[_pM] != null) {\n        contents[_PM] = __expectString(output[_pM]);\n    }\n    if (output[_mAAA] != null) {\n        contents[_MAAA] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_mAAA]));\n    }\n    if (output[_lMA] != null) {\n        contents[_LMA] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lMA]));\n    }\n    return contents;\n};\nconst de_ManagedPrefixList = (output, context) => {\n    const contents = {};\n    if (output[_pLI] != null) {\n        contents[_PLI] = __expectString(output[_pLI]);\n    }\n    if (output[_aF] != null) {\n        contents[_AF] = __expectString(output[_aF]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sMta] != null) {\n        contents[_SMta] = __expectString(output[_sMta]);\n    }\n    if (output[_pLA] != null) {\n        contents[_PLAr] = __expectString(output[_pLA]);\n    }\n    if (output[_pLN] != null) {\n        contents[_PLN] = __expectString(output[_pLN]);\n    }\n    if (output[_mE] != null) {\n        contents[_ME] = __strictParseInt32(output[_mE]);\n    }\n    if (output[_ve] != null) {\n        contents[_V] = __strictParseLong(output[_ve]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    return contents;\n};\nconst de_ManagedPrefixListSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ManagedPrefixList(entry, context);\n    });\n};\nconst de_MediaAcceleratorInfo = (output, context) => {\n    const contents = {};\n    if (output.accelerators === \"\") {\n        contents[_Acc] = [];\n    }\n    else if (output[_acc] != null && output[_acc][_i] != null) {\n        contents[_Acc] = de_MediaDeviceInfoList(__getArrayIfSingleItem(output[_acc][_i]), context);\n    }\n    if (output[_tMMIMB] != null) {\n        contents[_TMMIMB] = __strictParseInt32(output[_tMMIMB]);\n    }\n    return contents;\n};\nconst de_MediaDeviceInfo = (output, context) => {\n    const contents = {};\n    if (output[_cou] != null) {\n        contents[_Cou] = __strictParseInt32(output[_cou]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_man] != null) {\n        contents[_Man] = __expectString(output[_man]);\n    }\n    if (output[_mIe] != null) {\n        contents[_MIe] = de_MediaDeviceMemoryInfo(output[_mIe], context);\n    }\n    return contents;\n};\nconst de_MediaDeviceInfoList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MediaDeviceInfo(entry, context);\n    });\n};\nconst de_MediaDeviceMemoryInfo = (output, context) => {\n    const contents = {};\n    if (output[_sIMB] != null) {\n        contents[_SIMB] = __strictParseInt32(output[_sIMB]);\n    }\n    return contents;\n};\nconst de_MemoryGiBPerVCpu = (output, context) => {\n    const contents = {};\n    if (output[_m] != null) {\n        contents[_M] = __strictParseFloat(output[_m]);\n    }\n    if (output[_ma] != null) {\n        contents[_Ma] = __strictParseFloat(output[_ma]);\n    }\n    return contents;\n};\nconst de_MemoryInfo = (output, context) => {\n    const contents = {};\n    if (output[_sIMB] != null) {\n        contents[_SIMB] = __strictParseLong(output[_sIMB]);\n    }\n    return contents;\n};\nconst de_MemoryMiB = (output, context) => {\n    const contents = {};\n    if (output[_m] != null) {\n        contents[_M] = __strictParseInt32(output[_m]);\n    }\n    if (output[_ma] != null) {\n        contents[_Ma] = __strictParseInt32(output[_ma]);\n    }\n    return contents;\n};\nconst de_MetricPoint = (output, context) => {\n    const contents = {};\n    if (output[_sD] != null) {\n        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));\n    }\n    if (output[_eD] != null) {\n        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));\n    }\n    if (output[_v] != null) {\n        contents[_Va] = __strictParseFloat(output[_v]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_MetricPoints = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MetricPoint(entry, context);\n    });\n};\nconst de_ModifyAddressAttributeResult = (output, context) => {\n    const contents = {};\n    if (output[_ad] != null) {\n        contents[_Ad] = de_AddressAttribute(output[_ad], context);\n    }\n    return contents;\n};\nconst de_ModifyAvailabilityZoneGroupResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyCapacityReservationFleetResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyCapacityReservationResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyClientVpnEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyDefaultCreditSpecificationResult = (output, context) => {\n    const contents = {};\n    if (output[_iFCS] != null) {\n        contents[_IFCS] = de_InstanceFamilyCreditSpecification(output[_iFCS], context);\n    }\n    return contents;\n};\nconst de_ModifyEbsDefaultKmsKeyIdResult = (output, context) => {\n    const contents = {};\n    if (output[_kKI] != null) {\n        contents[_KKI] = __expectString(output[_kKI]);\n    }\n    return contents;\n};\nconst de_ModifyFleetResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyFpgaImageAttributeResult = (output, context) => {\n    const contents = {};\n    if (output[_fIA] != null) {\n        contents[_FIAp] = de_FpgaImageAttribute(output[_fIA], context);\n    }\n    return contents;\n};\nconst de_ModifyHostsResult = (output, context) => {\n    const contents = {};\n    if (output.successful === \"\") {\n        contents[_Suc] = [];\n    }\n    else if (output[_suc] != null && output[_suc][_i] != null) {\n        contents[_Suc] = de_ResponseHostIdList(__getArrayIfSingleItem(output[_suc][_i]), context);\n    }\n    if (output.unsuccessful === \"\") {\n        contents[_Un] = [];\n    }\n    else if (output[_u] != null && output[_u][_i] != null) {\n        contents[_Un] = de_UnsuccessfulItemList(__getArrayIfSingleItem(output[_u][_i]), context);\n    }\n    return contents;\n};\nconst de_ModifyInstanceCapacityReservationAttributesResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyInstanceCpuOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_cCo] != null) {\n        contents[_CC] = __strictParseInt32(output[_cCo]);\n    }\n    if (output[_tPC] != null) {\n        contents[_TPC] = __strictParseInt32(output[_tPC]);\n    }\n    return contents;\n};\nconst de_ModifyInstanceCreditSpecificationResult = (output, context) => {\n    const contents = {};\n    if (output.successfulInstanceCreditSpecificationSet === \"\") {\n        contents[_SICS] = [];\n    }\n    else if (output[_sICSS] != null && output[_sICSS][_i] != null) {\n        contents[_SICS] = de_SuccessfulInstanceCreditSpecificationSet(__getArrayIfSingleItem(output[_sICSS][_i]), context);\n    }\n    if (output.unsuccessfulInstanceCreditSpecificationSet === \"\") {\n        contents[_UICS] = [];\n    }\n    else if (output[_uICSS] != null && output[_uICSS][_i] != null) {\n        contents[_UICS] = de_UnsuccessfulInstanceCreditSpecificationSet(__getArrayIfSingleItem(output[_uICSS][_i]), context);\n    }\n    return contents;\n};\nconst de_ModifyInstanceEventStartTimeResult = (output, context) => {\n    const contents = {};\n    if (output[_ev] != null) {\n        contents[_Eve] = de_InstanceStatusEvent(output[_ev], context);\n    }\n    return contents;\n};\nconst de_ModifyInstanceEventWindowResult = (output, context) => {\n    const contents = {};\n    if (output[_iEW] != null) {\n        contents[_IEW] = de_InstanceEventWindow(output[_iEW], context);\n    }\n    return contents;\n};\nconst de_ModifyInstanceMaintenanceOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_aRu] != null) {\n        contents[_ARu] = __expectString(output[_aRu]);\n    }\n    if (output[_rM] != null) {\n        contents[_RMe] = __expectString(output[_rM]);\n    }\n    return contents;\n};\nconst de_ModifyInstanceMetadataDefaultsResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyInstanceMetadataOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_iMO] != null) {\n        contents[_IMOn] = de_InstanceMetadataOptionsResponse(output[_iMO], context);\n    }\n    return contents;\n};\nconst de_ModifyInstanceNetworkPerformanceResult = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_bW] != null) {\n        contents[_BW] = __expectString(output[_bW]);\n    }\n    return contents;\n};\nconst de_ModifyInstancePlacementResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyIpamPoolResult = (output, context) => {\n    const contents = {};\n    if (output[_iPp] != null) {\n        contents[_IPpa] = de_IpamPool(output[_iPp], context);\n    }\n    return contents;\n};\nconst de_ModifyIpamResourceCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_iRC] != null) {\n        contents[_IRCp] = de_IpamResourceCidr(output[_iRC], context);\n    }\n    return contents;\n};\nconst de_ModifyIpamResourceDiscoveryResult = (output, context) => {\n    const contents = {};\n    if (output[_iRD] != null) {\n        contents[_IRD] = de_IpamResourceDiscovery(output[_iRD], context);\n    }\n    return contents;\n};\nconst de_ModifyIpamResult = (output, context) => {\n    const contents = {};\n    if (output[_ip] != null) {\n        contents[_Ipa] = de_Ipam(output[_ip], context);\n    }\n    return contents;\n};\nconst de_ModifyIpamScopeResult = (output, context) => {\n    const contents = {};\n    if (output[_iS] != null) {\n        contents[_ISpa] = de_IpamScope(output[_iS], context);\n    }\n    return contents;\n};\nconst de_ModifyLaunchTemplateResult = (output, context) => {\n    const contents = {};\n    if (output[_lT] != null) {\n        contents[_LTa] = de_LaunchTemplate(output[_lT], context);\n    }\n    return contents;\n};\nconst de_ModifyLocalGatewayRouteResult = (output, context) => {\n    const contents = {};\n    if (output[_ro] != null) {\n        contents[_Rou] = de_LocalGatewayRoute(output[_ro], context);\n    }\n    return contents;\n};\nconst de_ModifyManagedPrefixListResult = (output, context) => {\n    const contents = {};\n    if (output[_pL] != null) {\n        contents[_PLr] = de_ManagedPrefixList(output[_pL], context);\n    }\n    return contents;\n};\nconst de_ModifyPrivateDnsNameOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyPublicIpDnsNameOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_suc] != null) {\n        contents[_Suc] = __parseBoolean(output[_suc]);\n    }\n    return contents;\n};\nconst de_ModifyReservedInstancesResult = (output, context) => {\n    const contents = {};\n    if (output[_rIMI] != null) {\n        contents[_RIMIe] = __expectString(output[_rIMI]);\n    }\n    return contents;\n};\nconst de_ModifyRouteServerResult = (output, context) => {\n    const contents = {};\n    if (output[_rSo] != null) {\n        contents[_RSo] = de_RouteServer(output[_rSo], context);\n    }\n    return contents;\n};\nconst de_ModifySecurityGroupRulesResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifySnapshotTierResult = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_tST] != null) {\n        contents[_TST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tST]));\n    }\n    return contents;\n};\nconst de_ModifySpotFleetRequestResponse = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyTrafficMirrorFilterNetworkServicesResult = (output, context) => {\n    const contents = {};\n    if (output[_tMF] != null) {\n        contents[_TMF] = de_TrafficMirrorFilter(output[_tMF], context);\n    }\n    return contents;\n};\nconst de_ModifyTrafficMirrorFilterRuleResult = (output, context) => {\n    const contents = {};\n    if (output[_tMFR] != null) {\n        contents[_TMFR] = de_TrafficMirrorFilterRule(output[_tMFR], context);\n    }\n    return contents;\n};\nconst de_ModifyTrafficMirrorSessionResult = (output, context) => {\n    const contents = {};\n    if (output[_tMS] != null) {\n        contents[_TMS] = de_TrafficMirrorSession(output[_tMS], context);\n    }\n    return contents;\n};\nconst de_ModifyTransitGatewayPrefixListReferenceResult = (output, context) => {\n    const contents = {};\n    if (output[_tGPLR] != null) {\n        contents[_TGPLR] = de_TransitGatewayPrefixListReference(output[_tGPLR], context);\n    }\n    return contents;\n};\nconst de_ModifyTransitGatewayResult = (output, context) => {\n    const contents = {};\n    if (output[_tG] != null) {\n        contents[_TGr] = de_TransitGateway(output[_tG], context);\n    }\n    return contents;\n};\nconst de_ModifyTransitGatewayVpcAttachmentResult = (output, context) => {\n    const contents = {};\n    if (output[_tGVA] != null) {\n        contents[_TGVA] = de_TransitGatewayVpcAttachment(output[_tGVA], context);\n    }\n    return contents;\n};\nconst de_ModifyVerifiedAccessEndpointPolicyResult = (output, context) => {\n    const contents = {};\n    if (output[_pE] != null) {\n        contents[_PE] = __parseBoolean(output[_pE]);\n    }\n    if (output[_pDo] != null) {\n        contents[_PD] = __expectString(output[_pDo]);\n    }\n    if (output[_sSs] != null) {\n        contents[_SS] = de_VerifiedAccessSseSpecificationResponse(output[_sSs], context);\n    }\n    return contents;\n};\nconst de_ModifyVerifiedAccessEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_vAE] != null) {\n        contents[_VAE] = de_VerifiedAccessEndpoint(output[_vAE], context);\n    }\n    return contents;\n};\nconst de_ModifyVerifiedAccessGroupPolicyResult = (output, context) => {\n    const contents = {};\n    if (output[_pE] != null) {\n        contents[_PE] = __parseBoolean(output[_pE]);\n    }\n    if (output[_pDo] != null) {\n        contents[_PD] = __expectString(output[_pDo]);\n    }\n    if (output[_sSs] != null) {\n        contents[_SS] = de_VerifiedAccessSseSpecificationResponse(output[_sSs], context);\n    }\n    return contents;\n};\nconst de_ModifyVerifiedAccessGroupResult = (output, context) => {\n    const contents = {};\n    if (output[_vAG] != null) {\n        contents[_VAG] = de_VerifiedAccessGroup(output[_vAG], context);\n    }\n    return contents;\n};\nconst de_ModifyVerifiedAccessInstanceLoggingConfigurationResult = (output, context) => {\n    const contents = {};\n    if (output[_lC] != null) {\n        contents[_LCo] = de_VerifiedAccessInstanceLoggingConfiguration(output[_lC], context);\n    }\n    return contents;\n};\nconst de_ModifyVerifiedAccessInstanceResult = (output, context) => {\n    const contents = {};\n    if (output[_vAI] != null) {\n        contents[_VAI] = de_VerifiedAccessInstance(output[_vAI], context);\n    }\n    return contents;\n};\nconst de_ModifyVerifiedAccessTrustProviderResult = (output, context) => {\n    const contents = {};\n    if (output[_vATP] != null) {\n        contents[_VATP] = de_VerifiedAccessTrustProvider(output[_vATP], context);\n    }\n    return contents;\n};\nconst de_ModifyVolumeResult = (output, context) => {\n    const contents = {};\n    if (output[_vM] != null) {\n        contents[_VMol] = de_VolumeModification(output[_vM], context);\n    }\n    return contents;\n};\nconst de_ModifyVpcBlockPublicAccessExclusionResult = (output, context) => {\n    const contents = {};\n    if (output[_vBPAE] != null) {\n        contents[_VBPAE] = de_VpcBlockPublicAccessExclusion(output[_vBPAE], context);\n    }\n    return contents;\n};\nconst de_ModifyVpcBlockPublicAccessOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_vBPAO] != null) {\n        contents[_VBPAO] = de_VpcBlockPublicAccessOptions(output[_vBPAO], context);\n    }\n    return contents;\n};\nconst de_ModifyVpcEndpointConnectionNotificationResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_RV] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyVpcEndpointResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyVpcEndpointServiceConfigurationResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyVpcEndpointServicePayerResponsibilityResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_RV] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyVpcEndpointServicePermissionsResult = (output, context) => {\n    const contents = {};\n    if (output.addedPrincipalSet === \"\") {\n        contents[_APd] = [];\n    }\n    else if (output[_aPS] != null && output[_aPS][_i] != null) {\n        contents[_APd] = de_AddedPrincipalSet(__getArrayIfSingleItem(output[_aPS][_i]), context);\n    }\n    if (output[_r] != null) {\n        contents[_RV] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyVpcPeeringConnectionOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_aPCO] != null) {\n        contents[_APCO] = de_PeeringConnectionOptions(output[_aPCO], context);\n    }\n    if (output[_rPCO] != null) {\n        contents[_RPCO] = de_PeeringConnectionOptions(output[_rPCO], context);\n    }\n    return contents;\n};\nconst de_ModifyVpcTenancyResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_RV] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ModifyVpnConnectionOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_vC] != null) {\n        contents[_VC] = de_VpnConnection(output[_vC], context);\n    }\n    return contents;\n};\nconst de_ModifyVpnConnectionResult = (output, context) => {\n    const contents = {};\n    if (output[_vC] != null) {\n        contents[_VC] = de_VpnConnection(output[_vC], context);\n    }\n    return contents;\n};\nconst de_ModifyVpnTunnelCertificateResult = (output, context) => {\n    const contents = {};\n    if (output[_vC] != null) {\n        contents[_VC] = de_VpnConnection(output[_vC], context);\n    }\n    return contents;\n};\nconst de_ModifyVpnTunnelOptionsResult = (output, context) => {\n    const contents = {};\n    if (output[_vC] != null) {\n        contents[_VC] = de_VpnConnection(output[_vC], context);\n    }\n    return contents;\n};\nconst de_Monitoring = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_MonitorInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.instancesSet === \"\") {\n        contents[_IMn] = [];\n    }\n    else if (output[_iSn] != null && output[_iSn][_i] != null) {\n        contents[_IMn] = de_InstanceMonitoringList(__getArrayIfSingleItem(output[_iSn][_i]), context);\n    }\n    return contents;\n};\nconst de_MoveAddressToVpcResult = (output, context) => {\n    const contents = {};\n    if (output[_aI] != null) {\n        contents[_AIl] = __expectString(output[_aI]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_MoveByoipCidrToIpamResult = (output, context) => {\n    const contents = {};\n    if (output[_bC] != null) {\n        contents[_BC] = de_ByoipCidr(output[_bC], context);\n    }\n    return contents;\n};\nconst de_MoveCapacityReservationInstancesResult = (output, context) => {\n    const contents = {};\n    if (output[_sCR] != null) {\n        contents[_SCR] = de_CapacityReservation(output[_sCR], context);\n    }\n    if (output[_dCR] != null) {\n        contents[_DCRe] = de_CapacityReservation(output[_dCR], context);\n    }\n    if (output[_iC] != null) {\n        contents[_IC] = __strictParseInt32(output[_iC]);\n    }\n    return contents;\n};\nconst de_MovingAddressStatus = (output, context) => {\n    const contents = {};\n    if (output[_mSo] != null) {\n        contents[_MSo] = __expectString(output[_mSo]);\n    }\n    if (output[_pI] != null) {\n        contents[_PI] = __expectString(output[_pI]);\n    }\n    return contents;\n};\nconst de_MovingAddressStatusSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MovingAddressStatus(entry, context);\n    });\n};\nconst de_NatGateway = (output, context) => {\n    const contents = {};\n    if (output[_cTr] != null) {\n        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));\n    }\n    if (output[_dTel] != null) {\n        contents[_DTele] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTel]));\n    }\n    if (output[_fCa] != null) {\n        contents[_FCa] = __expectString(output[_fCa]);\n    }\n    if (output[_fM] != null) {\n        contents[_FM] = __expectString(output[_fM]);\n    }\n    if (output.natGatewayAddressSet === \"\") {\n        contents[_NGA] = [];\n    }\n    else if (output[_nGAS] != null && output[_nGAS][_i] != null) {\n        contents[_NGA] = de_NatGatewayAddressList(__getArrayIfSingleItem(output[_nGAS][_i]), context);\n    }\n    if (output[_nGI] != null) {\n        contents[_NGI] = __expectString(output[_nGI]);\n    }\n    if (output[_pB] != null) {\n        contents[_PB] = de_ProvisionedBandwidth(output[_pB], context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_cTonn] != null) {\n        contents[_CTo] = __expectString(output[_cTonn]);\n    }\n    return contents;\n};\nconst de_NatGatewayAddress = (output, context) => {\n    const contents = {};\n    if (output[_aI] != null) {\n        contents[_AIl] = __expectString(output[_aI]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_pIriv] != null) {\n        contents[_PIri] = __expectString(output[_pIriv]);\n    }\n    if (output[_pI] != null) {\n        contents[_PI] = __expectString(output[_pI]);\n    }\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_iPsr] != null) {\n        contents[_IPsr] = __parseBoolean(output[_iPsr]);\n    }\n    if (output[_fM] != null) {\n        contents[_FM] = __expectString(output[_fM]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_NatGatewayAddressList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NatGatewayAddress(entry, context);\n    });\n};\nconst de_NatGatewayList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NatGateway(entry, context);\n    });\n};\nconst de_NativeApplicationOidcOptions = (output, context) => {\n    const contents = {};\n    if (output[_pSKE] != null) {\n        contents[_PSKE] = __expectString(output[_pSKE]);\n    }\n    if (output[_is] != null) {\n        contents[_I] = __expectString(output[_is]);\n    }\n    if (output[_aE] != null) {\n        contents[_AE] = __expectString(output[_aE]);\n    }\n    if (output[_tEo] != null) {\n        contents[_TEo] = __expectString(output[_tEo]);\n    }\n    if (output[_uIE] != null) {\n        contents[_UIE] = __expectString(output[_uIE]);\n    }\n    if (output[_cIli] != null) {\n        contents[_CIl] = __expectString(output[_cIli]);\n    }\n    if (output[_sc] != null) {\n        contents[_Sc] = __expectString(output[_sc]);\n    }\n    return contents;\n};\nconst de_NetworkAcl = (output, context) => {\n    const contents = {};\n    if (output.associationSet === \"\") {\n        contents[_Ass] = [];\n    }\n    else if (output[_aSss] != null && output[_aSss][_i] != null) {\n        contents[_Ass] = de_NetworkAclAssociationList(__getArrayIfSingleItem(output[_aSss][_i]), context);\n    }\n    if (output.entrySet === \"\") {\n        contents[_Ent] = [];\n    }\n    else if (output[_eSnt] != null && output[_eSnt][_i] != null) {\n        contents[_Ent] = de_NetworkAclEntryList(__getArrayIfSingleItem(output[_eSnt][_i]), context);\n    }\n    if (output[_def] != null) {\n        contents[_IDs] = __parseBoolean(output[_def]);\n    }\n    if (output[_nAI] != null) {\n        contents[_NAI] = __expectString(output[_nAI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    return contents;\n};\nconst de_NetworkAclAssociation = (output, context) => {\n    const contents = {};\n    if (output[_nAAI] != null) {\n        contents[_NAAI] = __expectString(output[_nAAI]);\n    }\n    if (output[_nAI] != null) {\n        contents[_NAI] = __expectString(output[_nAI]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    return contents;\n};\nconst de_NetworkAclAssociationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkAclAssociation(entry, context);\n    });\n};\nconst de_NetworkAclEntry = (output, context) => {\n    const contents = {};\n    if (output[_cB] != null) {\n        contents[_CB] = __expectString(output[_cB]);\n    }\n    if (output[_e] != null) {\n        contents[_Eg] = __parseBoolean(output[_e]);\n    }\n    if (output[_iTC] != null) {\n        contents[_ITC] = de_IcmpTypeCode(output[_iTC], context);\n    }\n    if (output[_iCB] != null) {\n        contents[_ICB] = __expectString(output[_iCB]);\n    }\n    if (output[_pRo] != null) {\n        contents[_PR] = de_PortRange(output[_pRo], context);\n    }\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    if (output[_rA] != null) {\n        contents[_RAu] = __expectString(output[_rA]);\n    }\n    if (output[_rN] != null) {\n        contents[_RNu] = __strictParseInt32(output[_rN]);\n    }\n    return contents;\n};\nconst de_NetworkAclEntryList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkAclEntry(entry, context);\n    });\n};\nconst de_NetworkAclList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkAcl(entry, context);\n    });\n};\nconst de_NetworkBandwidthGbps = (output, context) => {\n    const contents = {};\n    if (output[_m] != null) {\n        contents[_M] = __strictParseFloat(output[_m]);\n    }\n    if (output[_ma] != null) {\n        contents[_Ma] = __strictParseFloat(output[_ma]);\n    }\n    return contents;\n};\nconst de_NetworkCardInfo = (output, context) => {\n    const contents = {};\n    if (output[_nCI] != null) {\n        contents[_NCI] = __strictParseInt32(output[_nCI]);\n    }\n    if (output[_nPe] != null) {\n        contents[_NPe] = __expectString(output[_nPe]);\n    }\n    if (output[_mNI] != null) {\n        contents[_MNI] = __strictParseInt32(output[_mNI]);\n    }\n    if (output[_bBIG] != null) {\n        contents[_BBIG] = __strictParseFloat(output[_bBIG]);\n    }\n    if (output[_pBIG] != null) {\n        contents[_PBIG] = __strictParseFloat(output[_pBIG]);\n    }\n    if (output[_dEQCPI] != null) {\n        contents[_DEQCPI] = __strictParseInt32(output[_dEQCPI]);\n    }\n    if (output[_mEQC] != null) {\n        contents[_MEQC] = __strictParseInt32(output[_mEQC]);\n    }\n    if (output[_mEQCPI] != null) {\n        contents[_MEQCPI] = __strictParseInt32(output[_mEQCPI]);\n    }\n    return contents;\n};\nconst de_NetworkCardInfoList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkCardInfo(entry, context);\n    });\n};\nconst de_NetworkInfo = (output, context) => {\n    const contents = {};\n    if (output[_nPe] != null) {\n        contents[_NPe] = __expectString(output[_nPe]);\n    }\n    if (output[_mNI] != null) {\n        contents[_MNI] = __strictParseInt32(output[_mNI]);\n    }\n    if (output[_mNC] != null) {\n        contents[_MNC] = __strictParseInt32(output[_mNC]);\n    }\n    if (output[_dNCI] != null) {\n        contents[_DNCI] = __strictParseInt32(output[_dNCI]);\n    }\n    if (output.networkCards === \"\") {\n        contents[_NC] = [];\n    }\n    else if (output[_nC] != null && output[_nC][_i] != null) {\n        contents[_NC] = de_NetworkCardInfoList(__getArrayIfSingleItem(output[_nC][_i]), context);\n    }\n    if (output[_iAPI] != null) {\n        contents[_IAPI] = __strictParseInt32(output[_iAPI]);\n    }\n    if (output[_iAPIp] != null) {\n        contents[_IAPIp] = __strictParseInt32(output[_iAPIp]);\n    }\n    if (output[_iSpv] != null) {\n        contents[_ISpv] = __parseBoolean(output[_iSpv]);\n    }\n    if (output[_eSna] != null) {\n        contents[_ESn] = __expectString(output[_eSna]);\n    }\n    if (output[_eSf] != null) {\n        contents[_ESf] = __parseBoolean(output[_eSf]);\n    }\n    if (output[_eIf] != null) {\n        contents[_EIf] = de_EfaInfo(output[_eIf], context);\n    }\n    if (output[_eITSn] != null) {\n        contents[_EITS] = __parseBoolean(output[_eITSn]);\n    }\n    if (output[_eSSn] != null) {\n        contents[_ESSn] = __parseBoolean(output[_eSSn]);\n    }\n    if (output.bandwidthWeightings === \"\") {\n        contents[_BWa] = [];\n    }\n    else if (output[_bWa] != null && output[_bWa][_i] != null) {\n        contents[_BWa] = de_BandwidthWeightingTypeList(__getArrayIfSingleItem(output[_bWa][_i]), context);\n    }\n    if (output[_fEQS] != null) {\n        contents[_FEQS] = __expectString(output[_fEQS]);\n    }\n    return contents;\n};\nconst de_NetworkInsightsAccessScope = (output, context) => {\n    const contents = {};\n    if (output[_nIASI] != null) {\n        contents[_NIASI] = __expectString(output[_nIASI]);\n    }\n    if (output[_nIASA] != null) {\n        contents[_NIASAe] = __expectString(output[_nIASA]);\n    }\n    if (output[_cDre] != null) {\n        contents[_CDrea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cDre]));\n    }\n    if (output[_uDp] != null) {\n        contents[_UDp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uDp]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_NetworkInsightsAccessScopeAnalysis = (output, context) => {\n    const contents = {};\n    if (output[_nIASAI] != null) {\n        contents[_NIASAI] = __expectString(output[_nIASAI]);\n    }\n    if (output[_nIASAA] != null) {\n        contents[_NIASAA] = __expectString(output[_nIASAA]);\n    }\n    if (output[_nIASI] != null) {\n        contents[_NIASI] = __expectString(output[_nIASI]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_wM] != null) {\n        contents[_WM] = __expectString(output[_wM]);\n    }\n    if (output[_sD] != null) {\n        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));\n    }\n    if (output[_eD] != null) {\n        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));\n    }\n    if (output[_fFi] != null) {\n        contents[_FFi] = __expectString(output[_fFi]);\n    }\n    if (output[_aEC] != null) {\n        contents[_AEC] = __strictParseInt32(output[_aEC]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_NetworkInsightsAccessScopeAnalysisList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkInsightsAccessScopeAnalysis(entry, context);\n    });\n};\nconst de_NetworkInsightsAccessScopeContent = (output, context) => {\n    const contents = {};\n    if (output[_nIASI] != null) {\n        contents[_NIASI] = __expectString(output[_nIASI]);\n    }\n    if (output.matchPathSet === \"\") {\n        contents[_MP] = [];\n    }\n    else if (output[_mPSa] != null && output[_mPSa][_i] != null) {\n        contents[_MP] = de_AccessScopePathList(__getArrayIfSingleItem(output[_mPSa][_i]), context);\n    }\n    if (output.excludePathSet === \"\") {\n        contents[_EP] = [];\n    }\n    else if (output[_ePS] != null && output[_ePS][_i] != null) {\n        contents[_EP] = de_AccessScopePathList(__getArrayIfSingleItem(output[_ePS][_i]), context);\n    }\n    return contents;\n};\nconst de_NetworkInsightsAccessScopeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkInsightsAccessScope(entry, context);\n    });\n};\nconst de_NetworkInsightsAnalysis = (output, context) => {\n    const contents = {};\n    if (output[_nIAI] != null) {\n        contents[_NIAI] = __expectString(output[_nIAI]);\n    }\n    if (output[_nIAA] != null) {\n        contents[_NIAA] = __expectString(output[_nIAA]);\n    }\n    if (output[_nIPI] != null) {\n        contents[_NIPI] = __expectString(output[_nIPI]);\n    }\n    if (output.additionalAccountSet === \"\") {\n        contents[_AAd] = [];\n    }\n    else if (output[_aASd] != null && output[_aASd][_i] != null) {\n        contents[_AAd] = de_ValueStringList(__getArrayIfSingleItem(output[_aASd][_i]), context);\n    }\n    if (output.filterInArnSet === \"\") {\n        contents[_FIA] = [];\n    }\n    else if (output[_fIAS] != null && output[_fIAS][_i] != null) {\n        contents[_FIA] = de_ArnList(__getArrayIfSingleItem(output[_fIAS][_i]), context);\n    }\n    if (output.filterOutArnSet === \"\") {\n        contents[_FOA] = [];\n    }\n    else if (output[_fOAS] != null && output[_fOAS][_i] != null) {\n        contents[_FOA] = de_ArnList(__getArrayIfSingleItem(output[_fOAS][_i]), context);\n    }\n    if (output[_sD] != null) {\n        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_wM] != null) {\n        contents[_WM] = __expectString(output[_wM]);\n    }\n    if (output[_nPF] != null) {\n        contents[_NPF] = __parseBoolean(output[_nPF]);\n    }\n    if (output.forwardPathComponentSet === \"\") {\n        contents[_FPC] = [];\n    }\n    else if (output[_fPCS] != null && output[_fPCS][_i] != null) {\n        contents[_FPC] = de_PathComponentList(__getArrayIfSingleItem(output[_fPCS][_i]), context);\n    }\n    if (output.returnPathComponentSet === \"\") {\n        contents[_RPC] = [];\n    }\n    else if (output[_rPCS] != null && output[_rPCS][_i] != null) {\n        contents[_RPC] = de_PathComponentList(__getArrayIfSingleItem(output[_rPCS][_i]), context);\n    }\n    if (output.explanationSet === \"\") {\n        contents[_Ex] = [];\n    }\n    else if (output[_eSx] != null && output[_eSx][_i] != null) {\n        contents[_Ex] = de_ExplanationList(__getArrayIfSingleItem(output[_eSx][_i]), context);\n    }\n    if (output.alternatePathHintSet === \"\") {\n        contents[_APH] = [];\n    }\n    else if (output[_aPHS] != null && output[_aPHS][_i] != null) {\n        contents[_APH] = de_AlternatePathHintList(__getArrayIfSingleItem(output[_aPHS][_i]), context);\n    }\n    if (output.suggestedAccountSet === \"\") {\n        contents[_SAu] = [];\n    }\n    else if (output[_sASu] != null && output[_sASu][_i] != null) {\n        contents[_SAu] = de_ValueStringList(__getArrayIfSingleItem(output[_sASu][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_NetworkInsightsAnalysisList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkInsightsAnalysis(entry, context);\n    });\n};\nconst de_NetworkInsightsPath = (output, context) => {\n    const contents = {};\n    if (output[_nIPI] != null) {\n        contents[_NIPI] = __expectString(output[_nIPI]);\n    }\n    if (output[_nIPA] != null) {\n        contents[_NIPA] = __expectString(output[_nIPA]);\n    }\n    if (output[_cDre] != null) {\n        contents[_CDrea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cDre]));\n    }\n    if (output[_s] != null) {\n        contents[_S] = __expectString(output[_s]);\n    }\n    if (output[_d] != null) {\n        contents[_D] = __expectString(output[_d]);\n    }\n    if (output[_sA] != null) {\n        contents[_SAour] = __expectString(output[_sA]);\n    }\n    if (output[_dA] != null) {\n        contents[_DAesti] = __expectString(output[_dA]);\n    }\n    if (output[_sIo] != null) {\n        contents[_SIo] = __expectString(output[_sIo]);\n    }\n    if (output[_dIes] != null) {\n        contents[_DIest] = __expectString(output[_dIes]);\n    }\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    if (output[_dPes] != null) {\n        contents[_DPe] = __strictParseInt32(output[_dPes]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_fAS] != null) {\n        contents[_FAS] = de_PathFilter(output[_fAS], context);\n    }\n    if (output[_fAD] != null) {\n        contents[_FAD] = de_PathFilter(output[_fAD], context);\n    }\n    return contents;\n};\nconst de_NetworkInsightsPathList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkInsightsPath(entry, context);\n    });\n};\nconst de_NetworkInterface = (output, context) => {\n    const contents = {};\n    if (output[_ass] != null) {\n        contents[_Asso] = de_NetworkInterfaceAssociation(output[_ass], context);\n    }\n    if (output[_at] != null) {\n        contents[_Att] = de_NetworkInterfaceAttachment(output[_at], context);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_cTC] != null) {\n        contents[_CTC] = de_ConnectionTrackingConfiguration(output[_cTC], context);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.groupSet === \"\") {\n        contents[_G] = [];\n    }\n    else if (output[_gS] != null && output[_gS][_i] != null) {\n        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);\n    }\n    if (output[_iTnt] != null) {\n        contents[_ITn] = __expectString(output[_iTnt]);\n    }\n    if (output.ipv6AddressesSet === \"\") {\n        contents[_IA] = [];\n    }\n    else if (output[_iASp] != null && output[_iASp][_i] != null) {\n        contents[_IA] = de_NetworkInterfaceIpv6AddressesList(__getArrayIfSingleItem(output[_iASp][_i]), context);\n    }\n    if (output[_mAa] != null) {\n        contents[_MAa] = __expectString(output[_mAa]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_pDN] != null) {\n        contents[_PDN] = __expectString(output[_pDN]);\n    }\n    if (output[_pDNu] != null) {\n        contents[_PDNu] = __expectString(output[_pDNu]);\n    }\n    if (output[_pIDNO] != null) {\n        contents[_PIDNO] = de_PublicIpDnsNameOptions(output[_pIDNO], context);\n    }\n    if (output[_pIAr] != null) {\n        contents[_PIAr] = __expectString(output[_pIAr]);\n    }\n    if (output.privateIpAddressesSet === \"\") {\n        contents[_PIA] = [];\n    }\n    else if (output[_pIAS] != null && output[_pIAS][_i] != null) {\n        contents[_PIA] = de_NetworkInterfacePrivateIpAddressList(__getArrayIfSingleItem(output[_pIAS][_i]), context);\n    }\n    if (output.ipv4PrefixSet === \"\") {\n        contents[_IPp] = [];\n    }\n    else if (output[_iPSpv] != null && output[_iPSpv][_i] != null) {\n        contents[_IPp] = de_Ipv4PrefixesList(__getArrayIfSingleItem(output[_iPSpv][_i]), context);\n    }\n    if (output.ipv6PrefixSet === \"\") {\n        contents[_IP] = [];\n    }\n    else if (output[_iPSpvr] != null && output[_iPSpvr][_i] != null) {\n        contents[_IP] = de_Ipv6PrefixesList(__getArrayIfSingleItem(output[_iPSpvr][_i]), context);\n    }\n    if (output[_rIeq] != null) {\n        contents[_RIeq] = __expectString(output[_rIeq]);\n    }\n    if (output[_rMe] != null) {\n        contents[_RMeq] = __parseBoolean(output[_rMe]);\n    }\n    if (output[_sDC] != null) {\n        contents[_SDC] = __parseBoolean(output[_sDC]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_TSag] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_TSag] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_dAIT] != null) {\n        contents[_DAIT] = __parseBoolean(output[_dAIT]);\n    }\n    if (output[_iN] != null) {\n        contents[_IN] = __parseBoolean(output[_iN]);\n    }\n    if (output[_iApv] != null) {\n        contents[_IApv] = __expectString(output[_iApv]);\n    }\n    if (output[_op] != null) {\n        contents[_O] = de_OperatorResponse(output[_op], context);\n    }\n    return contents;\n};\nconst de_NetworkInterfaceAssociation = (output, context) => {\n    const contents = {};\n    if (output[_aI] != null) {\n        contents[_AIl] = __expectString(output[_aI]);\n    }\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_iOIp] != null) {\n        contents[_IOI] = __expectString(output[_iOIp]);\n    }\n    if (output[_pDNu] != null) {\n        contents[_PDNu] = __expectString(output[_pDNu]);\n    }\n    if (output[_pI] != null) {\n        contents[_PI] = __expectString(output[_pI]);\n    }\n    if (output[_cOI] != null) {\n        contents[_COI] = __expectString(output[_cOI]);\n    }\n    if (output[_cI] != null) {\n        contents[_CIa] = __expectString(output[_cI]);\n    }\n    return contents;\n};\nconst de_NetworkInterfaceAttachment = (output, context) => {\n    const contents = {};\n    if (output[_aTt] != null) {\n        contents[_ATtt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aTt]));\n    }\n    if (output[_aIt] != null) {\n        contents[_AIt] = __expectString(output[_aIt]);\n    }\n    if (output[_dOT] != null) {\n        contents[_DOT] = __parseBoolean(output[_dOT]);\n    }\n    if (output[_dIe] != null) {\n        contents[_DIev] = __strictParseInt32(output[_dIe]);\n    }\n    if (output[_nCI] != null) {\n        contents[_NCI] = __strictParseInt32(output[_nCI]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_iOIn] != null) {\n        contents[_IOIn] = __expectString(output[_iOIn]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_eSS] != null) {\n        contents[_ESS] = de_AttachmentEnaSrdSpecification(output[_eSS], context);\n    }\n    if (output[_eQC] != null) {\n        contents[_EQC] = __strictParseInt32(output[_eQC]);\n    }\n    return contents;\n};\nconst de_NetworkInterfaceCount = (output, context) => {\n    const contents = {};\n    if (output[_m] != null) {\n        contents[_M] = __strictParseInt32(output[_m]);\n    }\n    if (output[_ma] != null) {\n        contents[_Ma] = __strictParseInt32(output[_ma]);\n    }\n    return contents;\n};\nconst de_NetworkInterfaceIdSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_NetworkInterfaceIpv6Address = (output, context) => {\n    const contents = {};\n    if (output[_iApv] != null) {\n        contents[_IApv] = __expectString(output[_iApv]);\n    }\n    if (output[_pIDN] != null) {\n        contents[_PIDN] = __expectString(output[_pIDN]);\n    }\n    if (output[_iPI] != null) {\n        contents[_IPIs] = __parseBoolean(output[_iPI]);\n    }\n    return contents;\n};\nconst de_NetworkInterfaceIpv6AddressesList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkInterfaceIpv6Address(entry, context);\n    });\n};\nconst de_NetworkInterfaceList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkInterface(entry, context);\n    });\n};\nconst de_NetworkInterfacePermission = (output, context) => {\n    const contents = {};\n    if (output[_nIPIe] != null) {\n        contents[_NIPIe] = __expectString(output[_nIPIe]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_aAI] != null) {\n        contents[_AAI] = __expectString(output[_aAI]);\n    }\n    if (output[_aSw] != null) {\n        contents[_ASw] = __expectString(output[_aSw]);\n    }\n    if (output[_per] != null) {\n        contents[_Pe] = __expectString(output[_per]);\n    }\n    if (output[_pSe] != null) {\n        contents[_PSer] = de_NetworkInterfacePermissionState(output[_pSe], context);\n    }\n    return contents;\n};\nconst de_NetworkInterfacePermissionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkInterfacePermission(entry, context);\n    });\n};\nconst de_NetworkInterfacePermissionState = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    return contents;\n};\nconst de_NetworkInterfacePrivateIpAddress = (output, context) => {\n    const contents = {};\n    if (output[_ass] != null) {\n        contents[_Asso] = de_NetworkInterfaceAssociation(output[_ass], context);\n    }\n    if (output[_prim] != null) {\n        contents[_Prim] = __parseBoolean(output[_prim]);\n    }\n    if (output[_pDN] != null) {\n        contents[_PDN] = __expectString(output[_pDN]);\n    }\n    if (output[_pIAr] != null) {\n        contents[_PIAr] = __expectString(output[_pIAr]);\n    }\n    return contents;\n};\nconst de_NetworkInterfacePrivateIpAddressList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NetworkInterfacePrivateIpAddress(entry, context);\n    });\n};\nconst de_NetworkNodesList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_NeuronDeviceCoreInfo = (output, context) => {\n    const contents = {};\n    if (output[_cou] != null) {\n        contents[_Cou] = __strictParseInt32(output[_cou]);\n    }\n    if (output[_ve] != null) {\n        contents[_V] = __strictParseInt32(output[_ve]);\n    }\n    return contents;\n};\nconst de_NeuronDeviceInfo = (output, context) => {\n    const contents = {};\n    if (output[_cou] != null) {\n        contents[_Cou] = __strictParseInt32(output[_cou]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_cIor] != null) {\n        contents[_CIor] = de_NeuronDeviceCoreInfo(output[_cIor], context);\n    }\n    if (output[_mIe] != null) {\n        contents[_MIe] = de_NeuronDeviceMemoryInfo(output[_mIe], context);\n    }\n    return contents;\n};\nconst de_NeuronDeviceInfoList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_NeuronDeviceInfo(entry, context);\n    });\n};\nconst de_NeuronDeviceMemoryInfo = (output, context) => {\n    const contents = {};\n    if (output[_sIMB] != null) {\n        contents[_SIMB] = __strictParseInt32(output[_sIMB]);\n    }\n    return contents;\n};\nconst de_NeuronInfo = (output, context) => {\n    const contents = {};\n    if (output.neuronDevices === \"\") {\n        contents[_NDe] = [];\n    }\n    else if (output[_nDe] != null && output[_nDe][_i] != null) {\n        contents[_NDe] = de_NeuronDeviceInfoList(__getArrayIfSingleItem(output[_nDe][_i]), context);\n    }\n    if (output[_tNDMIMB] != null) {\n        contents[_TNDMIMB] = __strictParseInt32(output[_tNDMIMB]);\n    }\n    return contents;\n};\nconst de_NitroTpmInfo = (output, context) => {\n    const contents = {};\n    if (output.supportedVersions === \"\") {\n        contents[_SVu] = [];\n    }\n    else if (output[_sVu] != null && output[_sVu][_i] != null) {\n        contents[_SVu] = de_NitroTpmSupportedVersionsList(__getArrayIfSingleItem(output[_sVu][_i]), context);\n    }\n    return contents;\n};\nconst de_NitroTpmSupportedVersionsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_OccurrenceDaySet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __strictParseInt32(entry);\n    });\n};\nconst de_OidcOptions = (output, context) => {\n    const contents = {};\n    if (output[_is] != null) {\n        contents[_I] = __expectString(output[_is]);\n    }\n    if (output[_aE] != null) {\n        contents[_AE] = __expectString(output[_aE]);\n    }\n    if (output[_tEo] != null) {\n        contents[_TEo] = __expectString(output[_tEo]);\n    }\n    if (output[_uIE] != null) {\n        contents[_UIE] = __expectString(output[_uIE]);\n    }\n    if (output[_cIli] != null) {\n        contents[_CIl] = __expectString(output[_cIli]);\n    }\n    if (output[_cSl] != null) {\n        contents[_CSl] = __expectString(output[_cSl]);\n    }\n    if (output[_sc] != null) {\n        contents[_Sc] = __expectString(output[_sc]);\n    }\n    return contents;\n};\nconst de_OnDemandOptions = (output, context) => {\n    const contents = {};\n    if (output[_aSl] != null) {\n        contents[_AS] = __expectString(output[_aSl]);\n    }\n    if (output[_cRO] != null) {\n        contents[_CRO] = de_CapacityReservationOptions(output[_cRO], context);\n    }\n    if (output[_sITi] != null) {\n        contents[_SITi] = __parseBoolean(output[_sITi]);\n    }\n    if (output[_sAZ] != null) {\n        contents[_SAZ] = __parseBoolean(output[_sAZ]);\n    }\n    if (output[_mTC] != null) {\n        contents[_MTC] = __strictParseInt32(output[_mTC]);\n    }\n    if (output[_mTP] != null) {\n        contents[_MTP] = __expectString(output[_mTP]);\n    }\n    return contents;\n};\nconst de_OperatorResponse = (output, context) => {\n    const contents = {};\n    if (output[_mana] != null) {\n        contents[_Mana] = __parseBoolean(output[_mana]);\n    }\n    if (output[_p] != null) {\n        contents[_Prin] = __expectString(output[_p]);\n    }\n    return contents;\n};\nconst de_OutpostLag = (output, context) => {\n    const contents = {};\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_oLI] != null) {\n        contents[_OLI] = __expectString(output[_oLI]);\n    }\n    if (output.localGatewayVirtualInterfaceIdSet === \"\") {\n        contents[_LGVIIo] = [];\n    }\n    else if (output[_lGVIIS] != null && output[_lGVIIS][_i] != null) {\n        contents[_LGVIIo] = de_LocalGatewayVirtualInterfaceIdSet(__getArrayIfSingleItem(output[_lGVIIS][_i]), context);\n    }\n    if (output.serviceLinkVirtualInterfaceIdSet === \"\") {\n        contents[_SLVII] = [];\n    }\n    else if (output[_sLVIIS] != null && output[_sLVIIS][_i] != null) {\n        contents[_SLVII] = de_ServiceLinkVirtualInterfaceIdSet(__getArrayIfSingleItem(output[_sLVIIS][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_OutpostLagSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_OutpostLag(entry, context);\n    });\n};\nconst de_PacketHeaderStatement = (output, context) => {\n    const contents = {};\n    if (output.sourceAddressSet === \"\") {\n        contents[_SAo] = [];\n    }\n    else if (output[_sAS] != null && output[_sAS][_i] != null) {\n        contents[_SAo] = de_ValueStringList(__getArrayIfSingleItem(output[_sAS][_i]), context);\n    }\n    if (output.destinationAddressSet === \"\") {\n        contents[_DAes] = [];\n    }\n    else if (output[_dAS] != null && output[_dAS][_i] != null) {\n        contents[_DAes] = de_ValueStringList(__getArrayIfSingleItem(output[_dAS][_i]), context);\n    }\n    if (output.sourcePortSet === \"\") {\n        contents[_SPo] = [];\n    }\n    else if (output[_sPS] != null && output[_sPS][_i] != null) {\n        contents[_SPo] = de_ValueStringList(__getArrayIfSingleItem(output[_sPS][_i]), context);\n    }\n    if (output.destinationPortSet === \"\") {\n        contents[_DPes] = [];\n    }\n    else if (output[_dPS] != null && output[_dPS][_i] != null) {\n        contents[_DPes] = de_ValueStringList(__getArrayIfSingleItem(output[_dPS][_i]), context);\n    }\n    if (output.sourcePrefixListSet === \"\") {\n        contents[_SPL] = [];\n    }\n    else if (output[_sPLS] != null && output[_sPLS][_i] != null) {\n        contents[_SPL] = de_ValueStringList(__getArrayIfSingleItem(output[_sPLS][_i]), context);\n    }\n    if (output.destinationPrefixListSet === \"\") {\n        contents[_DPLe] = [];\n    }\n    else if (output[_dPLS] != null && output[_dPLS][_i] != null) {\n        contents[_DPLe] = de_ValueStringList(__getArrayIfSingleItem(output[_dPLS][_i]), context);\n    }\n    if (output.protocolSet === \"\") {\n        contents[_Pro] = [];\n    }\n    else if (output[_pSro] != null && output[_pSro][_i] != null) {\n        contents[_Pro] = de_ProtocolList(__getArrayIfSingleItem(output[_pSro][_i]), context);\n    }\n    return contents;\n};\nconst de_PathComponent = (output, context) => {\n    const contents = {};\n    if (output[_sNe] != null) {\n        contents[_SNeq] = __strictParseInt32(output[_sNe]);\n    }\n    if (output[_aRc] != null) {\n        contents[_ARcl] = de_AnalysisAclRule(output[_aRc], context);\n    }\n    if (output[_aTtt] != null) {\n        contents[_ATtta] = de_AnalysisComponent(output[_aTtt], context);\n    }\n    if (output[_c] != null) {\n        contents[_Com] = de_AnalysisComponent(output[_c], context);\n    }\n    if (output[_dV] != null) {\n        contents[_DVest] = de_AnalysisComponent(output[_dV], context);\n    }\n    if (output[_oH] != null) {\n        contents[_OH] = de_AnalysisPacketHeader(output[_oH], context);\n    }\n    if (output[_iHn] != null) {\n        contents[_IHn] = de_AnalysisPacketHeader(output[_iHn], context);\n    }\n    if (output[_rTR] != null) {\n        contents[_RTR] = de_AnalysisRouteTableRoute(output[_rTR], context);\n    }\n    if (output[_sGR] != null) {\n        contents[_SGRe] = de_AnalysisSecurityGroupRule(output[_sGR], context);\n    }\n    if (output[_sV] != null) {\n        contents[_SVo] = de_AnalysisComponent(output[_sV], context);\n    }\n    if (output[_su] != null) {\n        contents[_Su] = de_AnalysisComponent(output[_su], context);\n    }\n    if (output[_vp] != null) {\n        contents[_Vp] = de_AnalysisComponent(output[_vp], context);\n    }\n    if (output.additionalDetailSet === \"\") {\n        contents[_ADd] = [];\n    }\n    else if (output[_aDS] != null && output[_aDS][_i] != null) {\n        contents[_ADd] = de_AdditionalDetailList(__getArrayIfSingleItem(output[_aDS][_i]), context);\n    }\n    if (output[_tG] != null) {\n        contents[_TGr] = de_AnalysisComponent(output[_tG], context);\n    }\n    if (output[_tGRTR] != null) {\n        contents[_TGRTR] = de_TransitGatewayRouteTableRoute(output[_tGRTR], context);\n    }\n    if (output.explanationSet === \"\") {\n        contents[_Ex] = [];\n    }\n    else if (output[_eSx] != null && output[_eSx][_i] != null) {\n        contents[_Ex] = de_ExplanationList(__getArrayIfSingleItem(output[_eSx][_i]), context);\n    }\n    if (output[_eLBL] != null) {\n        contents[_ELBL] = de_AnalysisComponent(output[_eLBL], context);\n    }\n    if (output[_fSR] != null) {\n        contents[_FSRi] = de_FirewallStatelessRule(output[_fSR], context);\n    }\n    if (output[_fSRi] != null) {\n        contents[_FSRir] = de_FirewallStatefulRule(output[_fSRi], context);\n    }\n    if (output[_sN] != null) {\n        contents[_SNe] = __expectString(output[_sN]);\n    }\n    return contents;\n};\nconst de_PathComponentList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PathComponent(entry, context);\n    });\n};\nconst de_PathFilter = (output, context) => {\n    const contents = {};\n    if (output[_sAo] != null) {\n        contents[_SAou] = __expectString(output[_sAo]);\n    }\n    if (output[_sPR] != null) {\n        contents[_SPR] = de_FilterPortRange(output[_sPR], context);\n    }\n    if (output[_dAe] != null) {\n        contents[_DAest] = __expectString(output[_dAe]);\n    }\n    if (output[_dPR] != null) {\n        contents[_DPR] = de_FilterPortRange(output[_dPR], context);\n    }\n    return contents;\n};\nconst de_PathStatement = (output, context) => {\n    const contents = {};\n    if (output[_pHS] != null) {\n        contents[_PHS] = de_PacketHeaderStatement(output[_pHS], context);\n    }\n    if (output[_rSeso] != null) {\n        contents[_RSe] = de_ResourceStatement(output[_rSeso], context);\n    }\n    return contents;\n};\nconst de_PciId = (output, context) => {\n    const contents = {};\n    if (output[_DIevi] != null) {\n        contents[_DIevi] = __expectString(output[_DIevi]);\n    }\n    if (output[_VIe] != null) {\n        contents[_VIe] = __expectString(output[_VIe]);\n    }\n    if (output[_SIubs] != null) {\n        contents[_SIubs] = __expectString(output[_SIubs]);\n    }\n    if (output[_SVI] != null) {\n        contents[_SVI] = __expectString(output[_SVI]);\n    }\n    return contents;\n};\nconst de_PeeringAttachmentStatus = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_PeeringConnectionOptions = (output, context) => {\n    const contents = {};\n    if (output[_aDRFRV] != null) {\n        contents[_ADRFRV] = __parseBoolean(output[_aDRFRV]);\n    }\n    if (output[_aEFLCLTRV] != null) {\n        contents[_AEFLCLTRV] = __parseBoolean(output[_aEFLCLTRV]);\n    }\n    if (output[_aEFLVTRCL] != null) {\n        contents[_AEFLVTRCL] = __parseBoolean(output[_aEFLVTRCL]);\n    }\n    return contents;\n};\nconst de_PeeringTgwInfo = (output, context) => {\n    const contents = {};\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_cNIo] != null) {\n        contents[_CNIor] = __expectString(output[_cNIo]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_re] != null) {\n        contents[_Regi] = __expectString(output[_re]);\n    }\n    return contents;\n};\nconst de_PerformanceFactorReference = (output, context) => {\n    const contents = {};\n    if (output[_iF] != null) {\n        contents[_IF] = __expectString(output[_iF]);\n    }\n    return contents;\n};\nconst de_PerformanceFactorReferenceSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PerformanceFactorReference(entry, context);\n    });\n};\nconst de_Phase1DHGroupNumbersList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Phase1DHGroupNumbersListValue(entry, context);\n    });\n};\nconst de_Phase1DHGroupNumbersListValue = (output, context) => {\n    const contents = {};\n    if (output[_v] != null) {\n        contents[_Va] = __strictParseInt32(output[_v]);\n    }\n    return contents;\n};\nconst de_Phase1EncryptionAlgorithmsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Phase1EncryptionAlgorithmsListValue(entry, context);\n    });\n};\nconst de_Phase1EncryptionAlgorithmsListValue = (output, context) => {\n    const contents = {};\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    return contents;\n};\nconst de_Phase1IntegrityAlgorithmsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Phase1IntegrityAlgorithmsListValue(entry, context);\n    });\n};\nconst de_Phase1IntegrityAlgorithmsListValue = (output, context) => {\n    const contents = {};\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    return contents;\n};\nconst de_Phase2DHGroupNumbersList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Phase2DHGroupNumbersListValue(entry, context);\n    });\n};\nconst de_Phase2DHGroupNumbersListValue = (output, context) => {\n    const contents = {};\n    if (output[_v] != null) {\n        contents[_Va] = __strictParseInt32(output[_v]);\n    }\n    return contents;\n};\nconst de_Phase2EncryptionAlgorithmsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Phase2EncryptionAlgorithmsListValue(entry, context);\n    });\n};\nconst de_Phase2EncryptionAlgorithmsListValue = (output, context) => {\n    const contents = {};\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    return contents;\n};\nconst de_Phase2IntegrityAlgorithmsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Phase2IntegrityAlgorithmsListValue(entry, context);\n    });\n};\nconst de_Phase2IntegrityAlgorithmsListValue = (output, context) => {\n    const contents = {};\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    return contents;\n};\nconst de_Placement = (output, context) => {\n    const contents = {};\n    if (output[_af] != null) {\n        contents[_Af] = __expectString(output[_af]);\n    }\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    if (output[_pN] != null) {\n        contents[_PN] = __strictParseInt32(output[_pN]);\n    }\n    if (output[_hI] != null) {\n        contents[_HIo] = __expectString(output[_hI]);\n    }\n    if (output[_t] != null) {\n        contents[_Te] = __expectString(output[_t]);\n    }\n    if (output[_sDp] != null) {\n        contents[_SDp] = __expectString(output[_sDp]);\n    }\n    if (output[_hRGA] != null) {\n        contents[_HRGA] = __expectString(output[_hRGA]);\n    }\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    return contents;\n};\nconst de_PlacementGroup = (output, context) => {\n    const contents = {};\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_str] != null) {\n        contents[_Str] = __expectString(output[_str]);\n    }\n    if (output[_pCa] != null) {\n        contents[_PCa] = __strictParseInt32(output[_pCa]);\n    }\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_gA] != null) {\n        contents[_GA] = __expectString(output[_gA]);\n    }\n    if (output[_sLp] != null) {\n        contents[_SL] = __expectString(output[_sLp]);\n    }\n    return contents;\n};\nconst de_PlacementGroupInfo = (output, context) => {\n    const contents = {};\n    if (output.supportedStrategies === \"\") {\n        contents[_SSu] = [];\n    }\n    else if (output[_sSup] != null && output[_sSup][_i] != null) {\n        contents[_SSu] = de_PlacementGroupStrategyList(__getArrayIfSingleItem(output[_sSup][_i]), context);\n    }\n    return contents;\n};\nconst de_PlacementGroupList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PlacementGroup(entry, context);\n    });\n};\nconst de_PlacementGroupStrategyList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_PlacementResponse = (output, context) => {\n    const contents = {};\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    return contents;\n};\nconst de_PoolCidrBlock = (output, context) => {\n    const contents = {};\n    if (output[_pCB] != null) {\n        contents[_C] = __expectString(output[_pCB]);\n    }\n    return contents;\n};\nconst de_PoolCidrBlocksSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PoolCidrBlock(entry, context);\n    });\n};\nconst de_PortRange = (output, context) => {\n    const contents = {};\n    if (output[_fr] != null) {\n        contents[_Fr] = __strictParseInt32(output[_fr]);\n    }\n    if (output[_to] != null) {\n        contents[_To] = __strictParseInt32(output[_to]);\n    }\n    return contents;\n};\nconst de_PortRangeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PortRange(entry, context);\n    });\n};\nconst de_PrefixList = (output, context) => {\n    const contents = {};\n    if (output.cidrSet === \"\") {\n        contents[_Ci] = [];\n    }\n    else if (output[_cS] != null && output[_cS][_i] != null) {\n        contents[_Ci] = de_ValueStringList(__getArrayIfSingleItem(output[_cS][_i]), context);\n    }\n    if (output[_pLI] != null) {\n        contents[_PLI] = __expectString(output[_pLI]);\n    }\n    if (output[_pLN] != null) {\n        contents[_PLN] = __expectString(output[_pLN]);\n    }\n    return contents;\n};\nconst de_PrefixListAssociation = (output, context) => {\n    const contents = {};\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rO] != null) {\n        contents[_ROe] = __expectString(output[_rO]);\n    }\n    return contents;\n};\nconst de_PrefixListAssociationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PrefixListAssociation(entry, context);\n    });\n};\nconst de_PrefixListEntry = (output, context) => {\n    const contents = {};\n    if (output[_ci] != null) {\n        contents[_C] = __expectString(output[_ci]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    return contents;\n};\nconst de_PrefixListEntrySet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PrefixListEntry(entry, context);\n    });\n};\nconst de_PrefixListId = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_pLI] != null) {\n        contents[_PLI] = __expectString(output[_pLI]);\n    }\n    return contents;\n};\nconst de_PrefixListIdList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PrefixListId(entry, context);\n    });\n};\nconst de_PrefixListIdSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_PrefixListSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PrefixList(entry, context);\n    });\n};\nconst de_PriceSchedule = (output, context) => {\n    const contents = {};\n    if (output[_act] != null) {\n        contents[_Act] = __parseBoolean(output[_act]);\n    }\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    if (output[_pric] != null) {\n        contents[_Pric] = __strictParseFloat(output[_pric]);\n    }\n    if (output[_te] != null) {\n        contents[_Ter] = __strictParseLong(output[_te]);\n    }\n    return contents;\n};\nconst de_PriceScheduleList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PriceSchedule(entry, context);\n    });\n};\nconst de_PricingDetail = (output, context) => {\n    const contents = {};\n    if (output[_cou] != null) {\n        contents[_Cou] = __strictParseInt32(output[_cou]);\n    }\n    if (output[_pric] != null) {\n        contents[_Pric] = __strictParseFloat(output[_pric]);\n    }\n    return contents;\n};\nconst de_PricingDetailsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PricingDetail(entry, context);\n    });\n};\nconst de_PrincipalIdFormat = (output, context) => {\n    const contents = {};\n    if (output[_ar] != null) {\n        contents[_Ar] = __expectString(output[_ar]);\n    }\n    if (output.statusSet === \"\") {\n        contents[_Status] = [];\n    }\n    else if (output[_sSt] != null && output[_sSt][_i] != null) {\n        contents[_Status] = de_IdFormatList(__getArrayIfSingleItem(output[_sSt][_i]), context);\n    }\n    return contents;\n};\nconst de_PrincipalIdFormatList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PrincipalIdFormat(entry, context);\n    });\n};\nconst de_PrivateDnsDetails = (output, context) => {\n    const contents = {};\n    if (output[_pDN] != null) {\n        contents[_PDN] = __expectString(output[_pDN]);\n    }\n    return contents;\n};\nconst de_PrivateDnsDetailsSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PrivateDnsDetails(entry, context);\n    });\n};\nconst de_PrivateDnsNameConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    return contents;\n};\nconst de_PrivateDnsNameOptionsOnLaunch = (output, context) => {\n    const contents = {};\n    if (output[_hTo] != null) {\n        contents[_HTo] = __expectString(output[_hTo]);\n    }\n    if (output[_eRNDAR] != null) {\n        contents[_ERNDAR] = __parseBoolean(output[_eRNDAR]);\n    }\n    if (output[_eRNDAAAAR] != null) {\n        contents[_ERNDAAAAR] = __parseBoolean(output[_eRNDAAAAR]);\n    }\n    return contents;\n};\nconst de_PrivateDnsNameOptionsResponse = (output, context) => {\n    const contents = {};\n    if (output[_hTo] != null) {\n        contents[_HTo] = __expectString(output[_hTo]);\n    }\n    if (output[_eRNDAR] != null) {\n        contents[_ERNDAR] = __parseBoolean(output[_eRNDAR]);\n    }\n    if (output[_eRNDAAAAR] != null) {\n        contents[_ERNDAAAAR] = __parseBoolean(output[_eRNDAAAAR]);\n    }\n    return contents;\n};\nconst de_PrivateIpAddressSpecification = (output, context) => {\n    const contents = {};\n    if (output[_prim] != null) {\n        contents[_Prim] = __parseBoolean(output[_prim]);\n    }\n    if (output[_pIAr] != null) {\n        contents[_PIAr] = __expectString(output[_pIAr]);\n    }\n    return contents;\n};\nconst de_PrivateIpAddressSpecificationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PrivateIpAddressSpecification(entry, context);\n    });\n};\nconst de_ProcessorInfo = (output, context) => {\n    const contents = {};\n    if (output.supportedArchitectures === \"\") {\n        contents[_SAup] = [];\n    }\n    else if (output[_sAu] != null && output[_sAu][_i] != null) {\n        contents[_SAup] = de_ArchitectureTypeList(__getArrayIfSingleItem(output[_sAu][_i]), context);\n    }\n    if (output[_sCSIG] != null) {\n        contents[_SCSIG] = __strictParseFloat(output[_sCSIG]);\n    }\n    if (output.supportedFeatures === \"\") {\n        contents[_SF] = [];\n    }\n    else if (output[_sF] != null && output[_sF][_i] != null) {\n        contents[_SF] = de_SupportedAdditionalProcessorFeatureList(__getArrayIfSingleItem(output[_sF][_i]), context);\n    }\n    if (output[_man] != null) {\n        contents[_Man] = __expectString(output[_man]);\n    }\n    return contents;\n};\nconst de_ProductCode = (output, context) => {\n    const contents = {};\n    if (output[_pCr] != null) {\n        contents[_PCIr] = __expectString(output[_pCr]);\n    }\n    if (output[_ty] != null) {\n        contents[_PCT] = __expectString(output[_ty]);\n    }\n    return contents;\n};\nconst de_ProductCodeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ProductCode(entry, context);\n    });\n};\nconst de_PropagatingVgw = (output, context) => {\n    const contents = {};\n    if (output[_gI] != null) {\n        contents[_GI] = __expectString(output[_gI]);\n    }\n    return contents;\n};\nconst de_PropagatingVgwList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PropagatingVgw(entry, context);\n    });\n};\nconst de_ProtocolIntList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __strictParseInt32(entry);\n    });\n};\nconst de_ProtocolList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_ProvisionByoipCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_bC] != null) {\n        contents[_BC] = de_ByoipCidr(output[_bC], context);\n    }\n    return contents;\n};\nconst de_ProvisionedBandwidth = (output, context) => {\n    const contents = {};\n    if (output[_pTr] != null) {\n        contents[_PTro] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_pTr]));\n    }\n    if (output[_prov] != null) {\n        contents[_Prov] = __expectString(output[_prov]);\n    }\n    if (output[_rTeq] != null) {\n        contents[_RTeq] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rTeq]));\n    }\n    if (output[_req] != null) {\n        contents[_Req] = __expectString(output[_req]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_ProvisionIpamByoasnResult = (output, context) => {\n    const contents = {};\n    if (output[_b] != null) {\n        contents[_Byo] = de_Byoasn(output[_b], context);\n    }\n    return contents;\n};\nconst de_ProvisionIpamPoolCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_iPC] != null) {\n        contents[_IPCpa] = de_IpamPoolCidr(output[_iPC], context);\n    }\n    return contents;\n};\nconst de_ProvisionPublicIpv4PoolCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_pIo] != null) {\n        contents[_PIo] = __expectString(output[_pIo]);\n    }\n    if (output[_pAR] != null) {\n        contents[_PAR] = de_PublicIpv4PoolRange(output[_pAR], context);\n    }\n    return contents;\n};\nconst de_PtrUpdateStatus = (output, context) => {\n    const contents = {};\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_rea] != null) {\n        contents[_Rea] = __expectString(output[_rea]);\n    }\n    return contents;\n};\nconst de_PublicIpDnsNameOptions = (output, context) => {\n    const contents = {};\n    if (output[_dHT] != null) {\n        contents[_DHT] = __expectString(output[_dHT]);\n    }\n    if (output[_pIDNu] != null) {\n        contents[_PIDNu] = __expectString(output[_pIDNu]);\n    }\n    if (output[_pIDN] != null) {\n        contents[_PIDN] = __expectString(output[_pIDN]);\n    }\n    if (output[_pDSDN] != null) {\n        contents[_PDSDN] = __expectString(output[_pDSDN]);\n    }\n    return contents;\n};\nconst de_PublicIpv4Pool = (output, context) => {\n    const contents = {};\n    if (output[_pIo] != null) {\n        contents[_PIo] = __expectString(output[_pIo]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.poolAddressRangeSet === \"\") {\n        contents[_PARo] = [];\n    }\n    else if (output[_pARS] != null && output[_pARS][_i] != null) {\n        contents[_PARo] = de_PublicIpv4PoolRangeSet(__getArrayIfSingleItem(output[_pARS][_i]), context);\n    }\n    if (output[_tAC] != null) {\n        contents[_TAC] = __strictParseInt32(output[_tAC]);\n    }\n    if (output[_tAAC] != null) {\n        contents[_TAAC] = __strictParseInt32(output[_tAAC]);\n    }\n    if (output[_nBG] != null) {\n        contents[_NBG] = __expectString(output[_nBG]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_PublicIpv4PoolRange = (output, context) => {\n    const contents = {};\n    if (output[_fAi] != null) {\n        contents[_FAi] = __expectString(output[_fAi]);\n    }\n    if (output[_lAa] != null) {\n        contents[_LAa] = __expectString(output[_lAa]);\n    }\n    if (output[_aCd] != null) {\n        contents[_ACd] = __strictParseInt32(output[_aCd]);\n    }\n    if (output[_aAC] != null) {\n        contents[_AACv] = __strictParseInt32(output[_aAC]);\n    }\n    return contents;\n};\nconst de_PublicIpv4PoolRangeSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PublicIpv4PoolRange(entry, context);\n    });\n};\nconst de_PublicIpv4PoolSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PublicIpv4Pool(entry, context);\n    });\n};\nconst de_Purchase = (output, context) => {\n    const contents = {};\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    if (output[_du] != null) {\n        contents[_Du] = __strictParseInt32(output[_du]);\n    }\n    if (output.hostIdSet === \"\") {\n        contents[_HIS] = [];\n    }\n    else if (output[_hIS] != null && output[_hIS][_i] != null) {\n        contents[_HIS] = de_ResponseHostIdSet(__getArrayIfSingleItem(output[_hIS][_i]), context);\n    }\n    if (output[_hRI] != null) {\n        contents[_HRI] = __expectString(output[_hRI]);\n    }\n    if (output[_hPo] != null) {\n        contents[_HPo] = __expectString(output[_hPo]);\n    }\n    if (output[_iF] != null) {\n        contents[_IF] = __expectString(output[_iF]);\n    }\n    if (output[_pO] != null) {\n        contents[_PO] = __expectString(output[_pO]);\n    }\n    if (output[_uP] != null) {\n        contents[_UPp] = __expectString(output[_uP]);\n    }\n    return contents;\n};\nconst de_PurchaseCapacityBlockExtensionResult = (output, context) => {\n    const contents = {};\n    if (output.capacityBlockExtensionSet === \"\") {\n        contents[_CBE] = [];\n    }\n    else if (output[_cBESa] != null && output[_cBESa][_i] != null) {\n        contents[_CBE] = de_CapacityBlockExtensionSet(__getArrayIfSingleItem(output[_cBESa][_i]), context);\n    }\n    return contents;\n};\nconst de_PurchaseCapacityBlockResult = (output, context) => {\n    const contents = {};\n    if (output[_cR] != null) {\n        contents[_CRapa] = de_CapacityReservation(output[_cR], context);\n    }\n    return contents;\n};\nconst de_PurchasedScheduledInstanceSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ScheduledInstance(entry, context);\n    });\n};\nconst de_PurchaseHostReservationResult = (output, context) => {\n    const contents = {};\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    if (output.purchase === \"\") {\n        contents[_Pur] = [];\n    }\n    else if (output[_pur] != null && output[_pur][_i] != null) {\n        contents[_Pur] = de_PurchaseSet(__getArrayIfSingleItem(output[_pur][_i]), context);\n    }\n    if (output[_tHP] != null) {\n        contents[_THP] = __expectString(output[_tHP]);\n    }\n    if (output[_tUP] != null) {\n        contents[_TUP] = __expectString(output[_tUP]);\n    }\n    return contents;\n};\nconst de_PurchaseReservedInstancesOfferingResult = (output, context) => {\n    const contents = {};\n    if (output[_rII] != null) {\n        contents[_RIIe] = __expectString(output[_rII]);\n    }\n    return contents;\n};\nconst de_PurchaseScheduledInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.scheduledInstanceSet === \"\") {\n        contents[_SIS] = [];\n    }\n    else if (output[_sIS] != null && output[_sIS][_i] != null) {\n        contents[_SIS] = de_PurchasedScheduledInstanceSet(__getArrayIfSingleItem(output[_sIS][_i]), context);\n    }\n    return contents;\n};\nconst de_PurchaseSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Purchase(entry, context);\n    });\n};\nconst de_RecurringCharge = (output, context) => {\n    const contents = {};\n    if (output[_am] != null) {\n        contents[_Am] = __strictParseFloat(output[_am]);\n    }\n    if (output[_fre] != null) {\n        contents[_Fre] = __expectString(output[_fre]);\n    }\n    return contents;\n};\nconst de_RecurringChargesList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RecurringCharge(entry, context);\n    });\n};\nconst de_ReferencedSecurityGroup = (output, context) => {\n    const contents = {};\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output[_pSee] != null) {\n        contents[_PSe] = __expectString(output[_pSee]);\n    }\n    if (output[_uI] != null) {\n        contents[_UIs] = __expectString(output[_uI]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_vPCI] != null) {\n        contents[_VPCI] = __expectString(output[_vPCI]);\n    }\n    return contents;\n};\nconst de_Region = (output, context) => {\n    const contents = {};\n    if (output[_oIS] != null) {\n        contents[_OIS] = __expectString(output[_oIS]);\n    }\n    if (output[_rNe] != null) {\n        contents[_RN] = __expectString(output[_rNe]);\n    }\n    if (output[_rEe] != null) {\n        contents[_Endp] = __expectString(output[_rEe]);\n    }\n    return contents;\n};\nconst de_RegionalSummary = (output, context) => {\n    const contents = {};\n    if (output[_rNe] != null) {\n        contents[_RN] = __expectString(output[_rNe]);\n    }\n    if (output[_nOMA] != null) {\n        contents[_NOMA] = __strictParseInt32(output[_nOMA]);\n    }\n    if (output[_nOUA] != null) {\n        contents[_NOUA] = __strictParseInt32(output[_nOUA]);\n    }\n    return contents;\n};\nconst de_RegionalSummaryList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RegionalSummary(entry, context);\n    });\n};\nconst de_RegionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Region(entry, context);\n    });\n};\nconst de_RegisterImageResult = (output, context) => {\n    const contents = {};\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    return contents;\n};\nconst de_RegisterInstanceEventNotificationAttributesResult = (output, context) => {\n    const contents = {};\n    if (output[_iTA] != null) {\n        contents[_ITA] = de_InstanceTagNotificationAttribute(output[_iTA], context);\n    }\n    return contents;\n};\nconst de_RegisterTransitGatewayMulticastGroupMembersResult = (output, context) => {\n    const contents = {};\n    if (output[_rMGM] != null) {\n        contents[_RMGM] = de_TransitGatewayMulticastRegisteredGroupMembers(output[_rMGM], context);\n    }\n    return contents;\n};\nconst de_RegisterTransitGatewayMulticastGroupSourcesResult = (output, context) => {\n    const contents = {};\n    if (output[_rMGS] != null) {\n        contents[_RMGS] = de_TransitGatewayMulticastRegisteredGroupSources(output[_rMGS], context);\n    }\n    return contents;\n};\nconst de_RejectCapacityReservationBillingOwnershipResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_RejectTransitGatewayMulticastDomainAssociationsResult = (output, context) => {\n    const contents = {};\n    if (output[_a] != null) {\n        contents[_Ass] = de_TransitGatewayMulticastDomainAssociations(output[_a], context);\n    }\n    return contents;\n};\nconst de_RejectTransitGatewayPeeringAttachmentResult = (output, context) => {\n    const contents = {};\n    if (output[_tGPA] != null) {\n        contents[_TGPA] = de_TransitGatewayPeeringAttachment(output[_tGPA], context);\n    }\n    return contents;\n};\nconst de_RejectTransitGatewayVpcAttachmentResult = (output, context) => {\n    const contents = {};\n    if (output[_tGVA] != null) {\n        contents[_TGVA] = de_TransitGatewayVpcAttachment(output[_tGVA], context);\n    }\n    return contents;\n};\nconst de_RejectVpcEndpointConnectionsResult = (output, context) => {\n    const contents = {};\n    if (output.unsuccessful === \"\") {\n        contents[_Un] = [];\n    }\n    else if (output[_u] != null && output[_u][_i] != null) {\n        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);\n    }\n    return contents;\n};\nconst de_RejectVpcPeeringConnectionResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ReleaseHostsResult = (output, context) => {\n    const contents = {};\n    if (output.successful === \"\") {\n        contents[_Suc] = [];\n    }\n    else if (output[_suc] != null && output[_suc][_i] != null) {\n        contents[_Suc] = de_ResponseHostIdList(__getArrayIfSingleItem(output[_suc][_i]), context);\n    }\n    if (output.unsuccessful === \"\") {\n        contents[_Un] = [];\n    }\n    else if (output[_u] != null && output[_u][_i] != null) {\n        contents[_Un] = de_UnsuccessfulItemList(__getArrayIfSingleItem(output[_u][_i]), context);\n    }\n    return contents;\n};\nconst de_ReleaseIpamPoolAllocationResult = (output, context) => {\n    const contents = {};\n    if (output[_succ] != null) {\n        contents[_Succ] = __parseBoolean(output[_succ]);\n    }\n    return contents;\n};\nconst de_ReplaceIamInstanceProfileAssociationResult = (output, context) => {\n    const contents = {};\n    if (output[_iIPA] != null) {\n        contents[_IIPA] = de_IamInstanceProfileAssociation(output[_iIPA], context);\n    }\n    return contents;\n};\nconst de_ReplaceImageCriteriaInAllowedImagesSettingsResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_RV] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ReplaceNetworkAclAssociationResult = (output, context) => {\n    const contents = {};\n    if (output[_nAIe] != null) {\n        contents[_NAIew] = __expectString(output[_nAIe]);\n    }\n    return contents;\n};\nconst de_ReplaceRootVolumeTask = (output, context) => {\n    const contents = {};\n    if (output[_rRVTI] != null) {\n        contents[_RRVTIe] = __expectString(output[_rRVTI]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_tSas] != null) {\n        contents[_TSas] = __expectString(output[_tSas]);\n    }\n    if (output[_sT] != null) {\n        contents[_STt] = __expectString(output[_sT]);\n    }\n    if (output[_cTom] != null) {\n        contents[_CTom] = __expectString(output[_cTom]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_dRRV] != null) {\n        contents[_DRRV] = __parseBoolean(output[_dRRV]);\n    }\n    return contents;\n};\nconst de_ReplaceRootVolumeTasks = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ReplaceRootVolumeTask(entry, context);\n    });\n};\nconst de_ReplaceRouteTableAssociationResult = (output, context) => {\n    const contents = {};\n    if (output[_nAIe] != null) {\n        contents[_NAIew] = __expectString(output[_nAIe]);\n    }\n    if (output[_aS] != null) {\n        contents[_ASs] = de_RouteTableAssociationState(output[_aS], context);\n    }\n    return contents;\n};\nconst de_ReplaceTransitGatewayRouteResult = (output, context) => {\n    const contents = {};\n    if (output[_ro] != null) {\n        contents[_Rou] = de_TransitGatewayRoute(output[_ro], context);\n    }\n    return contents;\n};\nconst de_ReplaceVpnTunnelResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_RequestSpotFleetResponse = (output, context) => {\n    const contents = {};\n    if (output[_sFRI] != null) {\n        contents[_SFRIp] = __expectString(output[_sFRI]);\n    }\n    return contents;\n};\nconst de_RequestSpotInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.spotInstanceRequestSet === \"\") {\n        contents[_SIR] = [];\n    }\n    else if (output[_sIRS] != null && output[_sIRS][_i] != null) {\n        contents[_SIR] = de_SpotInstanceRequestList(__getArrayIfSingleItem(output[_sIRS][_i]), context);\n    }\n    return contents;\n};\nconst de_Reservation = (output, context) => {\n    const contents = {};\n    if (output[_rIese] != null) {\n        contents[_RIeser] = __expectString(output[_rIese]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_rIeq] != null) {\n        contents[_RIeq] = __expectString(output[_rIeq]);\n    }\n    if (output.groupSet === \"\") {\n        contents[_G] = [];\n    }\n    else if (output[_gS] != null && output[_gS][_i] != null) {\n        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);\n    }\n    if (output.instancesSet === \"\") {\n        contents[_In] = [];\n    }\n    else if (output[_iSn] != null && output[_iSn][_i] != null) {\n        contents[_In] = de_InstanceList(__getArrayIfSingleItem(output[_iSn][_i]), context);\n    }\n    return contents;\n};\nconst de_ReservationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Reservation(entry, context);\n    });\n};\nconst de_ReservationValue = (output, context) => {\n    const contents = {};\n    if (output[_hPo] != null) {\n        contents[_HPo] = __expectString(output[_hPo]);\n    }\n    if (output[_rTV] != null) {\n        contents[_RTV] = __expectString(output[_rTV]);\n    }\n    if (output[_rUV] != null) {\n        contents[_RUV] = __expectString(output[_rUV]);\n    }\n    return contents;\n};\nconst de_ReservedInstanceReservationValue = (output, context) => {\n    const contents = {};\n    if (output[_rVe] != null) {\n        contents[_RVe] = de_ReservationValue(output[_rVe], context);\n    }\n    if (output[_rIIe] != null) {\n        contents[_RIIese] = __expectString(output[_rIIe]);\n    }\n    return contents;\n};\nconst de_ReservedInstanceReservationValueSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ReservedInstanceReservationValue(entry, context);\n    });\n};\nconst de_ReservedInstances = (output, context) => {\n    const contents = {};\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    if (output[_iTns] != null) {\n        contents[_ITns] = __expectString(output[_iTns]);\n    }\n    if (output[_oC] != null) {\n        contents[_OC] = __expectString(output[_oC]);\n    }\n    if (output[_oTf] != null) {\n        contents[_OT] = __expectString(output[_oTf]);\n    }\n    if (output.recurringCharges === \"\") {\n        contents[_RCec] = [];\n    }\n    else if (output[_rCec] != null && output[_rCec][_i] != null) {\n        contents[_RCec] = de_RecurringChargesList(__getArrayIfSingleItem(output[_rCec][_i]), context);\n    }\n    if (output[_sc] != null) {\n        contents[_Sc] = __expectString(output[_sc]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    if (output[_rII] != null) {\n        contents[_RIIe] = __expectString(output[_rII]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_star] != null) {\n        contents[_Star] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_star]));\n    }\n    if (output[_end] != null) {\n        contents[_End] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_end]));\n    }\n    if (output[_du] != null) {\n        contents[_Du] = __strictParseLong(output[_du]);\n    }\n    if (output[_uPs] != null) {\n        contents[_UPs] = __strictParseFloat(output[_uPs]);\n    }\n    if (output[_fPix] != null) {\n        contents[_FPix] = __strictParseFloat(output[_fPix]);\n    }\n    if (output[_iC] != null) {\n        contents[_IC] = __strictParseInt32(output[_iC]);\n    }\n    if (output[_pDr] != null) {\n        contents[_PDr] = __expectString(output[_pDr]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_ReservedInstancesConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_iC] != null) {\n        contents[_IC] = __strictParseInt32(output[_iC]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_pl] != null) {\n        contents[_Pla] = __expectString(output[_pl]);\n    }\n    if (output[_sc] != null) {\n        contents[_Sc] = __expectString(output[_sc]);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    return contents;\n};\nconst de_ReservedInstancesId = (output, context) => {\n    const contents = {};\n    if (output[_rII] != null) {\n        contents[_RIIe] = __expectString(output[_rII]);\n    }\n    return contents;\n};\nconst de_ReservedInstancesList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ReservedInstances(entry, context);\n    });\n};\nconst de_ReservedInstancesListing = (output, context) => {\n    const contents = {};\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    if (output[_cD] != null) {\n        contents[_CDr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cD]));\n    }\n    if (output.instanceCounts === \"\") {\n        contents[_ICn] = [];\n    }\n    else if (output[_iCn] != null && output[_iCn][_i] != null) {\n        contents[_ICn] = de_InstanceCountList(__getArrayIfSingleItem(output[_iCn][_i]), context);\n    }\n    if (output.priceSchedules === \"\") {\n        contents[_PS] = [];\n    }\n    else if (output[_pSric] != null && output[_pSric][_i] != null) {\n        contents[_PS] = de_PriceScheduleList(__getArrayIfSingleItem(output[_pSric][_i]), context);\n    }\n    if (output[_rII] != null) {\n        contents[_RIIe] = __expectString(output[_rII]);\n    }\n    if (output[_rILI] != null) {\n        contents[_RILI] = __expectString(output[_rILI]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_uDpd] != null) {\n        contents[_UDpd] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uDpd]));\n    }\n    return contents;\n};\nconst de_ReservedInstancesListingList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ReservedInstancesListing(entry, context);\n    });\n};\nconst de_ReservedInstancesModification = (output, context) => {\n    const contents = {};\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    if (output[_cD] != null) {\n        contents[_CDr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cD]));\n    }\n    if (output[_eDf] != null) {\n        contents[_EDf] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eDf]));\n    }\n    if (output.modificationResultSet === \"\") {\n        contents[_MRo] = [];\n    }\n    else if (output[_mRS] != null && output[_mRS][_i] != null) {\n        contents[_MRo] = de_ReservedInstancesModificationResultList(__getArrayIfSingleItem(output[_mRS][_i]), context);\n    }\n    if (output.reservedInstancesSet === \"\") {\n        contents[_RIIes] = [];\n    }\n    else if (output[_rIS] != null && output[_rIS][_i] != null) {\n        contents[_RIIes] = de_ReservedIntancesIds(__getArrayIfSingleItem(output[_rIS][_i]), context);\n    }\n    if (output[_rIMI] != null) {\n        contents[_RIMIe] = __expectString(output[_rIMI]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_uDpd] != null) {\n        contents[_UDpd] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uDpd]));\n    }\n    return contents;\n};\nconst de_ReservedInstancesModificationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ReservedInstancesModification(entry, context);\n    });\n};\nconst de_ReservedInstancesModificationResult = (output, context) => {\n    const contents = {};\n    if (output[_rII] != null) {\n        contents[_RIIe] = __expectString(output[_rII]);\n    }\n    if (output[_tCa] != null) {\n        contents[_TCar] = de_ReservedInstancesConfiguration(output[_tCa], context);\n    }\n    return contents;\n};\nconst de_ReservedInstancesModificationResultList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ReservedInstancesModificationResult(entry, context);\n    });\n};\nconst de_ReservedInstancesOffering = (output, context) => {\n    const contents = {};\n    if (output[_cC] != null) {\n        contents[_CCu] = __expectString(output[_cC]);\n    }\n    if (output[_iTns] != null) {\n        contents[_ITns] = __expectString(output[_iTns]);\n    }\n    if (output[_mar] != null) {\n        contents[_Mar] = __parseBoolean(output[_mar]);\n    }\n    if (output[_oC] != null) {\n        contents[_OC] = __expectString(output[_oC]);\n    }\n    if (output[_oTf] != null) {\n        contents[_OT] = __expectString(output[_oTf]);\n    }\n    if (output.pricingDetailsSet === \"\") {\n        contents[_PDri] = [];\n    }\n    else if (output[_pDS] != null && output[_pDS][_i] != null) {\n        contents[_PDri] = de_PricingDetailsList(__getArrayIfSingleItem(output[_pDS][_i]), context);\n    }\n    if (output.recurringCharges === \"\") {\n        contents[_RCec] = [];\n    }\n    else if (output[_rCec] != null && output[_rCec][_i] != null) {\n        contents[_RCec] = de_RecurringChargesList(__getArrayIfSingleItem(output[_rCec][_i]), context);\n    }\n    if (output[_sc] != null) {\n        contents[_Sc] = __expectString(output[_sc]);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    if (output[_rIOI] != null) {\n        contents[_RIOIe] = __expectString(output[_rIOI]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_du] != null) {\n        contents[_Du] = __strictParseLong(output[_du]);\n    }\n    if (output[_uPs] != null) {\n        contents[_UPs] = __strictParseFloat(output[_uPs]);\n    }\n    if (output[_fPix] != null) {\n        contents[_FPix] = __strictParseFloat(output[_fPix]);\n    }\n    if (output[_pDr] != null) {\n        contents[_PDr] = __expectString(output[_pDr]);\n    }\n    return contents;\n};\nconst de_ReservedInstancesOfferingList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ReservedInstancesOffering(entry, context);\n    });\n};\nconst de_ReservedIntancesIds = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ReservedInstancesId(entry, context);\n    });\n};\nconst de_ResetAddressAttributeResult = (output, context) => {\n    const contents = {};\n    if (output[_ad] != null) {\n        contents[_Ad] = de_AddressAttribute(output[_ad], context);\n    }\n    return contents;\n};\nconst de_ResetEbsDefaultKmsKeyIdResult = (output, context) => {\n    const contents = {};\n    if (output[_kKI] != null) {\n        contents[_KKI] = __expectString(output[_kKI]);\n    }\n    return contents;\n};\nconst de_ResetFpgaImageAttributeResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_ResourceStatement = (output, context) => {\n    const contents = {};\n    if (output.resourceSet === \"\") {\n        contents[_Re] = [];\n    }\n    else if (output[_rSesou] != null && output[_rSesou][_i] != null) {\n        contents[_Re] = de_ValueStringList(__getArrayIfSingleItem(output[_rSesou][_i]), context);\n    }\n    if (output.resourceTypeSet === \"\") {\n        contents[_RTeso] = [];\n    }\n    else if (output[_rTSes] != null && output[_rTSes][_i] != null) {\n        contents[_RTeso] = de_ValueStringList(__getArrayIfSingleItem(output[_rTSes][_i]), context);\n    }\n    return contents;\n};\nconst de_ResponseError = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_ResponseHostIdList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_ResponseHostIdSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_ResponseLaunchTemplateData = (output, context) => {\n    const contents = {};\n    if (output[_kI] != null) {\n        contents[_KI] = __expectString(output[_kI]);\n    }\n    if (output[_eO] != null) {\n        contents[_EO] = __parseBoolean(output[_eO]);\n    }\n    if (output[_iIP] != null) {\n        contents[_IIP] = de_LaunchTemplateIamInstanceProfileSpecification(output[_iIP], context);\n    }\n    if (output.blockDeviceMappingSet === \"\") {\n        contents[_BDM] = [];\n    }\n    else if (output[_bDMS] != null && output[_bDMS][_i] != null) {\n        contents[_BDM] = de_LaunchTemplateBlockDeviceMappingList(__getArrayIfSingleItem(output[_bDMS][_i]), context);\n    }\n    if (output.networkInterfaceSet === \"\") {\n        contents[_NI] = [];\n    }\n    else if (output[_nIS] != null && output[_nIS][_i] != null) {\n        contents[_NI] = de_LaunchTemplateInstanceNetworkInterfaceSpecificationList(__getArrayIfSingleItem(output[_nIS][_i]), context);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_kN] != null) {\n        contents[_KN] = __expectString(output[_kN]);\n    }\n    if (output[_mo] != null) {\n        contents[_Mon] = de_LaunchTemplatesMonitoring(output[_mo], context);\n    }\n    if (output[_pla] != null) {\n        contents[_Pl] = de_LaunchTemplatePlacement(output[_pla], context);\n    }\n    if (output[_rDI] != null) {\n        contents[_RDI] = __expectString(output[_rDI]);\n    }\n    if (output[_dAT] != null) {\n        contents[_DATis] = __parseBoolean(output[_dAT]);\n    }\n    if (output[_iISB] != null) {\n        contents[_IISB] = __expectString(output[_iISB]);\n    }\n    if (output[_uDs] != null) {\n        contents[_UD] = __expectString(output[_uDs]);\n    }\n    if (output.tagSpecificationSet === \"\") {\n        contents[_TS] = [];\n    }\n    else if (output[_tSS] != null && output[_tSS][_i] != null) {\n        contents[_TS] = de_LaunchTemplateTagSpecificationList(__getArrayIfSingleItem(output[_tSS][_i]), context);\n    }\n    if (output.elasticGpuSpecificationSet === \"\") {\n        contents[_EGS] = [];\n    }\n    else if (output[_eGSS] != null && output[_eGSS][_i] != null) {\n        contents[_EGS] = de_ElasticGpuSpecificationResponseList(__getArrayIfSingleItem(output[_eGSS][_i]), context);\n    }\n    if (output.elasticInferenceAcceleratorSet === \"\") {\n        contents[_EIA] = [];\n    }\n    else if (output[_eIAS] != null && output[_eIAS][_i] != null) {\n        contents[_EIA] = de_LaunchTemplateElasticInferenceAcceleratorResponseList(__getArrayIfSingleItem(output[_eIAS][_i]), context);\n    }\n    if (output.securityGroupIdSet === \"\") {\n        contents[_SGI] = [];\n    }\n    else if (output[_sGIS] != null && output[_sGIS][_i] != null) {\n        contents[_SGI] = de_ValueStringList(__getArrayIfSingleItem(output[_sGIS][_i]), context);\n    }\n    if (output.securityGroupSet === \"\") {\n        contents[_SG] = [];\n    }\n    else if (output[_sGS] != null && output[_sGS][_i] != null) {\n        contents[_SG] = de_ValueStringList(__getArrayIfSingleItem(output[_sGS][_i]), context);\n    }\n    if (output[_iMOn] != null) {\n        contents[_IMO] = de_LaunchTemplateInstanceMarketOptions(output[_iMOn], context);\n    }\n    if (output[_cSr] != null) {\n        contents[_CSred] = de_CreditSpecification(output[_cSr], context);\n    }\n    if (output[_cO] != null) {\n        contents[_COp] = de_LaunchTemplateCpuOptions(output[_cO], context);\n    }\n    if (output[_cRSa] != null) {\n        contents[_CRSa] = de_LaunchTemplateCapacityReservationSpecificationResponse(output[_cRSa], context);\n    }\n    if (output.licenseSet === \"\") {\n        contents[_LSi] = [];\n    }\n    else if (output[_lSi] != null && output[_lSi][_i] != null) {\n        contents[_LSi] = de_LaunchTemplateLicenseList(__getArrayIfSingleItem(output[_lSi][_i]), context);\n    }\n    if (output[_hO] != null) {\n        contents[_HO] = de_LaunchTemplateHibernationOptions(output[_hO], context);\n    }\n    if (output[_mO] != null) {\n        contents[_MO] = de_LaunchTemplateInstanceMetadataOptions(output[_mO], context);\n    }\n    if (output[_eOn] != null) {\n        contents[_EOn] = de_LaunchTemplateEnclaveOptions(output[_eOn], context);\n    }\n    if (output[_iR] != null) {\n        contents[_IR] = de_InstanceRequirements(output[_iR], context);\n    }\n    if (output[_pDNO] != null) {\n        contents[_PDNO] = de_LaunchTemplatePrivateDnsNameOptions(output[_pDNO], context);\n    }\n    if (output[_mOa] != null) {\n        contents[_MOa] = de_LaunchTemplateInstanceMaintenanceOptions(output[_mOa], context);\n    }\n    if (output[_dASi] != null) {\n        contents[_DASi] = __parseBoolean(output[_dASi]);\n    }\n    if (output[_op] != null) {\n        contents[_O] = de_OperatorResponse(output[_op], context);\n    }\n    if (output[_nPO] != null) {\n        contents[_NPO] = de_LaunchTemplateNetworkPerformanceOptions(output[_nPO], context);\n    }\n    return contents;\n};\nconst de_RestoreAddressToClassicResult = (output, context) => {\n    const contents = {};\n    if (output[_pI] != null) {\n        contents[_PI] = __expectString(output[_pI]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_RestoreImageFromRecycleBinResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_RestoreManagedPrefixListVersionResult = (output, context) => {\n    const contents = {};\n    if (output[_pL] != null) {\n        contents[_PLr] = de_ManagedPrefixList(output[_pL], context);\n    }\n    return contents;\n};\nconst de_RestoreSnapshotFromRecycleBinResult = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_enc] != null) {\n        contents[_Enc] = __parseBoolean(output[_enc]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_pro] != null) {\n        contents[_Prog] = __expectString(output[_pro]);\n    }\n    if (output[_sT] != null) {\n        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));\n    }\n    if (output[_sta] != null) {\n        contents[_Stat] = __expectString(output[_sta]);\n    }\n    if (output[_vIo] != null) {\n        contents[_VIo] = __expectString(output[_vIo]);\n    }\n    if (output[_vSo] != null) {\n        contents[_VS] = __strictParseInt32(output[_vSo]);\n    }\n    if (output[_sTs] != null) {\n        contents[_STs] = __expectString(output[_sTs]);\n    }\n    return contents;\n};\nconst de_RestoreSnapshotTierResult = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_rST] != null) {\n        contents[_RSTe] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rST]));\n    }\n    if (output[_rD] != null) {\n        contents[_RD] = __strictParseInt32(output[_rD]);\n    }\n    if (output[_iPR] != null) {\n        contents[_IPR] = __parseBoolean(output[_iPR]);\n    }\n    return contents;\n};\nconst de_RevokeClientVpnIngressResult = (output, context) => {\n    const contents = {};\n    if (output[_sta] != null) {\n        contents[_Statu] = de_ClientVpnAuthorizationRuleStatus(output[_sta], context);\n    }\n    return contents;\n};\nconst de_RevokedSecurityGroupRule = (output, context) => {\n    const contents = {};\n    if (output[_sGRI] != null) {\n        contents[_SGRIe] = __expectString(output[_sGRI]);\n    }\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output[_iEs] != null) {\n        contents[_IE] = __parseBoolean(output[_iEs]);\n    }\n    if (output[_iPpr] != null) {\n        contents[_IPpr] = __expectString(output[_iPpr]);\n    }\n    if (output[_fP] != null) {\n        contents[_FP] = __strictParseInt32(output[_fP]);\n    }\n    if (output[_tPo] != null) {\n        contents[_TP] = __strictParseInt32(output[_tPo]);\n    }\n    if (output[_cIidr] != null) {\n        contents[_CIidr] = __expectString(output[_cIidr]);\n    }\n    if (output[_cIid] != null) {\n        contents[_CIid] = __expectString(output[_cIid]);\n    }\n    if (output[_pLI] != null) {\n        contents[_PLI] = __expectString(output[_pLI]);\n    }\n    if (output[_rGI] != null) {\n        contents[_RGI] = __expectString(output[_rGI]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    return contents;\n};\nconst de_RevokedSecurityGroupRuleList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RevokedSecurityGroupRule(entry, context);\n    });\n};\nconst de_RevokeSecurityGroupEgressResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    if (output.unknownIpPermissionSet === \"\") {\n        contents[_UIP] = [];\n    }\n    else if (output[_uIPS] != null && output[_uIPS][_i] != null) {\n        contents[_UIP] = de_IpPermissionList(__getArrayIfSingleItem(output[_uIPS][_i]), context);\n    }\n    if (output.revokedSecurityGroupRuleSet === \"\") {\n        contents[_RSGR] = [];\n    }\n    else if (output[_rSGRS] != null && output[_rSGRS][_i] != null) {\n        contents[_RSGR] = de_RevokedSecurityGroupRuleList(__getArrayIfSingleItem(output[_rSGRS][_i]), context);\n    }\n    return contents;\n};\nconst de_RevokeSecurityGroupIngressResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    if (output.unknownIpPermissionSet === \"\") {\n        contents[_UIP] = [];\n    }\n    else if (output[_uIPS] != null && output[_uIPS][_i] != null) {\n        contents[_UIP] = de_IpPermissionList(__getArrayIfSingleItem(output[_uIPS][_i]), context);\n    }\n    if (output.revokedSecurityGroupRuleSet === \"\") {\n        contents[_RSGR] = [];\n    }\n    else if (output[_rSGRS] != null && output[_rSGRS][_i] != null) {\n        contents[_RSGR] = de_RevokedSecurityGroupRuleList(__getArrayIfSingleItem(output[_rSGRS][_i]), context);\n    }\n    return contents;\n};\nconst de_RootDeviceTypeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_Route = (output, context) => {\n    const contents = {};\n    if (output[_dCB] != null) {\n        contents[_DCB] = __expectString(output[_dCB]);\n    }\n    if (output[_dICB] != null) {\n        contents[_DICB] = __expectString(output[_dICB]);\n    }\n    if (output[_dPLI] != null) {\n        contents[_DPLI] = __expectString(output[_dPLI]);\n    }\n    if (output[_eOIGI] != null) {\n        contents[_EOIGI] = __expectString(output[_eOIGI]);\n    }\n    if (output[_gI] != null) {\n        contents[_GI] = __expectString(output[_gI]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_iOIn] != null) {\n        contents[_IOIn] = __expectString(output[_iOIn]);\n    }\n    if (output[_nGI] != null) {\n        contents[_NGI] = __expectString(output[_nGI]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_lGI] != null) {\n        contents[_LGI] = __expectString(output[_lGI]);\n    }\n    if (output[_cGI] != null) {\n        contents[_CGI] = __expectString(output[_cGI]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_o] != null) {\n        contents[_Or] = __expectString(output[_o]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_vPCI] != null) {\n        contents[_VPCI] = __expectString(output[_vPCI]);\n    }\n    if (output[_cNA] != null) {\n        contents[_CNAo] = __expectString(output[_cNA]);\n    }\n    return contents;\n};\nconst de_RouteList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Route(entry, context);\n    });\n};\nconst de_RouteServer = (output, context) => {\n    const contents = {};\n    if (output[_rSI] != null) {\n        contents[_RSIo] = __expectString(output[_rSI]);\n    }\n    if (output[_aSA] != null) {\n        contents[_ASA] = __strictParseLong(output[_aSA]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_pRSe] != null) {\n        contents[_PRS] = __expectString(output[_pRSe]);\n    }\n    if (output[_pRD] != null) {\n        contents[_PRD] = __strictParseLong(output[_pRD]);\n    }\n    if (output[_sNE] != null) {\n        contents[_SNE] = __parseBoolean(output[_sNE]);\n    }\n    if (output[_sTA] != null) {\n        contents[_STA] = __expectString(output[_sTA]);\n    }\n    return contents;\n};\nconst de_RouteServerAssociation = (output, context) => {\n    const contents = {};\n    if (output[_rSI] != null) {\n        contents[_RSIo] = __expectString(output[_rSI]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_RouteServerAssociationsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RouteServerAssociation(entry, context);\n    });\n};\nconst de_RouteServerBfdStatus = (output, context) => {\n    const contents = {};\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_RouteServerBgpOptions = (output, context) => {\n    const contents = {};\n    if (output[_pAee] != null) {\n        contents[_PAee] = __strictParseLong(output[_pAee]);\n    }\n    if (output[_pLD] != null) {\n        contents[_PLD] = __expectString(output[_pLD]);\n    }\n    return contents;\n};\nconst de_RouteServerBgpStatus = (output, context) => {\n    const contents = {};\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_RouteServerEndpoint = (output, context) => {\n    const contents = {};\n    if (output[_rSI] != null) {\n        contents[_RSIo] = __expectString(output[_rSI]);\n    }\n    if (output[_rSEI] != null) {\n        contents[_RSEI] = __expectString(output[_rSEI]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_eIn] != null) {\n        contents[_EIn] = __expectString(output[_eIn]);\n    }\n    if (output[_eA] != null) {\n        contents[_EAn] = __expectString(output[_eA]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_fR] != null) {\n        contents[_FR] = __expectString(output[_fR]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_RouteServerEndpointsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RouteServerEndpoint(entry, context);\n    });\n};\nconst de_RouteServerPeer = (output, context) => {\n    const contents = {};\n    if (output[_rSPI] != null) {\n        contents[_RSPI] = __expectString(output[_rSPI]);\n    }\n    if (output[_rSEI] != null) {\n        contents[_RSEI] = __expectString(output[_rSEI]);\n    }\n    if (output[_rSI] != null) {\n        contents[_RSIo] = __expectString(output[_rSI]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_fR] != null) {\n        contents[_FR] = __expectString(output[_fR]);\n    }\n    if (output[_eEI] != null) {\n        contents[_EEI] = __expectString(output[_eEI]);\n    }\n    if (output[_eEA] != null) {\n        contents[_EEA] = __expectString(output[_eEA]);\n    }\n    if (output[_pAe] != null) {\n        contents[_PAe] = __expectString(output[_pAe]);\n    }\n    if (output[_bO] != null) {\n        contents[_BO] = de_RouteServerBgpOptions(output[_bO], context);\n    }\n    if (output[_bSg] != null) {\n        contents[_BSg] = de_RouteServerBgpStatus(output[_bSg], context);\n    }\n    if (output[_bSf] != null) {\n        contents[_BSf] = de_RouteServerBfdStatus(output[_bSf], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_RouteServerPeersList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RouteServerPeer(entry, context);\n    });\n};\nconst de_RouteServerPropagation = (output, context) => {\n    const contents = {};\n    if (output[_rSI] != null) {\n        contents[_RSIo] = __expectString(output[_rSI]);\n    }\n    if (output[_rTI] != null) {\n        contents[_RTI] = __expectString(output[_rTI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_RouteServerPropagationsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RouteServerPropagation(entry, context);\n    });\n};\nconst de_RouteServerRoute = (output, context) => {\n    const contents = {};\n    if (output[_rSEI] != null) {\n        contents[_RSEI] = __expectString(output[_rSEI]);\n    }\n    if (output[_rSPI] != null) {\n        contents[_RSPI] = __expectString(output[_rSPI]);\n    }\n    if (output.routeInstallationDetailSet === \"\") {\n        contents[_RID] = [];\n    }\n    else if (output[_rIDS] != null && output[_rIDS][_i] != null) {\n        contents[_RID] = de_RouteServerRouteInstallationDetails(__getArrayIfSingleItem(output[_rIDS][_i]), context);\n    }\n    if (output[_rSout] != null) {\n        contents[_RSout] = __expectString(output[_rSout]);\n    }\n    if (output[_pre] != null) {\n        contents[_Pr] = __expectString(output[_pre]);\n    }\n    if (output.asPathSet === \"\") {\n        contents[_APs] = [];\n    }\n    else if (output[_aPSs] != null && output[_aPSs][_i] != null) {\n        contents[_APs] = de_AsPath(__getArrayIfSingleItem(output[_aPSs][_i]), context);\n    }\n    if (output[_med] != null) {\n        contents[_Med] = __strictParseInt32(output[_med]);\n    }\n    if (output[_nHI] != null) {\n        contents[_NHI] = __expectString(output[_nHI]);\n    }\n    return contents;\n};\nconst de_RouteServerRouteInstallationDetail = (output, context) => {\n    const contents = {};\n    if (output[_rTI] != null) {\n        contents[_RTI] = __expectString(output[_rTI]);\n    }\n    if (output[_rISo] != null) {\n        contents[_RISo] = __expectString(output[_rISo]);\n    }\n    if (output[_rISR] != null) {\n        contents[_RISR] = __expectString(output[_rISR]);\n    }\n    return contents;\n};\nconst de_RouteServerRouteInstallationDetails = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RouteServerRouteInstallationDetail(entry, context);\n    });\n};\nconst de_RouteServerRouteList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RouteServerRoute(entry, context);\n    });\n};\nconst de_RouteServersList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RouteServer(entry, context);\n    });\n};\nconst de_RouteTable = (output, context) => {\n    const contents = {};\n    if (output.associationSet === \"\") {\n        contents[_Ass] = [];\n    }\n    else if (output[_aSss] != null && output[_aSss][_i] != null) {\n        contents[_Ass] = de_RouteTableAssociationList(__getArrayIfSingleItem(output[_aSss][_i]), context);\n    }\n    if (output.propagatingVgwSet === \"\") {\n        contents[_PVr] = [];\n    }\n    else if (output[_pVS] != null && output[_pVS][_i] != null) {\n        contents[_PVr] = de_PropagatingVgwList(__getArrayIfSingleItem(output[_pVS][_i]), context);\n    }\n    if (output[_rTI] != null) {\n        contents[_RTI] = __expectString(output[_rTI]);\n    }\n    if (output.routeSet === \"\") {\n        contents[_Rout] = [];\n    }\n    else if (output[_rSou] != null && output[_rSou][_i] != null) {\n        contents[_Rout] = de_RouteList(__getArrayIfSingleItem(output[_rSou][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    return contents;\n};\nconst de_RouteTableAssociation = (output, context) => {\n    const contents = {};\n    if (output[_mai] != null) {\n        contents[_Mai] = __parseBoolean(output[_mai]);\n    }\n    if (output[_rTAI] != null) {\n        contents[_RTAI] = __expectString(output[_rTAI]);\n    }\n    if (output[_rTI] != null) {\n        contents[_RTI] = __expectString(output[_rTI]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_gI] != null) {\n        contents[_GI] = __expectString(output[_gI]);\n    }\n    if (output[_aS] != null) {\n        contents[_ASs] = de_RouteTableAssociationState(output[_aS], context);\n    }\n    return contents;\n};\nconst de_RouteTableAssociationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RouteTableAssociation(entry, context);\n    });\n};\nconst de_RouteTableAssociationState = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    return contents;\n};\nconst de_RouteTableList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RouteTable(entry, context);\n    });\n};\nconst de_RuleGroupRuleOptionsPair = (output, context) => {\n    const contents = {};\n    if (output[_rGA] != null) {\n        contents[_RGA] = __expectString(output[_rGA]);\n    }\n    if (output.ruleOptionSet === \"\") {\n        contents[_ROu] = [];\n    }\n    else if (output[_rOS] != null && output[_rOS][_i] != null) {\n        contents[_ROu] = de_RuleOptionList(__getArrayIfSingleItem(output[_rOS][_i]), context);\n    }\n    return contents;\n};\nconst de_RuleGroupRuleOptionsPairList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RuleGroupRuleOptionsPair(entry, context);\n    });\n};\nconst de_RuleGroupTypePair = (output, context) => {\n    const contents = {};\n    if (output[_rGA] != null) {\n        contents[_RGA] = __expectString(output[_rGA]);\n    }\n    if (output[_rGT] != null) {\n        contents[_RGT] = __expectString(output[_rGT]);\n    }\n    return contents;\n};\nconst de_RuleGroupTypePairList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RuleGroupTypePair(entry, context);\n    });\n};\nconst de_RuleOption = (output, context) => {\n    const contents = {};\n    if (output[_key] != null) {\n        contents[_Key] = __expectString(output[_key]);\n    }\n    if (output.settingSet === \"\") {\n        contents[_Set] = [];\n    }\n    else if (output[_sSe] != null && output[_sSe][_i] != null) {\n        contents[_Set] = de_StringList(__getArrayIfSingleItem(output[_sSe][_i]), context);\n    }\n    return contents;\n};\nconst de_RuleOptionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_RuleOption(entry, context);\n    });\n};\nconst de_RunInstancesMonitoringEnabled = (output, context) => {\n    const contents = {};\n    if (output[_en] != null) {\n        contents[_En] = __parseBoolean(output[_en]);\n    }\n    return contents;\n};\nconst de_RunScheduledInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.instanceIdSet === \"\") {\n        contents[_IIS] = [];\n    }\n    else if (output[_iIS] != null && output[_iIS][_i] != null) {\n        contents[_IIS] = de_InstanceIdSet(__getArrayIfSingleItem(output[_iIS][_i]), context);\n    }\n    return contents;\n};\nconst de_S3Storage = (output, context) => {\n    const contents = {};\n    if (output[_AWSAKI] != null) {\n        contents[_AWSAKI] = __expectString(output[_AWSAKI]);\n    }\n    if (output[_bu] != null) {\n        contents[_B] = __expectString(output[_bu]);\n    }\n    if (output[_pre] != null) {\n        contents[_Pr] = __expectString(output[_pre]);\n    }\n    if (output[_uPp] != null) {\n        contents[_UP] = context.base64Decoder(output[_uPp]);\n    }\n    if (output[_uPS] != null) {\n        contents[_UPS] = __expectString(output[_uPS]);\n    }\n    return contents;\n};\nconst de_ScheduledInstance = (output, context) => {\n    const contents = {};\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_cD] != null) {\n        contents[_CDr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cD]));\n    }\n    if (output[_hPo] != null) {\n        contents[_HPo] = __expectString(output[_hPo]);\n    }\n    if (output[_iC] != null) {\n        contents[_IC] = __strictParseInt32(output[_iC]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_nPet] != null) {\n        contents[_NPet] = __expectString(output[_nPet]);\n    }\n    if (output[_nSST] != null) {\n        contents[_NSST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nSST]));\n    }\n    if (output[_pl] != null) {\n        contents[_Pla] = __expectString(output[_pl]);\n    }\n    if (output[_pSET] != null) {\n        contents[_PSET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_pSET]));\n    }\n    if (output[_rec] != null) {\n        contents[_Rec] = de_ScheduledInstanceRecurrence(output[_rec], context);\n    }\n    if (output[_sIIc] != null) {\n        contents[_SIIch] = __expectString(output[_sIIc]);\n    }\n    if (output[_sDIH] != null) {\n        contents[_SDIH] = __strictParseInt32(output[_sDIH]);\n    }\n    if (output[_tED] != null) {\n        contents[_TED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tED]));\n    }\n    if (output[_tSD] != null) {\n        contents[_TSD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tSD]));\n    }\n    if (output[_tSIH] != null) {\n        contents[_TSIH] = __strictParseInt32(output[_tSIH]);\n    }\n    return contents;\n};\nconst de_ScheduledInstanceAvailability = (output, context) => {\n    const contents = {};\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_aICv] != null) {\n        contents[_AICv] = __strictParseInt32(output[_aICv]);\n    }\n    if (output[_fSST] != null) {\n        contents[_FSST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_fSST]));\n    }\n    if (output[_hPo] != null) {\n        contents[_HPo] = __expectString(output[_hPo]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_mTDID] != null) {\n        contents[_MTDID] = __strictParseInt32(output[_mTDID]);\n    }\n    if (output[_mTDIDi] != null) {\n        contents[_MTDIDi] = __strictParseInt32(output[_mTDIDi]);\n    }\n    if (output[_nPet] != null) {\n        contents[_NPet] = __expectString(output[_nPet]);\n    }\n    if (output[_pl] != null) {\n        contents[_Pla] = __expectString(output[_pl]);\n    }\n    if (output[_pTu] != null) {\n        contents[_PT] = __expectString(output[_pTu]);\n    }\n    if (output[_rec] != null) {\n        contents[_Rec] = de_ScheduledInstanceRecurrence(output[_rec], context);\n    }\n    if (output[_sDIH] != null) {\n        contents[_SDIH] = __strictParseInt32(output[_sDIH]);\n    }\n    if (output[_tSIH] != null) {\n        contents[_TSIH] = __strictParseInt32(output[_tSIH]);\n    }\n    return contents;\n};\nconst de_ScheduledInstanceAvailabilitySet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ScheduledInstanceAvailability(entry, context);\n    });\n};\nconst de_ScheduledInstanceRecurrence = (output, context) => {\n    const contents = {};\n    if (output[_fre] != null) {\n        contents[_Fre] = __expectString(output[_fre]);\n    }\n    if (output[_int] != null) {\n        contents[_Int] = __strictParseInt32(output[_int]);\n    }\n    if (output.occurrenceDaySet === \"\") {\n        contents[_ODS] = [];\n    }\n    else if (output[_oDS] != null && output[_oDS][_i] != null) {\n        contents[_ODS] = de_OccurrenceDaySet(__getArrayIfSingleItem(output[_oDS][_i]), context);\n    }\n    if (output[_oRTE] != null) {\n        contents[_ORTE] = __parseBoolean(output[_oRTE]);\n    }\n    if (output[_oU] != null) {\n        contents[_OU] = __expectString(output[_oU]);\n    }\n    return contents;\n};\nconst de_ScheduledInstanceSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ScheduledInstance(entry, context);\n    });\n};\nconst de_SearchLocalGatewayRoutesResult = (output, context) => {\n    const contents = {};\n    if (output.routeSet === \"\") {\n        contents[_Rout] = [];\n    }\n    else if (output[_rSou] != null && output[_rSou][_i] != null) {\n        contents[_Rout] = de_LocalGatewayRouteList(__getArrayIfSingleItem(output[_rSou][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_SearchTransitGatewayMulticastGroupsResult = (output, context) => {\n    const contents = {};\n    if (output.multicastGroups === \"\") {\n        contents[_MG] = [];\n    }\n    else if (output[_mG] != null && output[_mG][_i] != null) {\n        contents[_MG] = de_TransitGatewayMulticastGroupList(__getArrayIfSingleItem(output[_mG][_i]), context);\n    }\n    if (output[_nTe] != null) {\n        contents[_NT] = __expectString(output[_nTe]);\n    }\n    return contents;\n};\nconst de_SearchTransitGatewayRoutesResult = (output, context) => {\n    const contents = {};\n    if (output.routeSet === \"\") {\n        contents[_Rout] = [];\n    }\n    else if (output[_rSou] != null && output[_rSou][_i] != null) {\n        contents[_Rout] = de_TransitGatewayRouteList(__getArrayIfSingleItem(output[_rSou][_i]), context);\n    }\n    if (output[_aRAd] != null) {\n        contents[_ARAd] = __parseBoolean(output[_aRAd]);\n    }\n    return contents;\n};\nconst de_SecurityGroup = (output, context) => {\n    const contents = {};\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output.ipPermissionsEgress === \"\") {\n        contents[_IPE] = [];\n    }\n    else if (output[_iPE] != null && output[_iPE][_i] != null) {\n        contents[_IPE] = de_IpPermissionList(__getArrayIfSingleItem(output[_iPE][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_sGA] != null) {\n        contents[_SGA] = __expectString(output[_sGA]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    if (output[_gD] != null) {\n        contents[_De] = __expectString(output[_gD]);\n    }\n    if (output.ipPermissions === \"\") {\n        contents[_IPpe] = [];\n    }\n    else if (output[_iPpe] != null && output[_iPpe][_i] != null) {\n        contents[_IPpe] = de_IpPermissionList(__getArrayIfSingleItem(output[_iPpe][_i]), context);\n    }\n    return contents;\n};\nconst de_SecurityGroupForVpc = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_pVI] != null) {\n        contents[_PVIr] = __expectString(output[_pVI]);\n    }\n    return contents;\n};\nconst de_SecurityGroupForVpcList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SecurityGroupForVpc(entry, context);\n    });\n};\nconst de_SecurityGroupIdentifier = (output, context) => {\n    const contents = {};\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    return contents;\n};\nconst de_SecurityGroupIdList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_SecurityGroupIdSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_SecurityGroupIdStringList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_SecurityGroupList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SecurityGroup(entry, context);\n    });\n};\nconst de_SecurityGroupReference = (output, context) => {\n    const contents = {};\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output[_rVI] != null) {\n        contents[_RVI] = __expectString(output[_rVI]);\n    }\n    if (output[_vPCI] != null) {\n        contents[_VPCI] = __expectString(output[_vPCI]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    return contents;\n};\nconst de_SecurityGroupReferences = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SecurityGroupReference(entry, context);\n    });\n};\nconst de_SecurityGroupRule = (output, context) => {\n    const contents = {};\n    if (output[_sGRI] != null) {\n        contents[_SGRIe] = __expectString(output[_sGRI]);\n    }\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output[_gOI] != null) {\n        contents[_GOI] = __expectString(output[_gOI]);\n    }\n    if (output[_iEs] != null) {\n        contents[_IE] = __parseBoolean(output[_iEs]);\n    }\n    if (output[_iPpr] != null) {\n        contents[_IPpr] = __expectString(output[_iPpr]);\n    }\n    if (output[_fP] != null) {\n        contents[_FP] = __strictParseInt32(output[_fP]);\n    }\n    if (output[_tPo] != null) {\n        contents[_TP] = __strictParseInt32(output[_tPo]);\n    }\n    if (output[_cIidr] != null) {\n        contents[_CIidr] = __expectString(output[_cIidr]);\n    }\n    if (output[_cIid] != null) {\n        contents[_CIid] = __expectString(output[_cIid]);\n    }\n    if (output[_pLI] != null) {\n        contents[_PLI] = __expectString(output[_pLI]);\n    }\n    if (output[_rGIe] != null) {\n        contents[_RGIe] = de_ReferencedSecurityGroup(output[_rGIe], context);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_sGRA] != null) {\n        contents[_SGRA] = __expectString(output[_sGRA]);\n    }\n    return contents;\n};\nconst de_SecurityGroupRuleList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SecurityGroupRule(entry, context);\n    });\n};\nconst de_SecurityGroupVpcAssociation = (output, context) => {\n    const contents = {};\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_vOIp] != null) {\n        contents[_VOIp] = __expectString(output[_vOIp]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sRt] != null) {\n        contents[_SRt] = __expectString(output[_sRt]);\n    }\n    return contents;\n};\nconst de_SecurityGroupVpcAssociationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SecurityGroupVpcAssociation(entry, context);\n    });\n};\nconst de_ServiceConfiguration = (output, context) => {\n    const contents = {};\n    if (output.serviceType === \"\") {\n        contents[_STe] = [];\n    }\n    else if (output[_sTe] != null && output[_sTe][_i] != null) {\n        contents[_STe] = de_ServiceTypeDetailSet(__getArrayIfSingleItem(output[_sTe][_i]), context);\n    }\n    if (output[_sI] != null) {\n        contents[_SIe] = __expectString(output[_sI]);\n    }\n    if (output[_sN] != null) {\n        contents[_SNe] = __expectString(output[_sN]);\n    }\n    if (output[_sSer] != null) {\n        contents[_SSe] = __expectString(output[_sSer]);\n    }\n    if (output.availabilityZoneSet === \"\") {\n        contents[_AZv] = [];\n    }\n    else if (output[_aZS] != null && output[_aZS][_i] != null) {\n        contents[_AZv] = de_ValueStringList(__getArrayIfSingleItem(output[_aZS][_i]), context);\n    }\n    if (output[_aRcc] != null) {\n        contents[_ARc] = __parseBoolean(output[_aRcc]);\n    }\n    if (output[_mVE] != null) {\n        contents[_MVEa] = __parseBoolean(output[_mVE]);\n    }\n    if (output.networkLoadBalancerArnSet === \"\") {\n        contents[_NLBAe] = [];\n    }\n    else if (output[_nLBAS] != null && output[_nLBAS][_i] != null) {\n        contents[_NLBAe] = de_ValueStringList(__getArrayIfSingleItem(output[_nLBAS][_i]), context);\n    }\n    if (output.gatewayLoadBalancerArnSet === \"\") {\n        contents[_GLBA] = [];\n    }\n    else if (output[_gLBAS] != null && output[_gLBAS][_i] != null) {\n        contents[_GLBA] = de_ValueStringList(__getArrayIfSingleItem(output[_gLBAS][_i]), context);\n    }\n    if (output.supportedIpAddressTypeSet === \"\") {\n        contents[_SIAT] = [];\n    }\n    else if (output[_sIATS] != null && output[_sIATS][_i] != null) {\n        contents[_SIAT] = de_SupportedIpAddressTypes(__getArrayIfSingleItem(output[_sIATS][_i]), context);\n    }\n    if (output.baseEndpointDnsNameSet === \"\") {\n        contents[_BEDN] = [];\n    }\n    else if (output[_bEDNS] != null && output[_bEDNS][_i] != null) {\n        contents[_BEDN] = de_ValueStringList(__getArrayIfSingleItem(output[_bEDNS][_i]), context);\n    }\n    if (output[_pDN] != null) {\n        contents[_PDN] = __expectString(output[_pDN]);\n    }\n    if (output[_pDNC] != null) {\n        contents[_PDNC] = de_PrivateDnsNameConfiguration(output[_pDNC], context);\n    }\n    if (output[_pRa] != null) {\n        contents[_PRa] = __expectString(output[_pRa]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output.supportedRegionSet === \"\") {\n        contents[_SRu] = [];\n    }\n    else if (output[_sRS] != null && output[_sRS][_i] != null) {\n        contents[_SRu] = de_SupportedRegionSet(__getArrayIfSingleItem(output[_sRS][_i]), context);\n    }\n    if (output[_rAE] != null) {\n        contents[_RAE] = __parseBoolean(output[_rAE]);\n    }\n    return contents;\n};\nconst de_ServiceConfigurationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ServiceConfiguration(entry, context);\n    });\n};\nconst de_ServiceDetail = (output, context) => {\n    const contents = {};\n    if (output[_sN] != null) {\n        contents[_SNe] = __expectString(output[_sN]);\n    }\n    if (output[_sI] != null) {\n        contents[_SIe] = __expectString(output[_sI]);\n    }\n    if (output.serviceType === \"\") {\n        contents[_STe] = [];\n    }\n    else if (output[_sTe] != null && output[_sTe][_i] != null) {\n        contents[_STe] = de_ServiceTypeDetailSet(__getArrayIfSingleItem(output[_sTe][_i]), context);\n    }\n    if (output[_sR] != null) {\n        contents[_SRe] = __expectString(output[_sR]);\n    }\n    if (output.availabilityZoneSet === \"\") {\n        contents[_AZv] = [];\n    }\n    else if (output[_aZS] != null && output[_aZS][_i] != null) {\n        contents[_AZv] = de_ValueStringList(__getArrayIfSingleItem(output[_aZS][_i]), context);\n    }\n    if (output[_ow] != null) {\n        contents[_Own] = __expectString(output[_ow]);\n    }\n    if (output.baseEndpointDnsNameSet === \"\") {\n        contents[_BEDN] = [];\n    }\n    else if (output[_bEDNS] != null && output[_bEDNS][_i] != null) {\n        contents[_BEDN] = de_ValueStringList(__getArrayIfSingleItem(output[_bEDNS][_i]), context);\n    }\n    if (output[_pDN] != null) {\n        contents[_PDN] = __expectString(output[_pDN]);\n    }\n    if (output.privateDnsNameSet === \"\") {\n        contents[_PDNr] = [];\n    }\n    else if (output[_pDNS] != null && output[_pDNS][_i] != null) {\n        contents[_PDNr] = de_PrivateDnsDetailsSet(__getArrayIfSingleItem(output[_pDNS][_i]), context);\n    }\n    if (output[_vEPS] != null) {\n        contents[_VEPS] = __parseBoolean(output[_vEPS]);\n    }\n    if (output[_aRcc] != null) {\n        contents[_ARc] = __parseBoolean(output[_aRcc]);\n    }\n    if (output[_mVE] != null) {\n        contents[_MVEa] = __parseBoolean(output[_mVE]);\n    }\n    if (output[_pRa] != null) {\n        contents[_PRa] = __expectString(output[_pRa]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_pDNVS] != null) {\n        contents[_PDNVS] = __expectString(output[_pDNVS]);\n    }\n    if (output.supportedIpAddressTypeSet === \"\") {\n        contents[_SIAT] = [];\n    }\n    else if (output[_sIATS] != null && output[_sIATS][_i] != null) {\n        contents[_SIAT] = de_SupportedIpAddressTypes(__getArrayIfSingleItem(output[_sIATS][_i]), context);\n    }\n    return contents;\n};\nconst de_ServiceDetailSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ServiceDetail(entry, context);\n    });\n};\nconst de_ServiceLinkVirtualInterface = (output, context) => {\n    const contents = {};\n    if (output[_sLVII] != null) {\n        contents[_SLVIIe] = __expectString(output[_sLVII]);\n    }\n    if (output[_sLVIA] != null) {\n        contents[_SLVIA] = __expectString(output[_sLVIA]);\n    }\n    if (output[_oIu] != null) {\n        contents[_OIu] = __expectString(output[_oIu]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_lA] != null) {\n        contents[_LA] = __expectString(output[_lA]);\n    }\n    if (output[_pAe] != null) {\n        contents[_PAe] = __expectString(output[_pAe]);\n    }\n    if (output[_pBA] != null) {\n        contents[_PBA] = __strictParseLong(output[_pBA]);\n    }\n    if (output[_vl] != null) {\n        contents[_Vl] = __strictParseInt32(output[_vl]);\n    }\n    if (output[_oLI] != null) {\n        contents[_OLI] = __expectString(output[_oLI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_cSon] != null) {\n        contents[_CSon] = __expectString(output[_cSon]);\n    }\n    return contents;\n};\nconst de_ServiceLinkVirtualInterfaceIdSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_ServiceLinkVirtualInterfaceSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ServiceLinkVirtualInterface(entry, context);\n    });\n};\nconst de_ServiceTypeDetail = (output, context) => {\n    const contents = {};\n    if (output[_sTe] != null) {\n        contents[_STe] = __expectString(output[_sTe]);\n    }\n    return contents;\n};\nconst de_ServiceTypeDetailSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ServiceTypeDetail(entry, context);\n    });\n};\nconst de_Snapshot = (output, context) => {\n    const contents = {};\n    if (output[_oAw] != null) {\n        contents[_OAw] = __expectString(output[_oAw]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_sTt] != null) {\n        contents[_STto] = __expectString(output[_sTt]);\n    }\n    if (output[_rET] != null) {\n        contents[_RET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rET]));\n    }\n    if (output[_sTs] != null) {\n        contents[_STs] = __expectString(output[_sTs]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_tTr] != null) {\n        contents[_TTr] = __expectString(output[_tTr]);\n    }\n    if (output[_cDM] != null) {\n        contents[_CDM] = __strictParseInt32(output[_cDM]);\n    }\n    if (output[_cTomp] != null) {\n        contents[_CTomp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTomp]));\n    }\n    if (output[_fSSIB] != null) {\n        contents[_FSSIB] = __strictParseLong(output[_fSSIB]);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_vIo] != null) {\n        contents[_VIo] = __expectString(output[_vIo]);\n    }\n    if (output[_sta] != null) {\n        contents[_Stat] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMta] = __expectString(output[_sMt]);\n    }\n    if (output[_sT] != null) {\n        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));\n    }\n    if (output[_pro] != null) {\n        contents[_Prog] = __expectString(output[_pro]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_vSo] != null) {\n        contents[_VS] = __strictParseInt32(output[_vSo]);\n    }\n    if (output[_enc] != null) {\n        contents[_Enc] = __parseBoolean(output[_enc]);\n    }\n    if (output[_kKI] != null) {\n        contents[_KKI] = __expectString(output[_kKI]);\n    }\n    if (output[_dEKI] != null) {\n        contents[_DEKI] = __expectString(output[_dEKI]);\n    }\n    return contents;\n};\nconst de_SnapshotDetail = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_dN] != null) {\n        contents[_DN] = __expectString(output[_dN]);\n    }\n    if (output[_dIS] != null) {\n        contents[_DISi] = __strictParseFloat(output[_dIS]);\n    }\n    if (output[_f] != null) {\n        contents[_Fo] = __expectString(output[_f]);\n    }\n    if (output[_pro] != null) {\n        contents[_Prog] = __expectString(output[_pro]);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_ur] != null) {\n        contents[_U] = __expectString(output[_ur]);\n    }\n    if (output[_uB] != null) {\n        contents[_UB] = de_UserBucketDetails(output[_uB], context);\n    }\n    return contents;\n};\nconst de_SnapshotDetailList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SnapshotDetail(entry, context);\n    });\n};\nconst de_SnapshotInfo = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_enc] != null) {\n        contents[_Enc] = __parseBoolean(output[_enc]);\n    }\n    if (output[_vIo] != null) {\n        contents[_VIo] = __expectString(output[_vIo]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_vSo] != null) {\n        contents[_VS] = __strictParseInt32(output[_vSo]);\n    }\n    if (output[_sT] != null) {\n        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));\n    }\n    if (output[_pro] != null) {\n        contents[_Prog] = __expectString(output[_pro]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_sTs] != null) {\n        contents[_STs] = __expectString(output[_sTs]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    return contents;\n};\nconst de_SnapshotList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Snapshot(entry, context);\n    });\n};\nconst de_SnapshotRecycleBinInfo = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_rBET] != null) {\n        contents[_RBET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rBET]));\n    }\n    if (output[_rBETe] != null) {\n        contents[_RBETe] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rBETe]));\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_vIo] != null) {\n        contents[_VIo] = __expectString(output[_vIo]);\n    }\n    return contents;\n};\nconst de_SnapshotRecycleBinInfoList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SnapshotRecycleBinInfo(entry, context);\n    });\n};\nconst de_SnapshotSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SnapshotInfo(entry, context);\n    });\n};\nconst de_SnapshotTaskDetail = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_dIS] != null) {\n        contents[_DISi] = __strictParseFloat(output[_dIS]);\n    }\n    if (output[_enc] != null) {\n        contents[_Enc] = __parseBoolean(output[_enc]);\n    }\n    if (output[_f] != null) {\n        contents[_Fo] = __expectString(output[_f]);\n    }\n    if (output[_kKI] != null) {\n        contents[_KKI] = __expectString(output[_kKI]);\n    }\n    if (output[_pro] != null) {\n        contents[_Prog] = __expectString(output[_pro]);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_ur] != null) {\n        contents[_U] = __expectString(output[_ur]);\n    }\n    if (output[_uB] != null) {\n        contents[_UB] = de_UserBucketDetails(output[_uB], context);\n    }\n    return contents;\n};\nconst de_SnapshotTierStatus = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_vIo] != null) {\n        contents[_VIo] = __expectString(output[_vIo]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_sTt] != null) {\n        contents[_STto] = __expectString(output[_sTt]);\n    }\n    if (output[_lTST] != null) {\n        contents[_LTST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lTST]));\n    }\n    if (output[_lTP] != null) {\n        contents[_LTP] = __strictParseInt32(output[_lTP]);\n    }\n    if (output[_lTOS] != null) {\n        contents[_LTOS] = __expectString(output[_lTOS]);\n    }\n    if (output[_lTOSD] != null) {\n        contents[_LTOSD] = __expectString(output[_lTOSD]);\n    }\n    if (output[_aCT] != null) {\n        contents[_ACT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aCT]));\n    }\n    if (output[_rET] != null) {\n        contents[_RET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rET]));\n    }\n    return contents;\n};\nconst de_snapshotTierStatusSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SnapshotTierStatus(entry, context);\n    });\n};\nconst de_SpotCapacityRebalance = (output, context) => {\n    const contents = {};\n    if (output[_rSep] != null) {\n        contents[_RS] = __expectString(output[_rSep]);\n    }\n    if (output[_tD] != null) {\n        contents[_TDe] = __strictParseInt32(output[_tD]);\n    }\n    return contents;\n};\nconst de_SpotDatafeedSubscription = (output, context) => {\n    const contents = {};\n    if (output[_bu] != null) {\n        contents[_B] = __expectString(output[_bu]);\n    }\n    if (output[_fa] != null) {\n        contents[_Fa] = de_SpotInstanceStateFault(output[_fa], context);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_pre] != null) {\n        contents[_Pr] = __expectString(output[_pre]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_SpotFleetLaunchSpecification = (output, context) => {\n    const contents = {};\n    if (output[_aTdd] != null) {\n        contents[_ATd] = __expectString(output[_aTdd]);\n    }\n    if (output.blockDeviceMapping === \"\") {\n        contents[_BDM] = [];\n    }\n    else if (output[_bDM] != null && output[_bDM][_i] != null) {\n        contents[_BDM] = de_BlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);\n    }\n    if (output[_eO] != null) {\n        contents[_EO] = __parseBoolean(output[_eO]);\n    }\n    if (output[_iIP] != null) {\n        contents[_IIP] = de_IamInstanceProfileSpecification(output[_iIP], context);\n    }\n    if (output[_iIma] != null) {\n        contents[_IIma] = __expectString(output[_iIma]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_kI] != null) {\n        contents[_KI] = __expectString(output[_kI]);\n    }\n    if (output[_kN] != null) {\n        contents[_KN] = __expectString(output[_kN]);\n    }\n    if (output[_mo] != null) {\n        contents[_Mon] = de_SpotFleetMonitoring(output[_mo], context);\n    }\n    if (output.networkInterfaceSet === \"\") {\n        contents[_NI] = [];\n    }\n    else if (output[_nIS] != null && output[_nIS][_i] != null) {\n        contents[_NI] = de_InstanceNetworkInterfaceSpecificationList(__getArrayIfSingleItem(output[_nIS][_i]), context);\n    }\n    if (output[_pla] != null) {\n        contents[_Pl] = de_SpotPlacement(output[_pla], context);\n    }\n    if (output[_rIa] != null) {\n        contents[_RIa] = __expectString(output[_rIa]);\n    }\n    if (output[_sPp] != null) {\n        contents[_SPp] = __expectString(output[_sPp]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_uDs] != null) {\n        contents[_UD] = __expectString(output[_uDs]);\n    }\n    if (output[_wC] != null) {\n        contents[_WCe] = __strictParseFloat(output[_wC]);\n    }\n    if (output.tagSpecificationSet === \"\") {\n        contents[_TS] = [];\n    }\n    else if (output[_tSS] != null && output[_tSS][_i] != null) {\n        contents[_TS] = de_SpotFleetTagSpecificationList(__getArrayIfSingleItem(output[_tSS][_i]), context);\n    }\n    if (output[_iR] != null) {\n        contents[_IR] = de_InstanceRequirements(output[_iR], context);\n    }\n    if (output.groupSet === \"\") {\n        contents[_SG] = [];\n    }\n    else if (output[_gS] != null && output[_gS][_i] != null) {\n        contents[_SG] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);\n    }\n    return contents;\n};\nconst de_SpotFleetMonitoring = (output, context) => {\n    const contents = {};\n    if (output[_en] != null) {\n        contents[_En] = __parseBoolean(output[_en]);\n    }\n    return contents;\n};\nconst de_SpotFleetRequestConfig = (output, context) => {\n    const contents = {};\n    if (output[_aSc] != null) {\n        contents[_ASc] = __expectString(output[_aSc]);\n    }\n    if (output[_cTr] != null) {\n        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));\n    }\n    if (output[_sFRC] != null) {\n        contents[_SFRC] = de_SpotFleetRequestConfigData(output[_sFRC], context);\n    }\n    if (output[_sFRI] != null) {\n        contents[_SFRIp] = __expectString(output[_sFRI]);\n    }\n    if (output[_sFRSp] != null) {\n        contents[_SFRS] = __expectString(output[_sFRSp]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_SpotFleetRequestConfigData = (output, context) => {\n    const contents = {};\n    if (output[_aSl] != null) {\n        contents[_AS] = __expectString(output[_aSl]);\n    }\n    if (output[_oDAS] != null) {\n        contents[_ODAS] = __expectString(output[_oDAS]);\n    }\n    if (output[_sMS] != null) {\n        contents[_SMS] = de_SpotMaintenanceStrategies(output[_sMS], context);\n    }\n    if (output[_cT] != null) {\n        contents[_CTl] = __expectString(output[_cT]);\n    }\n    if (output[_eCTP] != null) {\n        contents[_ECTP] = __expectString(output[_eCTP]);\n    }\n    if (output[_fC] != null) {\n        contents[_FC] = __strictParseFloat(output[_fC]);\n    }\n    if (output[_oDFC] != null) {\n        contents[_ODFC] = __strictParseFloat(output[_oDFC]);\n    }\n    if (output[_iFR] != null) {\n        contents[_IFR] = __expectString(output[_iFR]);\n    }\n    if (output.launchSpecifications === \"\") {\n        contents[_LSau] = [];\n    }\n    else if (output[_lSa] != null && output[_lSa][_i] != null) {\n        contents[_LSau] = de_LaunchSpecsList(__getArrayIfSingleItem(output[_lSa][_i]), context);\n    }\n    if (output.launchTemplateConfigs === \"\") {\n        contents[_LTC] = [];\n    }\n    else if (output[_lTC] != null && output[_lTC][_i] != null) {\n        contents[_LTC] = de_LaunchTemplateConfigList(__getArrayIfSingleItem(output[_lTC][_i]), context);\n    }\n    if (output[_sPp] != null) {\n        contents[_SPp] = __expectString(output[_sPp]);\n    }\n    if (output[_tCar] != null) {\n        contents[_TCa] = __strictParseInt32(output[_tCar]);\n    }\n    if (output[_oDTC] != null) {\n        contents[_ODTC] = __strictParseInt32(output[_oDTC]);\n    }\n    if (output[_oDMTP] != null) {\n        contents[_ODMTP] = __expectString(output[_oDMTP]);\n    }\n    if (output[_sMTP] != null) {\n        contents[_SMTP] = __expectString(output[_sMTP]);\n    }\n    if (output[_tIWE] != null) {\n        contents[_TIWE] = __parseBoolean(output[_tIWE]);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_vF] != null) {\n        contents[_VF] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vF]));\n    }\n    if (output[_vU] != null) {\n        contents[_VU] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vU]));\n    }\n    if (output[_rUI] != null) {\n        contents[_RUI] = __parseBoolean(output[_rUI]);\n    }\n    if (output[_iIB] != null) {\n        contents[_IIB] = __expectString(output[_iIB]);\n    }\n    if (output[_lBC] != null) {\n        contents[_LBC] = de_LoadBalancersConfig(output[_lBC], context);\n    }\n    if (output[_iPTUC] != null) {\n        contents[_IPTUC] = __strictParseInt32(output[_iPTUC]);\n    }\n    if (output[_cont] != null) {\n        contents[_Con] = __expectString(output[_cont]);\n    }\n    if (output[_tCUT] != null) {\n        contents[_TCUT] = __expectString(output[_tCUT]);\n    }\n    if (output.TagSpecification === \"\") {\n        contents[_TS] = [];\n    }\n    else if (output[_TSagp] != null && output[_TSagp][_i] != null) {\n        contents[_TS] = de_TagSpecificationList(__getArrayIfSingleItem(output[_TSagp][_i]), context);\n    }\n    return contents;\n};\nconst de_SpotFleetRequestConfigSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SpotFleetRequestConfig(entry, context);\n    });\n};\nconst de_SpotFleetTagSpecification = (output, context) => {\n    const contents = {};\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output.tag === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tag] != null && output[_tag][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tag][_i]), context);\n    }\n    return contents;\n};\nconst de_SpotFleetTagSpecificationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SpotFleetTagSpecification(entry, context);\n    });\n};\nconst de_SpotInstanceRequest = (output, context) => {\n    const contents = {};\n    if (output[_aBHP] != null) {\n        contents[_ABHP] = __expectString(output[_aBHP]);\n    }\n    if (output[_aZG] != null) {\n        contents[_AZG] = __expectString(output[_aZG]);\n    }\n    if (output[_bDMl] != null) {\n        contents[_BDMl] = __strictParseInt32(output[_bDMl]);\n    }\n    if (output[_cTr] != null) {\n        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));\n    }\n    if (output[_fa] != null) {\n        contents[_Fa] = de_SpotInstanceStateFault(output[_fa], context);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_lG] != null) {\n        contents[_LG] = __expectString(output[_lG]);\n    }\n    if (output[_lSau] != null) {\n        contents[_LSa] = de_LaunchSpecification(output[_lSau], context);\n    }\n    if (output[_lAZ] != null) {\n        contents[_LAZ] = __expectString(output[_lAZ]);\n    }\n    if (output[_pDr] != null) {\n        contents[_PDr] = __expectString(output[_pDr]);\n    }\n    if (output[_sIRI] != null) {\n        contents[_SIRIp] = __expectString(output[_sIRI]);\n    }\n    if (output[_sPp] != null) {\n        contents[_SPp] = __expectString(output[_sPp]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_SpotInstanceStatus(output[_sta], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_vF] != null) {\n        contents[_VF] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vF]));\n    }\n    if (output[_vU] != null) {\n        contents[_VU] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vU]));\n    }\n    if (output[_iIB] != null) {\n        contents[_IIB] = __expectString(output[_iIB]);\n    }\n    return contents;\n};\nconst de_SpotInstanceRequestList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SpotInstanceRequest(entry, context);\n    });\n};\nconst de_SpotInstanceStateFault = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_SpotInstanceStatus = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    if (output[_uT] != null) {\n        contents[_UTp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uT]));\n    }\n    return contents;\n};\nconst de_SpotMaintenanceStrategies = (output, context) => {\n    const contents = {};\n    if (output[_cRa] != null) {\n        contents[_CRap] = de_SpotCapacityRebalance(output[_cRa], context);\n    }\n    return contents;\n};\nconst de_SpotOptions = (output, context) => {\n    const contents = {};\n    if (output[_aSl] != null) {\n        contents[_AS] = __expectString(output[_aSl]);\n    }\n    if (output[_mSai] != null) {\n        contents[_MS] = de_FleetSpotMaintenanceStrategies(output[_mSai], context);\n    }\n    if (output[_iIB] != null) {\n        contents[_IIB] = __expectString(output[_iIB]);\n    }\n    if (output[_iPTUC] != null) {\n        contents[_IPTUC] = __strictParseInt32(output[_iPTUC]);\n    }\n    if (output[_sITi] != null) {\n        contents[_SITi] = __parseBoolean(output[_sITi]);\n    }\n    if (output[_sAZ] != null) {\n        contents[_SAZ] = __parseBoolean(output[_sAZ]);\n    }\n    if (output[_mTC] != null) {\n        contents[_MTC] = __strictParseInt32(output[_mTC]);\n    }\n    if (output[_mTP] != null) {\n        contents[_MTP] = __expectString(output[_mTP]);\n    }\n    return contents;\n};\nconst de_SpotPlacement = (output, context) => {\n    const contents = {};\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    if (output[_t] != null) {\n        contents[_Te] = __expectString(output[_t]);\n    }\n    return contents;\n};\nconst de_SpotPlacementScore = (output, context) => {\n    const contents = {};\n    if (output[_re] != null) {\n        contents[_Regi] = __expectString(output[_re]);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    if (output[_sco] != null) {\n        contents[_Sco] = __strictParseInt32(output[_sco]);\n    }\n    return contents;\n};\nconst de_SpotPlacementScores = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SpotPlacementScore(entry, context);\n    });\n};\nconst de_SpotPrice = (output, context) => {\n    const contents = {};\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_iT] != null) {\n        contents[_IT] = __expectString(output[_iT]);\n    }\n    if (output[_pDr] != null) {\n        contents[_PDr] = __expectString(output[_pDr]);\n    }\n    if (output[_sPp] != null) {\n        contents[_SPp] = __expectString(output[_sPp]);\n    }\n    if (output[_ti] != null) {\n        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));\n    }\n    return contents;\n};\nconst de_SpotPriceHistoryList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SpotPrice(entry, context);\n    });\n};\nconst de_StaleIpPermission = (output, context) => {\n    const contents = {};\n    if (output[_fP] != null) {\n        contents[_FP] = __strictParseInt32(output[_fP]);\n    }\n    if (output[_iPpr] != null) {\n        contents[_IPpr] = __expectString(output[_iPpr]);\n    }\n    if (output.ipRanges === \"\") {\n        contents[_IRp] = [];\n    }\n    else if (output[_iRpa] != null && output[_iRpa][_i] != null) {\n        contents[_IRp] = de_IpRanges(__getArrayIfSingleItem(output[_iRpa][_i]), context);\n    }\n    if (output.prefixListIds === \"\") {\n        contents[_PLIr] = [];\n    }\n    else if (output[_pLIr] != null && output[_pLIr][_i] != null) {\n        contents[_PLIr] = de_PrefixListIdSet(__getArrayIfSingleItem(output[_pLIr][_i]), context);\n    }\n    if (output[_tPo] != null) {\n        contents[_TP] = __strictParseInt32(output[_tPo]);\n    }\n    if (output.groups === \"\") {\n        contents[_UIGP] = [];\n    }\n    else if (output[_gr] != null && output[_gr][_i] != null) {\n        contents[_UIGP] = de_UserIdGroupPairSet(__getArrayIfSingleItem(output[_gr][_i]), context);\n    }\n    return contents;\n};\nconst de_StaleIpPermissionSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_StaleIpPermission(entry, context);\n    });\n};\nconst de_StaleSecurityGroup = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    if (output.staleIpPermissions === \"\") {\n        contents[_SIP] = [];\n    }\n    else if (output[_sIP] != null && output[_sIP][_i] != null) {\n        contents[_SIP] = de_StaleIpPermissionSet(__getArrayIfSingleItem(output[_sIP][_i]), context);\n    }\n    if (output.staleIpPermissionsEgress === \"\") {\n        contents[_SIPE] = [];\n    }\n    else if (output[_sIPE] != null && output[_sIPE][_i] != null) {\n        contents[_SIPE] = de_StaleIpPermissionSet(__getArrayIfSingleItem(output[_sIPE][_i]), context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    return contents;\n};\nconst de_StaleSecurityGroupSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_StaleSecurityGroup(entry, context);\n    });\n};\nconst de_StartDeclarativePoliciesReportResult = (output, context) => {\n    const contents = {};\n    if (output[_rI] != null) {\n        contents[_RIep] = __expectString(output[_rI]);\n    }\n    return contents;\n};\nconst de_StartInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.instancesSet === \"\") {\n        contents[_SIta] = [];\n    }\n    else if (output[_iSn] != null && output[_iSn][_i] != null) {\n        contents[_SIta] = de_InstanceStateChangeList(__getArrayIfSingleItem(output[_iSn][_i]), context);\n    }\n    return contents;\n};\nconst de_StartNetworkInsightsAccessScopeAnalysisResult = (output, context) => {\n    const contents = {};\n    if (output[_nIASAe] != null) {\n        contents[_NIASAet] = de_NetworkInsightsAccessScopeAnalysis(output[_nIASAe], context);\n    }\n    return contents;\n};\nconst de_StartNetworkInsightsAnalysisResult = (output, context) => {\n    const contents = {};\n    if (output[_nIA] != null) {\n        contents[_NIAe] = de_NetworkInsightsAnalysis(output[_nIA], context);\n    }\n    return contents;\n};\nconst de_StartVpcEndpointServicePrivateDnsVerificationResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_RV] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_StateReason = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_StopInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.instancesSet === \"\") {\n        contents[_SIto] = [];\n    }\n    else if (output[_iSn] != null && output[_iSn][_i] != null) {\n        contents[_SIto] = de_InstanceStateChangeList(__getArrayIfSingleItem(output[_iSn][_i]), context);\n    }\n    return contents;\n};\nconst de_Storage = (output, context) => {\n    const contents = {};\n    if (output[_S_] != null) {\n        contents[_S_] = de_S3Storage(output[_S_], context);\n    }\n    return contents;\n};\nconst de_StoreImageTaskResult = (output, context) => {\n    const contents = {};\n    if (output[_aIm] != null) {\n        contents[_AIm] = __expectString(output[_aIm]);\n    }\n    if (output[_tSTa] != null) {\n        contents[_TSTa] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tSTa]));\n    }\n    if (output[_bu] != null) {\n        contents[_B] = __expectString(output[_bu]);\n    }\n    if (output[_sKo] != null) {\n        contents[_SKo] = __expectString(output[_sKo]);\n    }\n    if (output[_pP] != null) {\n        contents[_PP] = __strictParseInt32(output[_pP]);\n    }\n    if (output[_sTS] != null) {\n        contents[_STSt] = __expectString(output[_sTS]);\n    }\n    if (output[_sTFR] != null) {\n        contents[_STFR] = __expectString(output[_sTFR]);\n    }\n    return contents;\n};\nconst de_StoreImageTaskResultSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_StoreImageTaskResult(entry, context);\n    });\n};\nconst de_StringList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_Subnet = (output, context) => {\n    const contents = {};\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    if (output[_eLADI] != null) {\n        contents[_ELADI] = __strictParseInt32(output[_eLADI]);\n    }\n    if (output[_mCOIOL] != null) {\n        contents[_MCOIOL] = __parseBoolean(output[_mCOIOL]);\n    }\n    if (output[_cOIP] != null) {\n        contents[_COIP] = __expectString(output[_cOIP]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_aIAOC] != null) {\n        contents[_AIAOC] = __parseBoolean(output[_aIAOC]);\n    }\n    if (output.ipv6CidrBlockAssociationSet === \"\") {\n        contents[_ICBAS] = [];\n    }\n    else if (output[_iCBAS] != null && output[_iCBAS][_i] != null) {\n        contents[_ICBAS] = de_SubnetIpv6CidrBlockAssociationSet(__getArrayIfSingleItem(output[_iCBAS][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_sAub] != null) {\n        contents[_SAub] = __expectString(output[_sAub]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_eDn] != null) {\n        contents[_EDn] = __parseBoolean(output[_eDn]);\n    }\n    if (output[_iN] != null) {\n        contents[_IN] = __parseBoolean(output[_iN]);\n    }\n    if (output[_pDNOOL] != null) {\n        contents[_PDNOOL] = de_PrivateDnsNameOptionsOnLaunch(output[_pDNOOL], context);\n    }\n    if (output[_bPAS] != null) {\n        contents[_BPAS] = de_BlockPublicAccessStates(output[_bPAS], context);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_cB] != null) {\n        contents[_CB] = __expectString(output[_cB]);\n    }\n    if (output[_aIAC] != null) {\n        contents[_AIAC] = __strictParseInt32(output[_aIAC]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_dFA] != null) {\n        contents[_DFA] = __parseBoolean(output[_dFA]);\n    }\n    if (output[_mPIOL] != null) {\n        contents[_MPIOL] = __parseBoolean(output[_mPIOL]);\n    }\n    return contents;\n};\nconst de_SubnetAssociation = (output, context) => {\n    const contents = {};\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_SubnetAssociationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SubnetAssociation(entry, context);\n    });\n};\nconst de_SubnetCidrBlockState = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    return contents;\n};\nconst de_SubnetCidrReservation = (output, context) => {\n    const contents = {};\n    if (output[_sCRI] != null) {\n        contents[_SCRIu] = __expectString(output[_sCRI]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_ci] != null) {\n        contents[_C] = __expectString(output[_ci]);\n    }\n    if (output[_rT] != null) {\n        contents[_RTe] = __expectString(output[_rT]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_SubnetCidrReservationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SubnetCidrReservation(entry, context);\n    });\n};\nconst de_SubnetIpPrefixes = (output, context) => {\n    const contents = {};\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output.ipPrefixSet === \"\") {\n        contents[_IPpre] = [];\n    }\n    else if (output[_iPSpr] != null && output[_iPSpr][_i] != null) {\n        contents[_IPpre] = de_ValueStringList(__getArrayIfSingleItem(output[_iPSpr][_i]), context);\n    }\n    return contents;\n};\nconst de_SubnetIpPrefixesList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SubnetIpPrefixes(entry, context);\n    });\n};\nconst de_SubnetIpv6CidrBlockAssociation = (output, context) => {\n    const contents = {};\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_iCB] != null) {\n        contents[_ICB] = __expectString(output[_iCB]);\n    }\n    if (output[_iCBS] != null) {\n        contents[_ICBS] = de_SubnetCidrBlockState(output[_iCBS], context);\n    }\n    if (output[_iAA] != null) {\n        contents[_IAA] = __expectString(output[_iAA]);\n    }\n    if (output[_iSpo] != null) {\n        contents[_ISpo] = __expectString(output[_iSpo]);\n    }\n    return contents;\n};\nconst de_SubnetIpv6CidrBlockAssociationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SubnetIpv6CidrBlockAssociation(entry, context);\n    });\n};\nconst de_SubnetList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Subnet(entry, context);\n    });\n};\nconst de_Subscription = (output, context) => {\n    const contents = {};\n    if (output[_s] != null) {\n        contents[_S] = __expectString(output[_s]);\n    }\n    if (output[_d] != null) {\n        contents[_D] = __expectString(output[_d]);\n    }\n    if (output[_met] != null) {\n        contents[_Met] = __expectString(output[_met]);\n    }\n    if (output[_stat] != null) {\n        contents[_Sta] = __expectString(output[_stat]);\n    }\n    if (output[_pe] != null) {\n        contents[_Per] = __expectString(output[_pe]);\n    }\n    return contents;\n};\nconst de_SubscriptionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Subscription(entry, context);\n    });\n};\nconst de_SuccessfulInstanceCreditSpecificationItem = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    return contents;\n};\nconst de_SuccessfulInstanceCreditSpecificationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SuccessfulInstanceCreditSpecificationItem(entry, context);\n    });\n};\nconst de_SuccessfulQueuedPurchaseDeletion = (output, context) => {\n    const contents = {};\n    if (output[_rII] != null) {\n        contents[_RIIe] = __expectString(output[_rII]);\n    }\n    return contents;\n};\nconst de_SuccessfulQueuedPurchaseDeletionSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SuccessfulQueuedPurchaseDeletion(entry, context);\n    });\n};\nconst de_SupportedAdditionalProcessorFeatureList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_SupportedIpAddressTypes = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_SupportedRegionDetail = (output, context) => {\n    const contents = {};\n    if (output[_re] != null) {\n        contents[_Regi] = __expectString(output[_re]);\n    }\n    if (output[_sSer] != null) {\n        contents[_SSe] = __expectString(output[_sSer]);\n    }\n    return contents;\n};\nconst de_SupportedRegionSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_SupportedRegionDetail(entry, context);\n    });\n};\nconst de_Tag = (output, context) => {\n    const contents = {};\n    if (output[_k] != null) {\n        contents[_Ke] = __expectString(output[_k]);\n    }\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    return contents;\n};\nconst de_TagDescription = (output, context) => {\n    const contents = {};\n    if (output[_k] != null) {\n        contents[_Ke] = __expectString(output[_k]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_v] != null) {\n        contents[_Va] = __expectString(output[_v]);\n    }\n    return contents;\n};\nconst de_TagDescriptionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TagDescription(entry, context);\n    });\n};\nconst de_TagList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Tag(entry, context);\n    });\n};\nconst de_TagSpecification = (output, context) => {\n    const contents = {};\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output.Tag === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_Tag] != null && output[_Tag][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_Tag][_i]), context);\n    }\n    return contents;\n};\nconst de_TagSpecificationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TagSpecification(entry, context);\n    });\n};\nconst de_TargetCapacitySpecification = (output, context) => {\n    const contents = {};\n    if (output[_tTC] != null) {\n        contents[_TTC] = __strictParseInt32(output[_tTC]);\n    }\n    if (output[_oDTC] != null) {\n        contents[_ODTC] = __strictParseInt32(output[_oDTC]);\n    }\n    if (output[_sTC] != null) {\n        contents[_STC] = __strictParseInt32(output[_sTC]);\n    }\n    if (output[_dTCT] != null) {\n        contents[_DTCT] = __expectString(output[_dTCT]);\n    }\n    if (output[_tCUT] != null) {\n        contents[_TCUT] = __expectString(output[_tCUT]);\n    }\n    return contents;\n};\nconst de_TargetConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_iC] != null) {\n        contents[_IC] = __strictParseInt32(output[_iC]);\n    }\n    if (output[_oIf] != null) {\n        contents[_OI] = __expectString(output[_oIf]);\n    }\n    return contents;\n};\nconst de_TargetGroup = (output, context) => {\n    const contents = {};\n    if (output[_ar] != null) {\n        contents[_Ar] = __expectString(output[_ar]);\n    }\n    return contents;\n};\nconst de_TargetGroups = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TargetGroup(entry, context);\n    });\n};\nconst de_TargetGroupsConfig = (output, context) => {\n    const contents = {};\n    if (output.targetGroups === \"\") {\n        contents[_TG] = [];\n    }\n    else if (output[_tGa] != null && output[_tGa][_i] != null) {\n        contents[_TG] = de_TargetGroups(__getArrayIfSingleItem(output[_tGa][_i]), context);\n    }\n    return contents;\n};\nconst de_TargetNetwork = (output, context) => {\n    const contents = {};\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_tNI] != null) {\n        contents[_TNI] = __expectString(output[_tNI]);\n    }\n    if (output[_cVEI] != null) {\n        contents[_CVEI] = __expectString(output[_cVEI]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_AssociationStatus(output[_sta], context);\n    }\n    if (output.securityGroups === \"\") {\n        contents[_SG] = [];\n    }\n    else if (output[_sGe] != null && output[_sGe][_i] != null) {\n        contents[_SG] = de_ValueStringList(__getArrayIfSingleItem(output[_sGe][_i]), context);\n    }\n    return contents;\n};\nconst de_TargetNetworkSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TargetNetwork(entry, context);\n    });\n};\nconst de_TargetReservationValue = (output, context) => {\n    const contents = {};\n    if (output[_rVe] != null) {\n        contents[_RVe] = de_ReservationValue(output[_rVe], context);\n    }\n    if (output[_tCa] != null) {\n        contents[_TCar] = de_TargetConfiguration(output[_tCa], context);\n    }\n    return contents;\n};\nconst de_TargetReservationValueSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TargetReservationValue(entry, context);\n    });\n};\nconst de_TerminateClientVpnConnectionsResult = (output, context) => {\n    const contents = {};\n    if (output[_cVEI] != null) {\n        contents[_CVEI] = __expectString(output[_cVEI]);\n    }\n    if (output[_us] != null) {\n        contents[_Us] = __expectString(output[_us]);\n    }\n    if (output.connectionStatuses === \"\") {\n        contents[_CSonn] = [];\n    }\n    else if (output[_cSonn] != null && output[_cSonn][_i] != null) {\n        contents[_CSonn] = de_TerminateConnectionStatusSet(__getArrayIfSingleItem(output[_cSonn][_i]), context);\n    }\n    return contents;\n};\nconst de_TerminateConnectionStatus = (output, context) => {\n    const contents = {};\n    if (output[_cIon] != null) {\n        contents[_CIo] = __expectString(output[_cIon]);\n    }\n    if (output[_pSre] != null) {\n        contents[_PSrev] = de_ClientVpnConnectionStatus(output[_pSre], context);\n    }\n    if (output[_cSur] != null) {\n        contents[_CSur] = de_ClientVpnConnectionStatus(output[_cSur], context);\n    }\n    return contents;\n};\nconst de_TerminateConnectionStatusSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TerminateConnectionStatus(entry, context);\n    });\n};\nconst de_TerminateInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.instancesSet === \"\") {\n        contents[_TIer] = [];\n    }\n    else if (output[_iSn] != null && output[_iSn][_i] != null) {\n        contents[_TIer] = de_InstanceStateChangeList(__getArrayIfSingleItem(output[_iSn][_i]), context);\n    }\n    return contents;\n};\nconst de_ThreadsPerCoreList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __strictParseInt32(entry);\n    });\n};\nconst de_ThroughResourcesStatement = (output, context) => {\n    const contents = {};\n    if (output[_rSeso] != null) {\n        contents[_RSe] = de_ResourceStatement(output[_rSeso], context);\n    }\n    return contents;\n};\nconst de_ThroughResourcesStatementList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ThroughResourcesStatement(entry, context);\n    });\n};\nconst de_TotalLocalStorageGB = (output, context) => {\n    const contents = {};\n    if (output[_m] != null) {\n        contents[_M] = __strictParseFloat(output[_m]);\n    }\n    if (output[_ma] != null) {\n        contents[_Ma] = __strictParseFloat(output[_ma]);\n    }\n    return contents;\n};\nconst de_TrafficMirrorFilter = (output, context) => {\n    const contents = {};\n    if (output[_tMFI] != null) {\n        contents[_TMFI] = __expectString(output[_tMFI]);\n    }\n    if (output.ingressFilterRuleSet === \"\") {\n        contents[_IFRn] = [];\n    }\n    else if (output[_iFRS] != null && output[_iFRS][_i] != null) {\n        contents[_IFRn] = de_TrafficMirrorFilterRuleList(__getArrayIfSingleItem(output[_iFRS][_i]), context);\n    }\n    if (output.egressFilterRuleSet === \"\") {\n        contents[_EFR] = [];\n    }\n    else if (output[_eFRS] != null && output[_eFRS][_i] != null) {\n        contents[_EFR] = de_TrafficMirrorFilterRuleList(__getArrayIfSingleItem(output[_eFRS][_i]), context);\n    }\n    if (output.networkServiceSet === \"\") {\n        contents[_NSe] = [];\n    }\n    else if (output[_nSS] != null && output[_nSS][_i] != null) {\n        contents[_NSe] = de_TrafficMirrorNetworkServiceList(__getArrayIfSingleItem(output[_nSS][_i]), context);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TrafficMirrorFilterRule = (output, context) => {\n    const contents = {};\n    if (output[_tMFRI] != null) {\n        contents[_TMFRI] = __expectString(output[_tMFRI]);\n    }\n    if (output[_tMFI] != null) {\n        contents[_TMFI] = __expectString(output[_tMFI]);\n    }\n    if (output[_tDr] != null) {\n        contents[_TD] = __expectString(output[_tDr]);\n    }\n    if (output[_rN] != null) {\n        contents[_RNu] = __strictParseInt32(output[_rN]);\n    }\n    if (output[_rA] != null) {\n        contents[_RAu] = __expectString(output[_rA]);\n    }\n    if (output[_pr] != null) {\n        contents[_P] = __strictParseInt32(output[_pr]);\n    }\n    if (output[_dPR] != null) {\n        contents[_DPR] = de_TrafficMirrorPortRange(output[_dPR], context);\n    }\n    if (output[_sPR] != null) {\n        contents[_SPR] = de_TrafficMirrorPortRange(output[_sPR], context);\n    }\n    if (output[_dCB] != null) {\n        contents[_DCB] = __expectString(output[_dCB]);\n    }\n    if (output[_sCB] != null) {\n        contents[_SCB] = __expectString(output[_sCB]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TrafficMirrorFilterRuleList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TrafficMirrorFilterRule(entry, context);\n    });\n};\nconst de_TrafficMirrorFilterRuleSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TrafficMirrorFilterRule(entry, context);\n    });\n};\nconst de_TrafficMirrorFilterSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TrafficMirrorFilter(entry, context);\n    });\n};\nconst de_TrafficMirrorNetworkServiceList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_TrafficMirrorPortRange = (output, context) => {\n    const contents = {};\n    if (output[_fP] != null) {\n        contents[_FP] = __strictParseInt32(output[_fP]);\n    }\n    if (output[_tPo] != null) {\n        contents[_TP] = __strictParseInt32(output[_tPo]);\n    }\n    return contents;\n};\nconst de_TrafficMirrorSession = (output, context) => {\n    const contents = {};\n    if (output[_tMSI] != null) {\n        contents[_TMSI] = __expectString(output[_tMSI]);\n    }\n    if (output[_tMTI] != null) {\n        contents[_TMTI] = __expectString(output[_tMTI]);\n    }\n    if (output[_tMFI] != null) {\n        contents[_TMFI] = __expectString(output[_tMFI]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_pLa] != null) {\n        contents[_PL] = __strictParseInt32(output[_pLa]);\n    }\n    if (output[_sNes] != null) {\n        contents[_SN] = __strictParseInt32(output[_sNes]);\n    }\n    if (output[_vNI] != null) {\n        contents[_VNI] = __strictParseInt32(output[_vNI]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TrafficMirrorSessionSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TrafficMirrorSession(entry, context);\n    });\n};\nconst de_TrafficMirrorTarget = (output, context) => {\n    const contents = {};\n    if (output[_tMTI] != null) {\n        contents[_TMTI] = __expectString(output[_tMTI]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_nLBA] != null) {\n        contents[_NLBA] = __expectString(output[_nLBA]);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_gLBEI] != null) {\n        contents[_GLBEI] = __expectString(output[_gLBEI]);\n    }\n    return contents;\n};\nconst de_TrafficMirrorTargetSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TrafficMirrorTarget(entry, context);\n    });\n};\nconst de_TransitGateway = (output, context) => {\n    const contents = {};\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_tGAra] != null) {\n        contents[_TGAran] = __expectString(output[_tGAra]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));\n    }\n    if (output[_opt] != null) {\n        contents[_Op] = de_TransitGatewayOptions(output[_opt], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayAssociation = (output, context) => {\n    const contents = {};\n    if (output[_tGRTI] != null) {\n        contents[_TGRTI] = __expectString(output[_tGRTI]);\n    }\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_TransitGatewayAttachment = (output, context) => {\n    const contents = {};\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_tGOI] != null) {\n        contents[_TGOI] = __expectString(output[_tGOI]);\n    }\n    if (output[_rOI] != null) {\n        contents[_ROI] = __expectString(output[_rOI]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_ass] != null) {\n        contents[_Asso] = de_TransitGatewayAttachmentAssociation(output[_ass], context);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayAttachmentAssociation = (output, context) => {\n    const contents = {};\n    if (output[_tGRTI] != null) {\n        contents[_TGRTI] = __expectString(output[_tGRTI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_TransitGatewayAttachmentBgpConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_tGAran] != null) {\n        contents[_TGArans] = __strictParseLong(output[_tGAran]);\n    }\n    if (output[_pAee] != null) {\n        contents[_PAee] = __strictParseLong(output[_pAee]);\n    }\n    if (output[_tGArans] != null) {\n        contents[_TGA] = __expectString(output[_tGArans]);\n    }\n    if (output[_pAe] != null) {\n        contents[_PAe] = __expectString(output[_pAe]);\n    }\n    if (output[_bSg] != null) {\n        contents[_BSg] = __expectString(output[_bSg]);\n    }\n    return contents;\n};\nconst de_TransitGatewayAttachmentBgpConfigurationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayAttachmentBgpConfiguration(entry, context);\n    });\n};\nconst de_TransitGatewayAttachmentList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayAttachment(entry, context);\n    });\n};\nconst de_TransitGatewayAttachmentPropagation = (output, context) => {\n    const contents = {};\n    if (output[_tGRTI] != null) {\n        contents[_TGRTI] = __expectString(output[_tGRTI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_TransitGatewayAttachmentPropagationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayAttachmentPropagation(entry, context);\n    });\n};\nconst de_TransitGatewayConnect = (output, context) => {\n    const contents = {};\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_tTGAI] != null) {\n        contents[_TTGAI] = __expectString(output[_tTGAI]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));\n    }\n    if (output[_opt] != null) {\n        contents[_Op] = de_TransitGatewayConnectOptions(output[_opt], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayConnectList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayConnect(entry, context);\n    });\n};\nconst de_TransitGatewayConnectOptions = (output, context) => {\n    const contents = {};\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    return contents;\n};\nconst de_TransitGatewayConnectPeer = (output, context) => {\n    const contents = {};\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_tGCPI] != null) {\n        contents[_TGCPI] = __expectString(output[_tGCPI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));\n    }\n    if (output[_cPC] != null) {\n        contents[_CPC] = de_TransitGatewayConnectPeerConfiguration(output[_cPC], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayConnectPeerConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_tGArans] != null) {\n        contents[_TGA] = __expectString(output[_tGArans]);\n    }\n    if (output[_pAe] != null) {\n        contents[_PAe] = __expectString(output[_pAe]);\n    }\n    if (output.insideCidrBlocks === \"\") {\n        contents[_ICBn] = [];\n    }\n    else if (output[_iCBn] != null && output[_iCBn][_i] != null) {\n        contents[_ICBn] = de_InsideCidrBlocksStringList(__getArrayIfSingleItem(output[_iCBn][_i]), context);\n    }\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    if (output.bgpConfigurations === \"\") {\n        contents[_BCg] = [];\n    }\n    else if (output[_bCg] != null && output[_bCg][_i] != null) {\n        contents[_BCg] = de_TransitGatewayAttachmentBgpConfigurationList(__getArrayIfSingleItem(output[_bCg][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayConnectPeerList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayConnectPeer(entry, context);\n    });\n};\nconst de_TransitGatewayList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGateway(entry, context);\n    });\n};\nconst de_TransitGatewayMulticastDeregisteredGroupMembers = (output, context) => {\n    const contents = {};\n    if (output[_tGMDI] != null) {\n        contents[_TGMDI] = __expectString(output[_tGMDI]);\n    }\n    if (output.deregisteredNetworkInterfaceIds === \"\") {\n        contents[_DNII] = [];\n    }\n    else if (output[_dNII] != null && output[_dNII][_i] != null) {\n        contents[_DNII] = de_ValueStringList(__getArrayIfSingleItem(output[_dNII][_i]), context);\n    }\n    if (output[_gIA] != null) {\n        contents[_GIA] = __expectString(output[_gIA]);\n    }\n    return contents;\n};\nconst de_TransitGatewayMulticastDeregisteredGroupSources = (output, context) => {\n    const contents = {};\n    if (output[_tGMDI] != null) {\n        contents[_TGMDI] = __expectString(output[_tGMDI]);\n    }\n    if (output.deregisteredNetworkInterfaceIds === \"\") {\n        contents[_DNII] = [];\n    }\n    else if (output[_dNII] != null && output[_dNII][_i] != null) {\n        contents[_DNII] = de_ValueStringList(__getArrayIfSingleItem(output[_dNII][_i]), context);\n    }\n    if (output[_gIA] != null) {\n        contents[_GIA] = __expectString(output[_gIA]);\n    }\n    return contents;\n};\nconst de_TransitGatewayMulticastDomain = (output, context) => {\n    const contents = {};\n    if (output[_tGMDI] != null) {\n        contents[_TGMDI] = __expectString(output[_tGMDI]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_tGMDA] != null) {\n        contents[_TGMDA] = __expectString(output[_tGMDA]);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_opt] != null) {\n        contents[_Op] = de_TransitGatewayMulticastDomainOptions(output[_opt], context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayMulticastDomainAssociation = (output, context) => {\n    const contents = {};\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_rOI] != null) {\n        contents[_ROI] = __expectString(output[_rOI]);\n    }\n    if (output[_su] != null) {\n        contents[_Su] = de_SubnetAssociation(output[_su], context);\n    }\n    return contents;\n};\nconst de_TransitGatewayMulticastDomainAssociationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayMulticastDomainAssociation(entry, context);\n    });\n};\nconst de_TransitGatewayMulticastDomainAssociations = (output, context) => {\n    const contents = {};\n    if (output[_tGMDI] != null) {\n        contents[_TGMDI] = __expectString(output[_tGMDI]);\n    }\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_rOI] != null) {\n        contents[_ROI] = __expectString(output[_rOI]);\n    }\n    if (output.subnets === \"\") {\n        contents[_Subn] = [];\n    }\n    else if (output[_sub] != null && output[_sub][_i] != null) {\n        contents[_Subn] = de_SubnetAssociationList(__getArrayIfSingleItem(output[_sub][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayMulticastDomainList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayMulticastDomain(entry, context);\n    });\n};\nconst de_TransitGatewayMulticastDomainOptions = (output, context) => {\n    const contents = {};\n    if (output[_iSg] != null) {\n        contents[_ISg] = __expectString(output[_iSg]);\n    }\n    if (output[_sSS] != null) {\n        contents[_SSS] = __expectString(output[_sSS]);\n    }\n    if (output[_aASA] != null) {\n        contents[_AASA] = __expectString(output[_aASA]);\n    }\n    return contents;\n};\nconst de_TransitGatewayMulticastGroup = (output, context) => {\n    const contents = {};\n    if (output[_gIA] != null) {\n        contents[_GIA] = __expectString(output[_gIA]);\n    }\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_sIu] != null) {\n        contents[_SIub] = __expectString(output[_sIu]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_rOI] != null) {\n        contents[_ROI] = __expectString(output[_rOI]);\n    }\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_gM] != null) {\n        contents[_GM] = __parseBoolean(output[_gM]);\n    }\n    if (output[_gSr] != null) {\n        contents[_GS] = __parseBoolean(output[_gSr]);\n    }\n    if (output[_mTe] != null) {\n        contents[_MTe] = __expectString(output[_mTe]);\n    }\n    if (output[_sTo] != null) {\n        contents[_STo] = __expectString(output[_sTo]);\n    }\n    return contents;\n};\nconst de_TransitGatewayMulticastGroupList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayMulticastGroup(entry, context);\n    });\n};\nconst de_TransitGatewayMulticastRegisteredGroupMembers = (output, context) => {\n    const contents = {};\n    if (output[_tGMDI] != null) {\n        contents[_TGMDI] = __expectString(output[_tGMDI]);\n    }\n    if (output.registeredNetworkInterfaceIds === \"\") {\n        contents[_RNII] = [];\n    }\n    else if (output[_rNII] != null && output[_rNII][_i] != null) {\n        contents[_RNII] = de_ValueStringList(__getArrayIfSingleItem(output[_rNII][_i]), context);\n    }\n    if (output[_gIA] != null) {\n        contents[_GIA] = __expectString(output[_gIA]);\n    }\n    return contents;\n};\nconst de_TransitGatewayMulticastRegisteredGroupSources = (output, context) => {\n    const contents = {};\n    if (output[_tGMDI] != null) {\n        contents[_TGMDI] = __expectString(output[_tGMDI]);\n    }\n    if (output.registeredNetworkInterfaceIds === \"\") {\n        contents[_RNII] = [];\n    }\n    else if (output[_rNII] != null && output[_rNII][_i] != null) {\n        contents[_RNII] = de_ValueStringList(__getArrayIfSingleItem(output[_rNII][_i]), context);\n    }\n    if (output[_gIA] != null) {\n        contents[_GIA] = __expectString(output[_gIA]);\n    }\n    return contents;\n};\nconst de_TransitGatewayOptions = (output, context) => {\n    const contents = {};\n    if (output[_aSA] != null) {\n        contents[_ASA] = __strictParseLong(output[_aSA]);\n    }\n    if (output.transitGatewayCidrBlocks === \"\") {\n        contents[_TGCB] = [];\n    }\n    else if (output[_tGCB] != null && output[_tGCB][_i] != null) {\n        contents[_TGCB] = de_ValueStringList(__getArrayIfSingleItem(output[_tGCB][_i]), context);\n    }\n    if (output[_aASAu] != null) {\n        contents[_AASAu] = __expectString(output[_aASAu]);\n    }\n    if (output[_dRTA] != null) {\n        contents[_DRTA] = __expectString(output[_dRTA]);\n    }\n    if (output[_aDRTI] != null) {\n        contents[_ADRTI] = __expectString(output[_aDRTI]);\n    }\n    if (output[_dRTP] != null) {\n        contents[_DRTP] = __expectString(output[_dRTP]);\n    }\n    if (output[_pDRTI] != null) {\n        contents[_PDRTI] = __expectString(output[_pDRTI]);\n    }\n    if (output[_vESpn] != null) {\n        contents[_VES] = __expectString(output[_vESpn]);\n    }\n    if (output[_dSn] != null) {\n        contents[_DSns] = __expectString(output[_dSn]);\n    }\n    if (output[_sGRSec] != null) {\n        contents[_SGRS] = __expectString(output[_sGRSec]);\n    }\n    if (output[_mSu] != null) {\n        contents[_MSu] = __expectString(output[_mSu]);\n    }\n    return contents;\n};\nconst de_TransitGatewayPeeringAttachment = (output, context) => {\n    const contents = {};\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_aTGAI] != null) {\n        contents[_ATGAI] = __expectString(output[_aTGAI]);\n    }\n    if (output[_rTIe] != null) {\n        contents[_RTIe] = de_PeeringTgwInfo(output[_rTIe], context);\n    }\n    if (output[_aTI] != null) {\n        contents[_ATIc] = de_PeeringTgwInfo(output[_aTI], context);\n    }\n    if (output[_opt] != null) {\n        contents[_Op] = de_TransitGatewayPeeringAttachmentOptions(output[_opt], context);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_PeeringAttachmentStatus(output[_sta], context);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayPeeringAttachmentList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayPeeringAttachment(entry, context);\n    });\n};\nconst de_TransitGatewayPeeringAttachmentOptions = (output, context) => {\n    const contents = {};\n    if (output[_dRy] != null) {\n        contents[_DRy] = __expectString(output[_dRy]);\n    }\n    return contents;\n};\nconst de_TransitGatewayPolicyRule = (output, context) => {\n    const contents = {};\n    if (output[_sCB] != null) {\n        contents[_SCB] = __expectString(output[_sCB]);\n    }\n    if (output[_sPR] != null) {\n        contents[_SPR] = __expectString(output[_sPR]);\n    }\n    if (output[_dCB] != null) {\n        contents[_DCB] = __expectString(output[_dCB]);\n    }\n    if (output[_dPR] != null) {\n        contents[_DPR] = __expectString(output[_dPR]);\n    }\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    if (output[_mDe] != null) {\n        contents[_MDe] = de_TransitGatewayPolicyRuleMetaData(output[_mDe], context);\n    }\n    return contents;\n};\nconst de_TransitGatewayPolicyRuleMetaData = (output, context) => {\n    const contents = {};\n    if (output[_mDK] != null) {\n        contents[_MDK] = __expectString(output[_mDK]);\n    }\n    if (output[_mDV] != null) {\n        contents[_MDV] = __expectString(output[_mDV]);\n    }\n    return contents;\n};\nconst de_TransitGatewayPolicyTable = (output, context) => {\n    const contents = {};\n    if (output[_tGPTI] != null) {\n        contents[_TGPTI] = __expectString(output[_tGPTI]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayPolicyTableAssociation = (output, context) => {\n    const contents = {};\n    if (output[_tGPTI] != null) {\n        contents[_TGPTI] = __expectString(output[_tGPTI]);\n    }\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_TransitGatewayPolicyTableAssociationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayPolicyTableAssociation(entry, context);\n    });\n};\nconst de_TransitGatewayPolicyTableEntry = (output, context) => {\n    const contents = {};\n    if (output[_pRN] != null) {\n        contents[_PRNo] = __expectString(output[_pRN]);\n    }\n    if (output[_pRol] != null) {\n        contents[_PRol] = de_TransitGatewayPolicyRule(output[_pRol], context);\n    }\n    if (output[_tRTI] != null) {\n        contents[_TRTI] = __expectString(output[_tRTI]);\n    }\n    return contents;\n};\nconst de_TransitGatewayPolicyTableEntryList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayPolicyTableEntry(entry, context);\n    });\n};\nconst de_TransitGatewayPolicyTableList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayPolicyTable(entry, context);\n    });\n};\nconst de_TransitGatewayPrefixListAttachment = (output, context) => {\n    const contents = {};\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    return contents;\n};\nconst de_TransitGatewayPrefixListReference = (output, context) => {\n    const contents = {};\n    if (output[_tGRTI] != null) {\n        contents[_TGRTI] = __expectString(output[_tGRTI]);\n    }\n    if (output[_pLI] != null) {\n        contents[_PLI] = __expectString(output[_pLI]);\n    }\n    if (output[_pLOI] != null) {\n        contents[_PLOI] = __expectString(output[_pLOI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_bl] != null) {\n        contents[_Bl] = __parseBoolean(output[_bl]);\n    }\n    if (output[_tGAr] != null) {\n        contents[_TGAra] = de_TransitGatewayPrefixListAttachment(output[_tGAr], context);\n    }\n    return contents;\n};\nconst de_TransitGatewayPrefixListReferenceSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayPrefixListReference(entry, context);\n    });\n};\nconst de_TransitGatewayPropagation = (output, context) => {\n    const contents = {};\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_tGRTI] != null) {\n        contents[_TGRTI] = __expectString(output[_tGRTI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_tGRTAI] != null) {\n        contents[_TGRTAI] = __expectString(output[_tGRTAI]);\n    }\n    return contents;\n};\nconst de_TransitGatewayRoute = (output, context) => {\n    const contents = {};\n    if (output[_dCB] != null) {\n        contents[_DCB] = __expectString(output[_dCB]);\n    }\n    if (output[_pLI] != null) {\n        contents[_PLI] = __expectString(output[_pLI]);\n    }\n    if (output[_tGRTAI] != null) {\n        contents[_TGRTAI] = __expectString(output[_tGRTAI]);\n    }\n    if (output.transitGatewayAttachments === \"\") {\n        contents[_TGAr] = [];\n    }\n    else if (output[_tGA] != null && output[_tGA][_i] != null) {\n        contents[_TGAr] = de_TransitGatewayRouteAttachmentList(__getArrayIfSingleItem(output[_tGA][_i]), context);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_TransitGatewayRouteAttachment = (output, context) => {\n    const contents = {};\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    return contents;\n};\nconst de_TransitGatewayRouteAttachmentList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayRouteAttachment(entry, context);\n    });\n};\nconst de_TransitGatewayRouteList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayRoute(entry, context);\n    });\n};\nconst de_TransitGatewayRouteTable = (output, context) => {\n    const contents = {};\n    if (output[_tGRTI] != null) {\n        contents[_TGRTI] = __expectString(output[_tGRTI]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_dART] != null) {\n        contents[_DART] = __parseBoolean(output[_dART]);\n    }\n    if (output[_dPRT] != null) {\n        contents[_DPRT] = __parseBoolean(output[_dPRT]);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayRouteTableAnnouncement = (output, context) => {\n    const contents = {};\n    if (output[_tGRTAI] != null) {\n        contents[_TGRTAI] = __expectString(output[_tGRTAI]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_cNIo] != null) {\n        contents[_CNIor] = __expectString(output[_cNIo]);\n    }\n    if (output[_pTGI] != null) {\n        contents[_PTGI] = __expectString(output[_pTGI]);\n    }\n    if (output[_pCNI] != null) {\n        contents[_PCNI] = __expectString(output[_pCNI]);\n    }\n    if (output[_pAI] != null) {\n        contents[_PAIe] = __expectString(output[_pAI]);\n    }\n    if (output[_aDn] != null) {\n        contents[_ADn] = __expectString(output[_aDn]);\n    }\n    if (output[_tGRTI] != null) {\n        contents[_TGRTI] = __expectString(output[_tGRTI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayRouteTableAnnouncementList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayRouteTableAnnouncement(entry, context);\n    });\n};\nconst de_TransitGatewayRouteTableAssociation = (output, context) => {\n    const contents = {};\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_TransitGatewayRouteTableAssociationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayRouteTableAssociation(entry, context);\n    });\n};\nconst de_TransitGatewayRouteTableList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayRouteTable(entry, context);\n    });\n};\nconst de_TransitGatewayRouteTablePropagation = (output, context) => {\n    const contents = {};\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_tGRTAI] != null) {\n        contents[_TGRTAI] = __expectString(output[_tGRTAI]);\n    }\n    return contents;\n};\nconst de_TransitGatewayRouteTablePropagationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayRouteTablePropagation(entry, context);\n    });\n};\nconst de_TransitGatewayRouteTableRoute = (output, context) => {\n    const contents = {};\n    if (output[_dC] != null) {\n        contents[_DCe] = __expectString(output[_dC]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_rOo] != null) {\n        contents[_ROo] = __expectString(output[_rOo]);\n    }\n    if (output[_pLI] != null) {\n        contents[_PLI] = __expectString(output[_pLI]);\n    }\n    if (output[_aIt] != null) {\n        contents[_AIt] = __expectString(output[_aIt]);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    if (output[_rTe] != null) {\n        contents[_RT] = __expectString(output[_rTe]);\n    }\n    return contents;\n};\nconst de_TransitGatewayVpcAttachment = (output, context) => {\n    const contents = {};\n    if (output[_tGAI] != null) {\n        contents[_TGAI] = __expectString(output[_tGAI]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_vOIp] != null) {\n        contents[_VOIp] = __expectString(output[_vOIp]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output.subnetIds === \"\") {\n        contents[_SIu] = [];\n    }\n    else if (output[_sIub] != null && output[_sIub][_i] != null) {\n        contents[_SIu] = de_ValueStringList(__getArrayIfSingleItem(output[_sIub][_i]), context);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));\n    }\n    if (output[_opt] != null) {\n        contents[_Op] = de_TransitGatewayVpcAttachmentOptions(output[_opt], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TransitGatewayVpcAttachmentList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TransitGatewayVpcAttachment(entry, context);\n    });\n};\nconst de_TransitGatewayVpcAttachmentOptions = (output, context) => {\n    const contents = {};\n    if (output[_dSn] != null) {\n        contents[_DSns] = __expectString(output[_dSn]);\n    }\n    if (output[_sGRSec] != null) {\n        contents[_SGRS] = __expectString(output[_sGRSec]);\n    }\n    if (output[_iSpvu] != null) {\n        contents[_ISp] = __expectString(output[_iSpvu]);\n    }\n    if (output[_aMSp] != null) {\n        contents[_AMS] = __expectString(output[_aMSp]);\n    }\n    return contents;\n};\nconst de_TrunkInterfaceAssociation = (output, context) => {\n    const contents = {};\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_bII] != null) {\n        contents[_BII] = __expectString(output[_bII]);\n    }\n    if (output[_tII] != null) {\n        contents[_TII] = __expectString(output[_tII]);\n    }\n    if (output[_iPnte] != null) {\n        contents[_IPnte] = __expectString(output[_iPnte]);\n    }\n    if (output[_vIl] != null) {\n        contents[_VIl] = __strictParseInt32(output[_vIl]);\n    }\n    if (output[_gK] != null) {\n        contents[_GK] = __strictParseInt32(output[_gK]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_TrunkInterfaceAssociationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TrunkInterfaceAssociation(entry, context);\n    });\n};\nconst de_TunnelOption = (output, context) => {\n    const contents = {};\n    if (output[_oIA] != null) {\n        contents[_OIA] = __expectString(output[_oIA]);\n    }\n    if (output[_tICu] != null) {\n        contents[_TIC] = __expectString(output[_tICu]);\n    }\n    if (output[_tIIC] != null) {\n        contents[_TIIC] = __expectString(output[_tIIC]);\n    }\n    if (output[_pSK] != null) {\n        contents[_PSK] = __expectString(output[_pSK]);\n    }\n    if (output[_pLSh] != null) {\n        contents[_PLS] = __strictParseInt32(output[_pLSh]);\n    }\n    if (output[_pLSha] != null) {\n        contents[_PLSh] = __strictParseInt32(output[_pLSha]);\n    }\n    if (output[_rMTS] != null) {\n        contents[_RMTS] = __strictParseInt32(output[_rMTS]);\n    }\n    if (output[_rFP] != null) {\n        contents[_RFP] = __strictParseInt32(output[_rFP]);\n    }\n    if (output[_rWS] != null) {\n        contents[_RWS] = __strictParseInt32(output[_rWS]);\n    }\n    if (output[_dTS] != null) {\n        contents[_DTS] = __strictParseInt32(output[_dTS]);\n    }\n    if (output[_dTA] != null) {\n        contents[_DTA] = __expectString(output[_dTA]);\n    }\n    if (output.phase1EncryptionAlgorithmSet === \"\") {\n        contents[_PEA] = [];\n    }\n    else if (output[_pEAS] != null && output[_pEAS][_i] != null) {\n        contents[_PEA] = de_Phase1EncryptionAlgorithmsList(__getArrayIfSingleItem(output[_pEAS][_i]), context);\n    }\n    if (output.phase2EncryptionAlgorithmSet === \"\") {\n        contents[_PEAh] = [];\n    }\n    else if (output[_pEASh] != null && output[_pEASh][_i] != null) {\n        contents[_PEAh] = de_Phase2EncryptionAlgorithmsList(__getArrayIfSingleItem(output[_pEASh][_i]), context);\n    }\n    if (output.phase1IntegrityAlgorithmSet === \"\") {\n        contents[_PIAh] = [];\n    }\n    else if (output[_pIASh] != null && output[_pIASh][_i] != null) {\n        contents[_PIAh] = de_Phase1IntegrityAlgorithmsList(__getArrayIfSingleItem(output[_pIASh][_i]), context);\n    }\n    if (output.phase2IntegrityAlgorithmSet === \"\") {\n        contents[_PIAha] = [];\n    }\n    else if (output[_pIASha] != null && output[_pIASha][_i] != null) {\n        contents[_PIAha] = de_Phase2IntegrityAlgorithmsList(__getArrayIfSingleItem(output[_pIASha][_i]), context);\n    }\n    if (output.phase1DHGroupNumberSet === \"\") {\n        contents[_PDHGN] = [];\n    }\n    else if (output[_pDHGNS] != null && output[_pDHGNS][_i] != null) {\n        contents[_PDHGN] = de_Phase1DHGroupNumbersList(__getArrayIfSingleItem(output[_pDHGNS][_i]), context);\n    }\n    if (output.phase2DHGroupNumberSet === \"\") {\n        contents[_PDHGNh] = [];\n    }\n    else if (output[_pDHGNSh] != null && output[_pDHGNSh][_i] != null) {\n        contents[_PDHGNh] = de_Phase2DHGroupNumbersList(__getArrayIfSingleItem(output[_pDHGNSh][_i]), context);\n    }\n    if (output.ikeVersionSet === \"\") {\n        contents[_IVke] = [];\n    }\n    else if (output[_iVS] != null && output[_iVS][_i] != null) {\n        contents[_IVke] = de_IKEVersionsList(__getArrayIfSingleItem(output[_iVS][_i]), context);\n    }\n    if (output[_sAt] != null) {\n        contents[_SA] = __expectString(output[_sAt]);\n    }\n    if (output[_lO] != null) {\n        contents[_LO] = de_VpnTunnelLogOptions(output[_lO], context);\n    }\n    if (output[_eTLC] != null) {\n        contents[_ETLC] = __parseBoolean(output[_eTLC]);\n    }\n    return contents;\n};\nconst de_TunnelOptionsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_TunnelOption(entry, context);\n    });\n};\nconst de_UnassignIpv6AddressesResult = (output, context) => {\n    const contents = {};\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output.unassignedIpv6Addresses === \"\") {\n        contents[_UIAn] = [];\n    }\n    else if (output[_uIA] != null && output[_uIA][_i] != null) {\n        contents[_UIAn] = de_Ipv6AddressList(__getArrayIfSingleItem(output[_uIA][_i]), context);\n    }\n    if (output.unassignedIpv6PrefixSet === \"\") {\n        contents[_UIPn] = [];\n    }\n    else if (output[_uIPSn] != null && output[_uIPSn][_i] != null) {\n        contents[_UIPn] = de_IpPrefixList(__getArrayIfSingleItem(output[_uIPSn][_i]), context);\n    }\n    return contents;\n};\nconst de_UnassignPrivateNatGatewayAddressResult = (output, context) => {\n    const contents = {};\n    if (output[_nGI] != null) {\n        contents[_NGI] = __expectString(output[_nGI]);\n    }\n    if (output.natGatewayAddressSet === \"\") {\n        contents[_NGA] = [];\n    }\n    else if (output[_nGAS] != null && output[_nGAS][_i] != null) {\n        contents[_NGA] = de_NatGatewayAddressList(__getArrayIfSingleItem(output[_nGAS][_i]), context);\n    }\n    return contents;\n};\nconst de_UnlockSnapshotResult = (output, context) => {\n    const contents = {};\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    return contents;\n};\nconst de_UnmonitorInstancesResult = (output, context) => {\n    const contents = {};\n    if (output.instancesSet === \"\") {\n        contents[_IMn] = [];\n    }\n    else if (output[_iSn] != null && output[_iSn][_i] != null) {\n        contents[_IMn] = de_InstanceMonitoringList(__getArrayIfSingleItem(output[_iSn][_i]), context);\n    }\n    return contents;\n};\nconst de_UnsuccessfulInstanceCreditSpecificationItem = (output, context) => {\n    const contents = {};\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_er] != null) {\n        contents[_Er] = de_UnsuccessfulInstanceCreditSpecificationItemError(output[_er], context);\n    }\n    return contents;\n};\nconst de_UnsuccessfulInstanceCreditSpecificationItemError = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_UnsuccessfulInstanceCreditSpecificationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_UnsuccessfulInstanceCreditSpecificationItem(entry, context);\n    });\n};\nconst de_UnsuccessfulItem = (output, context) => {\n    const contents = {};\n    if (output[_er] != null) {\n        contents[_Er] = de_UnsuccessfulItemError(output[_er], context);\n    }\n    if (output[_rIes] != null) {\n        contents[_RIeso] = __expectString(output[_rIes]);\n    }\n    return contents;\n};\nconst de_UnsuccessfulItemError = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_UnsuccessfulItemList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_UnsuccessfulItem(entry, context);\n    });\n};\nconst de_UnsuccessfulItemSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_UnsuccessfulItem(entry, context);\n    });\n};\nconst de_UpdateSecurityGroupRuleDescriptionsEgressResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_UpdateSecurityGroupRuleDescriptionsIngressResult = (output, context) => {\n    const contents = {};\n    if (output[_r] != null) {\n        contents[_Ret] = __parseBoolean(output[_r]);\n    }\n    return contents;\n};\nconst de_UsageClassTypeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_UserBucketDetails = (output, context) => {\n    const contents = {};\n    if (output[_sB] != null) {\n        contents[_SB] = __expectString(output[_sB]);\n    }\n    if (output[_sK] != null) {\n        contents[_SK] = __expectString(output[_sK]);\n    }\n    return contents;\n};\nconst de_UserIdGroupPair = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_uI] != null) {\n        contents[_UIs] = __expectString(output[_uI]);\n    }\n    if (output[_gN] != null) {\n        contents[_GN] = __expectString(output[_gN]);\n    }\n    if (output[_gIr] != null) {\n        contents[_GIr] = __expectString(output[_gIr]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_vPCI] != null) {\n        contents[_VPCI] = __expectString(output[_vPCI]);\n    }\n    if (output[_pSee] != null) {\n        contents[_PSe] = __expectString(output[_pSee]);\n    }\n    return contents;\n};\nconst de_UserIdGroupPairList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_UserIdGroupPair(entry, context);\n    });\n};\nconst de_UserIdGroupPairSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_UserIdGroupPair(entry, context);\n    });\n};\nconst de_ValidationError = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_ValidationWarning = (output, context) => {\n    const contents = {};\n    if (output.errorSet === \"\") {\n        contents[_Err] = [];\n    }\n    else if (output[_eSr] != null && output[_eSr][_i] != null) {\n        contents[_Err] = de_ErrorSet(__getArrayIfSingleItem(output[_eSr][_i]), context);\n    }\n    return contents;\n};\nconst de_ValueStringList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_VCpuCountRange = (output, context) => {\n    const contents = {};\n    if (output[_m] != null) {\n        contents[_M] = __strictParseInt32(output[_m]);\n    }\n    if (output[_ma] != null) {\n        contents[_Ma] = __strictParseInt32(output[_ma]);\n    }\n    return contents;\n};\nconst de_VCpuInfo = (output, context) => {\n    const contents = {};\n    if (output[_dVC] != null) {\n        contents[_DVCef] = __strictParseInt32(output[_dVC]);\n    }\n    if (output[_dCe] != null) {\n        contents[_DCef] = __strictParseInt32(output[_dCe]);\n    }\n    if (output[_dTPC] != null) {\n        contents[_DTPC] = __strictParseInt32(output[_dTPC]);\n    }\n    if (output.validCores === \"\") {\n        contents[_VCa] = [];\n    }\n    else if (output[_vCa] != null && output[_vCa][_i] != null) {\n        contents[_VCa] = de_CoreCountList(__getArrayIfSingleItem(output[_vCa][_i]), context);\n    }\n    if (output.validThreadsPerCore === \"\") {\n        contents[_VTPC] = [];\n    }\n    else if (output[_vTPC] != null && output[_vTPC][_i] != null) {\n        contents[_VTPC] = de_ThreadsPerCoreList(__getArrayIfSingleItem(output[_vTPC][_i]), context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessEndpoint = (output, context) => {\n    const contents = {};\n    if (output[_vAII] != null) {\n        contents[_VAII] = __expectString(output[_vAII]);\n    }\n    if (output[_vAGI] != null) {\n        contents[_VAGI] = __expectString(output[_vAGI]);\n    }\n    if (output[_vAEI] != null) {\n        contents[_VAEI] = __expectString(output[_vAEI]);\n    }\n    if (output[_aDp] != null) {\n        contents[_ADp] = __expectString(output[_aDp]);\n    }\n    if (output[_eTnd] != null) {\n        contents[_ET] = __expectString(output[_eTnd]);\n    }\n    if (output[_aTtta] != null) {\n        contents[_ATt] = __expectString(output[_aTtta]);\n    }\n    if (output[_dCA] != null) {\n        contents[_DCA] = __expectString(output[_dCA]);\n    }\n    if (output[_eDnd] != null) {\n        contents[_EDnd] = __expectString(output[_eDnd]);\n    }\n    if (output[_dVD] != null) {\n        contents[_DVD] = __expectString(output[_dVD]);\n    }\n    if (output.securityGroupIdSet === \"\") {\n        contents[_SGI] = [];\n    }\n    else if (output[_sGIS] != null && output[_sGIS][_i] != null) {\n        contents[_SGI] = de_SecurityGroupIdList(__getArrayIfSingleItem(output[_sGIS][_i]), context);\n    }\n    if (output[_lBO] != null) {\n        contents[_LBO] = de_VerifiedAccessEndpointLoadBalancerOptions(output[_lBO], context);\n    }\n    if (output[_nIO] != null) {\n        contents[_NIO] = de_VerifiedAccessEndpointEniOptions(output[_nIO], context);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_VerifiedAccessEndpointStatus(output[_sta], context);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectString(output[_cTre]);\n    }\n    if (output[_lUTa] != null) {\n        contents[_LUTa] = __expectString(output[_lUTa]);\n    }\n    if (output[_dT] != null) {\n        contents[_DTel] = __expectString(output[_dT]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_sSs] != null) {\n        contents[_SS] = de_VerifiedAccessSseSpecificationResponse(output[_sSs], context);\n    }\n    if (output[_rOd] != null) {\n        contents[_RO] = de_VerifiedAccessEndpointRdsOptions(output[_rOd], context);\n    }\n    if (output[_cOi] != null) {\n        contents[_CO] = de_VerifiedAccessEndpointCidrOptions(output[_cOi], context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessEndpointCidrOptions = (output, context) => {\n    const contents = {};\n    if (output[_ci] != null) {\n        contents[_C] = __expectString(output[_ci]);\n    }\n    if (output.portRangeSet === \"\") {\n        contents[_PRo] = [];\n    }\n    else if (output[_pRS] != null && output[_pRS][_i] != null) {\n        contents[_PRo] = de_VerifiedAccessEndpointPortRangeList(__getArrayIfSingleItem(output[_pRS][_i]), context);\n    }\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    if (output.subnetIdSet === \"\") {\n        contents[_SIu] = [];\n    }\n    else if (output[_sISu] != null && output[_sISu][_i] != null) {\n        contents[_SIu] = de_VerifiedAccessEndpointSubnetIdList(__getArrayIfSingleItem(output[_sISu][_i]), context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessEndpointEniOptions = (output, context) => {\n    const contents = {};\n    if (output[_nII] != null) {\n        contents[_NII] = __expectString(output[_nII]);\n    }\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    if (output[_po] != null) {\n        contents[_Po] = __strictParseInt32(output[_po]);\n    }\n    if (output.portRangeSet === \"\") {\n        contents[_PRo] = [];\n    }\n    else if (output[_pRS] != null && output[_pRS][_i] != null) {\n        contents[_PRo] = de_VerifiedAccessEndpointPortRangeList(__getArrayIfSingleItem(output[_pRS][_i]), context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessEndpointList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VerifiedAccessEndpoint(entry, context);\n    });\n};\nconst de_VerifiedAccessEndpointLoadBalancerOptions = (output, context) => {\n    const contents = {};\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    if (output[_po] != null) {\n        contents[_Po] = __strictParseInt32(output[_po]);\n    }\n    if (output[_lBA] != null) {\n        contents[_LBAo] = __expectString(output[_lBA]);\n    }\n    if (output.subnetIdSet === \"\") {\n        contents[_SIu] = [];\n    }\n    else if (output[_sISu] != null && output[_sISu][_i] != null) {\n        contents[_SIu] = de_VerifiedAccessEndpointSubnetIdList(__getArrayIfSingleItem(output[_sISu][_i]), context);\n    }\n    if (output.portRangeSet === \"\") {\n        contents[_PRo] = [];\n    }\n    else if (output[_pRS] != null && output[_pRS][_i] != null) {\n        contents[_PRo] = de_VerifiedAccessEndpointPortRangeList(__getArrayIfSingleItem(output[_pRS][_i]), context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessEndpointPortRange = (output, context) => {\n    const contents = {};\n    if (output[_fP] != null) {\n        contents[_FP] = __strictParseInt32(output[_fP]);\n    }\n    if (output[_tPo] != null) {\n        contents[_TP] = __strictParseInt32(output[_tPo]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessEndpointPortRangeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VerifiedAccessEndpointPortRange(entry, context);\n    });\n};\nconst de_VerifiedAccessEndpointRdsOptions = (output, context) => {\n    const contents = {};\n    if (output[_pr] != null) {\n        contents[_P] = __expectString(output[_pr]);\n    }\n    if (output[_po] != null) {\n        contents[_Po] = __strictParseInt32(output[_po]);\n    }\n    if (output[_rDIA] != null) {\n        contents[_RDIA] = __expectString(output[_rDIA]);\n    }\n    if (output[_rDCA] != null) {\n        contents[_RDCA] = __expectString(output[_rDCA]);\n    }\n    if (output[_rDPA] != null) {\n        contents[_RDPA] = __expectString(output[_rDPA]);\n    }\n    if (output[_rEd] != null) {\n        contents[_RE] = __expectString(output[_rEd]);\n    }\n    if (output.subnetIdSet === \"\") {\n        contents[_SIu] = [];\n    }\n    else if (output[_sISu] != null && output[_sISu][_i] != null) {\n        contents[_SIu] = de_VerifiedAccessEndpointSubnetIdList(__getArrayIfSingleItem(output[_sISu][_i]), context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessEndpointStatus = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessEndpointSubnetIdList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_VerifiedAccessEndpointTarget = (output, context) => {\n    const contents = {};\n    if (output[_vAEI] != null) {\n        contents[_VAEI] = __expectString(output[_vAEI]);\n    }\n    if (output[_vAETIA] != null) {\n        contents[_VAETIA] = __expectString(output[_vAETIA]);\n    }\n    if (output[_vAETD] != null) {\n        contents[_VAETD] = __expectString(output[_vAETD]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessEndpointTargetList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VerifiedAccessEndpointTarget(entry, context);\n    });\n};\nconst de_VerifiedAccessGroup = (output, context) => {\n    const contents = {};\n    if (output[_vAGI] != null) {\n        contents[_VAGI] = __expectString(output[_vAGI]);\n    }\n    if (output[_vAII] != null) {\n        contents[_VAII] = __expectString(output[_vAII]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_ow] != null) {\n        contents[_Own] = __expectString(output[_ow]);\n    }\n    if (output[_vAGA] != null) {\n        contents[_VAGA] = __expectString(output[_vAGA]);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectString(output[_cTre]);\n    }\n    if (output[_lUTa] != null) {\n        contents[_LUTa] = __expectString(output[_lUTa]);\n    }\n    if (output[_dT] != null) {\n        contents[_DTel] = __expectString(output[_dT]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_sSs] != null) {\n        contents[_SS] = de_VerifiedAccessSseSpecificationResponse(output[_sSs], context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessGroupList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VerifiedAccessGroup(entry, context);\n    });\n};\nconst de_VerifiedAccessInstance = (output, context) => {\n    const contents = {};\n    if (output[_vAII] != null) {\n        contents[_VAII] = __expectString(output[_vAII]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output.verifiedAccessTrustProviderSet === \"\") {\n        contents[_VATPe] = [];\n    }\n    else if (output[_vATPS] != null && output[_vATPS][_i] != null) {\n        contents[_VATPe] = de_VerifiedAccessTrustProviderCondensedList(__getArrayIfSingleItem(output[_vATPS][_i]), context);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectString(output[_cTre]);\n    }\n    if (output[_lUTa] != null) {\n        contents[_LUTa] = __expectString(output[_lUTa]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_fE] != null) {\n        contents[_FE] = __parseBoolean(output[_fE]);\n    }\n    if (output[_cECSD] != null) {\n        contents[_CECSD] = de_VerifiedAccessInstanceCustomSubDomain(output[_cECSD], context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessInstanceCustomSubDomain = (output, context) => {\n    const contents = {};\n    if (output[_sDu] != null) {\n        contents[_SDu] = __expectString(output[_sDu]);\n    }\n    if (output.nameserverSet === \"\") {\n        contents[_Na] = [];\n    }\n    else if (output[_nSa] != null && output[_nSa][_i] != null) {\n        contents[_Na] = de_ValueStringList(__getArrayIfSingleItem(output[_nSa][_i]), context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessInstanceList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VerifiedAccessInstance(entry, context);\n    });\n};\nconst de_VerifiedAccessInstanceLoggingConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_vAII] != null) {\n        contents[_VAII] = __expectString(output[_vAII]);\n    }\n    if (output[_aLc] != null) {\n        contents[_AL] = de_VerifiedAccessLogs(output[_aLc], context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessInstanceLoggingConfigurationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VerifiedAccessInstanceLoggingConfiguration(entry, context);\n    });\n};\nconst de_VerifiedAccessInstanceOpenVpnClientConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_confi] != null) {\n        contents[_Confi] = __expectString(output[_confi]);\n    }\n    if (output.routeSet === \"\") {\n        contents[_Rout] = [];\n    }\n    else if (output[_rSou] != null && output[_rSou][_i] != null) {\n        contents[_Rout] = de_VerifiedAccessInstanceOpenVpnClientConfigurationRouteList(__getArrayIfSingleItem(output[_rSou][_i]), context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessInstanceOpenVpnClientConfigurationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VerifiedAccessInstanceOpenVpnClientConfiguration(entry, context);\n    });\n};\nconst de_VerifiedAccessInstanceOpenVpnClientConfigurationRoute = (output, context) => {\n    const contents = {};\n    if (output[_ci] != null) {\n        contents[_C] = __expectString(output[_ci]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessInstanceOpenVpnClientConfigurationRouteList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VerifiedAccessInstanceOpenVpnClientConfigurationRoute(entry, context);\n    });\n};\nconst de_VerifiedAccessInstanceUserTrustProviderClientConfiguration = (output, context) => {\n    const contents = {};\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_scop] != null) {\n        contents[_Scop] = __expectString(output[_scop]);\n    }\n    if (output[_is] != null) {\n        contents[_I] = __expectString(output[_is]);\n    }\n    if (output[_aE] != null) {\n        contents[_AE] = __expectString(output[_aE]);\n    }\n    if (output[_pSKE] != null) {\n        contents[_PSKE] = __expectString(output[_pSKE]);\n    }\n    if (output[_tEo] != null) {\n        contents[_TEo] = __expectString(output[_tEo]);\n    }\n    if (output[_uIE] != null) {\n        contents[_UIE] = __expectString(output[_uIE]);\n    }\n    if (output[_cIli] != null) {\n        contents[_CIl] = __expectString(output[_cIli]);\n    }\n    if (output[_cSl] != null) {\n        contents[_CSl] = __expectString(output[_cSl]);\n    }\n    if (output[_pEk] != null) {\n        contents[_PEk] = __parseBoolean(output[_pEk]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessLogCloudWatchLogsDestination = (output, context) => {\n    const contents = {};\n    if (output[_en] != null) {\n        contents[_En] = __parseBoolean(output[_en]);\n    }\n    if (output[_dSel] != null) {\n        contents[_DSeli] = de_VerifiedAccessLogDeliveryStatus(output[_dSel], context);\n    }\n    if (output[_lGo] != null) {\n        contents[_LGo] = __expectString(output[_lGo]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessLogDeliveryStatus = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessLogKinesisDataFirehoseDestination = (output, context) => {\n    const contents = {};\n    if (output[_en] != null) {\n        contents[_En] = __parseBoolean(output[_en]);\n    }\n    if (output[_dSel] != null) {\n        contents[_DSeli] = de_VerifiedAccessLogDeliveryStatus(output[_dSel], context);\n    }\n    if (output[_dSeli] != null) {\n        contents[_DSel] = __expectString(output[_dSeli]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessLogs = (output, context) => {\n    const contents = {};\n    if (output[_s_] != null) {\n        contents[_S_] = de_VerifiedAccessLogS3Destination(output[_s_], context);\n    }\n    if (output[_cWL] != null) {\n        contents[_CWL] = de_VerifiedAccessLogCloudWatchLogsDestination(output[_cWL], context);\n    }\n    if (output[_kDF] != null) {\n        contents[_KDF] = de_VerifiedAccessLogKinesisDataFirehoseDestination(output[_kDF], context);\n    }\n    if (output[_lV] != null) {\n        contents[_LV] = __expectString(output[_lV]);\n    }\n    if (output[_iTCn] != null) {\n        contents[_ITCn] = __parseBoolean(output[_iTCn]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessLogS3Destination = (output, context) => {\n    const contents = {};\n    if (output[_en] != null) {\n        contents[_En] = __parseBoolean(output[_en]);\n    }\n    if (output[_dSel] != null) {\n        contents[_DSeli] = de_VerifiedAccessLogDeliveryStatus(output[_dSel], context);\n    }\n    if (output[_bN] != null) {\n        contents[_BN] = __expectString(output[_bN]);\n    }\n    if (output[_pre] != null) {\n        contents[_Pr] = __expectString(output[_pre]);\n    }\n    if (output[_bOu] != null) {\n        contents[_BOu] = __expectString(output[_bOu]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessSseSpecificationResponse = (output, context) => {\n    const contents = {};\n    if (output[_cMKE] != null) {\n        contents[_CMKE] = __parseBoolean(output[_cMKE]);\n    }\n    if (output[_kKA] != null) {\n        contents[_KKA] = __expectString(output[_kKA]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessTrustProvider = (output, context) => {\n    const contents = {};\n    if (output[_vATPI] != null) {\n        contents[_VATPI] = __expectString(output[_vATPI]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_tPT] != null) {\n        contents[_TPT] = __expectString(output[_tPT]);\n    }\n    if (output[_uTPT] != null) {\n        contents[_UTPT] = __expectString(output[_uTPT]);\n    }\n    if (output[_dTPT] != null) {\n        contents[_DTPT] = __expectString(output[_dTPT]);\n    }\n    if (output[_oO] != null) {\n        contents[_OO] = de_OidcOptions(output[_oO], context);\n    }\n    if (output[_dOev] != null) {\n        contents[_DOe] = de_DeviceOptions(output[_dOev], context);\n    }\n    if (output[_pRNo] != null) {\n        contents[_PRN] = __expectString(output[_pRNo]);\n    }\n    if (output[_cTre] != null) {\n        contents[_CTre] = __expectString(output[_cTre]);\n    }\n    if (output[_lUTa] != null) {\n        contents[_LUTa] = __expectString(output[_lUTa]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_sSs] != null) {\n        contents[_SS] = de_VerifiedAccessSseSpecificationResponse(output[_sSs], context);\n    }\n    if (output[_nAOO] != null) {\n        contents[_NAOO] = de_NativeApplicationOidcOptions(output[_nAOO], context);\n    }\n    return contents;\n};\nconst de_VerifiedAccessTrustProviderCondensed = (output, context) => {\n    const contents = {};\n    if (output[_vATPI] != null) {\n        contents[_VATPI] = __expectString(output[_vATPI]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_tPT] != null) {\n        contents[_TPT] = __expectString(output[_tPT]);\n    }\n    if (output[_uTPT] != null) {\n        contents[_UTPT] = __expectString(output[_uTPT]);\n    }\n    if (output[_dTPT] != null) {\n        contents[_DTPT] = __expectString(output[_dTPT]);\n    }\n    return contents;\n};\nconst de_VerifiedAccessTrustProviderCondensedList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VerifiedAccessTrustProviderCondensed(entry, context);\n    });\n};\nconst de_VerifiedAccessTrustProviderList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VerifiedAccessTrustProvider(entry, context);\n    });\n};\nconst de_VgwTelemetry = (output, context) => {\n    const contents = {};\n    if (output[_aRC] != null) {\n        contents[_ARC] = __strictParseInt32(output[_aRC]);\n    }\n    if (output[_lSC] != null) {\n        contents[_LSC] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lSC]));\n    }\n    if (output[_oIA] != null) {\n        contents[_OIA] = __expectString(output[_oIA]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_cAe] != null) {\n        contents[_CA] = __expectString(output[_cAe]);\n    }\n    return contents;\n};\nconst de_VgwTelemetryList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VgwTelemetry(entry, context);\n    });\n};\nconst de_VirtualizationTypeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_Volume = (output, context) => {\n    const contents = {};\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output[_io] != null) {\n        contents[_Io] = __strictParseInt32(output[_io]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vT] != null) {\n        contents[_VT] = __expectString(output[_vT]);\n    }\n    if (output[_fRa] != null) {\n        contents[_FRa] = __parseBoolean(output[_fRa]);\n    }\n    if (output[_mAE] != null) {\n        contents[_MAE] = __parseBoolean(output[_mAE]);\n    }\n    if (output[_th] != null) {\n        contents[_Th] = __strictParseInt32(output[_th]);\n    }\n    if (output[_sTs] != null) {\n        contents[_STs] = __expectString(output[_sTs]);\n    }\n    if (output[_op] != null) {\n        contents[_O] = de_OperatorResponse(output[_op], context);\n    }\n    if (output[_vIR] != null) {\n        contents[_VIR] = __strictParseInt32(output[_vIR]);\n    }\n    if (output[_vIo] != null) {\n        contents[_VIo] = __expectString(output[_vIo]);\n    }\n    if (output[_si] != null) {\n        contents[_Siz] = __strictParseInt32(output[_si]);\n    }\n    if (output[_sIn] != null) {\n        contents[_SIn] = __expectString(output[_sIn]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_sta] != null) {\n        contents[_Stat] = __expectString(output[_sta]);\n    }\n    if (output[_cTr] != null) {\n        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));\n    }\n    if (output.attachmentSet === \"\") {\n        contents[_Atta] = [];\n    }\n    else if (output[_aSt] != null && output[_aSt][_i] != null) {\n        contents[_Atta] = de_VolumeAttachmentList(__getArrayIfSingleItem(output[_aSt][_i]), context);\n    }\n    if (output[_enc] != null) {\n        contents[_Enc] = __parseBoolean(output[_enc]);\n    }\n    if (output[_kKI] != null) {\n        contents[_KKI] = __expectString(output[_kKI]);\n    }\n    return contents;\n};\nconst de_VolumeAttachment = (output, context) => {\n    const contents = {};\n    if (output[_dOT] != null) {\n        contents[_DOT] = __parseBoolean(output[_dOT]);\n    }\n    if (output[_aRs] != null) {\n        contents[_ARs] = __expectString(output[_aRs]);\n    }\n    if (output[_iOS] != null) {\n        contents[_IOS] = __expectString(output[_iOS]);\n    }\n    if (output[_vIo] != null) {\n        contents[_VIo] = __expectString(output[_vIo]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    if (output[_dev] != null) {\n        contents[_Dev] = __expectString(output[_dev]);\n    }\n    if (output[_sta] != null) {\n        contents[_Stat] = __expectString(output[_sta]);\n    }\n    if (output[_aTt] != null) {\n        contents[_ATtt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aTt]));\n    }\n    return contents;\n};\nconst de_VolumeAttachmentList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VolumeAttachment(entry, context);\n    });\n};\nconst de_VolumeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Volume(entry, context);\n    });\n};\nconst de_VolumeModification = (output, context) => {\n    const contents = {};\n    if (output[_vIo] != null) {\n        contents[_VIo] = __expectString(output[_vIo]);\n    }\n    if (output[_mSod] != null) {\n        contents[_MSod] = __expectString(output[_mSod]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    if (output[_tSar] != null) {\n        contents[_TSar] = __strictParseInt32(output[_tSar]);\n    }\n    if (output[_tIa] != null) {\n        contents[_TIar] = __strictParseInt32(output[_tIa]);\n    }\n    if (output[_tVT] != null) {\n        contents[_TVT] = __expectString(output[_tVT]);\n    }\n    if (output[_tTar] != null) {\n        contents[_TTar] = __strictParseInt32(output[_tTar]);\n    }\n    if (output[_tMAE] != null) {\n        contents[_TMAE] = __parseBoolean(output[_tMAE]);\n    }\n    if (output[_oSr] != null) {\n        contents[_OSr] = __strictParseInt32(output[_oSr]);\n    }\n    if (output[_oIr] != null) {\n        contents[_OIr] = __strictParseInt32(output[_oIr]);\n    }\n    if (output[_oVT] != null) {\n        contents[_OVT] = __expectString(output[_oVT]);\n    }\n    if (output[_oTr] != null) {\n        contents[_OTr] = __strictParseInt32(output[_oTr]);\n    }\n    if (output[_oMAE] != null) {\n        contents[_OMAE] = __parseBoolean(output[_oMAE]);\n    }\n    if (output[_pro] != null) {\n        contents[_Prog] = __strictParseLong(output[_pro]);\n    }\n    if (output[_sT] != null) {\n        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));\n    }\n    if (output[_eTn] != null) {\n        contents[_ETn] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTn]));\n    }\n    return contents;\n};\nconst de_VolumeModificationList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VolumeModification(entry, context);\n    });\n};\nconst de_VolumeStatusAction = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_eIve] != null) {\n        contents[_EIve] = __expectString(output[_eIve]);\n    }\n    if (output[_eTv] != null) {\n        contents[_ETv] = __expectString(output[_eTv]);\n    }\n    return contents;\n};\nconst de_VolumeStatusActionsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VolumeStatusAction(entry, context);\n    });\n};\nconst de_VolumeStatusAttachmentStatus = (output, context) => {\n    const contents = {};\n    if (output[_iPo] != null) {\n        contents[_IPo] = __expectString(output[_iPo]);\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    return contents;\n};\nconst de_VolumeStatusAttachmentStatusList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VolumeStatusAttachmentStatus(entry, context);\n    });\n};\nconst de_VolumeStatusDetails = (output, context) => {\n    const contents = {};\n    if (output[_n] != null) {\n        contents[_N] = __expectString(output[_n]);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_VolumeStatusDetailsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VolumeStatusDetails(entry, context);\n    });\n};\nconst de_VolumeStatusEvent = (output, context) => {\n    const contents = {};\n    if (output[_de] != null) {\n        contents[_De] = __expectString(output[_de]);\n    }\n    if (output[_eIve] != null) {\n        contents[_EIve] = __expectString(output[_eIve]);\n    }\n    if (output[_eTv] != null) {\n        contents[_ETv] = __expectString(output[_eTv]);\n    }\n    if (output[_nAo] != null) {\n        contents[_NAo] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nAo]));\n    }\n    if (output[_nB] != null) {\n        contents[_NB] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nB]));\n    }\n    if (output[_iI] != null) {\n        contents[_IIn] = __expectString(output[_iI]);\n    }\n    return contents;\n};\nconst de_VolumeStatusEventsList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VolumeStatusEvent(entry, context);\n    });\n};\nconst de_VolumeStatusInfo = (output, context) => {\n    const contents = {};\n    if (output.details === \"\") {\n        contents[_Det] = [];\n    }\n    else if (output[_det] != null && output[_det][_i] != null) {\n        contents[_Det] = de_VolumeStatusDetailsList(__getArrayIfSingleItem(output[_det][_i]), context);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = __expectString(output[_sta]);\n    }\n    return contents;\n};\nconst de_VolumeStatusItem = (output, context) => {\n    const contents = {};\n    if (output.actionsSet === \"\") {\n        contents[_Acti] = [];\n    }\n    else if (output[_aSct] != null && output[_aSct][_i] != null) {\n        contents[_Acti] = de_VolumeStatusActionsList(__getArrayIfSingleItem(output[_aSct][_i]), context);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output[_oA] != null) {\n        contents[_OA] = __expectString(output[_oA]);\n    }\n    if (output.eventsSet === \"\") {\n        contents[_Ev] = [];\n    }\n    else if (output[_eSv] != null && output[_eSv][_i] != null) {\n        contents[_Ev] = de_VolumeStatusEventsList(__getArrayIfSingleItem(output[_eSv][_i]), context);\n    }\n    if (output[_vIo] != null) {\n        contents[_VIo] = __expectString(output[_vIo]);\n    }\n    if (output[_vSol] != null) {\n        contents[_VSol] = de_VolumeStatusInfo(output[_vSol], context);\n    }\n    if (output.attachmentStatuses === \"\") {\n        contents[_AStt] = [];\n    }\n    else if (output[_aStt] != null && output[_aStt][_i] != null) {\n        contents[_AStt] = de_VolumeStatusAttachmentStatusList(__getArrayIfSingleItem(output[_aStt][_i]), context);\n    }\n    if (output[_aZI] != null) {\n        contents[_AZI] = __expectString(output[_aZI]);\n    }\n    return contents;\n};\nconst de_VolumeStatusList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VolumeStatusItem(entry, context);\n    });\n};\nconst de_Vpc = (output, context) => {\n    const contents = {};\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_iTns] != null) {\n        contents[_ITns] = __expectString(output[_iTns]);\n    }\n    if (output.ipv6CidrBlockAssociationSet === \"\") {\n        contents[_ICBAS] = [];\n    }\n    else if (output[_iCBAS] != null && output[_iCBAS][_i] != null) {\n        contents[_ICBAS] = de_VpcIpv6CidrBlockAssociationSet(__getArrayIfSingleItem(output[_iCBAS][_i]), context);\n    }\n    if (output.cidrBlockAssociationSet === \"\") {\n        contents[_CBAS] = [];\n    }\n    else if (output[_cBAS] != null && output[_cBAS][_i] != null) {\n        contents[_CBAS] = de_VpcCidrBlockAssociationSet(__getArrayIfSingleItem(output[_cBAS][_i]), context);\n    }\n    if (output[_iDs] != null) {\n        contents[_IDs] = __parseBoolean(output[_iDs]);\n    }\n    if (output[_eCn] != null) {\n        contents[_ECn] = de_VpcEncryptionControl(output[_eCn], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_bPAS] != null) {\n        contents[_BPAS] = de_BlockPublicAccessStates(output[_bPAS], context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_cB] != null) {\n        contents[_CB] = __expectString(output[_cB]);\n    }\n    if (output[_dOI] != null) {\n        contents[_DOI] = __expectString(output[_dOI]);\n    }\n    return contents;\n};\nconst de_VpcAttachment = (output, context) => {\n    const contents = {};\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_VpcAttachmentList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpcAttachment(entry, context);\n    });\n};\nconst de_VpcBlockPublicAccessExclusion = (output, context) => {\n    const contents = {};\n    if (output[_eIx] != null) {\n        contents[_EIxc] = __expectString(output[_eIx]);\n    }\n    if (output[_iGEM] != null) {\n        contents[_IGEM] = __expectString(output[_iGEM]);\n    }\n    if (output[_rAe] != null) {\n        contents[_RAes] = __expectString(output[_rAe]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_rea] != null) {\n        contents[_Rea] = __expectString(output[_rea]);\n    }\n    if (output[_cTrea] != null) {\n        contents[_CTrea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTrea]));\n    }\n    if (output[_lUTas] != null) {\n        contents[_LUTas] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lUTas]));\n    }\n    if (output[_dTele] != null) {\n        contents[_DTelet] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTele]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_VpcBlockPublicAccessExclusionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpcBlockPublicAccessExclusion(entry, context);\n    });\n};\nconst de_VpcBlockPublicAccessOptions = (output, context) => {\n    const contents = {};\n    if (output[_aAI] != null) {\n        contents[_AAI] = __expectString(output[_aAI]);\n    }\n    if (output[_aRw] != null) {\n        contents[_ARw] = __expectString(output[_aRw]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_iGBM] != null) {\n        contents[_IGBM] = __expectString(output[_iGBM]);\n    }\n    if (output[_rea] != null) {\n        contents[_Rea] = __expectString(output[_rea]);\n    }\n    if (output[_lUTas] != null) {\n        contents[_LUTas] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lUTas]));\n    }\n    if (output[_mB] != null) {\n        contents[_MB] = __expectString(output[_mB]);\n    }\n    if (output[_eAx] != null) {\n        contents[_EAx] = __expectString(output[_eAx]);\n    }\n    return contents;\n};\nconst de_VpcCidrBlockAssociation = (output, context) => {\n    const contents = {};\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_cB] != null) {\n        contents[_CB] = __expectString(output[_cB]);\n    }\n    if (output[_cBS] != null) {\n        contents[_CBS] = de_VpcCidrBlockState(output[_cBS], context);\n    }\n    return contents;\n};\nconst de_VpcCidrBlockAssociationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpcCidrBlockAssociation(entry, context);\n    });\n};\nconst de_VpcCidrBlockState = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sMt] != null) {\n        contents[_SMt] = __expectString(output[_sMt]);\n    }\n    return contents;\n};\nconst de_VpcClassicLink = (output, context) => {\n    const contents = {};\n    if (output[_cLE] != null) {\n        contents[_CLE] = __parseBoolean(output[_cLE]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    return contents;\n};\nconst de_VpcClassicLinkList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpcClassicLink(entry, context);\n    });\n};\nconst de_VpcEncryptionControl = (output, context) => {\n    const contents = {};\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_vECI] != null) {\n        contents[_VECI] = __expectString(output[_vECI]);\n    }\n    if (output[_mod] != null) {\n        contents[_Mo] = __expectString(output[_mod]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sMta] != null) {\n        contents[_SMta] = __expectString(output[_sMta]);\n    }\n    if (output[_rEes] != null) {\n        contents[_REeso] = de_VpcEncryptionControlExclusions(output[_rEes], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_VpcEncryptionControlExclusion = (output, context) => {\n    const contents = {};\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_sMta] != null) {\n        contents[_SMta] = __expectString(output[_sMta]);\n    }\n    return contents;\n};\nconst de_VpcEncryptionControlExclusions = (output, context) => {\n    const contents = {};\n    if (output[_iG] != null) {\n        contents[_IGn] = de_VpcEncryptionControlExclusion(output[_iG], context);\n    }\n    if (output[_eOIG] != null) {\n        contents[_EOIG] = de_VpcEncryptionControlExclusion(output[_eOIG], context);\n    }\n    if (output[_nG] != null) {\n        contents[_NG] = de_VpcEncryptionControlExclusion(output[_nG], context);\n    }\n    if (output[_vPG] != null) {\n        contents[_VPG] = de_VpcEncryptionControlExclusion(output[_vPG], context);\n    }\n    if (output[_vPpc] != null) {\n        contents[_VPpc] = de_VpcEncryptionControlExclusion(output[_vPpc], context);\n    }\n    return contents;\n};\nconst de_VpcEndpoint = (output, context) => {\n    const contents = {};\n    if (output[_vEI] != null) {\n        contents[_VEIp] = __expectString(output[_vEI]);\n    }\n    if (output[_vET] != null) {\n        contents[_VET] = __expectString(output[_vET]);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_sN] != null) {\n        contents[_SNe] = __expectString(output[_sN]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_pDo] != null) {\n        contents[_PD] = __expectString(output[_pDo]);\n    }\n    if (output.routeTableIdSet === \"\") {\n        contents[_RTIo] = [];\n    }\n    else if (output[_rTIS] != null && output[_rTIS][_i] != null) {\n        contents[_RTIo] = de_ValueStringList(__getArrayIfSingleItem(output[_rTIS][_i]), context);\n    }\n    if (output.subnetIdSet === \"\") {\n        contents[_SIu] = [];\n    }\n    else if (output[_sISu] != null && output[_sISu][_i] != null) {\n        contents[_SIu] = de_ValueStringList(__getArrayIfSingleItem(output[_sISu][_i]), context);\n    }\n    if (output.groupSet === \"\") {\n        contents[_G] = [];\n    }\n    else if (output[_gS] != null && output[_gS][_i] != null) {\n        contents[_G] = de_GroupIdentifierSet(__getArrayIfSingleItem(output[_gS][_i]), context);\n    }\n    if (output[_iAT] != null) {\n        contents[_IAT] = __expectString(output[_iAT]);\n    }\n    if (output[_dOn] != null) {\n        contents[_DOn] = de_DnsOptions(output[_dOn], context);\n    }\n    if (output[_pDE] != null) {\n        contents[_PDE] = __parseBoolean(output[_pDE]);\n    }\n    if (output[_rMe] != null) {\n        contents[_RMeq] = __parseBoolean(output[_rMe]);\n    }\n    if (output.networkInterfaceIdSet === \"\") {\n        contents[_NIIe] = [];\n    }\n    else if (output[_nIIS] != null && output[_nIIS][_i] != null) {\n        contents[_NIIe] = de_ValueStringList(__getArrayIfSingleItem(output[_nIIS][_i]), context);\n    }\n    if (output.dnsEntrySet === \"\") {\n        contents[_DE] = [];\n    }\n    else if (output[_dES] != null && output[_dES][_i] != null) {\n        contents[_DE] = de_DnsEntrySet(__getArrayIfSingleItem(output[_dES][_i]), context);\n    }\n    if (output[_cTrea] != null) {\n        contents[_CTrea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTrea]));\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_lEa] != null) {\n        contents[_LEa] = de_LastError(output[_lEa], context);\n    }\n    if (output.ipv4PrefixSet === \"\") {\n        contents[_IPp] = [];\n    }\n    else if (output[_iPSpv] != null && output[_iPSpv][_i] != null) {\n        contents[_IPp] = de_SubnetIpPrefixesList(__getArrayIfSingleItem(output[_iPSpv][_i]), context);\n    }\n    if (output.ipv6PrefixSet === \"\") {\n        contents[_IP] = [];\n    }\n    else if (output[_iPSpvr] != null && output[_iPSpvr][_i] != null) {\n        contents[_IP] = de_SubnetIpPrefixesList(__getArrayIfSingleItem(output[_iPSpvr][_i]), context);\n    }\n    if (output[_fR] != null) {\n        contents[_FR] = __expectString(output[_fR]);\n    }\n    if (output[_sNA] != null) {\n        contents[_SNA] = __expectString(output[_sNA]);\n    }\n    if (output[_rCA] != null) {\n        contents[_RCA] = __expectString(output[_rCA]);\n    }\n    if (output[_sR] != null) {\n        contents[_SRe] = __expectString(output[_sR]);\n    }\n    return contents;\n};\nconst de_VpcEndpointAssociation = (output, context) => {\n    const contents = {};\n    if (output[_id] != null) {\n        contents[_Id] = __expectString(output[_id]);\n    }\n    if (output[_vEI] != null) {\n        contents[_VEIp] = __expectString(output[_vEI]);\n    }\n    if (output[_sNA] != null) {\n        contents[_SNA] = __expectString(output[_sNA]);\n    }\n    if (output[_sNN] != null) {\n        contents[_SNN] = __expectString(output[_sNN]);\n    }\n    if (output[_aRAs] != null) {\n        contents[_ARAs] = __expectString(output[_aRAs]);\n    }\n    if (output[_fR] != null) {\n        contents[_FR] = __expectString(output[_fR]);\n    }\n    if (output[_fCa] != null) {\n        contents[_FCa] = __expectString(output[_fCa]);\n    }\n    if (output[_dE] != null) {\n        contents[_DEn] = de_DnsEntry(output[_dE], context);\n    }\n    if (output[_pDEr] != null) {\n        contents[_PDEr] = de_DnsEntry(output[_pDEr], context);\n    }\n    if (output[_aRAss] != null) {\n        contents[_ARAss] = __expectString(output[_aRAss]);\n    }\n    if (output[_rCGA] != null) {\n        contents[_RCGA] = __expectString(output[_rCGA]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    return contents;\n};\nconst de_VpcEndpointAssociationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpcEndpointAssociation(entry, context);\n    });\n};\nconst de_VpcEndpointConnection = (output, context) => {\n    const contents = {};\n    if (output[_sI] != null) {\n        contents[_SIe] = __expectString(output[_sI]);\n    }\n    if (output[_vEI] != null) {\n        contents[_VEIp] = __expectString(output[_vEI]);\n    }\n    if (output[_vEO] != null) {\n        contents[_VEO] = __expectString(output[_vEO]);\n    }\n    if (output[_vESpc] != null) {\n        contents[_VESpc] = __expectString(output[_vESpc]);\n    }\n    if (output[_cTrea] != null) {\n        contents[_CTrea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTrea]));\n    }\n    if (output.dnsEntrySet === \"\") {\n        contents[_DE] = [];\n    }\n    else if (output[_dES] != null && output[_dES][_i] != null) {\n        contents[_DE] = de_DnsEntrySet(__getArrayIfSingleItem(output[_dES][_i]), context);\n    }\n    if (output.networkLoadBalancerArnSet === \"\") {\n        contents[_NLBAe] = [];\n    }\n    else if (output[_nLBAS] != null && output[_nLBAS][_i] != null) {\n        contents[_NLBAe] = de_ValueStringList(__getArrayIfSingleItem(output[_nLBAS][_i]), context);\n    }\n    if (output.gatewayLoadBalancerArnSet === \"\") {\n        contents[_GLBA] = [];\n    }\n    else if (output[_gLBAS] != null && output[_gLBAS][_i] != null) {\n        contents[_GLBA] = de_ValueStringList(__getArrayIfSingleItem(output[_gLBAS][_i]), context);\n    }\n    if (output[_iAT] != null) {\n        contents[_IAT] = __expectString(output[_iAT]);\n    }\n    if (output[_vECIp] != null) {\n        contents[_VECIp] = __expectString(output[_vECIp]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vER] != null) {\n        contents[_VER] = __expectString(output[_vER]);\n    }\n    return contents;\n};\nconst de_VpcEndpointConnectionSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpcEndpointConnection(entry, context);\n    });\n};\nconst de_VpcEndpointSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpcEndpoint(entry, context);\n    });\n};\nconst de_VpcIpv6CidrBlockAssociation = (output, context) => {\n    const contents = {};\n    if (output[_aIs] != null) {\n        contents[_AIss] = __expectString(output[_aIs]);\n    }\n    if (output[_iCB] != null) {\n        contents[_ICB] = __expectString(output[_iCB]);\n    }\n    if (output[_iCBS] != null) {\n        contents[_ICBS] = de_VpcCidrBlockState(output[_iCBS], context);\n    }\n    if (output[_nBG] != null) {\n        contents[_NBG] = __expectString(output[_nBG]);\n    }\n    if (output[_iPpvo] != null) {\n        contents[_IPpv] = __expectString(output[_iPpvo]);\n    }\n    if (output[_iAA] != null) {\n        contents[_IAA] = __expectString(output[_iAA]);\n    }\n    if (output[_iSpo] != null) {\n        contents[_ISpo] = __expectString(output[_iSpo]);\n    }\n    return contents;\n};\nconst de_VpcIpv6CidrBlockAssociationSet = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpcIpv6CidrBlockAssociation(entry, context);\n    });\n};\nconst de_VpcList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Vpc(entry, context);\n    });\n};\nconst de_VpcPeeringConnection = (output, context) => {\n    const contents = {};\n    if (output[_aVI] != null) {\n        contents[_AVI] = de_VpcPeeringConnectionVpcInfo(output[_aVI], context);\n    }\n    if (output[_eT] != null) {\n        contents[_ETx] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eT]));\n    }\n    if (output[_rVIe] != null) {\n        contents[_RVIe] = de_VpcPeeringConnectionVpcInfo(output[_rVIe], context);\n    }\n    if (output[_sta] != null) {\n        contents[_Statu] = de_VpcPeeringConnectionStateReason(output[_sta], context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vPCI] != null) {\n        contents[_VPCI] = __expectString(output[_vPCI]);\n    }\n    return contents;\n};\nconst de_VpcPeeringConnectionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpcPeeringConnection(entry, context);\n    });\n};\nconst de_VpcPeeringConnectionOptionsDescription = (output, context) => {\n    const contents = {};\n    if (output[_aDRFRV] != null) {\n        contents[_ADRFRV] = __parseBoolean(output[_aDRFRV]);\n    }\n    if (output[_aEFLCLTRV] != null) {\n        contents[_AEFLCLTRV] = __parseBoolean(output[_aEFLCLTRV]);\n    }\n    if (output[_aEFLVTRCL] != null) {\n        contents[_AEFLVTRCL] = __parseBoolean(output[_aEFLVTRCL]);\n    }\n    return contents;\n};\nconst de_VpcPeeringConnectionStateReason = (output, context) => {\n    const contents = {};\n    if (output[_co] != null) {\n        contents[_Cod] = __expectString(output[_co]);\n    }\n    if (output[_me] != null) {\n        contents[_Me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_VpcPeeringConnectionVpcInfo = (output, context) => {\n    const contents = {};\n    if (output[_cB] != null) {\n        contents[_CB] = __expectString(output[_cB]);\n    }\n    if (output.ipv6CidrBlockSet === \"\") {\n        contents[_ICBSp] = [];\n    }\n    else if (output[_iCBSp] != null && output[_iCBSp][_i] != null) {\n        contents[_ICBSp] = de_Ipv6CidrBlockSet(__getArrayIfSingleItem(output[_iCBSp][_i]), context);\n    }\n    if (output.cidrBlockSet === \"\") {\n        contents[_CBSi] = [];\n    }\n    else if (output[_cBSi] != null && output[_cBSi][_i] != null) {\n        contents[_CBSi] = de_CidrBlockSet(__getArrayIfSingleItem(output[_cBSi][_i]), context);\n    }\n    if (output[_oI] != null) {\n        contents[_OIwn] = __expectString(output[_oI]);\n    }\n    if (output[_pOe] != null) {\n        contents[_POe] = de_VpcPeeringConnectionOptionsDescription(output[_pOe], context);\n    }\n    if (output[_vI] != null) {\n        contents[_VI] = __expectString(output[_vI]);\n    }\n    if (output[_re] != null) {\n        contents[_Regi] = __expectString(output[_re]);\n    }\n    return contents;\n};\nconst de_VpnConnection = (output, context) => {\n    const contents = {};\n    if (output[_ca] != null) {\n        contents[_Cat] = __expectString(output[_ca]);\n    }\n    if (output[_tGI] != null) {\n        contents[_TGI] = __expectString(output[_tGI]);\n    }\n    if (output[_cNA] != null) {\n        contents[_CNAo] = __expectString(output[_cNA]);\n    }\n    if (output[_cNAA] != null) {\n        contents[_CNAA] = __expectString(output[_cNAA]);\n    }\n    if (output[_gAS] != null) {\n        contents[_GAS] = __expectString(output[_gAS]);\n    }\n    if (output[_opt] != null) {\n        contents[_Op] = de_VpnConnectionOptions(output[_opt], context);\n    }\n    if (output.routes === \"\") {\n        contents[_Rout] = [];\n    }\n    else if (output[_rou] != null && output[_rou][_i] != null) {\n        contents[_Rout] = de_VpnStaticRouteList(__getArrayIfSingleItem(output[_rou][_i]), context);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output.vgwTelemetry === \"\") {\n        contents[_VTg] = [];\n    }\n    else if (output[_vTg] != null && output[_vTg][_i] != null) {\n        contents[_VTg] = de_VgwTelemetryList(__getArrayIfSingleItem(output[_vTg][_i]), context);\n    }\n    if (output[_pSKA] != null) {\n        contents[_PSKA] = __expectString(output[_pSKA]);\n    }\n    if (output[_vCI] != null) {\n        contents[_VCI] = __expectString(output[_vCI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_cGC] != null) {\n        contents[_CGC] = __expectString(output[_cGC]);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_cGIu] != null) {\n        contents[_CGIu] = __expectString(output[_cGIu]);\n    }\n    if (output[_vGI] != null) {\n        contents[_VGI] = __expectString(output[_vGI]);\n    }\n    return contents;\n};\nconst de_VpnConnectionDeviceType = (output, context) => {\n    const contents = {};\n    if (output[_vCDTI] != null) {\n        contents[_VCDTI] = __expectString(output[_vCDTI]);\n    }\n    if (output[_ven] != null) {\n        contents[_Ven] = __expectString(output[_ven]);\n    }\n    if (output[_pl] != null) {\n        contents[_Pla] = __expectString(output[_pl]);\n    }\n    if (output[_sof] != null) {\n        contents[_Sof] = __expectString(output[_sof]);\n    }\n    return contents;\n};\nconst de_VpnConnectionDeviceTypeList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpnConnectionDeviceType(entry, context);\n    });\n};\nconst de_VpnConnectionList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpnConnection(entry, context);\n    });\n};\nconst de_VpnConnectionOptions = (output, context) => {\n    const contents = {};\n    if (output[_eAn] != null) {\n        contents[_EA] = __parseBoolean(output[_eAn]);\n    }\n    if (output[_sRO] != null) {\n        contents[_SRO] = __parseBoolean(output[_sRO]);\n    }\n    if (output[_lINC] != null) {\n        contents[_LINC] = __expectString(output[_lINC]);\n    }\n    if (output[_rINC] != null) {\n        contents[_RINC] = __expectString(output[_rINC]);\n    }\n    if (output[_lINCo] != null) {\n        contents[_LINCo] = __expectString(output[_lINCo]);\n    }\n    if (output[_rINCe] != null) {\n        contents[_RINCe] = __expectString(output[_rINCe]);\n    }\n    if (output[_oIAT] != null) {\n        contents[_OIAT] = __expectString(output[_oIAT]);\n    }\n    if (output[_tTGAI] != null) {\n        contents[_TTGAI] = __expectString(output[_tTGAI]);\n    }\n    if (output[_tIIV] != null) {\n        contents[_TIIV] = __expectString(output[_tIIV]);\n    }\n    if (output.tunnelOptionSet === \"\") {\n        contents[_TO] = [];\n    }\n    else if (output[_tOS] != null && output[_tOS][_i] != null) {\n        contents[_TO] = de_TunnelOptionsList(__getArrayIfSingleItem(output[_tOS][_i]), context);\n    }\n    return contents;\n};\nconst de_VpnGateway = (output, context) => {\n    const contents = {};\n    if (output[_aSA] != null) {\n        contents[_ASA] = __strictParseLong(output[_aSA]);\n    }\n    if (output.tagSet === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_tS] != null && output[_tS][_i] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);\n    }\n    if (output[_vGI] != null) {\n        contents[_VGI] = __expectString(output[_vGI]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    if (output[_ty] != null) {\n        contents[_T] = __expectString(output[_ty]);\n    }\n    if (output[_aZ] != null) {\n        contents[_AZ] = __expectString(output[_aZ]);\n    }\n    if (output.attachments === \"\") {\n        contents[_VAp] = [];\n    }\n    else if (output[_att] != null && output[_att][_i] != null) {\n        contents[_VAp] = de_VpcAttachmentList(__getArrayIfSingleItem(output[_att][_i]), context);\n    }\n    return contents;\n};\nconst de_VpnGatewayList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpnGateway(entry, context);\n    });\n};\nconst de_VpnStaticRoute = (output, context) => {\n    const contents = {};\n    if (output[_dCB] != null) {\n        contents[_DCB] = __expectString(output[_dCB]);\n    }\n    if (output[_s] != null) {\n        contents[_S] = __expectString(output[_s]);\n    }\n    if (output[_st] != null) {\n        contents[_Stat] = __expectString(output[_st]);\n    }\n    return contents;\n};\nconst de_VpnStaticRouteList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_VpnStaticRoute(entry, context);\n    });\n};\nconst de_VpnTunnelLogOptions = (output, context) => {\n    const contents = {};\n    if (output[_cWLO] != null) {\n        contents[_CWLO] = de_CloudWatchLogOptions(output[_cWLO], context);\n    }\n    return contents;\n};\nconst de_WithdrawByoipCidrResult = (output, context) => {\n    const contents = {};\n    if (output[_bC] != null) {\n        contents[_BC] = de_ByoipCidr(output[_bC], context);\n    }\n    return contents;\n};\nconst deserializeMetadata = (output) => ({\n    httpStatusCode: output.statusCode,\n    requestId: output.headers[\"x-amzn-requestid\"] ?? output.headers[\"x-amzn-request-id\"] ?? output.headers[\"x-amz-request-id\"],\n    extendedRequestId: output.headers[\"x-amz-id-2\"],\n    cfId: output.headers[\"x-amz-cf-id\"],\n});\nconst collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));\nconst throwDefaultError = withBaseException(__BaseException);\nconst buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {\n    const { hostname, protocol = \"https\", port, path: basePath } = await context.endpoint();\n    const contents = {\n        protocol,\n        hostname,\n        port,\n        method: \"POST\",\n        path: basePath.endsWith(\"/\") ? basePath.slice(0, -1) + path : basePath + path,\n        headers,\n    };\n    if (resolvedHostname !== undefined) {\n        contents.hostname = resolvedHostname;\n    }\n    if (body !== undefined) {\n        contents.body = body;\n    }\n    return new __HttpRequest(contents);\n};\nconst SHARED_HEADERS = {\n    \"content-type\": \"application/x-www-form-urlencoded\",\n};\nconst _ = \"2016-11-15\";\nconst _A = \"Action\";\nconst _AA = \"AllocateAddress\";\nconst _AAC = \"AsnAuthorizationContext\";\nconst _AACv = \"AvailableAddressCount\";\nconst _AAG = \"AuthorizeAllGroups\";\nconst _AAI = \"AwsAccountId\";\nconst _AAId = \"AddressAllocationId\";\nconst _AAP = \"AddAllowedPrincipals\";\nconst _AART = \"AddAllocationResourceTags\";\nconst _AASA = \"AutoAcceptSharedAssociations\";\nconst _AASAu = \"AutoAcceptSharedAttachments\";\nconst _AAT = \"AcceptAddressTransfer\";\nconst _AAZ = \"AllAvailabilityZones\";\nconst _AAc = \"AccessAll\";\nconst _AAcc = \"AccountAttributes\";\nconst _AAd = \"AdditionalAccounts\";\nconst _AAs = \"AssociateAddress\";\nconst _AAsn = \"AsnAssociation\";\nconst _AAsns = \"AsnAssociations\";\nconst _ABC = \"AdvertiseByoipCidr\";\nconst _ABHP = \"ActualBlockHourlyPrice\";\nconst _AC = \"AllowedCidrs\";\nconst _ACIA = \"AssociateCarrierIpAddress\";\nconst _ACLV = \"AttachClassicLinkVpc\";\nconst _ACRBO = \"AcceptCapacityReservationBillingOwnership\";\nconst _ACRBOs = \"AssociateCapacityReservationBillingOwner\";\nconst _ACT = \"ArchivalCompleteTime\";\nconst _ACVI = \"AuthorizeClientVpnIngress\";\nconst _ACVTN = \"AssociateClientVpnTargetNetwork\";\nconst _ACc = \"AcceleratorCount\";\nconst _ACd = \"AddressCount\";\nconst _ACv = \"AvailableCapacity\";\nconst _AD = \"ActiveDirectory\";\nconst _ADNL = \"AllocationDefaultNetmaskLength\";\nconst _ADO = \"AssociateDhcpOptions\";\nconst _ADRFRV = \"AllowDnsResolutionFromRemoteVpc\";\nconst _ADRTI = \"AssociationDefaultRouteTableId\";\nconst _ADT = \"AdditionalDetailType\";\nconst _ADd = \"AdditionalDetails\";\nconst _ADn = \"AnnouncementDirection\";\nconst _ADp = \"ApplicationDomain\";\nconst _AE = \"AuthorizationEndpoint\";\nconst _AEC = \"AnalyzedEniCount\";\nconst _AECIR = \"AssociateEnclaveCertificateIamRole\";\nconst _AEFLCLTRV = \"AllowEgressFromLocalClassicLinkToRemoteVpc\";\nconst _AEFLVTRCL = \"AllowEgressFromLocalVpcToRemoteClassicLink\";\nconst _AEIO = \"AutoEnableIO\";\nconst _AES = \"AttachedEbsStatus\";\nconst _AET = \"AnalysisEndTime\";\nconst _AEd = \"AddEntries\";\nconst _AF = \"AddressFamily\";\nconst _AFn = \"AnalysisFindings\";\nconst _AGI = \"AccessGroupId\";\nconst _AGLBA = \"AddGatewayLoadBalancerArns\";\nconst _AH = \"AllocateHosts\";\nconst _AI = \"AssetIds\";\nconst _AIA = \"AssignIpv6Addresses\";\nconst _AIAC = \"AvailableIpAddressCount\";\nconst _AIAOC = \"AssignIpv6AddressOnCreation\";\nconst _AIAs = \"AssignedIpv6Addresses\";\nconst _AIB = \"AssociateIpamByoasn\";\nconst _AIC = \"AvailableInstanceCapacity\";\nconst _AICv = \"AvailableInstanceCount\";\nconst _AIEW = \"AssociateInstanceEventWindow\";\nconst _AIG = \"AttachInternetGateway\";\nconst _AIIP = \"AssociateIamInstanceProfile\";\nconst _AIP = \"AssignedIpv6Prefixes\";\nconst _AIPC = \"AllocateIpamPoolCidr\";\nconst _AIPs = \"AssignedIpv4Prefixes\";\nconst _AIRD = \"AssociateIpamResourceDiscovery\";\nconst _AISS = \"AllowedImagesSettingsState\";\nconst _AIT = \"AllowedInstanceTypes\";\nconst _AIc = \"ActiveInstances\";\nconst _AIcc = \"AccountId\";\nconst _AId = \"AdditionalInfo\";\nconst _AIl = \"AllocationId\";\nconst _AIll = \"AllocationIds\";\nconst _AIm = \"AmiId\";\nconst _AIp = \"AppleInternal\";\nconst _AIs = \"AssociationIds\";\nconst _AIss = \"AssociationId\";\nconst _AIsse = \"AssetId\";\nconst _AIt = \"AttachmentId\";\nconst _AIth = \"AthenaIntegrations\";\nconst _AIu = \"AutoImport\";\nconst _AL = \"AccessLogs\";\nconst _ALI = \"AmiLaunchIndex\";\nconst _ALc = \"AccountLevel\";\nconst _AM = \"AcceleratorManufacturers\";\nconst _AMIT = \"AllowsMultipleInstanceTypes\";\nconst _AMNL = \"AllocationMinNetmaskLength\";\nconst _AMNLl = \"AllocationMaxNetmaskLength\";\nconst _AMS = \"ApplianceModeSupport\";\nconst _AN = \"AttributeNames\";\nconst _ANGA = \"AssociateNatGatewayAddress\";\nconst _ANI = \"AttachNetworkInterface\";\nconst _ANLBA = \"AddNetworkLoadBalancerArns\";\nconst _ANS = \"AddNetworkServices\";\nconst _ANc = \"AcceleratorNames\";\nconst _ANt = \"AttributeName\";\nconst _AO = \"AuthenticationOptions\";\nconst _AOI = \"AddressOwnerId\";\nconst _AOR = \"AddOperatingRegions\";\nconst _AOUE = \"AddOrganizationalUnitExclusions\";\nconst _AP = \"AutoPlacement\";\nconst _APCO = \"AccepterPeeringConnectionOptions\";\nconst _APH = \"AlternatePathHints\";\nconst _APIA = \"AssignPrivateIpAddresses\";\nconst _APIAs = \"AssociatePublicIpAddress\";\nconst _APIAss = \"AssignedPrivateIpAddresses\";\nconst _APICB = \"AmazonProvidedIpv6CidrBlock\";\nconst _APM = \"ApplyPendingMaintenance\";\nconst _APNGA = \"AssignPrivateNatGatewayAddress\";\nconst _APd = \"AddedPrincipals\";\nconst _APl = \"AllowedPrincipals\";\nconst _APs = \"AsPaths\";\nconst _AR = \"AllowReassignment\";\nconst _ARA = \"AssociatedRoleArn\";\nconst _ARAd = \"AdditionalRoutesAvailable\";\nconst _ARAs = \"AssociatedResourceAccessibility\";\nconst _ARAss = \"AssociatedResourceArn\";\nconst _ARC = \"AcceptedRouteCount\";\nconst _ARIEQ = \"AcceptReservedInstancesExchangeQuote\";\nconst _ARP = \"AreRoutesPersisted\";\nconst _ARS = \"AssociateRouteServer\";\nconst _ARSu = \"AutoRecoverySupported\";\nconst _ART = \"AssociateRouteTable\";\nconst _ARTI = \"AddRouteTableIds\";\nconst _ARTl = \"AllocationResourceTags\";\nconst _ARc = \"AcceptanceRequired\";\nconst _ARcl = \"AclRule\";\nconst _ARd = \"AddressRegion\";\nconst _ARl = \"AllowReassociation\";\nconst _ARll = \"AllRegions\";\nconst _ARs = \"AssociatedResource\";\nconst _ARss = \"AssociatedRoles\";\nconst _ARu = \"AutoRecovery\";\nconst _ARut = \"AuthorizationRules\";\nconst _ARw = \"AwsRegion\";\nconst _AS = \"AllocationStrategy\";\nconst _ASA = \"AmazonSideAsn\";\nconst _ASCB = \"AssociateSubnetCidrBlock\";\nconst _ASGE = \"AuthorizeSecurityGroupEgress\";\nconst _ASGI = \"AuthorizeSecurityGroupIngress\";\nconst _ASGId = \"AddSecurityGroupIds\";\nconst _ASGTCVTN = \"ApplySecurityGroupsToClientVpnTargetNetwork\";\nconst _ASGV = \"AssociateSecurityGroupVpc\";\nconst _ASI = \"AddSubnetIds\";\nconst _ASIAT = \"AddSupportedIpAddressTypes\";\nconst _ASR = \"AddSupportedRegions\";\nconst _ASS = \"AmdSevSnp\";\nconst _AST = \"AnalysisStartTime\";\nconst _ASTB = \"AnalysisStartTimeBegin\";\nconst _ASTE = \"AnalysisStartTimeEnd\";\nconst _ASc = \"ActivityStatus\";\nconst _ASn = \"AnalysisStatus\";\nconst _ASs = \"AssociationState\";\nconst _ASss = \"AssociationStatus\";\nconst _ASt = \"AttributeSummaries\";\nconst _AStt = \"AttachmentStatuses\";\nconst _ASw = \"AwsService\";\nconst _AT = \"AssociationTarget\";\nconst _ATGAI = \"AccepterTransitGatewayAttachmentId\";\nconst _ATGCB = \"AddTransitGatewayCidrBlocks\";\nconst _ATGMD = \"AssociateTransitGatewayMulticastDomain\";\nconst _ATGMDA = \"AcceptTransitGatewayMulticastDomainAssociations\";\nconst _ATGPA = \"AcceptTransitGatewayPeeringAttachment\";\nconst _ATGPT = \"AssociateTransitGatewayPolicyTable\";\nconst _ATGRT = \"AssociateTransitGatewayRouteTable\";\nconst _ATGVA = \"AcceptTransitGatewayVpcAttachment\";\nconst _ATI = \"AssociateTrunkInterface\";\nconst _ATIc = \"AccepterTgwInfo\";\nconst _ATMMB = \"AcceleratorTotalMemoryMiB\";\nconst _ATN = \"AssociatedTargetNetworks\";\nconst _ATS = \"AddressTransferStatus\";\nconst _ATc = \"AcceleratorTypes\";\nconst _ATd = \"AddressingType\";\nconst _ATdd = \"AddressTransfer\";\nconst _ATddr = \"AddressTransfers\";\nconst _ATddre = \"AddressType\";\nconst _ATl = \"AllocationType\";\nconst _ATll = \"AllocationTime\";\nconst _ATr = \"ArchitectureTypes\";\nconst _ATt = \"AttachmentType\";\nconst _ATtt = \"AttachTime\";\nconst _ATtta = \"AttachedTo\";\nconst _AV = \"AttachVolume\";\nconst _AVATP = \"AttachVerifiedAccessTrustProvider\";\nconst _AVC = \"AvailableVCpus\";\nconst _AVCB = \"AssociateVpcCidrBlock\";\nconst _AVEC = \"AcceptVpcEndpointConnections\";\nconst _AVG = \"AttachVpnGateway\";\nconst _AVI = \"AccepterVpcInfo\";\nconst _AVPC = \"AcceptVpcPeeringConnection\";\nconst _AVTS = \"ActiveVpnTunnelStatus\";\nconst _AVt = \"AttributeValues\";\nconst _AVtt = \"AttributeValue\";\nconst _AWSAKI = \"AWSAccessKeyId\";\nconst _AZ = \"AvailabilityZone\";\nconst _AZG = \"AvailabilityZoneGroup\";\nconst _AZI = \"AvailabilityZoneId\";\nconst _AZIv = \"AvailabilityZoneIds\";\nconst _AZv = \"AvailabilityZones\";\nconst _Ac = \"Accept\";\nconst _Acc = \"Accelerators\";\nconst _Acl = \"Acl\";\nconst _Act = \"Active\";\nconst _Acti = \"Actions\";\nconst _Ad = \"Address\";\nconst _Add = \"Add\";\nconst _Addr = \"Addresses\";\nconst _Af = \"Affinity\";\nconst _Am = \"Amount\";\nconst _Ar = \"Arn\";\nconst _Arc = \"Architecture\";\nconst _As = \"Asn\";\nconst _Ass = \"Associations\";\nconst _Asso = \"Association\";\nconst _At = \"Attribute\";\nconst _Att = \"Attachment\";\nconst _Atta = \"Attachments\";\nconst _B = \"Bucket\";\nconst _BA = \"BgpAsn\";\nconst _BAE = \"BgpAsnExtended\";\nconst _BBIG = \"BaselineBandwidthInGbps\";\nconst _BBIM = \"BaselineBandwidthInMbps\";\nconst _BC = \"ByoipCidr\";\nconst _BCg = \"BgpConfigurations\";\nconst _BCy = \"ByoipCidrs\";\nconst _BCyt = \"BytesConverted\";\nconst _BDM = \"BlockDeviceMappings\";\nconst _BDMl = \"BlockDurationMinutes\";\nconst _BEBM = \"BaselineEbsBandwidthMbps\";\nconst _BEDN = \"BaseEndpointDnsNames\";\nconst _BI = \"BundleInstance\";\nconst _BII = \"BranchInterfaceId\";\nconst _BIa = \"BaselineIops\";\nconst _BIu = \"BundleId\";\nconst _BIun = \"BundleIds\";\nconst _BM = \"BootMode\";\nconst _BMa = \"BareMetal\";\nconst _BN = \"BucketName\";\nconst _BO = \"BgpOptions\";\nconst _BOu = \"BucketOwner\";\nconst _BP = \"BurstablePerformance\";\nconst _BPAS = \"BlockPublicAccessStates\";\nconst _BPF = \"BaselinePerformanceFactors\";\nconst _BPS = \"BurstablePerformanceSupported\";\nconst _BPi = \"BillingProducts\";\nconst _BS = \"BaseSystem\";\nconst _BSf = \"BfdStatus\";\nconst _BSg = \"BgpStatus\";\nconst _BT = \"BannerText\";\nconst _BTE = \"BundleTaskError\";\nconst _BTIMB = \"BaselineThroughputInMBps\";\nconst _BTu = \"BundleTask\";\nconst _BTun = \"BundleTasks\";\nconst _BW = \"BandwidthWeighting\";\nconst _BWa = \"BandwidthWeightings\";\nconst _Bl = \"Blackhole\";\nconst _By = \"Bytes\";\nconst _Byo = \"Byoasn\";\nconst _Byoa = \"Byoasns\";\nconst _C = \"Cidr\";\nconst _CA = \"CertificateArn\";\nconst _CAC = \"CidrAuthorizationContext\";\nconst _CADNL = \"ClearAllocationDefaultNetmaskLength\";\nconst _CAU = \"CoipAddressUsages\";\nconst _CAa = \"CapacityAllocations\";\nconst _CAo = \"ComponentArn\";\nconst _CAom = \"ComponentAccount\";\nconst _CAr = \"CreatedAt\";\nconst _CB = \"CidrBlock\";\nconst _CBA = \"CidrBlockAssociation\";\nconst _CBAS = \"CidrBlockAssociationSet\";\nconst _CBDH = \"CapacityBlockDurationHours\";\nconst _CBDM = \"CapacityBlockDurationMinutes\";\nconst _CBE = \"CapacityBlockExtensions\";\nconst _CBEDH = \"CapacityBlockExtensionDurationHours\";\nconst _CBEED = \"CapacityBlockExtensionEndDate\";\nconst _CBEO = \"CapacityBlockExtensionOfferings\";\nconst _CBEOI = \"CapacityBlockExtensionOfferingId\";\nconst _CBEPD = \"CapacityBlockExtensionPurchaseDate\";\nconst _CBES = \"CapacityBlockExtensionStatus\";\nconst _CBESD = \"CapacityBlockExtensionStartDate\";\nconst _CBO = \"CapacityBlockOfferings\";\nconst _CBOI = \"CapacityBlockOfferingId\";\nconst _CBS = \"CidrBlockState\";\nconst _CBSi = \"CidrBlockSet\";\nconst _CBT = \"CancelBundleTask\";\nconst _CBr = \"CreatedBy\";\nconst _CC = \"CoreCount\";\nconst _CCB = \"ClientCidrBlock\";\nconst _CCC = \"CreateCoipCidr\";\nconst _CCG = \"CreateCarrierGateway\";\nconst _CCGr = \"CreateCustomerGateway\";\nconst _CCO = \"ClientConnectOptions\";\nconst _CCP = \"CreateCoipPool\";\nconst _CCR = \"CancelCapacityReservation\";\nconst _CCRBS = \"CreateCapacityReservationBySplitting\";\nconst _CCRF = \"CancelCapacityReservationFleets\";\nconst _CCRFE = \"CancelCapacityReservationFleetError\";\nconst _CCRFr = \"CreateCapacityReservationFleet\";\nconst _CCRr = \"CreateCapacityReservation\";\nconst _CCT = \"CancelConversionTask\";\nconst _CCVE = \"CreateClientVpnEndpoint\";\nconst _CCVR = \"CreateClientVpnRoute\";\nconst _CCl = \"ClientConfiguration\";\nconst _CCo = \"CoipCidr\";\nconst _CCp = \"CpuCredits\";\nconst _CCu = \"CurrencyCode\";\nconst _CD = \"CommitmentDuration\";\nconst _CDH = \"CapacityDurationHours\";\nconst _CDM = \"CompletionDurationMinutes\";\nconst _CDMVOT = \"CreateDelegateMacVolumeOwnershipTask\";\nconst _CDO = \"CreateDhcpOptions\";\nconst _CDPR = \"CancelDeclarativePoliciesReport\";\nconst _CDS = \"CreateDefaultSubnet\";\nconst _CDSDA = \"ConfigDeliveryS3DestinationArn\";\nconst _CDSu = \"CustomDnsServers\";\nconst _CDV = \"CreateDefaultVpc\";\nconst _CDl = \"ClientData\";\nconst _CDr = \"CreateDate\";\nconst _CDre = \"CreationDate\";\nconst _CDrea = \"CreatedDate\";\nconst _CE = \"CronExpression\";\nconst _CECSD = \"CidrEndpointsCustomSubDomain\";\nconst _CED = \"CommitmentEndDate\";\nconst _CEOIG = \"CreateEgressOnlyInternetGateway\";\nconst _CET = \"CancelExportTask\";\nconst _CETo = \"ConnectionEstablishedTime\";\nconst _CETon = \"ConnectionEndTime\";\nconst _CEo = \"ConnectionEvents\";\nconst _CF = \"CreateFleet\";\nconst _CFI = \"CopyFpgaImage\";\nconst _CFIr = \"CreateFpgaImage\";\nconst _CFL = \"CreateFlowLogs\";\nconst _CFS = \"CurrentFleetState\";\nconst _CFo = \"ContainerFormat\";\nconst _CG = \"CarrierGateway\";\nconst _CGC = \"CustomerGatewayConfiguration\";\nconst _CGI = \"CarrierGatewayId\";\nconst _CGIa = \"CarrierGatewayIds\";\nconst _CGIu = \"CustomerGatewayId\";\nconst _CGIus = \"CustomerGatewayIds\";\nconst _CGa = \"CarrierGateways\";\nconst _CGu = \"CustomerGateway\";\nconst _CGur = \"CurrentGeneration\";\nconst _CGus = \"CustomerGateways\";\nconst _CI = \"CopyImage\";\nconst _CIBM = \"CurrentInstanceBootMode\";\nconst _CIC = \"CommittedInstanceCount\";\nconst _CICE = \"CreateInstanceConnectEndpoint\";\nconst _CIERVT = \"CreateIpamExternalResourceVerificationToken\";\nconst _CIET = \"CreateInstanceExportTask\";\nconst _CIEW = \"CreateInstanceEventWindow\";\nconst _CIG = \"CreateInternetGateway\";\nconst _CILP = \"CancelImageLaunchPermission\";\nconst _CIP = \"CreateIpamPool\";\nconst _CIRD = \"CreateIpamResourceDiscovery\";\nconst _CIS = \"CreateIpamScope\";\nconst _CISI = \"CurrentIpamScopeId\";\nconst _CIT = \"CancelImportTask\";\nconst _CITo = \"CopyImageTags\";\nconst _CIa = \"CarrierIp\";\nconst _CIi = \"CidrIp\";\nconst _CIid = \"CidrIpv6\";\nconst _CIidr = \"CidrIpv4\";\nconst _CIl = \"ClientId\";\nconst _CIli = \"ClientIp\";\nconst _CIo = \"ConnectionId\";\nconst _CIom = \"ComponentId\";\nconst _CIomm = \"CommitmentInfo\";\nconst _CIop = \"CoIp\";\nconst _CIor = \"CoreInfo\";\nconst _CIr = \"CreateImage\";\nconst _CIre = \"CreateIpam\";\nconst _CKP = \"CreateKeyPair\";\nconst _CLB = \"ClassicLoadBalancers\";\nconst _CLBC = \"ClassicLoadBalancersConfig\";\nconst _CLBL = \"ClassicLoadBalancerListener\";\nconst _CLBO = \"ClientLoginBannerOptions\";\nconst _CLDS = \"ClassicLinkDnsSupported\";\nconst _CLE = \"ClassicLinkEnabled\";\nconst _CLG = \"CloudwatchLogGroup\";\nconst _CLGR = \"CreateLocalGatewayRoute\";\nconst _CLGRT = \"CreateLocalGatewayRouteTable\";\nconst _CLGRTVA = \"CreateLocalGatewayRouteTableVpcAssociation\";\nconst _CLGRTVIGA = \"CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociation\";\nconst _CLGVI = \"CreateLocalGatewayVirtualInterface\";\nconst _CLGVIG = \"CreateLocalGatewayVirtualInterfaceGroup\";\nconst _CLO = \"ConnectionLogOptions\";\nconst _CLS = \"CloudwatchLogStream\";\nconst _CLT = \"CreateLaunchTemplate\";\nconst _CLTV = \"CreateLaunchTemplateVersion\";\nconst _CM = \"CpuManufacturers\";\nconst _CMKE = \"CustomerManagedKeyEnabled\";\nconst _CMPL = \"CreateManagedPrefixList\";\nconst _CMSIPMT = \"CreateMacSystemIntegrityProtectionModificationTask\";\nconst _CN = \"CommonName\";\nconst _CNA = \"CreateNetworkAcl\";\nconst _CNAA = \"CoreNetworkAttachmentArn\";\nconst _CNAE = \"CreateNetworkAclEntry\";\nconst _CNAo = \"CoreNetworkArn\";\nconst _CNAon = \"ConnectionNotificationArn\";\nconst _CNG = \"CreateNatGateway\";\nconst _CNI = \"CreateNetworkInterface\";\nconst _CNIAS = \"CreateNetworkInsightsAccessScope\";\nconst _CNIP = \"CreateNetworkInsightsPath\";\nconst _CNIPr = \"CreateNetworkInterfacePermission\";\nconst _CNIo = \"ConnectionNotificationIds\";\nconst _CNIon = \"ConnectionNotificationId\";\nconst _CNIor = \"CoreNetworkId\";\nconst _CNS = \"ConnectionNotificationState\";\nconst _CNSo = \"ConnectionNotificationSet\";\nconst _CNT = \"ConnectionNotificationType\";\nconst _CNo = \"ConnectionNotification\";\nconst _CO = \"CidrOptions\";\nconst _COI = \"CustomerOwnedIp\";\nconst _COIP = \"CustomerOwnedIpv4Pool\";\nconst _COP = \"CoolOffPeriod\";\nconst _COPEO = \"CoolOffPeriodExpiresOn\";\nconst _COp = \"CpuOptions\";\nconst _CP = \"CoipPool\";\nconst _CPC = \"ConnectPeerConfiguration\";\nconst _CPG = \"CreatePlacementGroup\";\nconst _CPI = \"ConfirmProductInstance\";\nconst _CPIP = \"CreatePublicIpv4Pool\";\nconst _CPIo = \"CoipPoolId\";\nconst _CPo = \"CoipPools\";\nconst _CR = \"CreateRoute\";\nconst _CRA = \"CapacityReservationArn\";\nconst _CRBR = \"CapacityReservationBillingRequests\";\nconst _CRCC = \"ClientRootCertificateChain\";\nconst _CRCCA = \"ClientRootCertificateChainArn\";\nconst _CREO = \"ClientRouteEnforcementOptions\";\nconst _CRF = \"CapacityReservationFleets\";\nconst _CRFA = \"CapacityReservationFleetArn\";\nconst _CRFI = \"CapacityReservationFleetIds\";\nconst _CRFIa = \"CapacityReservationFleetId\";\nconst _CRG = \"CapacityReservationGroups\";\nconst _CRI = \"CapacityReservationId\";\nconst _CRIL = \"CancelReservedInstancesListing\";\nconst _CRILr = \"CreateReservedInstancesListing\";\nconst _CRIT = \"CreateRestoreImageTask\";\nconst _CRIa = \"CapacityReservationIds\";\nconst _CRIap = \"CapacityReservationInfo\";\nconst _CRL = \"CertificateRevocationList\";\nconst _CRO = \"CapacityReservationOptions\";\nconst _CRP = \"CapacityReservationPreference\";\nconst _CRRGA = \"CapacityReservationResourceGroupArn\";\nconst _CRRVT = \"CreateReplaceRootVolumeTask\";\nconst _CRS = \"CreateRouteServer\";\nconst _CRSE = \"CreateRouteServerEndpoint\";\nconst _CRSP = \"CreateRouteServerPeer\";\nconst _CRSa = \"CapacityReservationSpecification\";\nconst _CRT = \"CreateRouteTable\";\nconst _CRTa = \"CapacityReservationTarget\";\nconst _CRa = \"CancelReason\";\nconst _CRap = \"CapacityRebalance\";\nconst _CRapa = \"CapacityReservation\";\nconst _CRapac = \"CapacityReservations\";\nconst _CRo = \"ComponentRegion\";\nconst _CS = \"CopySnapshot\";\nconst _CSBN = \"CertificateS3BucketName\";\nconst _CSCR = \"CreateSubnetCidrReservation\";\nconst _CSDS = \"CreateSpotDatafeedSubscription\";\nconst _CSFR = \"CancelSpotFleetRequests\";\nconst _CSFRS = \"CurrentSpotFleetRequestState\";\nconst _CSG = \"CreateSecurityGroup\";\nconst _CSIR = \"CancelSpotInstanceRequests\";\nconst _CSIRa = \"CancelledSpotInstanceRequests\";\nconst _CSIT = \"CreateStoreImageTask\";\nconst _CSOK = \"CertificateS3ObjectKey\";\nconst _CSl = \"ClientSecret\";\nconst _CSo = \"ComplianceStatus\";\nconst _CSon = \"ConfigurationState\";\nconst _CSonn = \"ConnectionStatuses\";\nconst _CSr = \"CreateSnapshot\";\nconst _CSre = \"CreateSnapshots\";\nconst _CSrea = \"CreateSubnet\";\nconst _CSred = \"CreditSpecification\";\nconst _CSu = \"CurrentState\";\nconst _CSur = \"CurrentStatus\";\nconst _CT = \"CreateTags\";\nconst _CTC = \"ConnectionTrackingConfiguration\";\nconst _CTFS = \"CopyTagsFromSource\";\nconst _CTG = \"CreateTransitGateway\";\nconst _CTGC = \"CreateTransitGatewayConnect\";\nconst _CTGCP = \"CreateTransitGatewayConnectPeer\";\nconst _CTGMD = \"CreateTransitGatewayMulticastDomain\";\nconst _CTGPA = \"CreateTransitGatewayPeeringAttachment\";\nconst _CTGPLR = \"CreateTransitGatewayPrefixListReference\";\nconst _CTGPT = \"CreateTransitGatewayPolicyTable\";\nconst _CTGR = \"CreateTransitGatewayRoute\";\nconst _CTGRT = \"CreateTransitGatewayRouteTable\";\nconst _CTGRTA = \"CreateTransitGatewayRouteTableAnnouncement\";\nconst _CTGVA = \"CreateTransitGatewayVpcAttachment\";\nconst _CTI = \"ConversionTaskId\";\nconst _CTIo = \"ConversionTaskIds\";\nconst _CTMF = \"CreateTrafficMirrorFilter\";\nconst _CTMFR = \"CreateTrafficMirrorFilterRule\";\nconst _CTMS = \"CreateTrafficMirrorSession\";\nconst _CTMT = \"CreateTrafficMirrorTarget\";\nconst _CTS = \"ConnectionTrackingSpecification\";\nconst _CTl = \"ClientToken\";\nconst _CTo = \"ConnectivityType\";\nconst _CTom = \"CompleteTime\";\nconst _CTomp = \"CompletionTime\";\nconst _CTon = \"ConversionTasks\";\nconst _CTonv = \"ConversionTask\";\nconst _CTr = \"CreateTime\";\nconst _CTre = \"CreationTime\";\nconst _CTrea = \"CreationTimestamp\";\nconst _CV = \"CreateVolume\";\nconst _CVAE = \"CreateVerifiedAccessEndpoint\";\nconst _CVAG = \"CreateVerifiedAccessGroup\";\nconst _CVAI = \"CreateVerifiedAccessInstance\";\nconst _CVATP = \"CreateVerifiedAccessTrustProvider\";\nconst _CVBPAE = \"CreateVpcBlockPublicAccessExclusion\";\nconst _CVC = \"CreateVpnConnection\";\nconst _CVCR = \"CreateVpnConnectionRoute\";\nconst _CVE = \"CreateVpcEndpoint\";\nconst _CVECN = \"CreateVpcEndpointConnectionNotification\";\nconst _CVEI = \"ClientVpnEndpointId\";\nconst _CVEIl = \"ClientVpnEndpointIds\";\nconst _CVESC = \"CreateVpcEndpointServiceConfiguration\";\nconst _CVEl = \"ClientVpnEndpoints\";\nconst _CVG = \"CreateVpnGateway\";\nconst _CVP = \"CreateVolumePermission\";\nconst _CVPC = \"CreateVpcPeeringConnection\";\nconst _CVPr = \"CreateVolumePermissions\";\nconst _CVTN = \"ClientVpnTargetNetworks\";\nconst _CVr = \"CreateVpc\";\nconst _CVu = \"CurrentVersion\";\nconst _CWL = \"CloudWatchLogs\";\nconst _CWLO = \"CloudWatchLogOptions\";\nconst _Ca = \"Cascade\";\nconst _Cat = \"Category\";\nconst _Ch = \"Checksum\";\nconst _Ci = \"Cidrs\";\nconst _Co = \"Comment\";\nconst _Cod = \"Code\";\nconst _Com = \"Component\";\nconst _Con = \"Context\";\nconst _Conf = \"Configured\";\nconst _Confi = \"Config\";\nconst _Conn = \"Connections\";\nconst _Cor = \"Cores\";\nconst _Cou = \"Count\";\nconst _Cp = \"Cpu\";\nconst _D = \"Destination\";\nconst _DA = \"DescribeAddresses\";\nconst _DAA = \"DescribeAccountAttributes\";\nconst _DAAI = \"DelegatedAdminAccountId\";\nconst _DAAe = \"DescribeAddressesAttribute\";\nconst _DAIF = \"DescribeAggregateIdFormat\";\nconst _DAIS = \"DisableAllowedImagesSettings\";\nconst _DAIT = \"DenyAllIgwTraffic\";\nconst _DANPMS = \"DescribeAwsNetworkPerformanceMetricSubscriptions\";\nconst _DANPMSi = \"DisableAwsNetworkPerformanceMetricSubscription\";\nconst _DART = \"DefaultAssociationRouteTable\";\nconst _DAS = \"DeleteAssociatedSnapshots\";\nconst _DASi = \"DisableApiStop\";\nconst _DAT = \"DescribeAddressTransfers\";\nconst _DATi = \"DisableAddressTransfer\";\nconst _DATis = \"DisableApiTermination\";\nconst _DAZ = \"DescribeAvailabilityZones\";\nconst _DAe = \"DeprecateAt\";\nconst _DAep = \"DeprovisionedAddresses\";\nconst _DAes = \"DestinationAddresses\";\nconst _DAest = \"DestinationAddress\";\nconst _DAesti = \"DestinationArn\";\nconst _DAi = \"DisassociateAddress\";\nconst _DBC = \"DeprovisionByoipCidr\";\nconst _DBCe = \"DescribeByoipCidrs\";\nconst _DBT = \"DescribeBundleTasks\";\nconst _DC = \"DisallowedCidrs\";\nconst _DCA = \"DomainCertificateArn\";\nconst _DCAR = \"DeliverCrossAccountRole\";\nconst _DCB = \"DestinationCidrBlock\";\nconst _DCBEH = \"DescribeCapacityBlockExtensionHistory\";\nconst _DCBEO = \"DescribeCapacityBlockExtensionOfferings\";\nconst _DCBO = \"DescribeCapacityBlockOfferings\";\nconst _DCC = \"DeleteCoipCidr\";\nconst _DCG = \"DeleteCarrierGateway\";\nconst _DCGe = \"DeleteCustomerGateway\";\nconst _DCGes = \"DescribeCarrierGateways\";\nconst _DCGesc = \"DescribeCustomerGateways\";\nconst _DCLI = \"DescribeClassicLinkInstances\";\nconst _DCLV = \"DetachClassicLinkVpc\";\nconst _DCP = \"DeleteCoipPool\";\nconst _DCPe = \"DescribeCoipPools\";\nconst _DCR = \"DescribeCapacityReservations\";\nconst _DCRBO = \"DisassociateCapacityReservationBillingOwner\";\nconst _DCRBR = \"DescribeCapacityReservationBillingRequests\";\nconst _DCRF = \"DescribeCapacityReservationFleets\";\nconst _DCRI = \"DestinationCapacityReservationId\";\nconst _DCRe = \"DestinationCapacityReservation\";\nconst _DCT = \"DescribeConversionTasks\";\nconst _DCVAR = \"DescribeClientVpnAuthorizationRules\";\nconst _DCVC = \"DescribeClientVpnConnections\";\nconst _DCVE = \"DeleteClientVpnEndpoint\";\nconst _DCVEe = \"DescribeClientVpnEndpoints\";\nconst _DCVR = \"DeleteClientVpnRoute\";\nconst _DCVRe = \"DescribeClientVpnRoutes\";\nconst _DCVTN = \"DescribeClientVpnTargetNetworks\";\nconst _DCVTNi = \"DisassociateClientVpnTargetNetwork\";\nconst _DCe = \"DestinationCidr\";\nconst _DCef = \"DefaultCores\";\nconst _DCh = \"DhcpConfigurations\";\nconst _DCi = \"DiskContainers\";\nconst _DCis = \"DiskContainer\";\nconst _DDO = \"DeleteDhcpOptions\";\nconst _DDOe = \"DescribeDhcpOptions\";\nconst _DDPR = \"DescribeDeclarativePoliciesReports\";\nconst _DE = \"DnsEntries\";\nconst _DECIR = \"DisassociateEnclaveCertificateIamRole\";\nconst _DEEBD = \"DisableEbsEncryptionByDefault\";\nconst _DEG = \"DescribeElasticGpus\";\nconst _DEIT = \"DescribeExportImageTasks\";\nconst _DEKI = \"DataEncryptionKeyId\";\nconst _DEOIG = \"DeleteEgressOnlyInternetGateway\";\nconst _DEOIGe = \"DescribeEgressOnlyInternetGateways\";\nconst _DEQC = \"DefaultEnaQueueCount\";\nconst _DEQCPI = \"DefaultEnaQueueCountPerInterface\";\nconst _DET = \"DescribeExportTasks\";\nconst _DEn = \"DnsEntry\";\nconst _DF = \"DeleteFleets\";\nconst _DFA = \"DefaultForAz\";\nconst _DFH = \"DescribeFleetHistory\";\nconst _DFI = \"DeleteFpgaImage\";\nconst _DFIA = \"DescribeFpgaImageAttribute\";\nconst _DFIe = \"DescribeFleetInstances\";\nconst _DFIes = \"DescribeFpgaImages\";\nconst _DFL = \"DeleteFlowLogs\";\nconst _DFLI = \"DescribeFastLaunchImages\";\nconst _DFLe = \"DescribeFlowLogs\";\nconst _DFLi = \"DisableFastLaunch\";\nconst _DFSR = \"DescribeFastSnapshotRestores\";\nconst _DFSRi = \"DisableFastSnapshotRestores\";\nconst _DFe = \"DescribeFleets\";\nconst _DH = \"DescribeHosts\";\nconst _DHI = \"DedicatedHostIds\";\nconst _DHR = \"DescribeHostReservations\";\nconst _DHRO = \"DescribeHostReservationOfferings\";\nconst _DHS = \"DedicatedHostsSupported\";\nconst _DHT = \"DnsHostnameType\";\nconst _DI = \"DeleteIpam\";\nconst _DIA = \"DescribeImageAttribute\";\nconst _DIAe = \"DescribeInstanceAttribute\";\nconst _DIB = \"DeprovisionIpamByoasn\";\nconst _DIBPA = \"DisableImageBlockPublicAccess\";\nconst _DIBe = \"DescribeIpamByoasn\";\nconst _DIBi = \"DisassociateIpamByoasn\";\nconst _DICB = \"DestinationIpv6CidrBlock\";\nconst _DICE = \"DeleteInstanceConnectEndpoint\";\nconst _DICEe = \"DescribeInstanceConnectEndpoints\";\nconst _DICS = \"DescribeInstanceCreditSpecifications\";\nconst _DID = \"DisableImageDeprecation\";\nconst _DIDP = \"DisableImageDeregistrationProtection\";\nconst _DIENA = \"DeregisterInstanceEventNotificationAttributes\";\nconst _DIENAe = \"DescribeInstanceEventNotificationAttributes\";\nconst _DIERVT = \"DeleteIpamExternalResourceVerificationToken\";\nconst _DIERVTe = \"DescribeIpamExternalResourceVerificationTokens\";\nconst _DIEW = \"DeleteInstanceEventWindow\";\nconst _DIEWe = \"DescribeInstanceEventWindows\";\nconst _DIEWi = \"DisassociateInstanceEventWindow\";\nconst _DIF = \"DescribeIdFormat\";\nconst _DIFi = \"DiskImageFormat\";\nconst _DIG = \"DeleteInternetGateway\";\nconst _DIGe = \"DescribeInternetGateways\";\nconst _DIGet = \"DetachInternetGateway\";\nconst _DIIF = \"DescribeIdentityIdFormat\";\nconst _DIIM = \"DescribeInstanceImageMetadata\";\nconst _DIIP = \"DisassociateIamInstanceProfile\";\nconst _DIIPA = \"DescribeIamInstanceProfileAssociations\";\nconst _DIIT = \"DescribeImportImageTasks\";\nconst _DIOAA = \"DisableIpamOrganizationAdminAccount\";\nconst _DIP = \"DeleteIpamPool\";\nconst _DIPC = \"DeprovisionIpamPoolCidr\";\nconst _DIPe = \"DescribeIpamPools\";\nconst _DIPes = \"DescribeIpv6Pools\";\nconst _DIRD = \"DeleteIpamResourceDiscovery\";\nconst _DIRDA = \"DescribeIpamResourceDiscoveryAssociations\";\nconst _DIRDe = \"DescribeIpamResourceDiscoveries\";\nconst _DIRDi = \"DisassociateIpamResourceDiscovery\";\nconst _DIS = \"DeleteIpamScope\";\nconst _DISI = \"DestinationIpamScopeId\";\nconst _DIST = \"DescribeImportSnapshotTasks\";\nconst _DISe = \"DescribeInstanceStatus\";\nconst _DISes = \"DescribeIpamScopes\";\nconst _DISi = \"DiskImageSize\";\nconst _DIT = \"DescribeInstanceTopology\";\nconst _DITO = \"DescribeInstanceTypeOfferings\";\nconst _DITe = \"DescribeInstanceTypes\";\nconst _DIe = \"DeregisterImage\";\nconst _DIes = \"DescribeImages\";\nconst _DIesc = \"DescribeInstances\";\nconst _DIescr = \"DescribeIpams\";\nconst _DIest = \"DestinationIp\";\nconst _DIev = \"DeviceIndex\";\nconst _DIevi = \"DeviceId\";\nconst _DIi = \"DisableImage\";\nconst _DIir = \"DirectoryId\";\nconst _DIis = \"DiskImages\";\nconst _DKP = \"DeleteKeyPair\";\nconst _DKPe = \"DescribeKeyPairs\";\nconst _DLADI = \"DisableLniAtDeviceIndex\";\nconst _DLEM = \"DeliverLogsErrorMessage\";\nconst _DLG = \"DescribeLocalGateways\";\nconst _DLGR = \"DeleteLocalGatewayRoute\";\nconst _DLGRT = \"DeleteLocalGatewayRouteTable\";\nconst _DLGRTVA = \"DeleteLocalGatewayRouteTableVpcAssociation\";\nconst _DLGRTVAe = \"DescribeLocalGatewayRouteTableVpcAssociations\";\nconst _DLGRTVIGA = \"DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociation\";\nconst _DLGRTVIGAe = \"DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations\";\nconst _DLGRTe = \"DescribeLocalGatewayRouteTables\";\nconst _DLGVI = \"DeleteLocalGatewayVirtualInterface\";\nconst _DLGVIG = \"DeleteLocalGatewayVirtualInterfaceGroup\";\nconst _DLGVIGe = \"DescribeLocalGatewayVirtualInterfaceGroups\";\nconst _DLGVIe = \"DescribeLocalGatewayVirtualInterfaces\";\nconst _DLPA = \"DeliverLogsPermissionArn\";\nconst _DLS = \"DescribeLockedSnapshots\";\nconst _DLSe = \"DeliverLogsStatus\";\nconst _DLT = \"DeleteLaunchTemplate\";\nconst _DLTV = \"DeleteLaunchTemplateVersions\";\nconst _DLTVe = \"DescribeLaunchTemplateVersions\";\nconst _DLTe = \"DescribeLaunchTemplates\";\nconst _DMA = \"DescribeMovingAddresses\";\nconst _DMGM = \"DeregisteredMulticastGroupMembers\";\nconst _DMGS = \"DeregisteredMulticastGroupSources\";\nconst _DMH = \"DescribeMacHosts\";\nconst _DMMT = \"DescribeMacModificationTasks\";\nconst _DMPL = \"DeleteManagedPrefixList\";\nconst _DMPLe = \"DescribeManagedPrefixLists\";\nconst _DN = \"DeviceName\";\nconst _DNA = \"DeleteNetworkAcl\";\nconst _DNAE = \"DeleteNetworkAclEntry\";\nconst _DNAe = \"DescribeNetworkAcls\";\nconst _DNCI = \"DefaultNetworkCardIndex\";\nconst _DNG = \"DeleteNatGateway\";\nconst _DNGA = \"DisassociateNatGatewayAddress\";\nconst _DNGe = \"DescribeNatGateways\";\nconst _DNI = \"DeleteNetworkInterface\";\nconst _DNIA = \"DeleteNetworkInsightsAnalysis\";\nconst _DNIAS = \"DeleteNetworkInsightsAccessScope\";\nconst _DNIASA = \"DeleteNetworkInsightsAccessScopeAnalysis\";\nconst _DNIASAe = \"DescribeNetworkInsightsAccessScopeAnalyses\";\nconst _DNIASe = \"DescribeNetworkInsightsAccessScopes\";\nconst _DNIAe = \"DescribeNetworkInsightsAnalyses\";\nconst _DNIAes = \"DescribeNetworkInterfaceAttribute\";\nconst _DNII = \"DeregisteredNetworkInterfaceIds\";\nconst _DNIP = \"DeleteNetworkInsightsPath\";\nconst _DNIPe = \"DeleteNetworkInterfacePermission\";\nconst _DNIPes = \"DescribeNetworkInsightsPaths\";\nconst _DNIPesc = \"DescribeNetworkInterfacePermissions\";\nconst _DNIe = \"DescribeNetworkInterfaces\";\nconst _DNIet = \"DetachNetworkInterface\";\nconst _DNn = \"DnsName\";\nconst _DNo = \"DomainName\";\nconst _DO = \"DestinationOptions\";\nconst _DOA = \"DestinationOutpostArn\";\nconst _DOI = \"DhcpOptionsId\";\nconst _DOIh = \"DhcpOptionsIds\";\nconst _DOL = \"DescribeOutpostLags\";\nconst _DOST = \"DisconnectOnSessionTimeout\";\nconst _DOT = \"DeleteOnTermination\";\nconst _DOe = \"DeviceOptions\";\nconst _DOh = \"DhcpOptions\";\nconst _DOn = \"DnsOptions\";\nconst _DP = \"DeliveryPreference\";\nconst _DPDTA = \"DPDTimeoutAction\";\nconst _DPDTS = \"DPDTimeoutSeconds\";\nconst _DPG = \"DeletePlacementGroup\";\nconst _DPGe = \"DescribePlacementGroups\";\nconst _DPIF = \"DescribePrincipalIdFormat\";\nconst _DPIP = \"DeletePublicIpv4Pool\";\nconst _DPIPC = \"DeprovisionPublicIpv4PoolCidr\";\nconst _DPIPe = \"DescribePublicIpv4Pools\";\nconst _DPL = \"DescribePrefixLists\";\nconst _DPLI = \"DestinationPrefixListId\";\nconst _DPLe = \"DestinationPrefixLists\";\nconst _DPR = \"DestinationPortRange\";\nconst _DPRT = \"DefaultPropagationRouteTable\";\nconst _DPRe = \"DestinationPortRanges\";\nconst _DPe = \"DestinationPort\";\nconst _DPer = \"DeregistrationProtection\";\nconst _DPes = \"DestinationPorts\";\nconst _DQ = \"DataQueries\";\nconst _DQRI = \"DeleteQueuedReservedInstances\";\nconst _DR = \"DeleteRoute\";\nconst _DRDAI = \"DefaultResourceDiscoveryAssociationId\";\nconst _DRDI = \"DefaultResourceDiscoveryId\";\nconst _DRI = \"DescribeReservedInstances\";\nconst _DRIL = \"DescribeReservedInstancesListings\";\nconst _DRIM = \"DescribeReservedInstancesModifications\";\nconst _DRIO = \"DescribeReservedInstancesOfferings\";\nconst _DRIT = \"DnsRecordIpType\";\nconst _DRRV = \"DeleteReplacedRootVolume\";\nconst _DRRVT = \"DescribeReplaceRootVolumeTasks\";\nconst _DRS = \"DeleteRouteServer\";\nconst _DRSE = \"DeleteRouteServerEndpoint\";\nconst _DRSEe = \"DescribeRouteServerEndpoints\";\nconst _DRSP = \"DeleteRouteServerPeer\";\nconst _DRSPe = \"DescribeRouteServerPeers\";\nconst _DRSPi = \"DisableRouteServerPropagation\";\nconst _DRSa = \"DataRetentionSupport\";\nconst _DRSe = \"DescribeRouteServers\";\nconst _DRSi = \"DisassociateRouteServer\";\nconst _DRT = \"DeleteRouteTable\";\nconst _DRTA = \"DefaultRouteTableAssociation\";\nconst _DRTP = \"DefaultRouteTablePropagation\";\nconst _DRTe = \"DescribeRouteTables\";\nconst _DRTi = \"DisassociateRouteTable\";\nconst _DRa = \"DataResponses\";\nconst _DRe = \"DescribeRegions\";\nconst _DReb = \"DebuggingRestrictions\";\nconst _DRes = \"DestinationRegion\";\nconst _DRi = \"DiscoveryRegion\";\nconst _DRr = \"DryRun\";\nconst _DRy = \"DynamicRouting\";\nconst _DS = \"DeleteSnapshot\";\nconst _DSA = \"DescribeSnapshotAttribute\";\nconst _DSBPA = \"DisableSnapshotBlockPublicAccess\";\nconst _DSCA = \"DisableSerialConsoleAccess\";\nconst _DSCB = \"DisassociateSubnetCidrBlock\";\nconst _DSCR = \"DeleteSubnetCidrReservation\";\nconst _DSCRe = \"DeletedSubnetCidrReservation\";\nconst _DSDS = \"DeleteSpotDatafeedSubscription\";\nconst _DSDSe = \"DescribeSpotDatafeedSubscription\";\nconst _DSFI = \"DescribeSpotFleetInstances\";\nconst _DSFR = \"DescribeSpotFleetRequests\";\nconst _DSFRH = \"DescribeSpotFleetRequestHistory\";\nconst _DSG = \"DeleteSecurityGroup\";\nconst _DSGR = \"DescribeSecurityGroupReferences\";\nconst _DSGRe = \"DescribeSecurityGroupRules\";\nconst _DSGV = \"DisassociateSecurityGroupVpc\";\nconst _DSGVA = \"DescribeSecurityGroupVpcAssociations\";\nconst _DSGe = \"DescribeSecurityGroups\";\nconst _DSI = \"DescribeScheduledInstances\";\nconst _DSIA = \"DescribeScheduledInstanceAvailability\";\nconst _DSIR = \"DescribeSpotInstanceRequests\";\nconst _DSIT = \"DescribeStoreImageTasks\";\nconst _DSLVI = \"DescribeServiceLinkVirtualInterfaces\";\nconst _DSPH = \"DescribeSpotPriceHistory\";\nconst _DSR = \"DeleteSnapshotResults\";\nconst _DSSG = \"DescribeStaleSecurityGroups\";\nconst _DSTS = \"DescribeSnapshotTierStatus\";\nconst _DSe = \"DeleteSubnet\";\nconst _DSel = \"DeliveryStream\";\nconst _DSeli = \"DeliveryStatus\";\nconst _DSes = \"DescribeSnapshots\";\nconst _DSesc = \"DescribeSubnets\";\nconst _DSn = \"DnsServers\";\nconst _DSns = \"DnsSupport\";\nconst _DT = \"DeleteTags\";\nconst _DTA = \"DpdTimeoutAction\";\nconst _DTCT = \"DefaultTargetCapacityType\";\nconst _DTG = \"DeleteTransitGateway\";\nconst _DTGA = \"DescribeTransitGatewayAttachments\";\nconst _DTGC = \"DeleteTransitGatewayConnect\";\nconst _DTGCP = \"DeleteTransitGatewayConnectPeer\";\nconst _DTGCPe = \"DescribeTransitGatewayConnectPeers\";\nconst _DTGCe = \"DescribeTransitGatewayConnects\";\nconst _DTGMD = \"DeleteTransitGatewayMulticastDomain\";\nconst _DTGMDe = \"DescribeTransitGatewayMulticastDomains\";\nconst _DTGMDi = \"DisassociateTransitGatewayMulticastDomain\";\nconst _DTGMGM = \"DeregisterTransitGatewayMulticastGroupMembers\";\nconst _DTGMGS = \"DeregisterTransitGatewayMulticastGroupSources\";\nconst _DTGPA = \"DeleteTransitGatewayPeeringAttachment\";\nconst _DTGPAe = \"DescribeTransitGatewayPeeringAttachments\";\nconst _DTGPLR = \"DeleteTransitGatewayPrefixListReference\";\nconst _DTGPT = \"DeleteTransitGatewayPolicyTable\";\nconst _DTGPTe = \"DescribeTransitGatewayPolicyTables\";\nconst _DTGPTi = \"DisassociateTransitGatewayPolicyTable\";\nconst _DTGR = \"DeleteTransitGatewayRoute\";\nconst _DTGRT = \"DeleteTransitGatewayRouteTable\";\nconst _DTGRTA = \"DeleteTransitGatewayRouteTableAnnouncement\";\nconst _DTGRTAe = \"DescribeTransitGatewayRouteTableAnnouncements\";\nconst _DTGRTP = \"DisableTransitGatewayRouteTablePropagation\";\nconst _DTGRTe = \"DescribeTransitGatewayRouteTables\";\nconst _DTGRTi = \"DisassociateTransitGatewayRouteTable\";\nconst _DTGVA = \"DeleteTransitGatewayVpcAttachment\";\nconst _DTGVAe = \"DescribeTransitGatewayVpcAttachments\";\nconst _DTGe = \"DescribeTransitGateways\";\nconst _DTI = \"DisassociateTrunkInterface\";\nconst _DTIA = \"DescribeTrunkInterfaceAssociations\";\nconst _DTMF = \"DeleteTrafficMirrorFilter\";\nconst _DTMFR = \"DeleteTrafficMirrorFilterRule\";\nconst _DTMFRe = \"DescribeTrafficMirrorFilterRules\";\nconst _DTMFe = \"DescribeTrafficMirrorFilters\";\nconst _DTMS = \"DeleteTrafficMirrorSession\";\nconst _DTMSe = \"DescribeTrafficMirrorSessions\";\nconst _DTMT = \"DeleteTrafficMirrorTarget\";\nconst _DTMTe = \"DescribeTrafficMirrorTargets\";\nconst _DTP = \"DeviceTrustProviders\";\nconst _DTPC = \"DefaultThreadsPerCore\";\nconst _DTPT = \"DeviceTrustProviderType\";\nconst _DTR = \"DTraceRestrictions\";\nconst _DTS = \"DpdTimeoutSeconds\";\nconst _DTe = \"DescribeTags\";\nconst _DTel = \"DeletionTime\";\nconst _DTele = \"DeleteTime\";\nconst _DTelet = \"DeletionTimestamp\";\nconst _DTep = \"DeprecationTime\";\nconst _DTi = \"DisablingTime\";\nconst _DTis = \"DisabledTime\";\nconst _DV = \"DeleteVolume\";\nconst _DVA = \"DescribeVolumeAttribute\";\nconst _DVAE = \"DeleteVerifiedAccessEndpoint\";\nconst _DVAEe = \"DescribeVerifiedAccessEndpoints\";\nconst _DVAG = \"DeleteVerifiedAccessGroup\";\nconst _DVAGe = \"DescribeVerifiedAccessGroups\";\nconst _DVAI = \"DeleteVerifiedAccessInstance\";\nconst _DVAILC = \"DescribeVerifiedAccessInstanceLoggingConfigurations\";\nconst _DVAIe = \"DescribeVerifiedAccessInstances\";\nconst _DVATP = \"DeleteVerifiedAccessTrustProvider\";\nconst _DVATPe = \"DescribeVerifiedAccessTrustProviders\";\nconst _DVATPet = \"DetachVerifiedAccessTrustProvider\";\nconst _DVAe = \"DescribeVpcAttribute\";\nconst _DVBPAE = \"DeleteVpcBlockPublicAccessExclusion\";\nconst _DVBPAEe = \"DescribeVpcBlockPublicAccessExclusions\";\nconst _DVBPAO = \"DescribeVpcBlockPublicAccessOptions\";\nconst _DVC = \"DeleteVpnConnection\";\nconst _DVCB = \"DisassociateVpcCidrBlock\";\nconst _DVCL = \"DescribeVpcClassicLink\";\nconst _DVCLDS = \"DescribeVpcClassicLinkDnsSupport\";\nconst _DVCLDSi = \"DisableVpcClassicLinkDnsSupport\";\nconst _DVCLi = \"DisableVpcClassicLink\";\nconst _DVCR = \"DeleteVpnConnectionRoute\";\nconst _DVCe = \"DescribeVpnConnections\";\nconst _DVCef = \"DefaultVCpus\";\nconst _DVD = \"DeviceValidationDomain\";\nconst _DVE = \"DeleteVpcEndpoints\";\nconst _DVEA = \"DescribeVpcEndpointAssociations\";\nconst _DVEC = \"DescribeVpcEndpointConnections\";\nconst _DVECN = \"DeleteVpcEndpointConnectionNotifications\";\nconst _DVECNe = \"DescribeVpcEndpointConnectionNotifications\";\nconst _DVES = \"DescribeVpcEndpointServices\";\nconst _DVESC = \"DeleteVpcEndpointServiceConfigurations\";\nconst _DVESCe = \"DescribeVpcEndpointServiceConfigurations\";\nconst _DVESP = \"DescribeVpcEndpointServicePermissions\";\nconst _DVEe = \"DescribeVpcEndpoints\";\nconst _DVG = \"DeleteVpnGateway\";\nconst _DVGe = \"DescribeVpnGateways\";\nconst _DVGet = \"DetachVpnGateway\";\nconst _DVM = \"DescribeVolumesModifications\";\nconst _DVN = \"DefaultVersionNumber\";\nconst _DVPC = \"DeleteVpcPeeringConnection\";\nconst _DVPCe = \"DescribeVpcPeeringConnections\";\nconst _DVRP = \"DisableVgwRoutePropagation\";\nconst _DVS = \"DescribeVolumeStatus\";\nconst _DVe = \"DeleteVpc\";\nconst _DVef = \"DefaultVersion\";\nconst _DVes = \"DescribeVolumes\";\nconst _DVesc = \"DescribeVpcs\";\nconst _DVest = \"DestinationVpc\";\nconst _DVet = \"DetachVolume\";\nconst _Da = \"Data\";\nconst _De = \"Description\";\nconst _Dea = \"Deadline\";\nconst _Des = \"Destinations\";\nconst _Det = \"Details\";\nconst _Dev = \"Device\";\nconst _Di = \"Direction\";\nconst _Dis = \"Disks\";\nconst _Do = \"Domain\";\nconst _Du = \"Duration\";\nconst _E = \"Ebs\";\nconst _EA = \"EnableAcceleration\";\nconst _EAIS = \"EnableAllowedImagesSettings\";\nconst _EANPMS = \"EnableAwsNetworkPerformanceMetricSubscription\";\nconst _EAT = \"EnableAddressTransfer\";\nconst _EAn = \"EniAddress\";\nconst _EAx = \"ExclusionsAllowed\";\nconst _EB = \"EgressBytes\";\nconst _EBV = \"ExcludeBootVolume\";\nconst _EC = \"ErrorCode\";\nconst _ECTP = \"ExcessCapacityTerminationPolicy\";\nconst _ECVCC = \"ExportClientVpnClientConfiguration\";\nconst _ECVCCRL = \"ExportClientVpnClientCertificateRevocationList\";\nconst _ECn = \"EncryptionControl\";\nconst _ECx = \"ExplanationCode\";\nconst _ED = \"EndDate\";\nconst _EDH = \"EnableDnsHostnames\";\nconst _EDP = \"EndpointDomainPrefix\";\nconst _EDR = \"EndDateRange\";\nconst _EDS = \"EnableDnsSupport\";\nconst _EDT = \"EndDateType\";\nconst _EDVI = \"ExcludeDataVolumeIds\";\nconst _EDf = \"EffectiveDate\";\nconst _EDn = \"EnableDns64\";\nconst _EDnd = \"EndpointDomain\";\nconst _EDv = \"EventDescription\";\nconst _EDx = \"ExpirationDate\";\nconst _EEA = \"EndpointEniAddress\";\nconst _EEBD = \"EbsEncryptionByDefault\";\nconst _EEEBD = \"EnableEbsEncryptionByDefault\";\nconst _EEI = \"EndpointEniId\";\nconst _EFL = \"EnableFastLaunch\";\nconst _EFR = \"EgressFilterRules\";\nconst _EFSR = \"EnableFastSnapshotRestores\";\nconst _EGA = \"ElasticGpuAssociations\";\nconst _EGAI = \"ElasticGpuAssociationId\";\nconst _EGAS = \"ElasticGpuAssociationState\";\nconst _EGAT = \"ElasticGpuAssociationTime\";\nconst _EGH = \"ElasticGpuHealth\";\nconst _EGI = \"ElasticGpuIds\";\nconst _EGIl = \"ElasticGpuId\";\nconst _EGS = \"ElasticGpuSpecifications\";\nconst _EGSl = \"ElasticGpuSpecification\";\nconst _EGSla = \"ElasticGpuSet\";\nconst _EGSlas = \"ElasticGpuState\";\nconst _EGT = \"ElasticGpuType\";\nconst _EH = \"EndHour\";\nconst _EI = \"EnableImage\";\nconst _EIA = \"ElasticInferenceAccelerators\";\nconst _EIAA = \"ElasticInferenceAcceleratorArn\";\nconst _EIAAI = \"ElasticInferenceAcceleratorAssociationId\";\nconst _EIAAS = \"ElasticInferenceAcceleratorAssociationState\";\nconst _EIAAT = \"ElasticInferenceAcceleratorAssociationTime\";\nconst _EIAAl = \"ElasticInferenceAcceleratorAssociations\";\nconst _EIBPA = \"EnableImageBlockPublicAccess\";\nconst _EID = \"EnableImageDeprecation\";\nconst _EIDP = \"EnableImageDeregistrationProtection\";\nconst _EIOAA = \"EnableIpamOrganizationAdminAccount\";\nconst _EIT = \"ExcludedInstanceTypes\";\nconst _EITI = \"ExportImageTaskIds\";\nconst _EITIx = \"ExportImageTaskId\";\nconst _EITS = \"EncryptionInTransitSupported\";\nconst _EITx = \"ExportImageTasks\";\nconst _EIb = \"EbsInfo\";\nconst _EIf = \"EfaInfo\";\nconst _EIn = \"EniId\";\nconst _EIv = \"EventInformation\";\nconst _EIve = \"EventId\";\nconst _EIx = \"ExportImage\";\nconst _EIxc = \"ExclusionId\";\nconst _EIxch = \"ExchangeId\";\nconst _EIxcl = \"ExclusionIds\";\nconst _EKKI = \"EncryptionKmsKeyId\";\nconst _ELADI = \"EnableLniAtDeviceIndex\";\nconst _ELBL = \"ElasticLoadBalancerListener\";\nconst _EM = \"ErrorMessage\";\nconst _ENAUM = \"EnableNetworkAddressUsageMetrics\";\nconst _EO = \"EbsOptimized\";\nconst _EOI = \"EbsOptimizedInfo\";\nconst _EOIG = \"EgressOnlyInternetGateway\";\nconst _EOIGI = \"EgressOnlyInternetGatewayId\";\nconst _EOIGIg = \"EgressOnlyInternetGatewayIds\";\nconst _EOIGg = \"EgressOnlyInternetGateways\";\nconst _EOS = \"EbsOptimizedSupport\";\nconst _EOn = \"EnclaveOptions\";\nconst _EP = \"ExcludePaths\";\nconst _EPG = \"EnablePrivateGua\";\nconst _EPI = \"EnablePrimaryIpv6\";\nconst _EPg = \"EgressPackets\";\nconst _EQC = \"EnaQueueCount\";\nconst _ERAOS = \"EnableReachabilityAnalyzerOrganizationSharing\";\nconst _ERNDAAAAR = \"EnableResourceNameDnsAAAARecord\";\nconst _ERNDAAAAROL = \"EnableResourceNameDnsAAAARecordOnLaunch\";\nconst _ERNDAR = \"EnableResourceNameDnsARecord\";\nconst _ERNDAROL = \"EnableResourceNameDnsARecordOnLaunch\";\nconst _ERSP = \"EnableRouteServerPropagation\";\nconst _ES = \"EphemeralStorage\";\nconst _ESBPA = \"EnableSnapshotBlockPublicAccess\";\nconst _ESCA = \"EnableSerialConsoleAccess\";\nconst _ESE = \"EnaSrdEnabled\";\nconst _ESS = \"EnaSrdSpecification\";\nconst _ESSn = \"EnaSrdSupported\";\nconst _EST = \"EventSubType\";\nconst _ESUE = \"EnaSrdUdpEnabled\";\nconst _ESUS = \"EnaSrdUdpSpecification\";\nconst _ESf = \"EfaSupported\";\nconst _ESn = \"EnaSupport\";\nconst _ESnc = \"EncryptionSupport\";\nconst _ET = \"EndpointType\";\nconst _ETGR = \"ExportTransitGatewayRoutes\";\nconst _ETGRTP = \"EnableTransitGatewayRouteTablePropagation\";\nconst _ETI = \"ExportTaskId\";\nconst _ETIx = \"ExportTaskIds\";\nconst _ETLC = \"EnableTunnelLifecycleControl\";\nconst _ETST = \"ExportToS3Task\";\nconst _ETa = \"EarliestTime\";\nconst _ETi = \"EipTags\";\nconst _ETn = \"EndTime\";\nconst _ETna = \"EnablingTime\";\nconst _ETnab = \"EnabledTime\";\nconst _ETv = \"EventType\";\nconst _ETx = \"ExpirationTime\";\nconst _ETxp = \"ExportTask\";\nconst _ETxpo = \"ExportTasks\";\nconst _EU = \"ExecutableUsers\";\nconst _EVAICC = \"ExportVerifiedAccessInstanceClientConfiguration\";\nconst _EVCL = \"EnableVpcClassicLink\";\nconst _EVCLDS = \"EnableVpcClassicLinkDnsSupport\";\nconst _EVIO = \"EnableVolumeIO\";\nconst _EVRP = \"EnableVgwRoutePropagation\";\nconst _EWD = \"EndWeekDay\";\nconst _Eg = \"Egress\";\nconst _En = \"Enabled\";\nconst _Enc = \"Encrypted\";\nconst _End = \"End\";\nconst _Endp = \"Endpoint\";\nconst _Enf = \"Enforced\";\nconst _Ent = \"Entries\";\nconst _Er = \"Error\";\nconst _Err = \"Errors\";\nconst _Ev = \"Events\";\nconst _Eve = \"Event\";\nconst _Ex = \"Explanations\";\nconst _F = \"Force\";\nconst _FA = \"FederatedAuthentication\";\nconst _FAD = \"FilterAtDestination\";\nconst _FAS = \"FilterAtSource\";\nconst _FAi = \"FirstAddress\";\nconst _FC = \"FulfilledCapacity\";\nconst _FCR = \"FleetCapacityReservations\";\nconst _FCa = \"FailureCode\";\nconst _FCi = \"FindingComponents\";\nconst _FD = \"ForceDelete\";\nconst _FDN = \"FipsDnsName\";\nconst _FE = \"FipsEnabled\";\nconst _FEQS = \"FlexibleEnaQueuesSupport\";\nconst _FF = \"FileFormat\";\nconst _FFC = \"FailedFleetCancellations\";\nconst _FFi = \"FindingsFound\";\nconst _FI = \"FleetIds\";\nconst _FIA = \"FilterInArns\";\nconst _FIAp = \"FpgaImageAttribute\";\nconst _FIGI = \"FpgaImageGlobalId\";\nconst _FII = \"FpgaImageId\";\nconst _FIIp = \"FpgaImageIds\";\nconst _FIPSE = \"FIPSEnabled\";\nconst _FIi = \"FindingId\";\nconst _FIl = \"FleetId\";\nconst _FIp = \"FpgaImages\";\nconst _FIpg = \"FpgaInfo\";\nconst _FL = \"FlowLogs\";\nconst _FLI = \"FlowLogIds\";\nconst _FLIa = \"FastLaunchImages\";\nconst _FLIl = \"FlowLogId\";\nconst _FLS = \"FlowLogStatus\";\nconst _FM = \"FailureMessage\";\nconst _FOA = \"FilterOutArns\";\nconst _FODC = \"FulfilledOnDemandCapacity\";\nconst _FP = \"FromPort\";\nconst _FPC = \"ForwardPathComponents\";\nconst _FPi = \"FilesystemProtections\";\nconst _FPix = \"FixedPrice\";\nconst _FQPD = \"FailedQueuedPurchaseDeletions\";\nconst _FR = \"FailureReason\";\nconst _FRa = \"FastRestored\";\nconst _FS = \"FleetState\";\nconst _FSR = \"FastSnapshotRestores\";\nconst _FSRSE = \"FastSnapshotRestoreStateErrors\";\nconst _FSRi = \"FirewallStatelessRule\";\nconst _FSRir = \"FirewallStatefulRule\";\nconst _FSSIB = \"FullSnapshotSizeInBytes\";\nconst _FSST = \"FirstSlotStartTime\";\nconst _FSSTR = \"FirstSlotStartTimeRange\";\nconst _FTE = \"FreeTierEligible\";\nconst _Fa = \"Fault\";\nconst _Fi = \"Filters\";\nconst _Fil = \"Filter\";\nconst _Fl = \"Fleets\";\nconst _Fo = \"Format\";\nconst _Fp = \"Fpgas\";\nconst _Fr = \"From\";\nconst _Fre = \"Frequency\";\nconst _G = \"Groups\";\nconst _GA = \"GroupArn\";\nconst _GAECIR = \"GetAssociatedEnclaveCertificateIamRoles\";\nconst _GAIPC = \"GetAssociatedIpv6PoolCidrs\";\nconst _GAIS = \"GetAllowedImagesSettings\";\nconst _GANPD = \"GetAwsNetworkPerformanceData\";\nconst _GAS = \"GatewayAssociationState\";\nconst _GAVTS = \"GetActiveVpnTunnelStatus\";\nconst _GCO = \"GetConsoleOutput\";\nconst _GCPU = \"GetCoipPoolUsage\";\nconst _GCRU = \"GetCapacityReservationUsage\";\nconst _GCS = \"GetConsoleScreenshot\";\nconst _GD = \"GroupDescription\";\nconst _GDCS = \"GetDefaultCreditSpecification\";\nconst _GDPRS = \"GetDeclarativePoliciesReportSummary\";\nconst _GEDKKI = \"GetEbsDefaultKmsKeyId\";\nconst _GEEBD = \"GetEbsEncryptionByDefault\";\nconst _GFLIT = \"GetFlowLogsIntegrationTemplate\";\nconst _GGFCR = \"GetGroupsForCapacityReservation\";\nconst _GHRPP = \"GetHostReservationPurchasePreview\";\nconst _GI = \"GatewayId\";\nconst _GIA = \"GroupIpAddress\";\nconst _GIAH = \"GetIpamAddressHistory\";\nconst _GIBPAS = \"GetImageBlockPublicAccessState\";\nconst _GIDA = \"GetIpamDiscoveredAccounts\";\nconst _GIDPA = \"GetIpamDiscoveredPublicAddresses\";\nconst _GIDRC = \"GetIpamDiscoveredResourceCidrs\";\nconst _GIMD = \"GetInstanceMetadataDefaults\";\nconst _GIPA = \"GetIpamPoolAllocations\";\nconst _GIPC = \"GetIpamPoolCidrs\";\nconst _GIRC = \"GetIpamResourceCidrs\";\nconst _GITEP = \"GetInstanceTpmEkPub\";\nconst _GITFIR = \"GetInstanceTypesFromInstanceRequirements\";\nconst _GIUD = \"GetInstanceUefiData\";\nconst _GIp = \"GpuInfo\";\nconst _GIr = \"GroupId\";\nconst _GIro = \"GroupIds\";\nconst _GK = \"GreKey\";\nconst _GLBA = \"GatewayLoadBalancerArns\";\nconst _GLBEI = \"GatewayLoadBalancerEndpointId\";\nconst _GLN = \"GroupLongName\";\nconst _GLTD = \"GetLaunchTemplateData\";\nconst _GM = \"GroupMember\";\nconst _GMPLA = \"GetManagedPrefixListAssociations\";\nconst _GMPLE = \"GetManagedPrefixListEntries\";\nconst _GN = \"GroupName\";\nconst _GNIASAF = \"GetNetworkInsightsAccessScopeAnalysisFindings\";\nconst _GNIASC = \"GetNetworkInsightsAccessScopeContent\";\nconst _GNr = \"GroupNames\";\nconst _GOI = \"GroupOwnerId\";\nconst _GPD = \"GetPasswordData\";\nconst _GRIEQ = \"GetReservedInstancesExchangeQuote\";\nconst _GRSA = \"GetRouteServerAssociations\";\nconst _GRSP = \"GetRouteServerPropagations\";\nconst _GRSRD = \"GetRouteServerRoutingDatabase\";\nconst _GS = \"GroupSource\";\nconst _GSBPAS = \"GetSnapshotBlockPublicAccessState\";\nconst _GSCAS = \"GetSerialConsoleAccessStatus\";\nconst _GSCR = \"GetSubnetCidrReservations\";\nconst _GSGFV = \"GetSecurityGroupsForVpc\";\nconst _GSPS = \"GetSpotPlacementScores\";\nconst _GTGAP = \"GetTransitGatewayAttachmentPropagations\";\nconst _GTGMDA = \"GetTransitGatewayMulticastDomainAssociations\";\nconst _GTGPLR = \"GetTransitGatewayPrefixListReferences\";\nconst _GTGPTA = \"GetTransitGatewayPolicyTableAssociations\";\nconst _GTGPTE = \"GetTransitGatewayPolicyTableEntries\";\nconst _GTGRTA = \"GetTransitGatewayRouteTableAssociations\";\nconst _GTGRTP = \"GetTransitGatewayRouteTablePropagations\";\nconst _GVAEP = \"GetVerifiedAccessEndpointPolicy\";\nconst _GVAET = \"GetVerifiedAccessEndpointTargets\";\nconst _GVAGP = \"GetVerifiedAccessGroupPolicy\";\nconst _GVCDSC = \"GetVpnConnectionDeviceSampleConfiguration\";\nconst _GVCDT = \"GetVpnConnectionDeviceTypes\";\nconst _GVTRS = \"GetVpnTunnelReplacementStatus\";\nconst _Gp = \"Gpus\";\nconst _Gr = \"Group\";\nconst _H = \"Hypervisor\";\nconst _HCP = \"HiveCompatiblePartitions\";\nconst _HE = \"HttpEndpoint\";\nconst _HI = \"HostIds\";\nconst _HIS = \"HostIdSet\";\nconst _HIo = \"HostId\";\nconst _HM = \"HostMaintenance\";\nconst _HO = \"HibernationOptions\";\nconst _HP = \"HostProperties\";\nconst _HPI = \"HttpProtocolIpv6\";\nconst _HPRHL = \"HttpPutResponseHopLimit\";\nconst _HPo = \"HourlyPrice\";\nconst _HR = \"HostRecovery\";\nconst _HRGA = \"HostResourceGroupArn\";\nconst _HRI = \"HostReservationId\";\nconst _HRIS = \"HostReservationIdSet\";\nconst _HRS = \"HostReservationSet\";\nconst _HRi = \"HistoryRecords\";\nconst _HS = \"HibernationSupported\";\nconst _HT = \"HttpTokens\";\nconst _HTo = \"HostnameType\";\nconst _HZI = \"HostedZoneId\";\nconst _Hi = \"Hibernate\";\nconst _Ho = \"Hosts\";\nconst _I = \"Issuer\";\nconst _IA = \"Ipv6Addresses\";\nconst _IAA = \"Ipv6AddressAttribute\";\nconst _IAC = \"Ipv6AddressCount\";\nconst _IAI = \"IncludeAllInstances\";\nconst _IAIn = \"InferenceAcceleratorInfo\";\nconst _IAPI = \"Ipv4AddressesPerInterface\";\nconst _IAPIp = \"Ipv6AddressesPerInterface\";\nconst _IAT = \"IpAddressType\";\nconst _IATOI = \"IncludeAllTagsOfInstance\";\nconst _IAm = \"ImageAllowed\";\nconst _IAn = \"InterfaceAssociation\";\nconst _IAnt = \"InterfaceAssociations\";\nconst _IAp = \"IpAddress\";\nconst _IApa = \"IpamArn\";\nconst _IApv = \"Ipv6Address\";\nconst _IB = \"IngressBytes\";\nconst _IBPAS = \"ImageBlockPublicAccessState\";\nconst _IC = \"InstanceCount\";\nconst _ICA = \"Ipv6CidrAssociations\";\nconst _ICB = \"Ipv6CidrBlock\";\nconst _ICBA = \"Ipv6CidrBlockAssociation\";\nconst _ICBAS = \"Ipv6CidrBlockAssociationSet\";\nconst _ICBNBG = \"Ipv6CidrBlockNetworkBorderGroup\";\nconst _ICBS = \"Ipv6CidrBlockState\";\nconst _ICBSp = \"Ipv6CidrBlockSet\";\nconst _ICBn = \"InsideCidrBlocks\";\nconst _ICE = \"InstanceConnectEndpoint\";\nconst _ICEA = \"InstanceConnectEndpointArn\";\nconst _ICEI = \"InstanceConnectEndpointId\";\nconst _ICEIn = \"InstanceConnectEndpointIds\";\nconst _ICEn = \"InstanceConnectEndpoints\";\nconst _ICS = \"InstanceCreditSpecifications\";\nconst _ICVCCRL = \"ImportClientVpnClientCertificateRevocationList\";\nconst _ICm = \"ImageCriteria\";\nconst _ICn = \"InstanceCounts\";\nconst _ICp = \"Ipv6Cidr\";\nconst _ID = \"IncludeDeprecated\";\nconst _IDA = \"IpamDiscoveredAccounts\";\nconst _IDPA = \"IpamDiscoveredPublicAddresses\";\nconst _IDRC = \"IpamDiscoveredResourceCidrs\";\nconst _IDm = \"ImageData\";\nconst _IDn = \"IncludeDisabled\";\nconst _IDs = \"IsDefault\";\nconst _IE = \"IsEgress\";\nconst _IED = \"InstanceExportDetails\";\nconst _IEI = \"InstanceEventId\";\nconst _IERVT = \"IpamExternalResourceVerificationToken\";\nconst _IERVTA = \"IpamExternalResourceVerificationTokenArn\";\nconst _IERVTI = \"IpamExternalResourceVerificationTokenId\";\nconst _IERVTIp = \"IpamExternalResourceVerificationTokenIds\";\nconst _IERVTp = \"IpamExternalResourceVerificationTokens\";\nconst _IEW = \"InstanceEventWindow\";\nconst _IEWI = \"InstanceEventWindowId\";\nconst _IEWIn = \"InstanceEventWindowIds\";\nconst _IEWS = \"InstanceEventWindowState\";\nconst _IEWn = \"InstanceEventWindows\";\nconst _IF = \"InstanceFamily\";\nconst _IFCS = \"InstanceFamilyCreditSpecification\";\nconst _IFR = \"IamFleetRole\";\nconst _IFRn = \"IngressFilterRules\";\nconst _IG = \"InstanceGenerations\";\nconst _IGBM = \"InternetGatewayBlockMode\";\nconst _IGEM = \"InternetGatewayExclusionMode\";\nconst _IGI = \"InternetGatewayId\";\nconst _IGIn = \"InternetGatewayIds\";\nconst _IGn = \"InternetGateway\";\nconst _IGnt = \"InternetGateways\";\nconst _IH = \"InstanceHealth\";\nconst _IHn = \"InboundHeader\";\nconst _II = \"ImportImage\";\nconst _IIB = \"InstanceInterruptionBehavior\";\nconst _IIM = \"InstanceImageMetadata\";\nconst _IIP = \"IamInstanceProfile\";\nconst _IIPA = \"IamInstanceProfileAssociation\";\nconst _IIPAa = \"IamInstanceProfileAssociations\";\nconst _IIPI = \"Ipv6IpamPoolId\";\nconst _IIPIp = \"Ipv4IpamPoolId\";\nconst _IIS = \"InstanceIdSet\";\nconst _IISB = \"InstanceInitiatedShutdownBehavior\";\nconst _IIT = \"ImportImageTasks\";\nconst _IIm = \"ImportInstance\";\nconst _IIma = \"ImageId\";\nconst _IImag = \"ImageIds\";\nconst _IIn = \"InstanceId\";\nconst _IIns = \"InstanceIds\";\nconst _IIp = \"IpamId\";\nconst _IIpa = \"IpamIds\";\nconst _IKEV = \"InternetKeyExchangeVersion\";\nconst _IKEVe = \"IKEVersions\";\nconst _IKP = \"ImportKeyPair\";\nconst _IL = \"ImageLocation\";\nconst _ILn = \"InstanceLifecycle\";\nconst _IM = \"IncludeMarketplace\";\nconst _IMC = \"InstanceMatchCriteria\";\nconst _IMO = \"InstanceMarketOptions\";\nconst _IMOn = \"InstanceMetadataOptions\";\nconst _IMT = \"InstanceMetadataTags\";\nconst _IMU = \"ImportManifestUrl\";\nconst _IMm = \"ImageMetadata\";\nconst _IMn = \"InstanceMonitorings\";\nconst _IN = \"Ipv6Native\";\nconst _INL = \"Ipv6NetmaskLength\";\nconst _INLp = \"Ipv4NetmaskLength\";\nconst _IOA = \"ImageOwnerAlias\";\nconst _IOI = \"IpOwnerId\";\nconst _IOIn = \"InstanceOwnerId\";\nconst _IOS = \"InstanceOwningService\";\nconst _IP = \"Ipv6Prefixes\";\nconst _IPA = \"IpamPoolAllocation\";\nconst _IPAI = \"IpamPoolAllocationId\";\nconst _IPAp = \"IpamPoolAllocations\";\nconst _IPApa = \"IpamPoolArn\";\nconst _IPC = \"Ipv6PrefixCount\";\nconst _IPCI = \"IpamPoolCidrId\";\nconst _IPCp = \"Ipv4PrefixCount\";\nconst _IPCpa = \"IpamPoolCidr\";\nconst _IPCpam = \"IpamPoolCidrs\";\nconst _IPE = \"IpPermissionsEgress\";\nconst _IPI = \"IpamPoolId\";\nconst _IPIp = \"IpamPoolIds\";\nconst _IPIs = \"IsPrimaryIpv6\";\nconst _IPK = \"IncludePublicKey\";\nconst _IPO = \"IpamPoolOwner\";\nconst _IPR = \"IsPermanentRestore\";\nconst _IPTUC = \"InstancePoolsToUseCount\";\nconst _IPm = \"ImageProviders\";\nconst _IPn = \"InstancePlatform\";\nconst _IPng = \"IngressPackets\";\nconst _IPns = \"InstancePort\";\nconst _IPnt = \"InterfacePermission\";\nconst _IPnte = \"InterfaceProtocol\";\nconst _IPo = \"IoPerformance\";\nconst _IPp = \"Ipv4Prefixes\";\nconst _IPpa = \"IpamPool\";\nconst _IPpam = \"IpamPools\";\nconst _IPpe = \"IpPermissions\";\nconst _IPpr = \"IpProtocol\";\nconst _IPpre = \"IpPrefixes\";\nconst _IPpv = \"Ipv6Pool\";\nconst _IPpvo = \"Ipv6Pools\";\nconst _IPpvr = \"Ipv4Prefix\";\nconst _IPpvre = \"Ipv6Prefix\";\nconst _IPs = \"IsPublic\";\nconst _IPsr = \"IsPrimary\";\nconst _IR = \"InstanceRequirements\";\nconst _IRC = \"IpamResourceCidrs\";\nconst _IRCp = \"IpamResourceCidr\";\nconst _IRD = \"IpamResourceDiscovery\";\nconst _IRDA = \"IpamResourceDiscoveryAssociation\";\nconst _IRDAA = \"IpamResourceDiscoveryAssociationArn\";\nconst _IRDAI = \"IpamResourceDiscoveryAssociationIds\";\nconst _IRDAIp = \"IpamResourceDiscoveryAssociationId\";\nconst _IRDAp = \"IpamResourceDiscoveryAssociations\";\nconst _IRDApa = \"IpamResourceDiscoveryArn\";\nconst _IRDI = \"IpamResourceDiscoveryId\";\nconst _IRDIp = \"IpamResourceDiscoveryIds\";\nconst _IRDR = \"IpamResourceDiscoveryRegion\";\nconst _IRDp = \"IpamResourceDiscoveries\";\nconst _IRSDA = \"IntegrationResultS3DestinationArn\";\nconst _IRT = \"IngressRouteTable\";\nconst _IRWM = \"InstanceRequirementsWithMetadata\";\nconst _IRp = \"IpRanges\";\nconst _IRpa = \"IpamRegion\";\nconst _IRpv = \"Ipv6Ranges\";\nconst _IS = \"ImportSnapshot\";\nconst _ISA = \"IpamScopeArn\";\nconst _ISI = \"IpamScopeId\";\nconst _ISIn = \"InstanceStorageInfo\";\nconst _ISIp = \"IpamScopeIds\";\nconst _ISL = \"InputStorageLocation\";\nconst _ISS = \"InstanceStorageSupported\";\nconst _IST = \"ImportSnapshotTasks\";\nconst _ISTp = \"IpamScopeType\";\nconst _ISg = \"Igmpv2Support\";\nconst _ISm = \"ImdsSupport\";\nconst _ISmp = \"ImpairedSince\";\nconst _ISn = \"InstanceSpecification\";\nconst _ISns = \"InstanceStatuses\";\nconst _ISnst = \"InstanceState\";\nconst _ISnsta = \"InstanceStatus\";\nconst _ISnt = \"IntegrateServices\";\nconst _ISp = \"Ipv6Support\";\nconst _ISpa = \"IpamScope\";\nconst _ISpam = \"IpamScopes\";\nconst _ISpo = \"IpSource\";\nconst _ISpv = \"Ipv6Supported\";\nconst _IT = \"InstanceType\";\nconst _ITA = \"InstanceTagAttribute\";\nconst _ITC = \"IcmpTypeCode\";\nconst _ITCn = \"IncludeTrustContext\";\nconst _ITI = \"ImportTaskId\";\nconst _ITIm = \"ImportTaskIds\";\nconst _ITK = \"InstanceTagKeys\";\nconst _ITO = \"InstanceTypeOfferings\";\nconst _ITS = \"InstanceTypeSpecifications\";\nconst _ITm = \"ImageType\";\nconst _ITn = \"InterfaceType\";\nconst _ITns = \"InstanceTenancy\";\nconst _ITnst = \"InstanceTypes\";\nconst _ITnsta = \"InstanceTags\";\nconst _IU = \"InstanceUsages\";\nconst _IUp = \"IpUsage\";\nconst _IV = \"ImportVolume\";\nconst _IVE = \"IsValidExchange\";\nconst _IVk = \"IkeVersion\";\nconst _IVke = \"IkeVersions\";\nconst _Id = \"Id\";\nconst _Im = \"Image\";\nconst _Ima = \"Images\";\nconst _In = \"Instances\";\nconst _Ins = \"Instance\";\nconst _Int = \"Interval\";\nconst _Io = \"Iops\";\nconst _Ip = \"Ipv4\";\nconst _Ipa = \"Ipam\";\nconst _Ipam = \"Ipams\";\nconst _Ipv = \"Ipv6\";\nconst _K = \"Kernel\";\nconst _KDF = \"KinesisDataFirehose\";\nconst _KF = \"KeyFormat\";\nconst _KFe = \"KeyFingerprint\";\nconst _KI = \"KernelId\";\nconst _KKA = \"KmsKeyArn\";\nconst _KKI = \"KmsKeyId\";\nconst _KM = \"KeyMaterial\";\nconst _KN = \"KeyName\";\nconst _KNe = \"KeyNames\";\nconst _KP = \"KeyPairs\";\nconst _KPI = \"KeyPairId\";\nconst _KPIe = \"KeyPairIds\";\nconst _KS = \"KextSigning\";\nconst _KT = \"KeyType\";\nconst _KV = \"KeyValue\";\nconst _Ke = \"Key\";\nconst _Key = \"Keyword\";\nconst _L = \"Locale\";\nconst _LA = \"LocalAddress\";\nconst _LADT = \"LastAttemptedDiscoveryTime\";\nconst _LAZ = \"LaunchedAvailabilityZone\";\nconst _LAa = \"LastAddress\";\nconst _LB = \"LoadBalancers\";\nconst _LBA = \"LocalBgpAsn\";\nconst _LBAE = \"LocalBgpAsnExtended\";\nconst _LBAo = \"LoadBalancerArn\";\nconst _LBC = \"LoadBalancersConfig\";\nconst _LBLP = \"LoadBalancerListenerPort\";\nconst _LBO = \"LoadBalancerOptions\";\nconst _LBP = \"LoadBalancerPort\";\nconst _LBT = \"LoadBalancerTarget\";\nconst _LBTG = \"LoadBalancerTargetGroup\";\nconst _LBTGo = \"LoadBalancerTargetGroups\";\nconst _LBTP = \"LoadBalancerTargetPort\";\nconst _LC = \"LoggingConfigurations\";\nconst _LCA = \"LicenseConfigurationArn\";\nconst _LCO = \"LockCreatedOn\";\nconst _LCo = \"LoggingConfiguration\";\nconst _LD = \"LogDestination\";\nconst _LDST = \"LockDurationStartTime\";\nconst _LDT = \"LogDestinationType\";\nconst _LDo = \"LockDuration\";\nconst _LE = \"LogEnabled\";\nconst _LEO = \"LockExpiresOn\";\nconst _LET = \"LastEvaluatedTime\";\nconst _LEa = \"LastError\";\nconst _LF = \"LogFormat\";\nconst _LFA = \"LambdaFunctionArn\";\nconst _LG = \"LaunchGroup\";\nconst _LGA = \"LogGroupArn\";\nconst _LGI = \"LocalGatewayId\";\nconst _LGIo = \"LocalGatewayIds\";\nconst _LGN = \"LogGroupName\";\nconst _LGRT = \"LocalGatewayRouteTable\";\nconst _LGRTA = \"LocalGatewayRouteTableArn\";\nconst _LGRTI = \"LocalGatewayRouteTableId\";\nconst _LGRTIo = \"LocalGatewayRouteTableIds\";\nconst _LGRTVA = \"LocalGatewayRouteTableVpcAssociation\";\nconst _LGRTVAI = \"LocalGatewayRouteTableVpcAssociationId\";\nconst _LGRTVAIo = \"LocalGatewayRouteTableVpcAssociationIds\";\nconst _LGRTVAo = \"LocalGatewayRouteTableVpcAssociations\";\nconst _LGRTVIGA = \"LocalGatewayRouteTableVirtualInterfaceGroupAssociation\";\nconst _LGRTVIGAI = \"LocalGatewayRouteTableVirtualInterfaceGroupAssociationId\";\nconst _LGRTVIGAIo = \"LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds\";\nconst _LGRTVIGAo = \"LocalGatewayRouteTableVirtualInterfaceGroupAssociations\";\nconst _LGRTo = \"LocalGatewayRouteTables\";\nconst _LGVI = \"LocalGatewayVirtualInterface\";\nconst _LGVIA = \"LocalGatewayVirtualInterfaceArn\";\nconst _LGVIG = \"LocalGatewayVirtualInterfaceGroup\";\nconst _LGVIGA = \"LocalGatewayVirtualInterfaceGroupArn\";\nconst _LGVIGI = \"LocalGatewayVirtualInterfaceGroupId\";\nconst _LGVIGIo = \"LocalGatewayVirtualInterfaceGroupIds\";\nconst _LGVIGo = \"LocalGatewayVirtualInterfaceGroups\";\nconst _LGVII = \"LocalGatewayVirtualInterfaceId\";\nconst _LGVIIo = \"LocalGatewayVirtualInterfaceIds\";\nconst _LGVIo = \"LocalGatewayVirtualInterfaces\";\nconst _LGo = \"LogGroup\";\nconst _LGoc = \"LocalGateways\";\nconst _LIIRB = \"ListImagesInRecycleBin\";\nconst _LINC = \"LocalIpv4NetworkCidr\";\nconst _LINCo = \"LocalIpv6NetworkCidr\";\nconst _LLT = \"LastLaunchedTime\";\nconst _LM = \"LockMode\";\nconst _LMA = \"LastMaintenanceApplied\";\nconst _LO = \"LogOptions\";\nconst _LOF = \"LogOutputFormat\";\nconst _LP = \"LoadPermission\";\nconst _LPa = \"LaunchPermission\";\nconst _LPau = \"LaunchPermissions\";\nconst _LPi = \"LimitPrice\";\nconst _LPo = \"LoadPermissions\";\nconst _LS = \"LockSnapshot\";\nconst _LSC = \"LastStatusChange\";\nconst _LSDT = \"LastSuccessfulDiscoveryTime\";\nconst _LSIRB = \"ListSnapshotsInRecycleBin\";\nconst _LSL = \"LogsStorageLocation\";\nconst _LST = \"LocalStorageTypes\";\nconst _LSa = \"LaunchSpecification\";\nconst _LSau = \"LaunchSpecifications\";\nconst _LSi = \"LicenseSpecifications\";\nconst _LSo = \"LocalStorage\";\nconst _LSoc = \"LockState\";\nconst _LT = \"LocationType\";\nconst _LTAO = \"LaunchTemplateAndOverrides\";\nconst _LTC = \"LaunchTemplateConfigs\";\nconst _LTD = \"LaunchTemplateData\";\nconst _LTI = \"LaunchTemplateId\";\nconst _LTIa = \"LaunchTemplateIds\";\nconst _LTN = \"LaunchTemplateName\";\nconst _LTNa = \"LaunchTemplateNames\";\nconst _LTOS = \"LastTieringOperationStatus\";\nconst _LTOSD = \"LastTieringOperationStatusDetail\";\nconst _LTP = \"LastTieringProgress\";\nconst _LTS = \"LaunchTemplateSpecification\";\nconst _LTST = \"LastTieringStartTime\";\nconst _LTV = \"LaunchTemplateVersion\";\nconst _LTVa = \"LaunchTemplateVersions\";\nconst _LTa = \"LaunchTemplate\";\nconst _LTat = \"LatestTime\";\nconst _LTau = \"LaunchTemplates\";\nconst _LTaun = \"LaunchTime\";\nconst _LTi = \"LicenseType\";\nconst _LTo = \"LocalTarget\";\nconst _LUT = \"LastUpdateTime\";\nconst _LUTa = \"LastUpdatedTime\";\nconst _LUTas = \"LastUpdateTimestamp\";\nconst _LV = \"LogVersion\";\nconst _LVN = \"LatestVersionNumber\";\nconst _La = \"Latest\";\nconst _Li = \"Lifecycle\";\nconst _Lic = \"Licenses\";\nconst _Lo = \"Location\";\nconst _M = \"Min\";\nconst _MA = \"MutualAuthentication\";\nconst _MAA = \"ModifyAddressAttribute\";\nconst _MAAA = \"MaintenanceAutoAppliedAfter\";\nconst _MAE = \"MultiAttachEnabled\";\nconst _MAI = \"MaxAggregationInterval\";\nconst _MAIe = \"MediaAcceleratorInfo\";\nconst _MAS = \"MovingAddressStatuses\";\nconst _MATV = \"MoveAddressToVpc\";\nconst _MAZG = \"ModifyAvailabilityZoneGroup\";\nconst _MAa = \"MacAddress\";\nconst _MAe = \"MeteredAccount\";\nconst _MB = \"ManagedBy\";\nconst _MBCTI = \"MoveByoipCidrToIpam\";\nconst _MBIM = \"MaximumBandwidthInMbps\";\nconst _MC = \"MacCredentials\";\nconst _MCOIOL = \"MapCustomerOwnedIpOnLaunch\";\nconst _MCR = \"ModifyCapacityReservation\";\nconst _MCRF = \"ModifyCapacityReservationFleet\";\nconst _MCRI = \"MoveCapacityReservationInstances\";\nconst _MCVE = \"ModifyClientVpnEndpoint\";\nconst _MCa = \"MaxCount\";\nconst _MCi = \"MinCount\";\nconst _MCis = \"MissingComponent\";\nconst _MD = \"MaxDuration\";\nconst _MDA = \"MulticastDomainAssociations\";\nconst _MDCS = \"ModifyDefaultCreditSpecification\";\nconst _MDDS = \"MaxDrainDurationSeconds\";\nconst _MDK = \"MetaDataKey\";\nconst _MDV = \"MetaDataValue\";\nconst _MDa = \"MaintenanceDetails\";\nconst _MDe = \"MetaData\";\nconst _MDi = \"MinDuration\";\nconst _ME = \"MaxEntries\";\nconst _MEDKKI = \"ModifyEbsDefaultKmsKeyId\";\nconst _MEI = \"MaximumEfaInterfaces\";\nconst _MEM = \"ManagedExceptionMessage\";\nconst _MEQC = \"MaximumEnaQueueCount\";\nconst _MEQCPI = \"MaximumEnaQueueCountPerInterface\";\nconst _MF = \"ModifyFleet\";\nconst _MFIA = \"ModifyFpgaImageAttribute\";\nconst _MFV = \"MostFrequentValue\";\nconst _MG = \"MulticastGroups\";\nconst _MGBPVC = \"MemoryGiBPerVCpu\";\nconst _MH = \"ModifyHosts\";\nconst _MHa = \"MacHosts\";\nconst _MI = \"ModifyIpam\";\nconst _MIA = \"ModifyImageAttribute\";\nconst _MIAo = \"ModifyInstanceAttribute\";\nconst _MIC = \"MaxInstanceCount\";\nconst _MICO = \"ModifyInstanceCpuOptions\";\nconst _MICRA = \"ModifyInstanceCapacityReservationAttributes\";\nconst _MICS = \"ModifyInstanceCreditSpecification\";\nconst _MIEST = \"ModifyInstanceEventStartTime\";\nconst _MIEW = \"ModifyInstanceEventWindow\";\nconst _MIF = \"ModifyIdFormat\";\nconst _MIIF = \"ModifyIdentityIdFormat\";\nconst _MIMD = \"ModifyInstanceMetadataDefaults\";\nconst _MIMO = \"ModifyInstanceMaintenanceOptions\";\nconst _MIMOo = \"ModifyInstanceMetadataOptions\";\nconst _MINPO = \"ModifyInstanceNetworkPerformanceOptions\";\nconst _MIP = \"ModifyInstancePlacement\";\nconst _MIPo = \"ModifyIpamPool\";\nconst _MIRC = \"ModifyIpamResourceCidr\";\nconst _MIRD = \"ModifyIpamResourceDiscovery\";\nconst _MIS = \"ModifyIpamScope\";\nconst _MIa = \"MaximumIops\";\nconst _MIe = \"MemoryInfo\";\nconst _MIo = \"MonitorInstances\";\nconst _MLGR = \"ModifyLocalGatewayRoute\";\nconst _MLT = \"ModifyLaunchTemplate\";\nconst _MMB = \"MemoryMiB\";\nconst _MMPL = \"ModifyManagedPrefixList\";\nconst _MMT = \"MacModificationTask\";\nconst _MMTI = \"MacModificationTaskIds\";\nconst _MMTIa = \"MacModificationTaskId\";\nconst _MMTa = \"MacModificationTasks\";\nconst _MNC = \"MaximumNetworkCards\";\nconst _MNI = \"MaximumNetworkInterfaces\";\nconst _MNIA = \"ModifyNetworkInterfaceAttribute\";\nconst _MO = \"MetadataOptions\";\nconst _MOSLRG = \"MemberOfServiceLinkedResourceGroup\";\nconst _MOSLSV = \"MacOSLatestSupportedVersions\";\nconst _MOa = \"MaintenanceOptions\";\nconst _MP = \"MatchPaths\";\nconst _MPDNO = \"ModifyPrivateDnsNameOptions\";\nconst _MPIDNO = \"ModifyPublicIpDnsNameOptions\";\nconst _MPIOL = \"MapPublicIpOnLaunch\";\nconst _MPL = \"MaxParallelLaunches\";\nconst _MPa = \"MaxPrice\";\nconst _MPe = \"MetricPoints\";\nconst _MR = \"MaxResults\";\nconst _MRI = \"ModifyReservedInstances\";\nconst _MRS = \"ModifyRouteServer\";\nconst _MRo = \"ModificationResults\";\nconst _MRu = \"MultiRegion\";\nconst _MS = \"MaintenanceStrategies\";\nconst _MSA = \"ModifySnapshotAttribute\";\nconst _MSAo = \"ModifySubnetAttribute\";\nconst _MSDIH = \"MaxSlotDurationInHours\";\nconst _MSDIHi = \"MinSlotDurationInHours\";\nconst _MSFR = \"ModifySpotFleetRequest\";\nconst _MSGR = \"ModifySecurityGroupRules\";\nconst _MSIPC = \"MacSystemIntegrityProtectionConfiguration\";\nconst _MSIPCa = \"MacSystemIntegrityProtectionConfig\";\nconst _MSIPS = \"MacSystemIntegrityProtectionStatus\";\nconst _MSPAPOOODP = \"MaxSpotPriceAsPercentageOfOptimalOnDemandPrice\";\nconst _MST = \"ModifySnapshotTier\";\nconst _MSa = \"ManagementState\";\nconst _MSo = \"MoveStatus\";\nconst _MSod = \"ModificationState\";\nconst _MSu = \"MulticastSupport\";\nconst _MT = \"MarketType\";\nconst _MTC = \"MinTargetCapacity\";\nconst _MTDID = \"MaxTermDurationInDays\";\nconst _MTDIDi = \"MinTermDurationInDays\";\nconst _MTG = \"ModifyTransitGateway\";\nconst _MTGPLR = \"ModifyTransitGatewayPrefixListReference\";\nconst _MTGVA = \"ModifyTransitGatewayVpcAttachment\";\nconst _MTIMB = \"MaximumThroughputInMBps\";\nconst _MTMFNS = \"ModifyTrafficMirrorFilterNetworkServices\";\nconst _MTMFR = \"ModifyTrafficMirrorFilterRule\";\nconst _MTMS = \"ModifyTrafficMirrorSession\";\nconst _MTP = \"MaxTotalPrice\";\nconst _MTe = \"MemberType\";\nconst _MV = \"ModifyVolume\";\nconst _MVA = \"ModifyVolumeAttribute\";\nconst _MVAE = \"ModifyVerifiedAccessEndpoint\";\nconst _MVAEP = \"ModifyVerifiedAccessEndpointPolicy\";\nconst _MVAG = \"ModifyVerifiedAccessGroup\";\nconst _MVAGP = \"ModifyVerifiedAccessGroupPolicy\";\nconst _MVAI = \"ModifyVerifiedAccessInstance\";\nconst _MVAILC = \"ModifyVerifiedAccessInstanceLoggingConfiguration\";\nconst _MVATP = \"ModifyVerifiedAccessTrustProvider\";\nconst _MVAo = \"ModifyVpcAttribute\";\nconst _MVBPAE = \"ModifyVpcBlockPublicAccessExclusion\";\nconst _MVBPAO = \"ModifyVpcBlockPublicAccessOptions\";\nconst _MVC = \"ModifyVpnConnection\";\nconst _MVCO = \"ModifyVpnConnectionOptions\";\nconst _MVE = \"ModifyVpcEndpoint\";\nconst _MVECN = \"ModifyVpcEndpointConnectionNotification\";\nconst _MVESC = \"ModifyVpcEndpointServiceConfiguration\";\nconst _MVESP = \"ModifyVpcEndpointServicePermissions\";\nconst _MVESPR = \"ModifyVpcEndpointServicePayerResponsibility\";\nconst _MVEa = \"ManagesVpcEndpoints\";\nconst _MVPCO = \"ModifyVpcPeeringConnectionOptions\";\nconst _MVT = \"ModifyVpcTenancy\";\nconst _MVTC = \"ModifyVpnTunnelCertificate\";\nconst _MVTO = \"ModifyVpnTunnelOptions\";\nconst _MVa = \"MaxVersion\";\nconst _MVi = \"MinVersion\";\nconst _Ma = \"Max\";\nconst _Mai = \"Main\";\nconst _Man = \"Manufacturer\";\nconst _Mana = \"Managed\";\nconst _Mar = \"Marketplace\";\nconst _Me = \"Message\";\nconst _Med = \"Med\";\nconst _Mes = \"Messages\";\nconst _Met = \"Metric\";\nconst _Mo = \"Mode\";\nconst _Mon = \"Monitoring\";\nconst _Moni = \"Monitored\";\nconst _N = \"Name\";\nconst _NA = \"NetworkAcl\";\nconst _NAAI = \"NetworkAclAssociationId\";\nconst _NAI = \"NetworkAclId\";\nconst _NAIe = \"NetworkAclIds\";\nconst _NAIew = \"NewAssociationId\";\nconst _NAOO = \"NativeApplicationOidcOptions\";\nconst _NAe = \"NetworkAcls\";\nconst _NAo = \"NotAfter\";\nconst _NB = \"NotBefore\";\nconst _NBD = \"NotBeforeDeadline\";\nconst _NBG = \"NetworkBorderGroup\";\nconst _NBGe = \"NetworkBandwidthGbps\";\nconst _NC = \"NetworkCards\";\nconst _NCI = \"NetworkCardIndex\";\nconst _ND = \"NoDevice\";\nconst _NDe = \"NeuronDevices\";\nconst _NES = \"NitroEnclavesSupport\";\nconst _NG = \"NatGateway\";\nconst _NGA = \"NatGatewayAddresses\";\nconst _NGI = \"NatGatewayId\";\nconst _NGIa = \"NatGatewayIds\";\nconst _NGa = \"NatGateways\";\nconst _NHI = \"NextHopIp\";\nconst _NI = \"NetworkInterfaces\";\nconst _NIA = \"NetworkInsightsAnalyses\";\nconst _NIAA = \"NetworkInsightsAnalysisArn\";\nconst _NIAI = \"NetworkInsightsAnalysisId\";\nconst _NIAIe = \"NetworkInsightsAnalysisIds\";\nconst _NIAS = \"NetworkInsightsAccessScope\";\nconst _NIASA = \"NetworkInsightsAccessScopeAnalyses\";\nconst _NIASAA = \"NetworkInsightsAccessScopeAnalysisArn\";\nconst _NIASAI = \"NetworkInsightsAccessScopeAnalysisId\";\nconst _NIASAIe = \"NetworkInsightsAccessScopeAnalysisIds\";\nconst _NIASAe = \"NetworkInsightsAccessScopeArn\";\nconst _NIASAet = \"NetworkInsightsAccessScopeAnalysis\";\nconst _NIASC = \"NetworkInsightsAccessScopeContent\";\nconst _NIASI = \"NetworkInsightsAccessScopeId\";\nconst _NIASIe = \"NetworkInsightsAccessScopeIds\";\nconst _NIASe = \"NetworkInsightsAccessScopes\";\nconst _NIASet = \"NetworkInterfaceAttachmentStatus\";\nconst _NIAe = \"NetworkInsightsAnalysis\";\nconst _NIC = \"NetworkInterfaceCount\";\nconst _NID = \"NetworkInterfaceDescription\";\nconst _NII = \"NetworkInterfaceId\";\nconst _NIIe = \"NetworkInterfaceIds\";\nconst _NIO = \"NetworkInterfaceOptions\";\nconst _NIOI = \"NetworkInterfaceOwnerId\";\nconst _NIP = \"NetworkInsightsPath\";\nconst _NIPA = \"NetworkInsightsPathArn\";\nconst _NIPI = \"NetworkInsightsPathId\";\nconst _NIPIe = \"NetworkInterfacePermissionId\";\nconst _NIPIet = \"NetworkInsightsPathIds\";\nconst _NIPIetw = \"NetworkInterfacePermissionIds\";\nconst _NIPe = \"NetworkInsightsPaths\";\nconst _NIPet = \"NetworkInterfacePermissions\";\nconst _NIe = \"NetworkId\";\nconst _NIet = \"NetworkInterface\";\nconst _NIetw = \"NetworkInfo\";\nconst _NIeu = \"NeuronInfo\";\nconst _NL = \"NetmaskLength\";\nconst _NLBA = \"NetworkLoadBalancerArn\";\nconst _NLBAe = \"NetworkLoadBalancerArns\";\nconst _NN = \"NetworkNodes\";\nconst _NOA = \"NumberOfAccounts\";\nconst _NOFA = \"NumberOfFailedAccounts\";\nconst _NOMA = \"NumberOfMatchedAccounts\";\nconst _NOUA = \"NumberOfUnmatchedAccounts\";\nconst _NP = \"NvramProtections\";\nconst _NPF = \"NetworkPathFound\";\nconst _NPO = \"NetworkPerformanceOptions\";\nconst _NPe = \"NetworkPerformance\";\nconst _NPet = \"NetworkPlatform\";\nconst _NR = \"NoReboot\";\nconst _NS = \"NvmeSupport\";\nconst _NSST = \"NextSlotStartTime\";\nconst _NSe = \"NetworkServices\";\nconst _NT = \"NextToken\";\nconst _NTI = \"NitroTpmInfo\";\nconst _NTS = \"NitroTpmSupport\";\nconst _NTe = \"NetworkType\";\nconst _Na = \"Nameservers\";\nconst _O = \"Operator\";\nconst _OA = \"OutpostArn\";\nconst _OAr = \"OrganizationArn\";\nconst _OArg = \"OrganizationArns\";\nconst _OAw = \"OwnerAlias\";\nconst _OC = \"OfferingClass\";\nconst _OD = \"OccurrenceDays\";\nconst _ODAS = \"OnDemandAllocationStrategy\";\nconst _ODFC = \"OnDemandFulfilledCapacity\";\nconst _ODMPPOLP = \"OnDemandMaxPricePercentageOverLowestPrice\";\nconst _ODMTP = \"OnDemandMaxTotalPrice\";\nconst _ODO = \"OnDemandOptions\";\nconst _ODS = \"OccurrenceDaySet\";\nconst _ODTC = \"OnDemandTargetCapacity\";\nconst _OEP = \"OrganizationsEntityPath\";\nconst _OH = \"OutboundHeader\";\nconst _OI = \"OfferingId\";\nconst _OIA = \"OutsideIpAddress\";\nconst _OIAT = \"OutsideIpAddressType\";\nconst _OIS = \"OptInStatus\";\nconst _OIr = \"OriginalIops\";\nconst _OIu = \"OutpostId\";\nconst _OIw = \"OwnerIds\";\nconst _OIwn = \"OwnerId\";\nconst _OK = \"ObjectKey\";\nconst _OL = \"OutpostLags\";\nconst _OLI = \"OutpostLagId\";\nconst _OLIu = \"OutpostLagIds\";\nconst _OMAE = \"OriginalMultiAttachEnabled\";\nconst _OO = \"OidcOptions\";\nconst _OR = \"OperatingRegions\";\nconst _ORIWEA = \"OutputReservedInstancesWillExpireAt\";\nconst _ORTE = \"OccurrenceRelativeToEnd\";\nconst _OS = \"OfferingSet\";\nconst _OST = \"OldestSampleTime\";\nconst _OSr = \"OriginalSize\";\nconst _OSv = \"OverlapStatus\";\nconst _OT = \"OfferingType\";\nconst _OTp = \"OperationType\";\nconst _OTpt = \"OptimizingTime\";\nconst _OTr = \"OriginalThroughput\";\nconst _OU = \"OccurrenceUnit\";\nconst _OUA = \"OrganizationalUnitArn\";\nconst _OUAr = \"OrganizationalUnitArns\";\nconst _OUE = \"OrganizationalUnitExclusions\";\nconst _OUI = \"OrganizationalUnitId\";\nconst _OVC = \"OpenVpnConfigurations\";\nconst _OVT = \"OriginalVolumeType\";\nconst _Op = \"Options\";\nconst _Or = \"Origin\";\nconst _Ou = \"Output\";\nconst _Ov = \"Overrides\";\nconst _Ow = \"Owners\";\nconst _Own = \"Owner\";\nconst _P = \"Protocol\";\nconst _PA = \"PubliclyAdvertisable\";\nconst _PAI = \"PeerAccountId\";\nconst _PAIe = \"PeeringAttachmentId\";\nconst _PAR = \"PoolAddressRange\";\nconst _PARo = \"PoolAddressRanges\";\nconst _PAe = \"PeerAddress\";\nconst _PAee = \"PeerAsn\";\nconst _PAo = \"PoolArn\";\nconst _PAr = \"PrincipalArn\";\nconst _PB = \"ProvisionedBandwidth\";\nconst _PBA = \"PeerBgpAsn\";\nconst _PBAE = \"PeerBgpAsnExtended\";\nconst _PBC = \"ProvisionByoipCidr\";\nconst _PBIG = \"PeakBandwidthInGbps\";\nconst _PC = \"ProductCode\";\nconst _PCB = \"PurchaseCapacityBlock\";\nconst _PCBE = \"PurchaseCapacityBlockExtension\";\nconst _PCBo = \"PoolCidrBlocks\";\nconst _PCI = \"PreserveClientIp\";\nconst _PCIr = \"ProductCodeId\";\nconst _PCNI = \"PeerCoreNetworkId\";\nconst _PCS = \"PostureComplianceStatuses\";\nconst _PCT = \"ProductCodeType\";\nconst _PCa = \"PartitionCount\";\nconst _PCo = \"PoolCidrs\";\nconst _PCoo = \"PoolCount\";\nconst _PCr = \"ProductCodes\";\nconst _PD = \"PolicyDocument\";\nconst _PDE = \"PrivateDnsEnabled\";\nconst _PDEr = \"PrivateDnsEntry\";\nconst _PDHG = \"Phase1DHGroup\";\nconst _PDHGN = \"Phase1DHGroupNumbers\";\nconst _PDHGNh = \"Phase2DHGroupNumbers\";\nconst _PDHGh = \"Phase2DHGroup\";\nconst _PDHT = \"PrivateDnsHostnameType\";\nconst _PDHTOL = \"PrivateDnsHostnameTypeOnLaunch\";\nconst _PDN = \"PrivateDnsName\";\nconst _PDNC = \"PrivateDnsNameConfiguration\";\nconst _PDNO = \"PrivateDnsNameOptions\";\nconst _PDNOOL = \"PrivateDnsNameOptionsOnLaunch\";\nconst _PDNVS = \"PrivateDnsNameVerificationState\";\nconst _PDNr = \"PrivateDnsNames\";\nconst _PDNu = \"PublicDnsName\";\nconst _PDOFIRE = \"PrivateDnsOnlyForInboundResolverEndpoint\";\nconst _PDRTI = \"PropagationDefaultRouteTableId\";\nconst _PDSDN = \"PublicDualStackDnsName\";\nconst _PDSI = \"PublicDefaultScopeId\";\nconst _PDSIr = \"PrivateDefaultScopeId\";\nconst _PDa = \"PasswordData\";\nconst _PDay = \"PaymentDue\";\nconst _PDl = \"PlatformDetails\";\nconst _PDo = \"PoolDepth\";\nconst _PDr = \"ProductDescription\";\nconst _PDri = \"PricingDetails\";\nconst _PDro = \"ProductDescriptions\";\nconst _PE = \"PolicyEnabled\";\nconst _PEA = \"Phase1EncryptionAlgorithms\";\nconst _PEAh = \"Phase2EncryptionAlgorithms\";\nconst _PEAha = \"Phase1EncryptionAlgorithm\";\nconst _PEAhas = \"Phase2EncryptionAlgorithm\";\nconst _PED = \"PartitionEndDate\";\nconst _PEk = \"PkceEnabled\";\nconst _PF = \"PacketField\";\nconst _PFS = \"PreviousFleetState\";\nconst _PG = \"PlacementGroup\";\nconst _PGA = \"PlacementGroupArn\";\nconst _PGI = \"PlacementGroupInfo\";\nconst _PGl = \"PlacementGroups\";\nconst _PHP = \"PerHourPartition\";\nconst _PHR = \"PurchaseHostReservation\";\nconst _PHS = \"PacketHeaderStatement\";\nconst _PI = \"PublicIp\";\nconst _PIA = \"PrivateIpAddresses\";\nconst _PIAC = \"PrivateIpAddressCount\";\nconst _PIACr = \"PrivateIpAddressConfigs\";\nconst _PIAh = \"Phase1IntegrityAlgorithms\";\nconst _PIAha = \"Phase2IntegrityAlgorithms\";\nconst _PIAhas = \"Phase1IntegrityAlgorithm\";\nconst _PIAhase = \"Phase2IntegrityAlgorithm\";\nconst _PIAr = \"PrivateIpAddress\";\nconst _PIAu = \"PublicIpAddress\";\nconst _PIB = \"ProvisionIpamByoasn\";\nconst _PIDN = \"PublicIpv6DnsName\";\nconst _PIDNO = \"PublicIpDnsNameOptions\";\nconst _PIDNu = \"PublicIpv4DnsName\";\nconst _PIP = \"PublicIpv4Pool\";\nconst _PIPC = \"ProvisionIpamPoolCidr\";\nconst _PIPI = \"PublicIpv4PoolId\";\nconst _PIPu = \"PublicIpv4Pools\";\nconst _PIS = \"PublicIpSource\";\nconst _PIc = \"PciId\";\nconst _PIo = \"PoolId\";\nconst _PIoo = \"PoolIds\";\nconst _PIr = \"PrimaryIpv6\";\nconst _PIri = \"PrivateIp\";\nconst _PIro = \"ProcessorInfo\";\nconst _PIu = \"PublicIps\";\nconst _PK = \"PublicKey\";\nconst _PKM = \"PublicKeyMaterial\";\nconst _PL = \"PacketLength\";\nconst _PLA = \"PrefixListAssociations\";\nconst _PLAr = \"PrefixListArn\";\nconst _PLD = \"PeerLivenessDetection\";\nconst _PLF = \"PartitionLoadFrequency\";\nconst _PLI = \"PrefixListId\";\nconst _PLIr = \"PrefixListIds\";\nconst _PLN = \"PrefixListName\";\nconst _PLOI = \"PrefixListOwnerId\";\nconst _PLS = \"Phase1LifetimeSeconds\";\nconst _PLSh = \"Phase2LifetimeSeconds\";\nconst _PLr = \"PrefixList\";\nconst _PLre = \"PrefixLists\";\nconst _PM = \"PendingMaintenance\";\nconst _PN = \"PartitionNumber\";\nconst _PNC = \"PreviewNextCidr\";\nconst _PO = \"PaymentOption\";\nconst _POI = \"PeerOwnerId\";\nconst _POe = \"PeeringOptions\";\nconst _PP = \"ProgressPercentage\";\nconst _PPIPC = \"ProvisionPublicIpv4PoolCidr\";\nconst _PR = \"PortRange\";\nconst _PRD = \"PersistRoutesDuration\";\nconst _PRIO = \"PurchaseReservedInstancesOffering\";\nconst _PRN = \"PolicyReferenceName\";\nconst _PRNo = \"PolicyRuleNumber\";\nconst _PRS = \"PersistRoutesState\";\nconst _PRU = \"PtrRecordUpdate\";\nconst _PRa = \"PayerResponsibility\";\nconst _PRe = \"PersistRoutes\";\nconst _PRee = \"PeerRegion\";\nconst _PRer = \"PermanentRestore\";\nconst _PRo = \"PortRanges\";\nconst _PRol = \"PolicyRule\";\nconst _PRt = \"PtrRecord\";\nconst _PRu = \"PurchaseRequests\";\nconst _PS = \"PriceSchedules\";\nconst _PSD = \"PartitionStartDate\";\nconst _PSET = \"PreviousSlotEndTime\";\nconst _PSFRS = \"PreviousSpotFleetRequestState\";\nconst _PSI = \"PurchaseScheduledInstances\";\nconst _PSK = \"PreSharedKey\";\nconst _PSKA = \"PreSharedKeyArn\";\nconst _PSKE = \"PublicSigningKeyEndpoint\";\nconst _PSKS = \"PreSharedKeyStorage\";\nconst _PSKU = \"PublicSigningKeyUrl\";\nconst _PSR = \"ProvisioningStatusReason\";\nconst _PSe = \"PeeringStatus\";\nconst _PSer = \"PermissionState\";\nconst _PSh = \"PhcSupport\";\nconst _PSr = \"ProvisioningStatus\";\nconst _PSre = \"PreviousState\";\nconst _PSrev = \"PreviousStatus\";\nconst _PT = \"PurchaseToken\";\nconst _PTGI = \"PeerTransitGatewayId\";\nconst _PTS = \"PoolTagSpecifications\";\nconst _PTr = \"PrincipalType\";\nconst _PTro = \"ProvisionTime\";\nconst _PTu = \"PurchaseTime\";\nconst _PU = \"PresignedUrl\";\nconst _PV = \"PreviousVersion\";\nconst _PVI = \"PeerVpcId\";\nconst _PVIr = \"PrimaryVpcId\";\nconst _PVr = \"PropagatingVgws\";\nconst _PZI = \"ParentZoneId\";\nconst _PZN = \"ParentZoneName\";\nconst _Pe = \"Permission\";\nconst _Per = \"Period\";\nconst _Pl = \"Placement\";\nconst _Pla = \"Platform\";\nconst _Po = \"Port\";\nconst _Pr = \"Prefix\";\nconst _Pri = \"Priority\";\nconst _Pric = \"Price\";\nconst _Prim = \"Primary\";\nconst _Prin = \"Principal\";\nconst _Princ = \"Principals\";\nconst _Pro = \"Protocols\";\nconst _Prog = \"Progress\";\nconst _Prop = \"Propagation\";\nconst _Prov = \"Provisioned\";\nconst _Pu = \"Public\";\nconst _Pur = \"Purchase\";\nconst _Q = \"Quantity\";\nconst _R = \"References\";\nconst _RA = \"ReleaseAddress\";\nconst _RAA = \"ResetAddressAttribute\";\nconst _RAE = \"RemoteAccessEnabled\";\nconst _RAG = \"RevokeAllGroups\";\nconst _RAP = \"RemoveAllowedPrincipals\";\nconst _RART = \"RemoveAllocationResourceTags\";\nconst _RATC = \"RestoreAddressToClassic\";\nconst _RAe = \"ResolveAlias\";\nconst _RAes = \"ResourceArn\";\nconst _RAo = \"RoleArn\";\nconst _RAu = \"RuleAction\";\nconst _RB = \"RequestedBy\";\nconst _RBET = \"RecycleBinEnterTime\";\nconst _RBETe = \"RecycleBinExitTime\";\nconst _RBUI = \"RestorableByUserIds\";\nconst _RC = \"ResourceCidr\";\nconst _RCA = \"ResourceConfigurationArn\";\nconst _RCGA = \"ResourceConfigurationGroupArn\";\nconst _RCRBO = \"RejectCapacityReservationBillingOwnership\";\nconst _RCS = \"ResourceComplianceStatus\";\nconst _RCVI = \"RevokeClientVpnIngress\";\nconst _RCe = \"ReasonCodes\";\nconst _RCec = \"RecurringCharges\";\nconst _RCet = \"ReturnCode\";\nconst _RD = \"RestoreDuration\";\nconst _RDAC = \"ResourceDiscoveryAssociationCount\";\nconst _RDCA = \"RdsDbClusterArn\";\nconst _RDI = \"RamDiskId\";\nconst _RDIA = \"RdsDbInstanceArn\";\nconst _RDN = \"RootDeviceName\";\nconst _RDPA = \"RdsDbProxyArn\";\nconst _RDS = \"ResourceDiscoveryStatus\";\nconst _RDT = \"RootDeviceType\";\nconst _RE = \"RdsEndpoint\";\nconst _RED = \"RemoveEndDate\";\nconst _REDKKI = \"ResetEbsDefaultKmsKeyId\";\nconst _RET = \"RestoreExpiryTime\";\nconst _REe = \"RemoveEntries\";\nconst _REes = \"ResponseError\";\nconst _REeso = \"ResourceExclusions\";\nconst _RF = \"RemoveFields\";\nconst _RFIA = \"ResetFpgaImageAttribute\";\nconst _RFP = \"RekeyFuzzPercentage\";\nconst _RGA = \"RuleGroupArn\";\nconst _RGI = \"ReferencedGroupId\";\nconst _RGIe = \"ReferencedGroupInfo\";\nconst _RGLBA = \"RemoveGatewayLoadBalancerArns\";\nconst _RGROP = \"RuleGroupRuleOptionsPairs\";\nconst _RGT = \"RuleGroupType\";\nconst _RGTP = \"RuleGroupTypePairs\";\nconst _RH = \"ReleaseHosts\";\nconst _RHS = \"RequireHibernateSupport\";\nconst _RI = \"RebootInstances\";\nconst _RIA = \"ResetImageAttribute\";\nconst _RIAe = \"ResetInstanceAttribute\";\nconst _RICIAIS = \"ReplaceImageCriteriaInAllowedImagesSettings\";\nconst _RID = \"RouteInstallationDetails\";\nconst _RIENA = \"RegisterInstanceEventNotificationAttributes\";\nconst _RIFRB = \"RestoreImageFromRecycleBin\";\nconst _RII = \"ReservedInstanceIds\";\nconst _RIIPA = \"ReplaceIamInstanceProfileAssociation\";\nconst _RIIe = \"ReservedInstancesId\";\nconst _RIIes = \"ReservedInstancesIds\";\nconst _RIIese = \"ReservedInstanceId\";\nconst _RIL = \"ReservedInstancesListings\";\nconst _RILI = \"ReservedInstancesListingId\";\nconst _RIM = \"ReservedInstancesModifications\";\nconst _RIMI = \"ReservedInstancesModificationIds\";\nconst _RIMIe = \"ReservedInstancesModificationId\";\nconst _RINC = \"RemoteIpv4NetworkCidr\";\nconst _RINCe = \"RemoteIpv6NetworkCidr\";\nconst _RIO = \"ReservedInstancesOfferings\";\nconst _RIOI = \"ReservedInstancesOfferingIds\";\nconst _RIOIe = \"ReservedInstancesOfferingId\";\nconst _RIPA = \"ReleaseIpamPoolAllocation\";\nconst _RIS = \"ReportInstanceStatus\";\nconst _RISR = \"RouteInstallationStatusReason\";\nconst _RISo = \"RouteInstallationStatus\";\nconst _RIVR = \"ReservedInstanceValueRollup\";\nconst _RIVS = \"ReservedInstanceValueSet\";\nconst _RIa = \"RamdiskId\";\nconst _RIe = \"RegisterImage\";\nconst _RIep = \"ReportId\";\nconst _RIepo = \"ReportIds\";\nconst _RIeq = \"RequesterId\";\nconst _RIes = \"ResourceIds\";\nconst _RIese = \"ReservedInstances\";\nconst _RIeser = \"ReservationId\";\nconst _RIeso = \"ResourceId\";\nconst _RIu = \"RunInstances\";\nconst _RM = \"ReasonMessage\";\nconst _RMGM = \"RegisteredMulticastGroupMembers\";\nconst _RMGS = \"RegisteredMulticastGroupSources\";\nconst _RMPLV = \"RestoreManagedPrefixListVersion\";\nconst _RMS = \"RebootMigrationSupport\";\nconst _RMTS = \"RekeyMarginTimeSeconds\";\nconst _RMe = \"RebootMigration\";\nconst _RMeq = \"RequesterManaged\";\nconst _RN = \"RegionName\";\nconst _RNAA = \"ReplaceNetworkAclAssociation\";\nconst _RNAE = \"ReplaceNetworkAclEntry\";\nconst _RNIA = \"ResetNetworkInterfaceAttribute\";\nconst _RNII = \"RegisteredNetworkInterfaceIds\";\nconst _RNLBA = \"RemoveNetworkLoadBalancerArns\";\nconst _RNS = \"RemoveNetworkServices\";\nconst _RNe = \"RegionNames\";\nconst _RNes = \"ResourceName\";\nconst _RNo = \"RoleName\";\nconst _RNu = \"RuleNumber\";\nconst _RO = \"RdsOptions\";\nconst _ROI = \"ResourceOwnerId\";\nconst _ROR = \"RemoveOperatingRegions\";\nconst _ROS = \"ResourceOverlapStatus\";\nconst _ROUE = \"RemoveOrganizationalUnitExclusions\";\nconst _ROe = \"ResourceOwner\";\nconst _ROo = \"RouteOrigin\";\nconst _ROu = \"RuleOptions\";\nconst _RP = \"ResetPolicy\";\nconst _RPC = \"ReturnPathComponents\";\nconst _RPCO = \"RequesterPeeringConnectionOptions\";\nconst _RPDN = \"RemovePrivateDnsName\";\nconst _RR = \"ReplaceRoute\";\nconst _RRTA = \"ReplaceRouteTableAssociation\";\nconst _RRTI = \"RemoveRouteTableIds\";\nconst _RRVT = \"ReplaceRootVolumeTask\";\nconst _RRVTI = \"ReplaceRootVolumeTaskIds\";\nconst _RRVTIe = \"ReplaceRootVolumeTaskId\";\nconst _RRVTe = \"ReplaceRootVolumeTasks\";\nconst _RRe = \"ResourceRegion\";\nconst _RS = \"ReplacementStrategy\";\nconst _RSA = \"ResetSnapshotAttribute\";\nconst _RSAo = \"RouteServerAssociation\";\nconst _RSAou = \"RouteServerAssociations\";\nconst _RSE = \"RouteServerEndpoint\";\nconst _RSEI = \"RouteServerEndpointId\";\nconst _RSEIo = \"RouteServerEndpointIds\";\nconst _RSEo = \"RouteServerEndpoints\";\nconst _RSF = \"RequestSpotFleet\";\nconst _RSFRB = \"RestoreSnapshotFromRecycleBin\";\nconst _RSGE = \"RevokeSecurityGroupEgress\";\nconst _RSGI = \"RevokeSecurityGroupIngress\";\nconst _RSGIe = \"RemoveSecurityGroupIds\";\nconst _RSGR = \"RevokedSecurityGroupRules\";\nconst _RSI = \"RequestSpotInstances\";\nconst _RSIAT = \"RemoveSupportedIpAddressTypes\";\nconst _RSIe = \"RemoveSubnetIds\";\nconst _RSIo = \"RouteServerId\";\nconst _RSIou = \"RouteServerIds\";\nconst _RSIu = \"RunScheduledInstances\";\nconst _RSP = \"RouteServerPeer\";\nconst _RSPI = \"RouteServerPeerId\";\nconst _RSPIo = \"RouteServerPeerIds\";\nconst _RSPo = \"RouteServerPeers\";\nconst _RSPou = \"RouteServerPropagation\";\nconst _RSPout = \"RouteServerPropagations\";\nconst _RSR = \"RemoveSupportedRegions\";\nconst _RST = \"RestoreSnapshotTier\";\nconst _RSTe = \"RestoreStartTime\";\nconst _RSe = \"ResourceStatement\";\nconst _RSeg = \"RegionalSummaries\";\nconst _RSo = \"RouteServer\";\nconst _RSou = \"RouteServers\";\nconst _RSout = \"RouteStatus\";\nconst _RT = \"ResourceType\";\nconst _RTAI = \"RouteTableAssociationId\";\nconst _RTGCB = \"RemoveTransitGatewayCidrBlocks\";\nconst _RTGMDA = \"RejectTransitGatewayMulticastDomainAssociations\";\nconst _RTGMGM = \"RegisterTransitGatewayMulticastGroupMembers\";\nconst _RTGMGS = \"RegisterTransitGatewayMulticastGroupSources\";\nconst _RTGPA = \"RejectTransitGatewayPeeringAttachment\";\nconst _RTGR = \"ReplaceTransitGatewayRoute\";\nconst _RTGVA = \"RejectTransitGatewayVpcAttachment\";\nconst _RTI = \"RouteTableId\";\nconst _RTIe = \"RequesterTgwInfo\";\nconst _RTIo = \"RouteTableIds\";\nconst _RTR = \"RouteTableRoute\";\nconst _RTV = \"RemainingTotalValue\";\nconst _RTe = \"ReservationType\";\nconst _RTel = \"ReleaseTime\";\nconst _RTeq = \"RequestTime\";\nconst _RTes = \"ResourceTag\";\nconst _RTeso = \"ResourceTypes\";\nconst _RTesou = \"ResourceTags\";\nconst _RTo = \"RouteTable\";\nconst _RTou = \"RouteTables\";\nconst _RUI = \"ReplaceUnhealthyInstances\";\nconst _RUV = \"RemainingUpfrontValue\";\nconst _RV = \"ReturnValue\";\nconst _RVEC = \"RejectVpcEndpointConnections\";\nconst _RVI = \"ReferencingVpcId\";\nconst _RVIe = \"RequesterVpcInfo\";\nconst _RVPC = \"RejectVpcPeeringConnection\";\nconst _RVT = \"ReplaceVpnTunnel\";\nconst _RVe = \"ReservationValue\";\nconst _RWS = \"ReplayWindowSize\";\nconst _Ra = \"Ramdisk\";\nconst _Re = \"Resources\";\nconst _Rea = \"Reason\";\nconst _Rec = \"Recurrence\";\nconst _Reg = \"Regions\";\nconst _Regi = \"Region\";\nconst _Rem = \"Remove\";\nconst _Rep = \"Reports\";\nconst _Req = \"Requested\";\nconst _Res = \"Resource\";\nconst _Rese = \"Reservations\";\nconst _Resu = \"Result\";\nconst _Ret = \"Return\";\nconst _Ro = \"Role\";\nconst _Rou = \"Route\";\nconst _Rout = \"Routes\";\nconst _S = \"Source\";\nconst _SA = \"StartupAction\";\nconst _SAI = \"SecondaryAllocationIds\";\nconst _SAMLPA = \"SAMLProviderArn\";\nconst _SAZ = \"SingleAvailabilityZone\";\nconst _SAo = \"SourceAddresses\";\nconst _SAou = \"SourceAddress\";\nconst _SAour = \"SourceArn\";\nconst _SAu = \"SuggestedAccounts\";\nconst _SAub = \"SubnetArn\";\nconst _SAup = \"SupportedArchitectures\";\nconst _SB = \"S3Bucket\";\nconst _SBM = \"SupportedBootModes\";\nconst _SC = \"SubnetConfigurations\";\nconst _SCA = \"ServerCertificateArn\";\nconst _SCAE = \"SerialConsoleAccessEnabled\";\nconst _SCB = \"SourceCidrBlock\";\nconst _SCCDM = \"SnapshotCopyCompletionDurationMinutes\";\nconst _SCR = \"SourceCapacityReservation\";\nconst _SCRI = \"SourceCapacityReservationId\";\nconst _SCRIu = \"SubnetCidrReservationId\";\nconst _SCRu = \"SubnetCidrReservation\";\nconst _SCSIG = \"SustainedClockSpeedInGhz\";\nconst _SCc = \"ScopeCount\";\nconst _SCe = \"ServiceConfiguration\";\nconst _SCer = \"ServiceConfigurations\";\nconst _SCn = \"SnapshotConfiguration\";\nconst _SD = \"StartDate\";\nconst _SDC = \"SourceDestCheck\";\nconst _SDI = \"SendDiagnosticInterrupt\";\nconst _SDIH = \"SlotDurationInHours\";\nconst _SDLTV = \"SuccessfullyDeletedLaunchTemplateVersions\";\nconst _SDPR = \"StartDeclarativePoliciesReport\";\nconst _SDR = \"StartDateRange\";\nconst _SDS = \"SpotDatafeedSubscription\";\nconst _SDV = \"SetDefaultVersion\";\nconst _SDe = \"ServiceDetails\";\nconst _SDn = \"SnapshotDetails\";\nconst _SDp = \"SpreadDomain\";\nconst _SDu = \"SubDomain\";\nconst _SEL = \"S3ExportLocation\";\nconst _SET = \"SampledEndTime\";\nconst _SF = \"SupportedFeatures\";\nconst _SFC = \"SuccessfulFleetCancellations\";\nconst _SFD = \"SuccessfulFleetDeletions\";\nconst _SFII = \"SourceFpgaImageId\";\nconst _SFR = \"SuccessfulFleetRequests\";\nconst _SFRC = \"SpotFleetRequestConfig\";\nconst _SFRCp = \"SpotFleetRequestConfigs\";\nconst _SFRI = \"SpotFleetRequestIds\";\nconst _SFRIp = \"SpotFleetRequestId\";\nconst _SFRS = \"SpotFleetRequestState\";\nconst _SG = \"SecurityGroups\";\nconst _SGA = \"SecurityGroupArn\";\nconst _SGFV = \"SecurityGroupForVpcs\";\nconst _SGI = \"SecurityGroupIds\";\nconst _SGIe = \"SecurityGroupId\";\nconst _SGR = \"SecurityGroupRules\";\nconst _SGRA = \"SecurityGroupRuleArn\";\nconst _SGRD = \"SecurityGroupRuleDescriptions\";\nconst _SGRI = \"SecurityGroupRuleIds\";\nconst _SGRIe = \"SecurityGroupRuleId\";\nconst _SGRS = \"SecurityGroupReferencingSupport\";\nconst _SGRSe = \"SecurityGroupReferenceSet\";\nconst _SGRe = \"SecurityGroupRule\";\nconst _SGVA = \"SecurityGroupVpcAssociations\";\nconst _SGe = \"SecurityGroup\";\nconst _SH = \"StartHour\";\nconst _SI = \"StartInstances\";\nconst _SIAS = \"ScheduledInstanceAvailabilitySet\";\nconst _SIAT = \"SupportedIpAddressTypes\";\nconst _SICR = \"SubnetIpv4CidrReservations\";\nconst _SICRu = \"SubnetIpv6CidrReservations\";\nconst _SICS = \"SuccessfulInstanceCreditSpecifications\";\nconst _SIGB = \"SizeInGB\";\nconst _SII = \"SourceImageId\";\nconst _SIIc = \"ScheduledInstanceIds\";\nconst _SIIch = \"ScheduledInstanceId\";\nconst _SIIo = \"SourceInstanceId\";\nconst _SIMB = \"SizeInMiB\";\nconst _SIP = \"StaleIpPermissions\";\nconst _SIPE = \"StaleIpPermissionsEgress\";\nconst _SIPI = \"SourceIpamPoolId\";\nconst _SIR = \"SpotInstanceRequests\";\nconst _SIRI = \"SpotInstanceRequestIds\";\nconst _SIRIp = \"SpotInstanceRequestId\";\nconst _SIRo = \"SourceImageRegion\";\nconst _SIS = \"ScheduledInstanceSet\";\nconst _SIT = \"SpotInstanceType\";\nconst _SITR = \"StoreImageTaskResults\";\nconst _SITi = \"SingleInstanceType\";\nconst _SIe = \"ServiceId\";\nconst _SIer = \"ServiceIds\";\nconst _SIn = \"SnapshotId\";\nconst _SIna = \"SnapshotIds\";\nconst _SIo = \"SourceIp\";\nconst _SIt = \"StopInstances\";\nconst _SIta = \"StartingInstances\";\nconst _SIto = \"StoppingInstances\";\nconst _SIu = \"SubnetIds\";\nconst _SIub = \"SubnetId\";\nconst _SIubs = \"SubsystemId\";\nconst _SK = \"S3Key\";\nconst _SKo = \"S3objectKey\";\nconst _SL = \"SpreadLevel\";\nconst _SLGR = \"SearchLocalGatewayRoutes\";\nconst _SLVI = \"ServiceLinkVirtualInterfaces\";\nconst _SLVIA = \"ServiceLinkVirtualInterfaceArn\";\nconst _SLVII = \"ServiceLinkVirtualInterfaceIds\";\nconst _SLVIIe = \"ServiceLinkVirtualInterfaceId\";\nconst _SLo = \"S3Location\";\nconst _SM = \"ServiceManaged\";\nconst _SMPPOLP = \"SpotMaxPricePercentageOverLowestPrice\";\nconst _SMS = \"SpotMaintenanceStrategies\";\nconst _SMTP = \"SpotMaxTotalPrice\";\nconst _SMt = \"StatusMessage\";\nconst _SMta = \"StateMessage\";\nconst _SN = \"SessionNumber\";\nconst _SNA = \"ServiceNetworkArn\";\nconst _SNE = \"SnsNotificationsEnabled\";\nconst _SNIA = \"StartNetworkInsightsAnalysis\";\nconst _SNIASA = \"StartNetworkInsightsAccessScopeAnalysis\";\nconst _SNN = \"ServiceNetworkName\";\nconst _SNS = \"SriovNetSupport\";\nconst _SNe = \"ServiceName\";\nconst _SNeq = \"SequenceNumber\";\nconst _SNer = \"ServiceNames\";\nconst _SO = \"SpotOptions\";\nconst _SOT = \"S3ObjectTags\";\nconst _SP = \"S3Prefix\";\nconst _SPA = \"SamlProviderArn\";\nconst _SPH = \"SpotPriceHistory\";\nconst _SPI = \"ServicePermissionId\";\nconst _SPIA = \"SecondaryPrivateIpAddresses\";\nconst _SPIAC = \"SecondaryPrivateIpAddressCount\";\nconst _SPL = \"SourcePrefixLists\";\nconst _SPR = \"SourcePortRange\";\nconst _SPRo = \"SourcePortRanges\";\nconst _SPS = \"SpotPlacementScores\";\nconst _SPo = \"SourcePorts\";\nconst _SPp = \"SpotPrice\";\nconst _SQPD = \"SuccessfulQueuedPurchaseDeletions\";\nconst _SR = \"SourceRegion\";\nconst _SRDT = \"SupportedRootDeviceTypes\";\nconst _SRO = \"StaticRoutesOnly\";\nconst _SRT = \"SubnetRouteTable\";\nconst _SRe = \"ServiceRegion\";\nconst _SRer = \"ServiceRegions\";\nconst _SRerv = \"ServiceResource\";\nconst _SRo = \"SourceResource\";\nconst _SRt = \"StateReason\";\nconst _SRu = \"SupportedRegions\";\nconst _SS = \"SseSpecification\";\nconst _SSGN = \"SourceSecurityGroupName\";\nconst _SSGOI = \"SourceSecurityGroupOwnerId\";\nconst _SSGS = \"StaleSecurityGroupSet\";\nconst _SSI = \"SourceSnapshotId\";\nconst _SSIo = \"SourceSnapshotIds\";\nconst _SSP = \"SelfServicePortal\";\nconst _SSPU = \"SelfServicePortalUrl\";\nconst _SSS = \"StaticSourcesSupport\";\nconst _SSSAMLPA = \"SelfServiceSAMLProviderArn\";\nconst _SSSPA = \"SelfServiceSamlProviderArn\";\nconst _SST = \"SampledStartTime\";\nconst _SSTR = \"SlotStartTimeRange\";\nconst _SSe = \"ServiceState\";\nconst _SSu = \"SupportedStrategies\";\nconst _SSy = \"SystemStatus\";\nconst _ST = \"SplitTunnel\";\nconst _STA = \"SnsTopicArn\";\nconst _STC = \"SpotTargetCapacity\";\nconst _STD = \"SnapshotTaskDetail\";\nconst _STFR = \"StoreTaskFailureReason\";\nconst _STGMG = \"SearchTransitGatewayMulticastGroups\";\nconst _STGR = \"SearchTransitGatewayRoutes\";\nconst _STH = \"SessionTimeoutHours\";\nconst _STR = \"SkipTunnelReplacement\";\nconst _STRt = \"StateTransitionReason\";\nconst _STS = \"SnapshotTierStatuses\";\nconst _STSt = \"StoreTaskState\";\nconst _STT = \"StateTransitionTime\";\nconst _STa = \"SampleType\";\nconst _STam = \"SampleTime\";\nconst _STe = \"ServiceType\";\nconst _STo = \"SourceType\";\nconst _STs = \"SseType\";\nconst _STt = \"StartTime\";\nconst _STto = \"StorageTier\";\nconst _SUC = \"SupportedUsageClasses\";\nconst _SV = \"SourceVersion\";\nconst _SVESPDV = \"StartVpcEndpointServicePrivateDnsVerification\";\nconst _SVI = \"SubsystemVendorId\";\nconst _SVT = \"SupportedVirtualizationTypes\";\nconst _SVh = \"ShellVersion\";\nconst _SVo = \"SourceVpc\";\nconst _SVu = \"SupportedVersions\";\nconst _SWD = \"StartWeekDay\";\nconst _S_ = \"S3\";\nconst _Sc = \"Scope\";\nconst _Sco = \"Score\";\nconst _Scop = \"Scopes\";\nconst _Se = \"Service\";\nconst _Set = \"Settings\";\nconst _Si = \"Signature\";\nconst _Siz = \"Size\";\nconst _Sn = \"Snapshots\";\nconst _So = \"Sources\";\nconst _Soc = \"Sockets\";\nconst _Sof = \"Software\";\nconst _St = \"Storage\";\nconst _Sta = \"Statistic\";\nconst _Star = \"Start\";\nconst _Stat = \"State\";\nconst _Statu = \"Status\";\nconst _Status = \"Statuses\";\nconst _Str = \"Strategy\";\nconst _Su = \"Subnet\";\nconst _Sub = \"Subscriptions\";\nconst _Subn = \"Subnets\";\nconst _Suc = \"Successful\";\nconst _Succ = \"Success\";\nconst _T = \"Type\";\nconst _TAAC = \"TotalAvailableAddressCount\";\nconst _TAC = \"TotalAddressCount\";\nconst _TAI = \"TransferAccountId\";\nconst _TC = \"TargetConfigurations\";\nconst _TCS = \"TargetCapacitySpecification\";\nconst _TCUT = \"TargetCapacityUnitType\";\nconst _TCVC = \"TerminateClientVpnConnections\";\nconst _TCVR = \"TargetConfigurationValueRollup\";\nconst _TCVS = \"TargetConfigurationValueSet\";\nconst _TCa = \"TargetCapacity\";\nconst _TCar = \"TargetConfiguration\";\nconst _TCo = \"TotalCapacity\";\nconst _TD = \"TrafficDirection\";\nconst _TDe = \"TerminationDelay\";\nconst _TE = \"TargetEnvironment\";\nconst _TED = \"TermEndDate\";\nconst _TET = \"TcpEstablishedTimeout\";\nconst _TEo = \"TokenEndpoint\";\nconst _TFC = \"TotalFulfilledCapacity\";\nconst _TFMIMB = \"TotalFpgaMemoryInMiB\";\nconst _TG = \"TargetGroups\";\nconst _TGA = \"TransitGatewayAddress\";\nconst _TGAI = \"TransitGatewayAttachmentId\";\nconst _TGAIr = \"TransitGatewayAttachmentIds\";\nconst _TGAP = \"TransitGatewayAttachmentPropagations\";\nconst _TGAr = \"TransitGatewayAttachments\";\nconst _TGAra = \"TransitGatewayAttachment\";\nconst _TGAran = \"TransitGatewayArn\";\nconst _TGArans = \"TransitGatewayAsn\";\nconst _TGC = \"TargetGroupsConfig\";\nconst _TGCB = \"TransitGatewayCidrBlocks\";\nconst _TGCP = \"TransitGatewayConnectPeer\";\nconst _TGCPI = \"TransitGatewayConnectPeerId\";\nconst _TGCPIr = \"TransitGatewayConnectPeerIds\";\nconst _TGCPr = \"TransitGatewayConnectPeers\";\nconst _TGCr = \"TransitGatewayConnect\";\nconst _TGCra = \"TransitGatewayConnects\";\nconst _TGI = \"TransitGatewayId\";\nconst _TGIr = \"TransitGatewayIds\";\nconst _TGMD = \"TransitGatewayMulticastDomain\";\nconst _TGMDA = \"TransitGatewayMulticastDomainArn\";\nconst _TGMDI = \"TransitGatewayMulticastDomainId\";\nconst _TGMDIr = \"TransitGatewayMulticastDomainIds\";\nconst _TGMDr = \"TransitGatewayMulticastDomains\";\nconst _TGMIMB = \"TotalGpuMemoryInMiB\";\nconst _TGOI = \"TransitGatewayOwnerId\";\nconst _TGPA = \"TransitGatewayPeeringAttachment\";\nconst _TGPAr = \"TransitGatewayPeeringAttachments\";\nconst _TGPLR = \"TransitGatewayPrefixListReference\";\nconst _TGPLRr = \"TransitGatewayPrefixListReferences\";\nconst _TGPT = \"TransitGatewayPolicyTable\";\nconst _TGPTE = \"TransitGatewayPolicyTableEntries\";\nconst _TGPTI = \"TransitGatewayPolicyTableId\";\nconst _TGPTIr = \"TransitGatewayPolicyTableIds\";\nconst _TGPTr = \"TransitGatewayPolicyTables\";\nconst _TGRT = \"TransitGatewayRouteTable\";\nconst _TGRTA = \"TransitGatewayRouteTableAnnouncement\";\nconst _TGRTAI = \"TransitGatewayRouteTableAnnouncementId\";\nconst _TGRTAIr = \"TransitGatewayRouteTableAnnouncementIds\";\nconst _TGRTAr = \"TransitGatewayRouteTableAnnouncements\";\nconst _TGRTI = \"TransitGatewayRouteTableId\";\nconst _TGRTIr = \"TransitGatewayRouteTableIds\";\nconst _TGRTP = \"TransitGatewayRouteTablePropagations\";\nconst _TGRTR = \"TransitGatewayRouteTableRoute\";\nconst _TGRTr = \"TransitGatewayRouteTables\";\nconst _TGVA = \"TransitGatewayVpcAttachment\";\nconst _TGVAr = \"TransitGatewayVpcAttachments\";\nconst _TGr = \"TransitGateway\";\nconst _TGra = \"TransitGateways\";\nconst _THP = \"TotalHourlyPrice\";\nconst _TI = \"TerminateInstances\";\nconst _TIC = \"TunnelInsideCidr\";\nconst _TICo = \"TotalInstanceCount\";\nconst _TII = \"TrunkInterfaceId\";\nconst _TIIC = \"TunnelInsideIpv6Cidr\";\nconst _TIIV = \"TunnelInsideIpVersion\";\nconst _TIMIMB = \"TotalInferenceMemoryInMiB\";\nconst _TIWE = \"TerminateInstancesWithExpiration\";\nconst _TIa = \"TargetId\";\nconst _TIar = \"TargetIops\";\nconst _TIe = \"TenantId\";\nconst _TIer = \"TerminatingInstances\";\nconst _TLSGB = \"TotalLocalStorageGB\";\nconst _TMAE = \"TargetMultiAttachEnabled\";\nconst _TMF = \"TrafficMirrorFilter\";\nconst _TMFI = \"TrafficMirrorFilterId\";\nconst _TMFIr = \"TrafficMirrorFilterIds\";\nconst _TMFR = \"TrafficMirrorFilterRule\";\nconst _TMFRI = \"TrafficMirrorFilterRuleId\";\nconst _TMFRIr = \"TrafficMirrorFilterRuleIds\";\nconst _TMFRr = \"TrafficMirrorFilterRules\";\nconst _TMFr = \"TrafficMirrorFilters\";\nconst _TMMIMB = \"TotalMediaMemoryInMiB\";\nconst _TMS = \"TrafficMirrorSession\";\nconst _TMSI = \"TrafficMirrorSessionId\";\nconst _TMSIr = \"TrafficMirrorSessionIds\";\nconst _TMSr = \"TrafficMirrorSessions\";\nconst _TMT = \"TrafficMirrorTarget\";\nconst _TMTI = \"TrafficMirrorTargetId\";\nconst _TMTIr = \"TrafficMirrorTargetIds\";\nconst _TMTr = \"TrafficMirrorTargets\";\nconst _TN = \"TokenName\";\nconst _TNC = \"TargetNetworkCidr\";\nconst _TNDMIMB = \"TotalNeuronDeviceMemoryInMiB\";\nconst _TNI = \"TargetNetworkId\";\nconst _TO = \"TunnelOptions\";\nconst _TOAT = \"TransferOfferAcceptedTimestamp\";\nconst _TOET = \"TransferOfferExpirationTimestamp\";\nconst _TP = \"ToPort\";\nconst _TPC = \"ThreadsPerCore\";\nconst _TPT = \"TrustProviderType\";\nconst _TPr = \"TransportProtocol\";\nconst _TR = \"ThroughResources\";\nconst _TRC = \"TargetResourceCount\";\nconst _TRD = \"TemporaryRestoreDays\";\nconst _TRTI = \"TargetRouteTableId\";\nconst _TRi = \"TimeRanges\";\nconst _TS = \"TagSpecifications\";\nconst _TSD = \"TermStartDate\";\nconst _TSIGB = \"TotalSizeInGB\";\nconst _TSIH = \"TotalScheduledInstanceHours\";\nconst _TST = \"TieringStartTime\";\nconst _TSTa = \"TaskStartTime\";\nconst _TSa = \"TargetSubnet\";\nconst _TSag = \"TagSet\";\nconst _TSagp = \"TagSpecification\";\nconst _TSar = \"TargetSize\";\nconst _TSas = \"TaskState\";\nconst _TSp = \"TpmSupport\";\nconst _TT = \"TrafficType\";\nconst _TTC = \"TotalTargetCapacity\";\nconst _TTGAI = \"TransportTransitGatewayAttachmentId\";\nconst _TTa = \"TaskType\";\nconst _TTar = \"TargetThroughput\";\nconst _TTr = \"TransferType\";\nconst _TUP = \"TotalUpfrontPrice\";\nconst _TV = \"TargetVersion\";\nconst _TVC = \"TotalVCpus\";\nconst _TVSI = \"TargetVpcSubnetId\";\nconst _TVT = \"TargetVolumeType\";\nconst _TVo = \"TokenValue\";\nconst _Ta = \"Tags\";\nconst _Tag = \"Tag\";\nconst _Te = \"Tenancy\";\nconst _Ter = \"Term\";\nconst _Th = \"Throughput\";\nconst _Ti = \"Tier\";\nconst _Tim = \"Timestamp\";\nconst _To = \"To\";\nconst _U = \"Url\";\nconst _UB = \"UserBucket\";\nconst _UD = \"UserData\";\nconst _UDLTV = \"UnsuccessfullyDeletedLaunchTemplateVersions\";\nconst _UDe = \"UefiData\";\nconst _UDp = \"UpdatedDate\";\nconst _UDpd = \"UpdateDate\";\nconst _UE = \"UploadEnd\";\nconst _UF = \"UpfrontFee\";\nconst _UFD = \"UnsuccessfulFleetDeletions\";\nconst _UFR = \"UnsuccessfulFleetRequests\";\nconst _UG = \"UserGroups\";\nconst _UI = \"UnmonitorInstances\";\nconst _UIA = \"UnassignIpv6Addresses\";\nconst _UIAn = \"UnassignedIpv6Addresses\";\nconst _UIC = \"UsedInstanceCount\";\nconst _UICS = \"UnsuccessfulInstanceCreditSpecifications\";\nconst _UIE = \"UserInfoEndpoint\";\nconst _UIGP = \"UserIdGroupPairs\";\nconst _UIP = \"UnknownIpPermissions\";\nconst _UIPn = \"UnassignedIpv6Prefixes\";\nconst _UIs = \"UserId\";\nconst _UIse = \"UserIds\";\nconst _ULI = \"UseLongIds\";\nconst _ULIA = \"UseLongIdsAggregated\";\nconst _UO = \"UsageOperation\";\nconst _UOUT = \"UsageOperationUpdateTime\";\nconst _UP = \"UploadPolicy\";\nconst _UPIA = \"UnassignPrivateIpAddresses\";\nconst _UPNGA = \"UnassignPrivateNatGatewayAddress\";\nconst _UPS = \"UploadPolicySignature\";\nconst _UPp = \"UpfrontPrice\";\nconst _UPs = \"UsagePrice\";\nconst _URBOI = \"UnusedReservationBillingOwnerId\";\nconst _US = \"UnlockSnapshot\";\nconst _USGRDE = \"UpdateSecurityGroupRuleDescriptionsEgress\";\nconst _USGRDI = \"UpdateSecurityGroupRuleDescriptionsIngress\";\nconst _UST = \"UdpStreamTimeout\";\nconst _USp = \"UploadSize\";\nconst _USpl = \"UploadStart\";\nconst _USs = \"UsageStrategy\";\nconst _UT = \"UdpTimeout\";\nconst _UTP = \"UserTrustProvider\";\nconst _UTPT = \"UserTrustProviderType\";\nconst _UTp = \"UpdateTime\";\nconst _Un = \"Unsuccessful\";\nconst _Us = \"Username\";\nconst _V = \"Version\";\nconst _VA = \"VpcAttachment\";\nconst _VAE = \"VerifiedAccessEndpoint\";\nconst _VAEI = \"VerifiedAccessEndpointId\";\nconst _VAEIe = \"VerifiedAccessEndpointIds\";\nconst _VAET = \"VerifiedAccessEndpointTargets\";\nconst _VAETD = \"VerifiedAccessEndpointTargetDns\";\nconst _VAETIA = \"VerifiedAccessEndpointTargetIpAddress\";\nconst _VAEe = \"VerifiedAccessEndpoints\";\nconst _VAG = \"VerifiedAccessGroup\";\nconst _VAGA = \"VerifiedAccessGroupArn\";\nconst _VAGI = \"VerifiedAccessGroupId\";\nconst _VAGIe = \"VerifiedAccessGroupIds\";\nconst _VAGe = \"VerifiedAccessGroups\";\nconst _VAI = \"VerifiedAccessInstance\";\nconst _VAII = \"VerifiedAccessInstanceId\";\nconst _VAIIe = \"VerifiedAccessInstanceIds\";\nconst _VAIe = \"VerifiedAccessInstances\";\nconst _VATP = \"VerifiedAccessTrustProvider\";\nconst _VATPI = \"VerifiedAccessTrustProviderId\";\nconst _VATPIe = \"VerifiedAccessTrustProviderIds\";\nconst _VATPe = \"VerifiedAccessTrustProviders\";\nconst _VAp = \"VpcAttachments\";\nconst _VBPAE = \"VpcBlockPublicAccessExclusion\";\nconst _VBPAEp = \"VpcBlockPublicAccessExclusions\";\nconst _VBPAO = \"VpcBlockPublicAccessOptions\";\nconst _VC = \"VpnConnection\";\nconst _VCC = \"VCpuCount\";\nconst _VCDSC = \"VpnConnectionDeviceSampleConfiguration\";\nconst _VCDT = \"VpnConnectionDeviceTypes\";\nconst _VCDTI = \"VpnConnectionDeviceTypeId\";\nconst _VCI = \"VpnConnectionId\";\nconst _VCIp = \"VpnConnectionIds\";\nconst _VCIpu = \"VCpuInfo\";\nconst _VCa = \"ValidCores\";\nconst _VCp = \"VpnConnections\";\nconst _VD = \"VersionDescription\";\nconst _VE = \"VpcEndpoint\";\nconst _VEA = \"VpcEndpointAssociations\";\nconst _VEC = \"VpcEndpointConnections\";\nconst _VECI = \"VpcEncryptionControlId\";\nconst _VECIp = \"VpcEndpointConnectionId\";\nconst _VEI = \"VpcEndpointIds\";\nconst _VEIp = \"VpcEndpointId\";\nconst _VEO = \"VpcEndpointOwner\";\nconst _VEPS = \"VpcEndpointPolicySupported\";\nconst _VER = \"VpcEndpointRegion\";\nconst _VES = \"VpnEcmpSupport\";\nconst _VESp = \"VpcEndpointService\";\nconst _VESpc = \"VpcEndpointState\";\nconst _VET = \"VpcEndpointType\";\nconst _VEp = \"VpcEndpoints\";\nconst _VF = \"ValidFrom\";\nconst _VFR = \"ValidationFailureReason\";\nconst _VG = \"VpnGateway\";\nconst _VGI = \"VpnGatewayId\";\nconst _VGIp = \"VpnGatewayIds\";\nconst _VGp = \"VpnGateways\";\nconst _VI = \"VpcId\";\nconst _VIR = \"VolumeInitializationRate\";\nconst _VIe = \"VendorId\";\nconst _VIl = \"VlanId\";\nconst _VIo = \"VolumeId\";\nconst _VIol = \"VolumeIds\";\nconst _VIp = \"VpcIds\";\nconst _VM = \"VerificationMethod\";\nconst _VMo = \"VolumesModifications\";\nconst _VMol = \"VolumeModification\";\nconst _VN = \"VirtualName\";\nconst _VNI = \"VirtualNetworkId\";\nconst _VNe = \"VersionNumber\";\nconst _VOI = \"VolumeOwnerId\";\nconst _VOIp = \"VpcOwnerId\";\nconst _VP = \"VpnPort\";\nconst _VPC = \"VpcPeeringConnection\";\nconst _VPCI = \"VpcPeeringConnectionId\";\nconst _VPCIp = \"VpcPeeringConnectionIds\";\nconst _VPCp = \"VpcPeeringConnections\";\nconst _VPG = \"VirtualPrivateGateway\";\nconst _VPp = \"VpnProtocol\";\nconst _VPpc = \"VpcPeering\";\nconst _VS = \"VolumeSize\";\nconst _VSo = \"VolumeStatuses\";\nconst _VSol = \"VolumeStatus\";\nconst _VT = \"VolumeType\";\nconst _VTOIA = \"VpnTunnelOutsideIpAddress\";\nconst _VTPC = \"ValidThreadsPerCore\";\nconst _VTg = \"VgwTelemetry\";\nconst _VTi = \"VirtualizationTypes\";\nconst _VTir = \"VirtualizationType\";\nconst _VU = \"ValidUntil\";\nconst _Va = \"Value\";\nconst _Val = \"Values\";\nconst _Ve = \"Versions\";\nconst _Ven = \"Vendor\";\nconst _Vl = \"Vlan\";\nconst _Vo = \"Volume\";\nconst _Vol = \"Volumes\";\nconst _Vp = \"Vpc\";\nconst _Vpc = \"Vpcs\";\nconst _W = \"Weight\";\nconst _WBC = \"WithdrawByoipCidr\";\nconst _WC = \"WithCooldown\";\nconst _WCe = \"WeightedCapacity\";\nconst _WM = \"WarningMessage\";\nconst _WU = \"WakeUp\";\nconst _Wa = \"Warning\";\nconst _ZI = \"ZoneIds\";\nconst _ZIo = \"ZoneId\";\nconst _ZN = \"ZoneNames\";\nconst _ZNo = \"ZoneName\";\nconst _ZT = \"ZoneType\";\nconst _a = \"associations\";\nconst _aA = \"asnAssociation\";\nconst _aAC = \"availableAddressCount\";\nconst _aAI = \"awsAccountId\";\nconst _aAId = \"addressAllocationId\";\nconst _aAS = \"asnAssociationSet\";\nconst _aASA = \"autoAcceptSharedAssociations\";\nconst _aASAu = \"autoAcceptSharedAttachments\";\nconst _aASc = \"accountAttributeSet\";\nconst _aASd = \"additionalAccountSet\";\nconst _aAc = \"accessAll\";\nconst _aBHP = \"actualBlockHourlyPrice\";\nconst _aC = \"availableCapacity\";\nconst _aCIA = \"associateCarrierIpAddress\";\nconst _aCT = \"archivalCompleteTime\";\nconst _aCc = \"acceleratorCount\";\nconst _aCd = \"addressCount\";\nconst _aD = \"activeDirectory\";\nconst _aDNL = \"allocationDefaultNetmaskLength\";\nconst _aDRFRV = \"allowDnsResolutionFromRemoteVpc\";\nconst _aDRTI = \"associationDefaultRouteTableId\";\nconst _aDS = \"additionalDetailSet\";\nconst _aDT = \"additionalDetailType\";\nconst _aDn = \"announcementDirection\";\nconst _aDp = \"applicationDomain\";\nconst _aE = \"authorizationEndpoint\";\nconst _aEC = \"analyzedEniCount\";\nconst _aEFLCLTRV = \"allowEgressFromLocalClassicLinkToRemoteVpc\";\nconst _aEFLVTRCL = \"allowEgressFromLocalVpcToRemoteClassicLink\";\nconst _aEIO = \"autoEnableIO\";\nconst _aES = \"attachedEbsStatus\";\nconst _aF = \"addressFamily\";\nconst _aFS = \"analysisFindingSet\";\nconst _aI = \"allocationId\";\nconst _aIA = \"assignedIpv6Addresses\";\nconst _aIAC = \"availableIpAddressCount\";\nconst _aIAOC = \"assignIpv6AddressOnCreation\";\nconst _aIC = \"availableInstanceCapacity\";\nconst _aICv = \"availableInstanceCount\";\nconst _aIPS = \"assignedIpv6PrefixSet\";\nconst _aIPSs = \"assignedIpv4PrefixSet\";\nconst _aIS = \"activeInstanceSet\";\nconst _aISS = \"allowedImagesSettingsState\";\nconst _aITS = \"allowedInstanceTypeSet\";\nconst _aIc = \"accountId\";\nconst _aIm = \"amiId\";\nconst _aIp = \"appleInternal\";\nconst _aIs = \"associationId\";\nconst _aIss = \"assetId\";\nconst _aIt = \"attachmentId\";\nconst _aIu = \"autoImport\";\nconst _aL = \"accountLevel\";\nconst _aLI = \"amiLaunchIndex\";\nconst _aLc = \"accessLogs\";\nconst _aMIT = \"allowsMultipleInstanceTypes\";\nconst _aMNL = \"allocationMinNetmaskLength\";\nconst _aMNLl = \"allocationMaxNetmaskLength\";\nconst _aMS = \"acceleratorManufacturerSet\";\nconst _aMSp = \"applianceModeSupport\";\nconst _aN = \"attributeName\";\nconst _aNS = \"acceleratorNameSet\";\nconst _aO = \"authenticationOptions\";\nconst _aOI = \"addressOwnerId\";\nconst _aP = \"allowedPrincipals\";\nconst _aPCO = \"accepterPeeringConnectionOptions\";\nconst _aPHS = \"alternatePathHintSet\";\nconst _aPIA = \"associatePublicIpAddress\";\nconst _aPIAS = \"assignedPrivateIpAddressesSet\";\nconst _aPS = \"addedPrincipalSet\";\nconst _aPSs = \"asPathSet\";\nconst _aPu = \"autoPlacement\";\nconst _aR = \"authorizationRule\";\nconst _aRA = \"associatedRoleArn\";\nconst _aRAd = \"additionalRoutesAvailable\";\nconst _aRAs = \"associatedResourceAccessibility\";\nconst _aRAss = \"associatedResourceArn\";\nconst _aRC = \"acceptedRouteCount\";\nconst _aRP = \"areRoutesPersisted\";\nconst _aRS = \"associatedRoleSet\";\nconst _aRSu = \"autoRecoverySupported\";\nconst _aRTS = \"allocationResourceTagSet\";\nconst _aRc = \"aclRule\";\nconst _aRcc = \"acceptanceRequired\";\nconst _aRd = \"addressRegion\";\nconst _aRs = \"associatedResource\";\nconst _aRu = \"autoRecovery\";\nconst _aRw = \"awsRegion\";\nconst _aS = \"associationState\";\nconst _aSA = \"amazonSideAsn\";\nconst _aSS = \"amdSevSnp\";\nconst _aSSt = \"attributeSummarySet\";\nconst _aSc = \"activityStatus\";\nconst _aSct = \"actionsSet\";\nconst _aSd = \"addressSet\";\nconst _aSdd = \"addressesSet\";\nconst _aSl = \"allocationStrategy\";\nconst _aSn = \"analysisStatus\";\nconst _aSs = \"associationStatus\";\nconst _aSss = \"associationSet\";\nconst _aSt = \"attachmentSet\";\nconst _aStt = \"attachmentStatuses\";\nconst _aSw = \"awsService\";\nconst _aT = \"addressTransfer\";\nconst _aTGAI = \"accepterTransitGatewayAttachmentId\";\nconst _aTI = \"accepterTgwInfo\";\nconst _aTMMB = \"acceleratorTotalMemoryMiB\";\nconst _aTN = \"associatedTargetNetwork\";\nconst _aTS = \"addressTransferStatus\";\nconst _aTSc = \"acceleratorTypeSet\";\nconst _aTSd = \"addressTransferSet\";\nconst _aTd = \"addressType\";\nconst _aTdd = \"addressingType\";\nconst _aTl = \"allocationType\";\nconst _aTll = \"allocationTime\";\nconst _aTs = \"associationTarget\";\nconst _aTt = \"attachTime\";\nconst _aTtt = \"attachedTo\";\nconst _aTtta = \"attachmentType\";\nconst _aV = \"attributeValue\";\nconst _aVC = \"availableVCpus\";\nconst _aVI = \"accepterVpcInfo\";\nconst _aVS = \"attributeValueSet\";\nconst _aVTS = \"activeVpnTunnelStatus\";\nconst _aZ = \"availabilityZone\";\nconst _aZG = \"availabilityZoneGroup\";\nconst _aZI = \"availabilityZoneId\";\nconst _aZIS = \"availabilityZoneIdSet\";\nconst _aZIv = \"availabilityZoneInfo\";\nconst _aZS = \"availabilityZoneSet\";\nconst _ac = \"acl\";\nconst _acc = \"accelerators\";\nconst _act = \"active\";\nconst _ad = \"address\";\nconst _af = \"affinity\";\nconst _am = \"amount\";\nconst _ar = \"arn\";\nconst _arc = \"architecture\";\nconst _as = \"asn\";\nconst _ass = \"association\";\nconst _at = \"attachment\";\nconst _att = \"attachments\";\nconst _b = \"byoasn\";\nconst _bA = \"bgpAsn\";\nconst _bAE = \"bgpAsnExtended\";\nconst _bBIG = \"baselineBandwidthInGbps\";\nconst _bBIM = \"baselineBandwidthInMbps\";\nconst _bC = \"byoipCidr\";\nconst _bCS = \"byoipCidrSet\";\nconst _bCg = \"bgpConfigurations\";\nconst _bCy = \"bytesConverted\";\nconst _bDM = \"blockDeviceMapping\";\nconst _bDMS = \"blockDeviceMappingSet\";\nconst _bDMl = \"blockDurationMinutes\";\nconst _bEBM = \"baselineEbsBandwidthMbps\";\nconst _bEDNS = \"baseEndpointDnsNameSet\";\nconst _bI = \"bundleId\";\nconst _bII = \"branchInterfaceId\";\nconst _bIT = \"bundleInstanceTask\";\nconst _bITS = \"bundleInstanceTasksSet\";\nconst _bIa = \"baselineIops\";\nconst _bM = \"bootMode\";\nconst _bMa = \"bareMetal\";\nconst _bN = \"bucketName\";\nconst _bO = \"bgpOptions\";\nconst _bOu = \"bucketOwner\";\nconst _bP = \"burstablePerformance\";\nconst _bPAS = \"blockPublicAccessStates\";\nconst _bPF = \"baselinePerformanceFactors\";\nconst _bPS = \"burstablePerformanceSupported\";\nconst _bS = \"byoasnSet\";\nconst _bSa = \"baseSystem\";\nconst _bSf = \"bfdStatus\";\nconst _bSg = \"bgpStatus\";\nconst _bT = \"bannerText\";\nconst _bTIMB = \"baselineThroughputInMBps\";\nconst _bW = \"bandwidthWeighting\";\nconst _bWa = \"bandwidthWeightings\";\nconst _bl = \"blackhole\";\nconst _bu = \"bucket\";\nconst _c = \"component\";\nconst _cA = \"componentArn\";\nconst _cAS = \"capacityAllocationSet\";\nconst _cAUS = \"coipAddressUsageSet\";\nconst _cAe = \"certificateArn\";\nconst _cAo = \"componentAccount\";\nconst _cAr = \"createdAt\";\nconst _cB = \"cidrBlock\";\nconst _cBA = \"cidrBlockAssociation\";\nconst _cBAS = \"cidrBlockAssociationSet\";\nconst _cBDH = \"capacityBlockDurationHours\";\nconst _cBDM = \"capacityBlockDurationMinutes\";\nconst _cBEDH = \"capacityBlockExtensionDurationHours\";\nconst _cBEED = \"capacityBlockExtensionEndDate\";\nconst _cBEOI = \"capacityBlockExtensionOfferingId\";\nconst _cBEOS = \"capacityBlockExtensionOfferingSet\";\nconst _cBEPD = \"capacityBlockExtensionPurchaseDate\";\nconst _cBES = \"capacityBlockExtensionStatus\";\nconst _cBESD = \"capacityBlockExtensionStartDate\";\nconst _cBESa = \"capacityBlockExtensionSet\";\nconst _cBOI = \"capacityBlockOfferingId\";\nconst _cBOS = \"capacityBlockOfferingSet\";\nconst _cBS = \"cidrBlockState\";\nconst _cBSi = \"cidrBlockSet\";\nconst _cBr = \"createdBy\";\nconst _cC = \"currencyCode\";\nconst _cCB = \"clientCidrBlock\";\nconst _cCO = \"clientConnectOptions\";\nconst _cCRFE = \"cancelCapacityReservationFleetError\";\nconst _cCl = \"clientConfiguration\";\nconst _cCo = \"coreCount\";\nconst _cCoi = \"coipCidr\";\nconst _cCp = \"cpuCredits\";\nconst _cD = \"createDate\";\nconst _cDM = \"completionDurationMinutes\";\nconst _cDr = \"creationDate\";\nconst _cDre = \"createdDate\";\nconst _cE = \"connectionEvents\";\nconst _cECSD = \"cidrEndpointsCustomSubDomain\";\nconst _cED = \"commitmentEndDate\";\nconst _cET = \"connectionEstablishedTime\";\nconst _cETo = \"connectionEndTime\";\nconst _cEr = \"cronExpression\";\nconst _cF = \"containerFormat\";\nconst _cFS = \"currentFleetState\";\nconst _cG = \"carrierGateway\";\nconst _cGC = \"customerGatewayConfiguration\";\nconst _cGI = \"carrierGatewayId\";\nconst _cGIu = \"customerGatewayId\";\nconst _cGS = \"carrierGatewaySet\";\nconst _cGSu = \"customerGatewaySet\";\nconst _cGu = \"customerGateway\";\nconst _cGur = \"currentGeneration\";\nconst _cI = \"carrierIp\";\nconst _cIBM = \"currentInstanceBootMode\";\nconst _cIC = \"committedInstanceCount\";\nconst _cIi = \"cidrIp\";\nconst _cIid = \"cidrIpv6\";\nconst _cIidr = \"cidrIpv4\";\nconst _cIl = \"clientIp\";\nconst _cIli = \"clientId\";\nconst _cIo = \"componentId\";\nconst _cIom = \"commitmentInfo\";\nconst _cIon = \"connectionId\";\nconst _cIop = \"coIp\";\nconst _cIor = \"coreInfo\";\nconst _cLB = \"classicLoadBalancers\";\nconst _cLBC = \"classicLoadBalancersConfig\";\nconst _cLBL = \"classicLoadBalancerListener\";\nconst _cLBO = \"clientLoginBannerOptions\";\nconst _cLDS = \"classicLinkDnsSupported\";\nconst _cLE = \"classicLinkEnabled\";\nconst _cLO = \"connectionLogOptions\";\nconst _cMKE = \"customerManagedKeyEnabled\";\nconst _cMS = \"cpuManufacturerSet\";\nconst _cN = \"commonName\";\nconst _cNA = \"coreNetworkArn\";\nconst _cNAA = \"coreNetworkAttachmentArn\";\nconst _cNAo = \"connectionNotificationArn\";\nconst _cNI = \"connectionNotificationId\";\nconst _cNIo = \"coreNetworkId\";\nconst _cNS = \"connectionNotificationState\";\nconst _cNSo = \"connectionNotificationSet\";\nconst _cNT = \"connectionNotificationType\";\nconst _cNo = \"connectionNotification\";\nconst _cO = \"cpuOptions\";\nconst _cOI = \"customerOwnedIp\";\nconst _cOIP = \"customerOwnedIpv4Pool\";\nconst _cOP = \"coolOffPeriod\";\nconst _cOPEO = \"coolOffPeriodExpiresOn\";\nconst _cOi = \"cidrOptions\";\nconst _cP = \"coipPool\";\nconst _cPC = \"connectPeerConfiguration\";\nconst _cPI = \"coipPoolId\";\nconst _cPS = \"coipPoolSet\";\nconst _cR = \"capacityReservation\";\nconst _cRA = \"capacityReservationArn\";\nconst _cRBRS = \"capacityReservationBillingRequestSet\";\nconst _cRCC = \"clientRootCertificateChain\";\nconst _cREO = \"clientRouteEnforcementOptions\";\nconst _cRFA = \"capacityReservationFleetArn\";\nconst _cRFI = \"capacityReservationFleetId\";\nconst _cRFS = \"capacityReservationFleetSet\";\nconst _cRGS = \"capacityReservationGroupSet\";\nconst _cRI = \"capacityReservationId\";\nconst _cRIa = \"capacityReservationInfo\";\nconst _cRL = \"certificateRevocationList\";\nconst _cRO = \"capacityReservationOptions\";\nconst _cRP = \"capacityReservationPreference\";\nconst _cRRGA = \"capacityReservationResourceGroupArn\";\nconst _cRS = \"capacityReservationSet\";\nconst _cRSa = \"capacityReservationSpecification\";\nconst _cRT = \"capacityReservationTarget\";\nconst _cRa = \"capacityRebalance\";\nconst _cRo = \"componentRegion\";\nconst _cS = \"cidrSet\";\nconst _cSBN = \"certificateS3BucketName\";\nconst _cSFRS = \"currentSpotFleetRequestState\";\nconst _cSOK = \"certificateS3ObjectKey\";\nconst _cSl = \"clientSecret\";\nconst _cSo = \"complianceStatus\";\nconst _cSon = \"configurationState\";\nconst _cSonn = \"connectionStatuses\";\nconst _cSr = \"creditSpecification\";\nconst _cSu = \"currentState\";\nconst _cSur = \"currentStatus\";\nconst _cT = \"clientToken\";\nconst _cTC = \"connectionTrackingConfiguration\";\nconst _cTI = \"conversionTaskId\";\nconst _cTS = \"connectionTrackingSpecification\";\nconst _cTo = \"conversionTasks\";\nconst _cTom = \"completeTime\";\nconst _cTomp = \"completionTime\";\nconst _cTon = \"conversionTask\";\nconst _cTonn = \"connectivityType\";\nconst _cTr = \"createTime\";\nconst _cTre = \"creationTime\";\nconst _cTrea = \"creationTimestamp\";\nconst _cVE = \"clientVpnEndpoint\";\nconst _cVEI = \"clientVpnEndpointId\";\nconst _cVP = \"createVolumePermission\";\nconst _cVTN = \"clientVpnTargetNetworks\";\nconst _cWL = \"cloudWatchLogs\";\nconst _cWLO = \"cloudWatchLogOptions\";\nconst _ca = \"category\";\nconst _ch = \"checksum\";\nconst _ci = \"cidr\";\nconst _co = \"code\";\nconst _con = \"connections\";\nconst _conf = \"configured\";\nconst _confi = \"config\";\nconst _cont = \"context\";\nconst _cor = \"cores\";\nconst _cou = \"count\";\nconst _cp = \"cpu\";\nconst _d = \"destination\";\nconst _dA = \"destinationArn\";\nconst _dAIT = \"denyAllIgwTraffic\";\nconst _dART = \"defaultAssociationRouteTable\";\nconst _dAS = \"destinationAddressSet\";\nconst _dASe = \"deprovisionedAddressSet\";\nconst _dASi = \"disableApiStop\";\nconst _dAT = \"disableApiTermination\";\nconst _dAe = \"destinationAddress\";\nconst _dC = \"destinationCidr\";\nconst _dCA = \"domainCertificateArn\";\nconst _dCAR = \"deliverCrossAccountRole\";\nconst _dCB = \"destinationCidrBlock\";\nconst _dCR = \"destinationCapacityReservation\";\nconst _dCS = \"dhcpConfigurationSet\";\nconst _dCe = \"defaultCores\";\nconst _dE = \"dnsEntry\";\nconst _dEKI = \"dataEncryptionKeyId\";\nconst _dEQCPI = \"defaultEnaQueueCountPerInterface\";\nconst _dES = \"dnsEntrySet\";\nconst _dFA = \"defaultForAz\";\nconst _dHIS = \"dedicatedHostIdSet\";\nconst _dHS = \"dedicatedHostsSupported\";\nconst _dHT = \"dnsHostnameType\";\nconst _dI = \"directoryId\";\nconst _dICB = \"destinationIpv6CidrBlock\";\nconst _dIF = \"diskImageFormat\";\nconst _dIS = \"diskImageSize\";\nconst _dIe = \"deviceIndex\";\nconst _dIes = \"destinationIp\";\nconst _dLEM = \"deliverLogsErrorMessage\";\nconst _dLPA = \"deliverLogsPermissionArn\";\nconst _dLS = \"deliverLogsStatus\";\nconst _dMGM = \"deregisteredMulticastGroupMembers\";\nconst _dMGS = \"deregisteredMulticastGroupSources\";\nconst _dN = \"deviceName\";\nconst _dNCI = \"defaultNetworkCardIndex\";\nconst _dNII = \"deregisteredNetworkInterfaceIds\";\nconst _dNn = \"dnsName\";\nconst _dO = \"dhcpOptions\";\nconst _dOI = \"dhcpOptionsId\";\nconst _dOS = \"dhcpOptionsSet\";\nconst _dOST = \"disconnectOnSessionTimeout\";\nconst _dOT = \"deleteOnTermination\";\nconst _dOe = \"destinationOptions\";\nconst _dOev = \"deviceOptions\";\nconst _dOn = \"dnsOptions\";\nconst _dP = \"deliveryPreference\";\nconst _dPLI = \"destinationPrefixListId\";\nconst _dPLS = \"destinationPrefixListSet\";\nconst _dPR = \"destinationPortRange\";\nconst _dPRS = \"destinationPortRangeSet\";\nconst _dPRT = \"defaultPropagationRouteTable\";\nconst _dPS = \"destinationPortSet\";\nconst _dPe = \"deregistrationProtection\";\nconst _dPes = \"destinationPort\";\nconst _dR = \"discoveryRegion\";\nconst _dRDAI = \"defaultResourceDiscoveryAssociationId\";\nconst _dRDI = \"defaultResourceDiscoveryId\";\nconst _dRIT = \"dnsRecordIpType\";\nconst _dRRV = \"deleteReplacedRootVolume\";\nconst _dRS = \"dataRetentionSupport\";\nconst _dRSa = \"dataResponseSet\";\nconst _dRTA = \"defaultRouteTableAssociation\";\nconst _dRTP = \"defaultRouteTablePropagation\";\nconst _dRe = \"debuggingRestrictions\";\nconst _dRy = \"dynamicRouting\";\nconst _dS = \"dnsServer\";\nconst _dSCR = \"deletedSubnetCidrReservation\";\nconst _dSRS = \"deleteSnapshotResultSet\";\nconst _dSe = \"destinationSet\";\nconst _dSel = \"deliveryStatus\";\nconst _dSeli = \"deliveryStream\";\nconst _dSn = \"dnsSupport\";\nconst _dT = \"deletionTime\";\nconst _dTA = \"dpdTimeoutAction\";\nconst _dTCT = \"defaultTargetCapacityType\";\nconst _dTPC = \"defaultThreadsPerCore\";\nconst _dTPS = \"deviceTrustProviderSet\";\nconst _dTPT = \"deviceTrustProviderType\";\nconst _dTR = \"dTraceRestrictions\";\nconst _dTS = \"dpdTimeoutSeconds\";\nconst _dTe = \"deprecationTime\";\nconst _dTel = \"deleteTime\";\nconst _dTele = \"deletionTimestamp\";\nconst _dTi = \"disablingTime\";\nconst _dTis = \"disabledTime\";\nconst _dV = \"destinationVpc\";\nconst _dVC = \"defaultVCpus\";\nconst _dVD = \"deviceValidationDomain\";\nconst _dVN = \"defaultVersionNumber\";\nconst _dVe = \"defaultVersion\";\nconst _de = \"description\";\nconst _dea = \"deadline\";\nconst _def = \"default\";\nconst _det = \"details\";\nconst _dev = \"device\";\nconst _di = \"direction\";\nconst _dis = \"disks\";\nconst _do = \"domain\";\nconst _du = \"duration\";\nconst _e = \"egress\";\nconst _eA = \"eniAddress\";\nconst _eAn = \"enableAcceleration\";\nconst _eAx = \"exclusionsAllowed\";\nconst _eB = \"egressBytes\";\nconst _eC = \"errorCode\";\nconst _eCTP = \"excessCapacityTerminationPolicy\";\nconst _eCn = \"encryptionControl\";\nconst _eCx = \"explanationCode\";\nconst _eD = \"endDate\";\nconst _eDH = \"enableDnsHostnames\";\nconst _eDS = \"enableDnsSupport\";\nconst _eDT = \"endDateType\";\nconst _eDf = \"effectiveDate\";\nconst _eDn = \"enableDns64\";\nconst _eDnd = \"endpointDomain\";\nconst _eDv = \"eventDescription\";\nconst _eEA = \"endpointEniAddress\";\nconst _eEBD = \"ebsEncryptionByDefault\";\nconst _eEI = \"endpointEniId\";\nconst _eFRS = \"egressFilterRuleSet\";\nconst _eGAI = \"elasticGpuAssociationId\";\nconst _eGAS = \"elasticGpuAssociationState\";\nconst _eGASl = \"elasticGpuAssociationSet\";\nconst _eGAT = \"elasticGpuAssociationTime\";\nconst _eGH = \"elasticGpuHealth\";\nconst _eGI = \"elasticGpuId\";\nconst _eGS = \"elasticGpuSet\";\nconst _eGSS = \"elasticGpuSpecificationSet\";\nconst _eGSl = \"elasticGpuState\";\nconst _eGT = \"elasticGpuType\";\nconst _eH = \"endHour\";\nconst _eI = \"exchangeId\";\nconst _eIAA = \"elasticInferenceAcceleratorArn\";\nconst _eIAAI = \"elasticInferenceAcceleratorAssociationId\";\nconst _eIAAS = \"elasticInferenceAcceleratorAssociationState\";\nconst _eIAASl = \"elasticInferenceAcceleratorAssociationSet\";\nconst _eIAAT = \"elasticInferenceAcceleratorAssociationTime\";\nconst _eIAS = \"elasticInferenceAcceleratorSet\";\nconst _eITI = \"exportImageTaskId\";\nconst _eITS = \"exportImageTaskSet\";\nconst _eITSn = \"encryptionInTransitSupported\";\nconst _eITSx = \"excludedInstanceTypeSet\";\nconst _eIb = \"ebsInfo\";\nconst _eIf = \"efaInfo\";\nconst _eIn = \"eniId\";\nconst _eIv = \"eventInformation\";\nconst _eIve = \"eventId\";\nconst _eIx = \"exclusionId\";\nconst _eKKI = \"encryptionKmsKeyId\";\nconst _eLADI = \"enableLniAtDeviceIndex\";\nconst _eLBL = \"elasticLoadBalancerListener\";\nconst _eM = \"errorMessage\";\nconst _eNAUM = \"enableNetworkAddressUsageMetrics\";\nconst _eO = \"ebsOptimized\";\nconst _eOI = \"ebsOptimizedInfo\";\nconst _eOIG = \"egressOnlyInternetGateway\";\nconst _eOIGI = \"egressOnlyInternetGatewayId\";\nconst _eOIGS = \"egressOnlyInternetGatewaySet\";\nconst _eOS = \"ebsOptimizedSupport\";\nconst _eOn = \"enclaveOptions\";\nconst _eP = \"egressPackets\";\nconst _ePG = \"enablePrivateGua\";\nconst _ePS = \"excludePathSet\";\nconst _eQC = \"enaQueueCount\";\nconst _eRNDAAAAR = \"enableResourceNameDnsAAAARecord\";\nconst _eRNDAR = \"enableResourceNameDnsARecord\";\nconst _eS = \"ephemeralStorage\";\nconst _eSE = \"enaSrdEnabled\";\nconst _eSS = \"enaSrdSpecification\";\nconst _eSSn = \"enaSrdSupported\";\nconst _eST = \"eventSubType\";\nconst _eSUE = \"enaSrdUdpEnabled\";\nconst _eSUS = \"enaSrdUdpSpecification\";\nconst _eSf = \"efaSupported\";\nconst _eSn = \"encryptionSupport\";\nconst _eSna = \"enaSupport\";\nconst _eSnt = \"entrySet\";\nconst _eSr = \"errorSet\";\nconst _eSv = \"eventsSet\";\nconst _eSx = \"explanationSet\";\nconst _eT = \"expirationTime\";\nconst _eTI = \"exportTaskId\";\nconst _eTLC = \"enableTunnelLifecycleControl\";\nconst _eTS = \"exportTaskSet\";\nconst _eTSi = \"eipTagSet\";\nconst _eTSx = \"exportToS3\";\nconst _eTn = \"endTime\";\nconst _eTna = \"enablingTime\";\nconst _eTnab = \"enabledTime\";\nconst _eTnd = \"endpointType\";\nconst _eTv = \"eventType\";\nconst _eTx = \"exportTask\";\nconst _eWD = \"endWeekDay\";\nconst _eb = \"ebs\";\nconst _en = \"enabled\";\nconst _enc = \"encrypted\";\nconst _end = \"end\";\nconst _enf = \"enforced\";\nconst _er = \"error\";\nconst _ev = \"event\";\nconst _f = \"format\";\nconst _fA = \"federatedAuthentication\";\nconst _fAD = \"filterAtDestination\";\nconst _fAS = \"filterAtSource\";\nconst _fAi = \"firstAddress\";\nconst _fC = \"fulfilledCapacity\";\nconst _fCRS = \"fleetCapacityReservationSet\";\nconst _fCS = \"findingComponentSet\";\nconst _fCa = \"failureCode\";\nconst _fDN = \"fipsDnsName\";\nconst _fE = \"fipsEnabled\";\nconst _fEQS = \"flexibleEnaQueuesSupport\";\nconst _fF = \"fileFormat\";\nconst _fFCS = \"failedFleetCancellationSet\";\nconst _fFi = \"findingsFound\";\nconst _fI = \"findingId\";\nconst _fIA = \"fpgaImageAttribute\";\nconst _fIAS = \"filterInArnSet\";\nconst _fIGI = \"fpgaImageGlobalId\";\nconst _fII = \"fpgaImageId\";\nconst _fIS = \"fleetInstanceSet\";\nconst _fISp = \"fpgaImageSet\";\nconst _fIl = \"fleetId\";\nconst _fIp = \"fpgaInfo\";\nconst _fLI = \"flowLogId\";\nconst _fLIS = \"flowLogIdSet\";\nconst _fLISa = \"fastLaunchImageSet\";\nconst _fLS = \"flowLogSet\";\nconst _fLSl = \"flowLogStatus\";\nconst _fM = \"failureMessage\";\nconst _fOAS = \"filterOutArnSet\";\nconst _fODC = \"fulfilledOnDemandCapacity\";\nconst _fP = \"fromPort\";\nconst _fPCS = \"forwardPathComponentSet\";\nconst _fPi = \"filesystemProtections\";\nconst _fPix = \"fixedPrice\";\nconst _fQPDS = \"failedQueuedPurchaseDeletionSet\";\nconst _fR = \"failureReason\";\nconst _fRa = \"fastRestored\";\nconst _fS = \"fleetSet\";\nconst _fSR = \"firewallStatelessRule\";\nconst _fSRS = \"fastSnapshotRestoreSet\";\nconst _fSRSES = \"fastSnapshotRestoreStateErrorSet\";\nconst _fSRi = \"firewallStatefulRule\";\nconst _fSSIB = \"fullSnapshotSizeInBytes\";\nconst _fSST = \"firstSlotStartTime\";\nconst _fSl = \"fleetState\";\nconst _fTE = \"freeTierEligible\";\nconst _fa = \"fault\";\nconst _fp = \"fpgas\";\nconst _fr = \"from\";\nconst _fre = \"frequency\";\nconst _g = \"group\";\nconst _gA = \"groupArn\";\nconst _gAS = \"gatewayAssociationState\";\nconst _gD = \"groupDescription\";\nconst _gI = \"gatewayId\";\nconst _gIA = \"groupIpAddress\";\nconst _gIp = \"gpuInfo\";\nconst _gIr = \"groupId\";\nconst _gK = \"greKey\";\nconst _gLBAS = \"gatewayLoadBalancerArnSet\";\nconst _gLBEI = \"gatewayLoadBalancerEndpointId\";\nconst _gLN = \"groupLongName\";\nconst _gM = \"groupMember\";\nconst _gN = \"groupName\";\nconst _gOI = \"groupOwnerId\";\nconst _gS = \"groupSet\";\nconst _gSr = \"groupSource\";\nconst _gp = \"gpus\";\nconst _gr = \"groups\";\nconst _h = \"hypervisor\";\nconst _hCP = \"hiveCompatiblePartitions\";\nconst _hE = \"httpEndpoint\";\nconst _hI = \"hostId\";\nconst _hIS = \"hostIdSet\";\nconst _hM = \"hostMaintenance\";\nconst _hO = \"hibernationOptions\";\nconst _hP = \"hostProperties\";\nconst _hPI = \"httpProtocolIpv6\";\nconst _hPRHL = \"httpPutResponseHopLimit\";\nconst _hPo = \"hourlyPrice\";\nconst _hR = \"hostRecovery\";\nconst _hRGA = \"hostResourceGroupArn\";\nconst _hRI = \"hostReservationId\";\nconst _hRS = \"historyRecordSet\";\nconst _hRSo = \"hostReservationSet\";\nconst _hS = \"hostSet\";\nconst _hSi = \"hibernationSupported\";\nconst _hT = \"httpTokens\";\nconst _hTo = \"hostnameType\";\nconst _hZI = \"hostedZoneId\";\nconst _i = \"item\";\nconst _iA = \"interfaceAssociation\";\nconst _iAA = \"ipv6AddressAttribute\";\nconst _iAC = \"ipv6AddressCount\";\nconst _iAI = \"inferenceAcceleratorInfo\";\nconst _iAPI = \"ipv4AddressesPerInterface\";\nconst _iAPIp = \"ipv6AddressesPerInterface\";\nconst _iAS = \"interfaceAssociationSet\";\nconst _iASp = \"ipv6AddressesSet\";\nconst _iAT = \"ipAddressType\";\nconst _iATOI = \"includeAllTagsOfInstance\";\nconst _iAm = \"imageAllowed\";\nconst _iAp = \"ipAddress\";\nconst _iApa = \"ipamArn\";\nconst _iApv = \"ipv6Address\";\nconst _iB = \"ingressBytes\";\nconst _iBPAS = \"imageBlockPublicAccessState\";\nconst _iC = \"instanceCount\";\nconst _iCAS = \"ipv6CidrAssociationSet\";\nconst _iCB = \"ipv6CidrBlock\";\nconst _iCBA = \"ipv6CidrBlockAssociation\";\nconst _iCBAS = \"ipv6CidrBlockAssociationSet\";\nconst _iCBS = \"ipv6CidrBlockState\";\nconst _iCBSp = \"ipv6CidrBlockSet\";\nconst _iCBn = \"insideCidrBlocks\";\nconst _iCE = \"instanceConnectEndpoint\";\nconst _iCEA = \"instanceConnectEndpointArn\";\nconst _iCEI = \"instanceConnectEndpointId\";\nconst _iCES = \"instanceConnectEndpointSet\";\nconst _iCS = \"imageCriterionSet\";\nconst _iCSS = \"instanceCreditSpecificationSet\";\nconst _iCn = \"instanceCounts\";\nconst _iCp = \"ipv6Cidr\";\nconst _iD = \"imageData\";\nconst _iDAS = \"ipamDiscoveredAccountSet\";\nconst _iDPAS = \"ipamDiscoveredPublicAddressSet\";\nconst _iDRCS = \"ipamDiscoveredResourceCidrSet\";\nconst _iDs = \"isDefault\";\nconst _iE = \"instanceExport\";\nconst _iEI = \"instanceEventId\";\nconst _iERVT = \"ipamExternalResourceVerificationToken\";\nconst _iERVTA = \"ipamExternalResourceVerificationTokenArn\";\nconst _iERVTI = \"ipamExternalResourceVerificationTokenId\";\nconst _iERVTS = \"ipamExternalResourceVerificationTokenSet\";\nconst _iEW = \"instanceEventWindow\";\nconst _iEWI = \"instanceEventWindowId\";\nconst _iEWS = \"instanceEventWindowState\";\nconst _iEWSn = \"instanceEventWindowSet\";\nconst _iEs = \"isEgress\";\nconst _iF = \"instanceFamily\";\nconst _iFCS = \"instanceFamilyCreditSpecification\";\nconst _iFR = \"iamFleetRole\";\nconst _iFRS = \"ingressFilterRuleSet\";\nconst _iG = \"internetGateway\";\nconst _iGBM = \"internetGatewayBlockMode\";\nconst _iGEM = \"internetGatewayExclusionMode\";\nconst _iGI = \"internetGatewayId\";\nconst _iGS = \"internetGatewaySet\";\nconst _iGSn = \"instanceGenerationSet\";\nconst _iH = \"instanceHealth\";\nconst _iHn = \"inboundHeader\";\nconst _iI = \"instanceId\";\nconst _iIB = \"instanceInterruptionBehavior\";\nconst _iIMS = \"instanceImageMetadataSet\";\nconst _iIP = \"iamInstanceProfile\";\nconst _iIPA = \"iamInstanceProfileAssociation\";\nconst _iIPAS = \"iamInstanceProfileAssociationSet\";\nconst _iIS = \"instanceIdSet\";\nconst _iISB = \"instanceInitiatedShutdownBehavior\";\nconst _iITS = \"importImageTaskSet\";\nconst _iIm = \"importInstance\";\nconst _iIma = \"imageId\";\nconst _iIn = \"instanceIds\";\nconst _iIp = \"ipamId\";\nconst _iL = \"imageLocation\";\nconst _iLn = \"instanceLifecycle\";\nconst _iM = \"imageMetadata\";\nconst _iMC = \"instanceMatchCriteria\";\nconst _iMO = \"instanceMetadataOptions\";\nconst _iMOn = \"instanceMarketOptions\";\nconst _iMT = \"instanceMetadataTags\";\nconst _iMU = \"importManifestUrl\";\nconst _iN = \"ipv6Native\";\nconst _iOA = \"imageOwnerAlias\";\nconst _iOI = \"imageOwnerId\";\nconst _iOIn = \"instanceOwnerId\";\nconst _iOIp = \"ipOwnerId\";\nconst _iOS = \"instanceOwningService\";\nconst _iP = \"instancePort\";\nconst _iPA = \"ipamPoolAllocation\";\nconst _iPAI = \"ipamPoolAllocationId\";\nconst _iPAS = \"ipamPoolAllocationSet\";\nconst _iPAp = \"ipamPoolArn\";\nconst _iPC = \"ipamPoolCidr\";\nconst _iPCI = \"ipamPoolCidrId\";\nconst _iPCS = \"ipamPoolCidrSet\";\nconst _iPCp = \"ipv4PrefixCount\";\nconst _iPCpv = \"ipv6PrefixCount\";\nconst _iPE = \"ipPermissionsEgress\";\nconst _iPI = \"isPrimaryIpv6\";\nconst _iPIp = \"ipamPoolId\";\nconst _iPR = \"isPermanentRestore\";\nconst _iPS = \"ipamPoolSet\";\nconst _iPSm = \"imageProviderSet\";\nconst _iPSp = \"ipv6PoolSet\";\nconst _iPSpr = \"ipPrefixSet\";\nconst _iPSpv = \"ipv4PrefixSet\";\nconst _iPSpvr = \"ipv6PrefixSet\";\nconst _iPTUC = \"instancePoolsToUseCount\";\nconst _iPn = \"instancePlatform\";\nconst _iPng = \"ingressPackets\";\nconst _iPnt = \"interfacePermission\";\nconst _iPnte = \"interfaceProtocol\";\nconst _iPo = \"ioPerformance\";\nconst _iPp = \"ipamPool\";\nconst _iPpe = \"ipPermissions\";\nconst _iPpr = \"ipProtocol\";\nconst _iPpv = \"ipv4Prefix\";\nconst _iPpvo = \"ipv6Pool\";\nconst _iPpvr = \"ipv6Prefix\";\nconst _iPs = \"isPublic\";\nconst _iPsr = \"isPrimary\";\nconst _iR = \"instanceRequirements\";\nconst _iRC = \"ipamResourceCidr\";\nconst _iRCS = \"ipamResourceCidrSet\";\nconst _iRD = \"ipamResourceDiscovery\";\nconst _iRDA = \"ipamResourceDiscoveryAssociation\";\nconst _iRDAA = \"ipamResourceDiscoveryAssociationArn\";\nconst _iRDAI = \"ipamResourceDiscoveryAssociationId\";\nconst _iRDAS = \"ipamResourceDiscoveryAssociationSet\";\nconst _iRDAp = \"ipamResourceDiscoveryArn\";\nconst _iRDI = \"ipamResourceDiscoveryId\";\nconst _iRDR = \"ipamResourceDiscoveryRegion\";\nconst _iRDS = \"ipamResourceDiscoverySet\";\nconst _iRT = \"ingressRouteTable\";\nconst _iRp = \"ipamRegion\";\nconst _iRpa = \"ipRanges\";\nconst _iRpv = \"ipv6Ranges\";\nconst _iS = \"ipamScope\";\nconst _iSA = \"ipamScopeArn\";\nconst _iSI = \"instanceStorageInfo\";\nconst _iSIp = \"ipamScopeId\";\nconst _iSS = \"instanceStatusSet\";\nconst _iSSn = \"instanceStorageSupported\";\nconst _iSSp = \"ipamScopeSet\";\nconst _iST = \"ipamScopeType\";\nconst _iSTS = \"importSnapshotTaskSet\";\nconst _iSg = \"igmpv2Support\";\nconst _iSm = \"imagesSet\";\nconst _iSma = \"imageState\";\nconst _iSmag = \"imageSet\";\nconst _iSmd = \"imdsSupport\";\nconst _iSmp = \"impairedSince\";\nconst _iSn = \"instancesSet\";\nconst _iSns = \"instanceSet\";\nconst _iSnst = \"instanceState\";\nconst _iSnsta = \"instanceStatus\";\nconst _iSp = \"ipamSet\";\nconst _iSpo = \"ipSource\";\nconst _iSpv = \"ipv6Supported\";\nconst _iSpvu = \"ipv6Support\";\nconst _iT = \"instanceType\";\nconst _iTA = \"instanceTagAttribute\";\nconst _iTC = \"icmpTypeCode\";\nconst _iTCn = \"includeTrustContext\";\nconst _iTI = \"importTaskId\";\nconst _iTKS = \"instanceTagKeySet\";\nconst _iTOS = \"instanceTypeOfferingSet\";\nconst _iTS = \"instanceTypeSet\";\nconst _iTSS = \"instanceTypeSpecificationSet\";\nconst _iTm = \"imageType\";\nconst _iTn = \"instanceTypes\";\nconst _iTns = \"instanceTenancy\";\nconst _iTnt = \"interfaceType\";\nconst _iU = \"ipUsage\";\nconst _iUS = \"instanceUsageSet\";\nconst _iV = \"ikeVersion\";\nconst _iVE = \"isValidExchange\";\nconst _iVS = \"ikeVersionSet\";\nconst _iVm = \"importVolume\";\nconst _id = \"id\";\nconst _im = \"image\";\nconst _in = \"instance\";\nconst _ins = \"instances\";\nconst _int = \"interval\";\nconst _io = \"iops\";\nconst _ip = \"ipam\";\nconst _is = \"issuer\";\nconst _k = \"key\";\nconst _kDF = \"kinesisDataFirehose\";\nconst _kF = \"keyFormat\";\nconst _kFe = \"keyFingerprint\";\nconst _kI = \"kernelId\";\nconst _kKA = \"kmsKeyArn\";\nconst _kKI = \"kmsKeyId\";\nconst _kM = \"keyMaterial\";\nconst _kN = \"keyName\";\nconst _kPI = \"keyPairId\";\nconst _kS = \"keySet\";\nconst _kSe = \"kextSigning\";\nconst _kT = \"keyType\";\nconst _kV = \"keyValue\";\nconst _ke = \"kernel\";\nconst _key = \"keyword\";\nconst _l = \"lifecycle\";\nconst _lA = \"localAddress\";\nconst _lADT = \"lastAttemptedDiscoveryTime\";\nconst _lAZ = \"launchedAvailabilityZone\";\nconst _lAa = \"lastAddress\";\nconst _lBA = \"loadBalancerArn\";\nconst _lBAE = \"localBgpAsnExtended\";\nconst _lBAo = \"localBgpAsn\";\nconst _lBC = \"loadBalancersConfig\";\nconst _lBLP = \"loadBalancerListenerPort\";\nconst _lBO = \"loadBalancerOptions\";\nconst _lBP = \"loadBalancerPort\";\nconst _lBS = \"loadBalancerSet\";\nconst _lBT = \"loadBalancerTarget\";\nconst _lBTG = \"loadBalancerTargetGroup\";\nconst _lBTGS = \"loadBalancerTargetGroupSet\";\nconst _lBTP = \"loadBalancerTargetPort\";\nconst _lC = \"loggingConfiguration\";\nconst _lCA = \"licenseConfigurationArn\";\nconst _lCO = \"lockCreatedOn\";\nconst _lCS = \"loggingConfigurationSet\";\nconst _lD = \"logDestination\";\nconst _lDST = \"lockDurationStartTime\";\nconst _lDT = \"logDestinationType\";\nconst _lDo = \"lockDuration\";\nconst _lE = \"logEnabled\";\nconst _lEO = \"lockExpiresOn\";\nconst _lET = \"lastEvaluatedTime\";\nconst _lEa = \"lastError\";\nconst _lF = \"logFormat\";\nconst _lFA = \"lambdaFunctionArn\";\nconst _lG = \"launchGroup\";\nconst _lGA = \"logGroupArn\";\nconst _lGI = \"localGatewayId\";\nconst _lGN = \"logGroupName\";\nconst _lGRT = \"localGatewayRouteTable\";\nconst _lGRTA = \"localGatewayRouteTableArn\";\nconst _lGRTI = \"localGatewayRouteTableId\";\nconst _lGRTS = \"localGatewayRouteTableSet\";\nconst _lGRTVA = \"localGatewayRouteTableVpcAssociation\";\nconst _lGRTVAI = \"localGatewayRouteTableVpcAssociationId\";\nconst _lGRTVAS = \"localGatewayRouteTableVpcAssociationSet\";\nconst _lGRTVIGA = \"localGatewayRouteTableVirtualInterfaceGroupAssociation\";\nconst _lGRTVIGAI = \"localGatewayRouteTableVirtualInterfaceGroupAssociationId\";\nconst _lGRTVIGAS = \"localGatewayRouteTableVirtualInterfaceGroupAssociationSet\";\nconst _lGS = \"localGatewaySet\";\nconst _lGVI = \"localGatewayVirtualInterface\";\nconst _lGVIA = \"localGatewayVirtualInterfaceArn\";\nconst _lGVIG = \"localGatewayVirtualInterfaceGroup\";\nconst _lGVIGA = \"localGatewayVirtualInterfaceGroupArn\";\nconst _lGVIGI = \"localGatewayVirtualInterfaceGroupId\";\nconst _lGVIGS = \"localGatewayVirtualInterfaceGroupSet\";\nconst _lGVII = \"localGatewayVirtualInterfaceId\";\nconst _lGVIIS = \"localGatewayVirtualInterfaceIdSet\";\nconst _lGVIS = \"localGatewayVirtualInterfaceSet\";\nconst _lGo = \"logGroup\";\nconst _lINC = \"localIpv4NetworkCidr\";\nconst _lINCo = \"localIpv6NetworkCidr\";\nconst _lLT = \"lastLaunchedTime\";\nconst _lMA = \"lastMaintenanceApplied\";\nconst _lO = \"logOptions\";\nconst _lOF = \"logOutputFormat\";\nconst _lP = \"loadPermissions\";\nconst _lPa = \"launchPermission\";\nconst _lS = \"licenseSpecifications\";\nconst _lSC = \"lastStatusChange\";\nconst _lSDT = \"lastSuccessfulDiscoveryTime\";\nconst _lSTS = \"localStorageTypeSet\";\nconst _lSa = \"launchSpecifications\";\nconst _lSau = \"launchSpecification\";\nconst _lSi = \"licenseSet\";\nconst _lSo = \"localStorage\";\nconst _lSoc = \"lockState\";\nconst _lT = \"launchTemplate\";\nconst _lTAO = \"launchTemplateAndOverrides\";\nconst _lTC = \"launchTemplateConfigs\";\nconst _lTD = \"launchTemplateData\";\nconst _lTI = \"launchTemplateId\";\nconst _lTN = \"launchTemplateName\";\nconst _lTOS = \"lastTieringOperationStatus\";\nconst _lTOSD = \"lastTieringOperationStatusDetail\";\nconst _lTP = \"lastTieringProgress\";\nconst _lTS = \"launchTemplateSpecification\";\nconst _lTST = \"lastTieringStartTime\";\nconst _lTV = \"launchTemplateVersion\";\nconst _lTVS = \"launchTemplateVersionSet\";\nconst _lTa = \"launchTemplates\";\nconst _lTau = \"launchTime\";\nconst _lTi = \"licenseType\";\nconst _lTo = \"locationType\";\nconst _lUT = \"lastUpdateTime\";\nconst _lUTa = \"lastUpdatedTime\";\nconst _lUTas = \"lastUpdateTimestamp\";\nconst _lV = \"logVersion\";\nconst _lVN = \"latestVersionNumber\";\nconst _lo = \"location\";\nconst _loc = \"locale\";\nconst _m = \"min\";\nconst _mA = \"mutualAuthentication\";\nconst _mAAA = \"maintenanceAutoAppliedAfter\";\nconst _mAE = \"multiAttachEnabled\";\nconst _mAI = \"maxAggregationInterval\";\nconst _mAIe = \"mediaAcceleratorInfo\";\nconst _mASS = \"movingAddressStatusSet\";\nconst _mAa = \"macAddress\";\nconst _mAe = \"meteredAccount\";\nconst _mB = \"managedBy\";\nconst _mBIM = \"maximumBandwidthInMbps\";\nconst _mC = \"missingComponent\";\nconst _mCOIOL = \"mapCustomerOwnedIpOnLaunch\";\nconst _mD = \"maintenanceDetails\";\nconst _mDA = \"multicastDomainAssociations\";\nconst _mDK = \"metaDataKey\";\nconst _mDV = \"metaDataValue\";\nconst _mDe = \"metaData\";\nconst _mE = \"maxEntries\";\nconst _mEI = \"maximumEfaInterfaces\";\nconst _mEM = \"managedExceptionMessage\";\nconst _mEQC = \"maximumEnaQueueCount\";\nconst _mEQCPI = \"maximumEnaQueueCountPerInterface\";\nconst _mFV = \"mostFrequentValue\";\nconst _mG = \"multicastGroups\";\nconst _mGBPVC = \"memoryGiBPerVCpu\";\nconst _mHS = \"macHostSet\";\nconst _mI = \"maximumIops\";\nconst _mIe = \"memoryInfo\";\nconst _mMB = \"memoryMiB\";\nconst _mMT = \"macModificationTask\";\nconst _mMTI = \"macModificationTaskId\";\nconst _mMTS = \"macModificationTaskSet\";\nconst _mNC = \"maximumNetworkCards\";\nconst _mNI = \"maximumNetworkInterfaces\";\nconst _mO = \"metadataOptions\";\nconst _mOSLRG = \"memberOfServiceLinkedResourceGroup\";\nconst _mOSLSVS = \"macOSLatestSupportedVersionSet\";\nconst _mOa = \"maintenanceOptions\";\nconst _mP = \"maxPrice\";\nconst _mPIOL = \"mapPublicIpOnLaunch\";\nconst _mPL = \"maxParallelLaunches\";\nconst _mPS = \"metricPointSet\";\nconst _mPSa = \"matchPathSet\";\nconst _mR = \"maxResults\";\nconst _mRS = \"modificationResultSet\";\nconst _mS = \"messageSet\";\nconst _mSIPC = \"macSystemIntegrityProtectionConfig\";\nconst _mSPAPOOODP = \"maxSpotPriceAsPercentageOfOptimalOnDemandPrice\";\nconst _mSa = \"managementState\";\nconst _mSai = \"maintenanceStrategies\";\nconst _mSo = \"moveStatus\";\nconst _mSod = \"modificationState\";\nconst _mSu = \"multicastSupport\";\nconst _mT = \"marketType\";\nconst _mTC = \"minTargetCapacity\";\nconst _mTDID = \"maxTermDurationInDays\";\nconst _mTDIDi = \"minTermDurationInDays\";\nconst _mTIMB = \"maximumThroughputInMBps\";\nconst _mTP = \"maxTotalPrice\";\nconst _mTe = \"memberType\";\nconst _mVE = \"managesVpcEndpoints\";\nconst _ma = \"max\";\nconst _mai = \"main\";\nconst _man = \"manufacturer\";\nconst _mana = \"managed\";\nconst _mar = \"marketplace\";\nconst _me = \"message\";\nconst _med = \"med\";\nconst _mem = \"member\";\nconst _met = \"metric\";\nconst _mo = \"monitoring\";\nconst _mod = \"mode\";\nconst _n = \"name\";\nconst _nA = \"networkAcl\";\nconst _nAAI = \"networkAclAssociationId\";\nconst _nAI = \"networkAclId\";\nconst _nAIe = \"newAssociationId\";\nconst _nAOO = \"nativeApplicationOidcOptions\";\nconst _nAS = \"networkAclSet\";\nconst _nAo = \"notAfter\";\nconst _nB = \"notBefore\";\nconst _nBD = \"notBeforeDeadline\";\nconst _nBG = \"networkBorderGroup\";\nconst _nBGe = \"networkBandwidthGbps\";\nconst _nC = \"networkCards\";\nconst _nCI = \"networkCardIndex\";\nconst _nD = \"noDevice\";\nconst _nDe = \"neuronDevices\";\nconst _nES = \"nitroEnclavesSupport\";\nconst _nG = \"natGateway\";\nconst _nGAS = \"natGatewayAddressSet\";\nconst _nGI = \"natGatewayId\";\nconst _nGS = \"natGatewaySet\";\nconst _nHI = \"nextHopIp\";\nconst _nI = \"networkId\";\nconst _nIA = \"networkInsightsAnalysis\";\nconst _nIAA = \"networkInsightsAnalysisArn\";\nconst _nIAI = \"networkInsightsAnalysisId\";\nconst _nIAS = \"networkInsightsAccessScope\";\nconst _nIASA = \"networkInsightsAccessScopeArn\";\nconst _nIASAA = \"networkInsightsAccessScopeAnalysisArn\";\nconst _nIASAI = \"networkInsightsAccessScopeAnalysisId\";\nconst _nIASAS = \"networkInsightsAccessScopeAnalysisSet\";\nconst _nIASAe = \"networkInsightsAccessScopeAnalysis\";\nconst _nIASC = \"networkInsightsAccessScopeContent\";\nconst _nIASI = \"networkInsightsAccessScopeId\";\nconst _nIASS = \"networkInsightsAccessScopeSet\";\nconst _nIASe = \"networkInsightsAnalysisSet\";\nconst _nIASet = \"networkInterfaceAttachmentStatus\";\nconst _nIC = \"networkInterfaceCount\";\nconst _nID = \"networkInterfaceDescription\";\nconst _nII = \"networkInterfaceId\";\nconst _nIIS = \"networkInterfaceIdSet\";\nconst _nIO = \"networkInterfaceOptions\";\nconst _nIOI = \"networkInterfaceOwnerId\";\nconst _nIP = \"networkInsightsPath\";\nconst _nIPA = \"networkInsightsPathArn\";\nconst _nIPI = \"networkInsightsPathId\";\nconst _nIPIe = \"networkInterfacePermissionId\";\nconst _nIPS = \"networkInsightsPathSet\";\nconst _nIPe = \"networkInterfacePermissions\";\nconst _nIS = \"networkInterfaceSet\";\nconst _nIe = \"networkInterface\";\nconst _nIet = \"networkInfo\";\nconst _nIeu = \"neuronInfo\";\nconst _nL = \"netmaskLength\";\nconst _nLBA = \"networkLoadBalancerArn\";\nconst _nLBAS = \"networkLoadBalancerArnSet\";\nconst _nNS = \"networkNodeSet\";\nconst _nOA = \"numberOfAccounts\";\nconst _nOFA = \"numberOfFailedAccounts\";\nconst _nOMA = \"numberOfMatchedAccounts\";\nconst _nOUA = \"numberOfUnmatchedAccounts\";\nconst _nP = \"nvramProtections\";\nconst _nPF = \"networkPathFound\";\nconst _nPO = \"networkPerformanceOptions\";\nconst _nPe = \"networkPerformance\";\nconst _nPet = \"networkPlatform\";\nconst _nS = \"nvmeSupport\";\nconst _nSS = \"networkServiceSet\";\nconst _nSST = \"nextSlotStartTime\";\nconst _nSa = \"nameserverSet\";\nconst _nT = \"networkType\";\nconst _nTI = \"nitroTpmInfo\";\nconst _nTS = \"nitroTpmSupport\";\nconst _nTe = \"nextToken\";\nconst _o = \"origin\";\nconst _oA = \"outpostArn\";\nconst _oAr = \"organizationArn\";\nconst _oAw = \"ownerAlias\";\nconst _oC = \"offeringClass\";\nconst _oDAS = \"onDemandAllocationStrategy\";\nconst _oDFC = \"onDemandFulfilledCapacity\";\nconst _oDMPPOLP = \"onDemandMaxPricePercentageOverLowestPrice\";\nconst _oDMTP = \"onDemandMaxTotalPrice\";\nconst _oDO = \"onDemandOptions\";\nconst _oDS = \"occurrenceDaySet\";\nconst _oDTC = \"onDemandTargetCapacity\";\nconst _oEP = \"organizationsEntityPath\";\nconst _oH = \"outboundHeader\";\nconst _oI = \"ownerId\";\nconst _oIA = \"outsideIpAddress\";\nconst _oIAT = \"outsideIpAddressType\";\nconst _oIS = \"optInStatus\";\nconst _oIf = \"offeringId\";\nconst _oIr = \"originalIops\";\nconst _oIu = \"outpostId\";\nconst _oK = \"objectKey\";\nconst _oLI = \"outpostLagId\";\nconst _oLS = \"outpostLagSet\";\nconst _oMAE = \"originalMultiAttachEnabled\";\nconst _oO = \"oidcOptions\";\nconst _oRIWEA = \"outputReservedInstancesWillExpireAt\";\nconst _oRS = \"operatingRegionSet\";\nconst _oRTE = \"occurrenceRelativeToEnd\";\nconst _oS = \"offeringSet\";\nconst _oST = \"oldestSampleTime\";\nconst _oSr = \"originalSize\";\nconst _oSv = \"overlapStatus\";\nconst _oT = \"optimizingTime\";\nconst _oTf = \"offeringType\";\nconst _oTr = \"originalThroughput\";\nconst _oU = \"occurrenceUnit\";\nconst _oUA = \"organizationalUnitArn\";\nconst _oUES = \"organizationalUnitExclusionSet\";\nconst _oUI = \"organizationalUnitId\";\nconst _oVCS = \"openVpnConfigurationSet\";\nconst _oVT = \"originalVolumeType\";\nconst _op = \"operator\";\nconst _opt = \"options\";\nconst _ou = \"output\";\nconst _ov = \"overrides\";\nconst _ow = \"owner\";\nconst _p = \"principal\";\nconst _pA = \"poolArn\";\nconst _pAI = \"peeringAttachmentId\";\nconst _pAR = \"poolAddressRange\";\nconst _pARS = \"poolAddressRangeSet\";\nconst _pAe = \"peerAddress\";\nconst _pAee = \"peerAsn\";\nconst _pAu = \"publiclyAdvertisable\";\nconst _pB = \"provisionedBandwidth\";\nconst _pBA = \"peerBgpAsn\";\nconst _pBAE = \"peerBgpAsnExtended\";\nconst _pBIG = \"peakBandwidthInGbps\";\nconst _pC = \"productCodes\";\nconst _pCB = \"poolCidrBlock\";\nconst _pCBS = \"poolCidrBlockSet\";\nconst _pCI = \"preserveClientIp\";\nconst _pCNI = \"peerCoreNetworkId\";\nconst _pCS = \"poolCidrSet\";\nconst _pCSS = \"postureComplianceStatusSet\";\nconst _pCa = \"partitionCount\";\nconst _pCo = \"poolCount\";\nconst _pCr = \"productCode\";\nconst _pD = \"passwordData\";\nconst _pDE = \"privateDnsEnabled\";\nconst _pDEr = \"privateDnsEntry\";\nconst _pDHG = \"phase1DHGroup\";\nconst _pDHGNS = \"phase1DHGroupNumberSet\";\nconst _pDHGNSh = \"phase2DHGroupNumberSet\";\nconst _pDHGh = \"phase2DHGroup\";\nconst _pDN = \"privateDnsName\";\nconst _pDNC = \"privateDnsNameConfiguration\";\nconst _pDNO = \"privateDnsNameOptions\";\nconst _pDNOOL = \"privateDnsNameOptionsOnLaunch\";\nconst _pDNS = \"privateDnsNameSet\";\nconst _pDNVS = \"privateDnsNameVerificationState\";\nconst _pDNu = \"publicDnsName\";\nconst _pDOFIRE = \"privateDnsOnlyForInboundResolverEndpoint\";\nconst _pDRTI = \"propagationDefaultRouteTableId\";\nconst _pDS = \"pricingDetailsSet\";\nconst _pDSDN = \"publicDualStackDnsName\";\nconst _pDSI = \"publicDefaultScopeId\";\nconst _pDSIr = \"privateDefaultScopeId\";\nconst _pDa = \"paymentDue\";\nconst _pDl = \"platformDetails\";\nconst _pDo = \"policyDocument\";\nconst _pDoo = \"poolDepth\";\nconst _pDr = \"productDescription\";\nconst _pE = \"policyEnabled\";\nconst _pEA = \"phase1EncryptionAlgorithm\";\nconst _pEAS = \"phase1EncryptionAlgorithmSet\";\nconst _pEASh = \"phase2EncryptionAlgorithmSet\";\nconst _pEAh = \"phase2EncryptionAlgorithm\";\nconst _pEk = \"pkceEnabled\";\nconst _pF = \"packetField\";\nconst _pFS = \"previousFleetState\";\nconst _pG = \"placementGroup\";\nconst _pGA = \"placementGroupArn\";\nconst _pGI = \"placementGroupInfo\";\nconst _pGS = \"placementGroupSet\";\nconst _pHP = \"perHourPartition\";\nconst _pHS = \"packetHeaderStatement\";\nconst _pI = \"publicIp\";\nconst _pIA = \"phase1IntegrityAlgorithm\";\nconst _pIAS = \"privateIpAddressesSet\";\nconst _pIASh = \"phase1IntegrityAlgorithmSet\";\nconst _pIASha = \"phase2IntegrityAlgorithmSet\";\nconst _pIAh = \"phase2IntegrityAlgorithm\";\nconst _pIAr = \"privateIpAddress\";\nconst _pIDN = \"publicIpv6DnsName\";\nconst _pIDNO = \"publicIpDnsNameOptions\";\nconst _pIDNu = \"publicIpv4DnsName\";\nconst _pIP = \"publicIpv4Pool\";\nconst _pIPI = \"publicIpv4PoolId\";\nconst _pIPS = \"publicIpv4PoolSet\";\nconst _pIS = \"publicIpSource\";\nconst _pIc = \"pciId\";\nconst _pIo = \"poolId\";\nconst _pIr = \"processorInfo\";\nconst _pIri = \"primaryIpv6\";\nconst _pIriv = \"privateIp\";\nconst _pK = \"publicKey\";\nconst _pL = \"prefixList\";\nconst _pLA = \"prefixListArn\";\nconst _pLAS = \"prefixListAssociationSet\";\nconst _pLD = \"peerLivenessDetection\";\nconst _pLI = \"prefixListId\";\nconst _pLIr = \"prefixListIds\";\nconst _pLN = \"prefixListName\";\nconst _pLOI = \"prefixListOwnerId\";\nconst _pLS = \"prefixListSet\";\nconst _pLSh = \"phase1LifetimeSeconds\";\nconst _pLSha = \"phase2LifetimeSeconds\";\nconst _pLa = \"packetLength\";\nconst _pM = \"pendingMaintenance\";\nconst _pN = \"partitionNumber\";\nconst _pO = \"paymentOption\";\nconst _pOe = \"peeringOptions\";\nconst _pP = \"progressPercentage\";\nconst _pR = \"ptrRecord\";\nconst _pRD = \"persistRoutesDuration\";\nconst _pRN = \"policyRuleNumber\";\nconst _pRNo = \"policyReferenceName\";\nconst _pRS = \"portRangeSet\";\nconst _pRSe = \"persistRoutesState\";\nconst _pRU = \"ptrRecordUpdate\";\nconst _pRa = \"payerResponsibility\";\nconst _pRo = \"portRange\";\nconst _pRol = \"policyRule\";\nconst _pS = \"provisioningStatus\";\nconst _pSET = \"previousSlotEndTime\";\nconst _pSFRS = \"previousSpotFleetRequestState\";\nconst _pSK = \"preSharedKey\";\nconst _pSKA = \"preSharedKeyArn\";\nconst _pSKE = \"publicSigningKeyEndpoint\";\nconst _pSKU = \"publicSigningKeyUrl\";\nconst _pSR = \"provisioningStatusReason\";\nconst _pSe = \"permissionState\";\nconst _pSee = \"peeringStatus\";\nconst _pSh = \"phcSupport\";\nconst _pSr = \"previousState\";\nconst _pSre = \"previousStatus\";\nconst _pSri = \"principalSet\";\nconst _pSric = \"priceSchedules\";\nconst _pSro = \"protocolSet\";\nconst _pT = \"principalType\";\nconst _pTGI = \"peerTransitGatewayId\";\nconst _pTr = \"provisionTime\";\nconst _pTu = \"purchaseToken\";\nconst _pVI = \"primaryVpcId\";\nconst _pVS = \"propagatingVgwSet\";\nconst _pZI = \"parentZoneId\";\nconst _pZN = \"parentZoneName\";\nconst _pe = \"period\";\nconst _per = \"permission\";\nconst _pl = \"platform\";\nconst _pla = \"placement\";\nconst _po = \"port\";\nconst _pr = \"protocol\";\nconst _pre = \"prefix\";\nconst _pri = \"priority\";\nconst _pric = \"price\";\nconst _prim = \"primary\";\nconst _pro = \"progress\";\nconst _prop = \"propagation\";\nconst _prov = \"provisioned\";\nconst _pu = \"public\";\nconst _pur = \"purchase\";\nconst _r = \"return\";\nconst _rA = \"ruleAction\";\nconst _rAE = \"remoteAccessEnabled\";\nconst _rAe = \"resourceArn\";\nconst _rB = \"requestedBy\";\nconst _rBET = \"recycleBinEnterTime\";\nconst _rBETe = \"recycleBinExitTime\";\nconst _rC = \"returnCode\";\nconst _rCA = \"resourceConfigurationArn\";\nconst _rCGA = \"resourceConfigurationGroupArn\";\nconst _rCS = \"resourceComplianceStatus\";\nconst _rCe = \"resourceCidr\";\nconst _rCec = \"recurringCharges\";\nconst _rD = \"restoreDuration\";\nconst _rDAC = \"resourceDiscoveryAssociationCount\";\nconst _rDCA = \"rdsDbClusterArn\";\nconst _rDI = \"ramDiskId\";\nconst _rDIA = \"rdsDbInstanceArn\";\nconst _rDN = \"rootDeviceName\";\nconst _rDPA = \"rdsDbProxyArn\";\nconst _rDS = \"resourceDiscoveryStatus\";\nconst _rDT = \"rootDeviceType\";\nconst _rE = \"responseError\";\nconst _rET = \"restoreExpiryTime\";\nconst _rEd = \"rdsEndpoint\";\nconst _rEe = \"regionEndpoint\";\nconst _rEes = \"resourceExclusions\";\nconst _rFP = \"rekeyFuzzPercentage\";\nconst _rGA = \"ruleGroupArn\";\nconst _rGI = \"referencedGroupId\";\nconst _rGIe = \"referencedGroupInfo\";\nconst _rGROPS = \"ruleGroupRuleOptionsPairSet\";\nconst _rGT = \"ruleGroupType\";\nconst _rGTPS = \"ruleGroupTypePairSet\";\nconst _rHS = \"requireHibernateSupport\";\nconst _rI = \"reportId\";\nconst _rIDS = \"routeInstallationDetailSet\";\nconst _rII = \"reservedInstancesId\";\nconst _rIIe = \"reservedInstanceId\";\nconst _rILI = \"reservedInstancesListingId\";\nconst _rILS = \"reservedInstancesListingsSet\";\nconst _rIMI = \"reservedInstancesModificationId\";\nconst _rIMS = \"reservedInstancesModificationsSet\";\nconst _rINC = \"remoteIpv4NetworkCidr\";\nconst _rINCe = \"remoteIpv6NetworkCidr\";\nconst _rIOI = \"reservedInstancesOfferingId\";\nconst _rIOS = \"reservedInstancesOfferingsSet\";\nconst _rIS = \"reservedInstancesSet\";\nconst _rISR = \"routeInstallationStatusReason\";\nconst _rISo = \"routeInstallationStatus\";\nconst _rIVR = \"reservedInstanceValueRollup\";\nconst _rIVS = \"reservedInstanceValueSet\";\nconst _rIa = \"ramdiskId\";\nconst _rIe = \"regionInfo\";\nconst _rIeq = \"requesterId\";\nconst _rIes = \"resourceId\";\nconst _rIese = \"reservationId\";\nconst _rM = \"rebootMigration\";\nconst _rMGM = \"registeredMulticastGroupMembers\";\nconst _rMGS = \"registeredMulticastGroupSources\";\nconst _rMS = \"rebootMigrationSupport\";\nconst _rMTS = \"rekeyMarginTimeSeconds\";\nconst _rMe = \"requesterManaged\";\nconst _rN = \"ruleNumber\";\nconst _rNII = \"registeredNetworkInterfaceIds\";\nconst _rNe = \"regionName\";\nconst _rNes = \"resourceName\";\nconst _rNo = \"roleName\";\nconst _rO = \"resourceOwner\";\nconst _rOI = \"resourceOwnerId\";\nconst _rOS = \"ruleOptionSet\";\nconst _rOSe = \"resourceOverlapStatus\";\nconst _rOd = \"rdsOptions\";\nconst _rOo = \"routeOrigin\";\nconst _rPCO = \"requesterPeeringConnectionOptions\";\nconst _rPCS = \"returnPathComponentSet\";\nconst _rR = \"resourceRegion\";\nconst _rRVT = \"replaceRootVolumeTask\";\nconst _rRVTI = \"replaceRootVolumeTaskId\";\nconst _rRVTS = \"replaceRootVolumeTaskSet\";\nconst _rS = \"referenceSet\";\nconst _rSA = \"routeServerAssociation\";\nconst _rSAS = \"routeServerAssociationSet\";\nconst _rSE = \"routeServerEndpoint\";\nconst _rSEI = \"routeServerEndpointId\";\nconst _rSES = \"routeServerEndpointSet\";\nconst _rSGRS = \"revokedSecurityGroupRuleSet\";\nconst _rSI = \"routeServerId\";\nconst _rSP = \"routeServerPeer\";\nconst _rSPI = \"routeServerPeerId\";\nconst _rSPS = \"routeServerPeerSet\";\nconst _rSPSo = \"routeServerPropagationSet\";\nconst _rSPo = \"routeServerPropagation\";\nconst _rSS = \"regionalSummarySet\";\nconst _rSSo = \"routeServerSet\";\nconst _rST = \"restoreStartTime\";\nconst _rSe = \"reportSet\";\nconst _rSep = \"replacementStrategy\";\nconst _rSes = \"reservationSet\";\nconst _rSeso = \"resourceStatement\";\nconst _rSesou = \"resourceSet\";\nconst _rSo = \"routeServer\";\nconst _rSou = \"routeSet\";\nconst _rSout = \"routeStatus\";\nconst _rT = \"reservationType\";\nconst _rTAI = \"routeTableAssociationId\";\nconst _rTI = \"routeTableId\";\nconst _rTIS = \"routeTableIdSet\";\nconst _rTIe = \"requesterTgwInfo\";\nconst _rTR = \"routeTableRoute\";\nconst _rTS = \"routeTableSet\";\nconst _rTSe = \"resourceTagSet\";\nconst _rTSes = \"resourceTypeSet\";\nconst _rTV = \"remainingTotalValue\";\nconst _rTe = \"resourceType\";\nconst _rTel = \"releaseTime\";\nconst _rTeq = \"requestTime\";\nconst _rTo = \"routeTable\";\nconst _rUI = \"replaceUnhealthyInstances\";\nconst _rUV = \"remainingUpfrontValue\";\nconst _rV = \"returnValue\";\nconst _rVI = \"referencingVpcId\";\nconst _rVIe = \"requesterVpcInfo\";\nconst _rVe = \"reservationValue\";\nconst _rWS = \"replayWindowSize\";\nconst _ra = \"ramdisk\";\nconst _re = \"region\";\nconst _rea = \"reason\";\nconst _rec = \"recurrence\";\nconst _req = \"requested\";\nconst _res = \"result\";\nconst _reso = \"resource\";\nconst _ro = \"route\";\nconst _rou = \"routes\";\nconst _s = \"source\";\nconst _sA = \"sourceArn\";\nconst _sAS = \"sourceAddressSet\";\nconst _sASu = \"suggestedAccountSet\";\nconst _sAZ = \"singleAvailabilityZone\";\nconst _sAo = \"sourceAddress\";\nconst _sAt = \"startupAction\";\nconst _sAu = \"supportedArchitectures\";\nconst _sAub = \"subnetArn\";\nconst _sB = \"s3Bucket\";\nconst _sBM = \"supportedBootModes\";\nconst _sC = \"serviceConfiguration\";\nconst _sCA = \"serverCertificateArn\";\nconst _sCAE = \"serialConsoleAccessEnabled\";\nconst _sCB = \"sourceCidrBlock\";\nconst _sCR = \"sourceCapacityReservation\";\nconst _sCRI = \"subnetCidrReservationId\";\nconst _sCRu = \"subnetCidrReservation\";\nconst _sCS = \"serviceConfigurationSet\";\nconst _sCSIG = \"sustainedClockSpeedInGhz\";\nconst _sCc = \"scopeCount\";\nconst _sCn = \"snapshotConfiguration\";\nconst _sD = \"startDate\";\nconst _sDC = \"sourceDestCheck\";\nconst _sDIH = \"slotDurationInHours\";\nconst _sDLTVS = \"successfullyDeletedLaunchTemplateVersionSet\";\nconst _sDS = \"spotDatafeedSubscription\";\nconst _sDSe = \"serviceDetailSet\";\nconst _sDSn = \"snapshotDetailSet\";\nconst _sDp = \"spreadDomain\";\nconst _sDu = \"subDomain\";\nconst _sEL = \"s3ExportLocation\";\nconst _sET = \"sampledEndTime\";\nconst _sF = \"supportedFeatures\";\nconst _sFCS = \"successfulFleetCancellationSet\";\nconst _sFDS = \"successfulFleetDeletionSet\";\nconst _sFRC = \"spotFleetRequestConfig\";\nconst _sFRCS = \"spotFleetRequestConfigSet\";\nconst _sFRI = \"spotFleetRequestId\";\nconst _sFRS = \"successfulFleetRequestSet\";\nconst _sFRSp = \"spotFleetRequestState\";\nconst _sG = \"securityGroup\";\nconst _sGA = \"securityGroupArn\";\nconst _sGFVS = \"securityGroupForVpcSet\";\nconst _sGI = \"securityGroupId\";\nconst _sGIS = \"securityGroupIdSet\";\nconst _sGIe = \"securityGroupIds\";\nconst _sGIec = \"securityGroupInfo\";\nconst _sGR = \"securityGroupRule\";\nconst _sGRA = \"securityGroupRuleArn\";\nconst _sGRI = \"securityGroupRuleId\";\nconst _sGRS = \"securityGroupRuleSet\";\nconst _sGRSe = \"securityGroupReferenceSet\";\nconst _sGRSec = \"securityGroupReferencingSupport\";\nconst _sGS = \"securityGroupSet\";\nconst _sGVAS = \"securityGroupVpcAssociationSet\";\nconst _sGe = \"securityGroups\";\nconst _sH = \"startHour\";\nconst _sI = \"serviceId\";\nconst _sIAS = \"scheduledInstanceAvailabilitySet\";\nconst _sIATS = \"supportedIpAddressTypeSet\";\nconst _sICRS = \"subnetIpv4CidrReservationSet\";\nconst _sICRSu = \"subnetIpv6CidrReservationSet\";\nconst _sICSS = \"successfulInstanceCreditSpecificationSet\";\nconst _sIGB = \"sizeInGB\";\nconst _sII = \"sourceInstanceId\";\nconst _sIIc = \"scheduledInstanceId\";\nconst _sIIo = \"sourceImageId\";\nconst _sIMB = \"sizeInMiB\";\nconst _sIP = \"staleIpPermissions\";\nconst _sIPE = \"staleIpPermissionsEgress\";\nconst _sIPI = \"sourceIpamPoolId\";\nconst _sIR = \"sourceImageRegion\";\nconst _sIRI = \"spotInstanceRequestId\";\nconst _sIRS = \"spotInstanceRequestSet\";\nconst _sIS = \"scheduledInstanceSet\";\nconst _sISu = \"subnetIdSet\";\nconst _sIT = \"spotInstanceType\";\nconst _sITRS = \"storeImageTaskResultSet\";\nconst _sITi = \"singleInstanceType\";\nconst _sIn = \"snapshotId\";\nconst _sIo = \"sourceIp\";\nconst _sIu = \"subnetId\";\nconst _sIub = \"subnetIds\";\nconst _sK = \"s3Key\";\nconst _sKo = \"s3objectKey\";\nconst _sL = \"s3Location\";\nconst _sLVIA = \"serviceLinkVirtualInterfaceArn\";\nconst _sLVII = \"serviceLinkVirtualInterfaceId\";\nconst _sLVIIS = \"serviceLinkVirtualInterfaceIdSet\";\nconst _sLVIS = \"serviceLinkVirtualInterfaceSet\";\nconst _sLp = \"spreadLevel\";\nconst _sM = \"serviceManaged\";\nconst _sMPPOLP = \"spotMaxPricePercentageOverLowestPrice\";\nconst _sMS = \"spotMaintenanceStrategies\";\nconst _sMTP = \"spotMaxTotalPrice\";\nconst _sMt = \"statusMessage\";\nconst _sMta = \"stateMessage\";\nconst _sN = \"serviceName\";\nconst _sNA = \"serviceNetworkArn\";\nconst _sNE = \"snsNotificationsEnabled\";\nconst _sNN = \"serviceNetworkName\";\nconst _sNS = \"serviceNameSet\";\nconst _sNSr = \"sriovNetSupport\";\nconst _sNe = \"sequenceNumber\";\nconst _sNes = \"sessionNumber\";\nconst _sO = \"spotOptions\";\nconst _sP = \"s3Prefix\";\nconst _sPA = \"samlProviderArn\";\nconst _sPHS = \"spotPriceHistorySet\";\nconst _sPI = \"servicePermissionId\";\nconst _sPIAC = \"secondaryPrivateIpAddressCount\";\nconst _sPLS = \"sourcePrefixListSet\";\nconst _sPR = \"sourcePortRange\";\nconst _sPRS = \"sourcePortRangeSet\";\nconst _sPS = \"sourcePortSet\";\nconst _sPSS = \"spotPlacementScoreSet\";\nconst _sPp = \"spotPrice\";\nconst _sQPDS = \"successfulQueuedPurchaseDeletionSet\";\nconst _sR = \"serviceRegion\";\nconst _sRDT = \"supportedRootDeviceTypes\";\nconst _sRO = \"staticRoutesOnly\";\nconst _sRS = \"supportedRegionSet\";\nconst _sRT = \"subnetRouteTable\";\nconst _sRe = \"serviceResource\";\nconst _sRo = \"sourceResource\";\nconst _sRt = \"stateReason\";\nconst _sS = \"snapshotSet\";\nconst _sSGS = \"staleSecurityGroupSet\";\nconst _sSPU = \"selfServicePortalUrl\";\nconst _sSS = \"staticSourcesSupport\";\nconst _sSSPA = \"selfServiceSamlProviderArn\";\nconst _sST = \"sampledStartTime\";\nconst _sSe = \"settingSet\";\nconst _sSer = \"serviceState\";\nconst _sSo = \"sourceSet\";\nconst _sSs = \"sseSpecification\";\nconst _sSt = \"statusSet\";\nconst _sSu = \"subscriptionSet\";\nconst _sSub = \"subnetSet\";\nconst _sSup = \"supportedStrategies\";\nconst _sSy = \"systemStatus\";\nconst _sT = \"startTime\";\nconst _sTA = \"snsTopicArn\";\nconst _sTC = \"spotTargetCapacity\";\nconst _sTD = \"snapshotTaskDetail\";\nconst _sTFR = \"storeTaskFailureReason\";\nconst _sTH = \"sessionTimeoutHours\";\nconst _sTR = \"stateTransitionReason\";\nconst _sTS = \"storeTaskState\";\nconst _sTSS = \"snapshotTierStatusSet\";\nconst _sTT = \"stateTransitionTime\";\nconst _sTa = \"sampleTime\";\nconst _sTe = \"serviceType\";\nconst _sTo = \"sourceType\";\nconst _sTp = \"splitTunnel\";\nconst _sTs = \"sseType\";\nconst _sTt = \"storageTier\";\nconst _sUC = \"supportedUsageClasses\";\nconst _sV = \"sourceVpc\";\nconst _sVT = \"supportedVirtualizationTypes\";\nconst _sVh = \"shellVersion\";\nconst _sVu = \"supportedVersions\";\nconst _sWD = \"startWeekDay\";\nconst _s_ = \"s3\";\nconst _sc = \"scope\";\nconst _sco = \"score\";\nconst _scop = \"scopes\";\nconst _se = \"service\";\nconst _si = \"size\";\nconst _so = \"sockets\";\nconst _sof = \"software\";\nconst _st = \"state\";\nconst _sta = \"status\";\nconst _star = \"start\";\nconst _stat = \"statistic\";\nconst _sto = \"storage\";\nconst _str = \"strategy\";\nconst _su = \"subnet\";\nconst _sub = \"subnets\";\nconst _suc = \"successful\";\nconst _succ = \"success\";\nconst _t = \"tenancy\";\nconst _tAAC = \"totalAvailableAddressCount\";\nconst _tAC = \"totalAddressCount\";\nconst _tAI = \"transferAccountId\";\nconst _tC = \"totalCapacity\";\nconst _tCS = \"targetCapacitySpecification\";\nconst _tCUT = \"targetCapacityUnitType\";\nconst _tCVR = \"targetConfigurationValueRollup\";\nconst _tCVS = \"targetConfigurationValueSet\";\nconst _tCa = \"targetConfiguration\";\nconst _tCar = \"targetCapacity\";\nconst _tD = \"terminationDelay\";\nconst _tDr = \"trafficDirection\";\nconst _tE = \"targetEnvironment\";\nconst _tED = \"termEndDate\";\nconst _tET = \"tcpEstablishedTimeout\";\nconst _tEo = \"tokenEndpoint\";\nconst _tFC = \"totalFulfilledCapacity\";\nconst _tFMIMB = \"totalFpgaMemoryInMiB\";\nconst _tG = \"transitGateway\";\nconst _tGA = \"transitGatewayAttachments\";\nconst _tGAI = \"transitGatewayAttachmentId\";\nconst _tGAP = \"transitGatewayAttachmentPropagations\";\nconst _tGAr = \"transitGatewayAttachment\";\nconst _tGAra = \"transitGatewayArn\";\nconst _tGAran = \"transitGatewayAsn\";\nconst _tGArans = \"transitGatewayAddress\";\nconst _tGC = \"transitGatewayConnect\";\nconst _tGCB = \"transitGatewayCidrBlocks\";\nconst _tGCP = \"transitGatewayConnectPeer\";\nconst _tGCPI = \"transitGatewayConnectPeerId\";\nconst _tGCPS = \"transitGatewayConnectPeerSet\";\nconst _tGCS = \"transitGatewayConnectSet\";\nconst _tGCa = \"targetGroupsConfig\";\nconst _tGI = \"transitGatewayId\";\nconst _tGMD = \"transitGatewayMulticastDomain\";\nconst _tGMDA = \"transitGatewayMulticastDomainArn\";\nconst _tGMDI = \"transitGatewayMulticastDomainId\";\nconst _tGMDr = \"transitGatewayMulticastDomains\";\nconst _tGMIMB = \"totalGpuMemoryInMiB\";\nconst _tGOI = \"transitGatewayOwnerId\";\nconst _tGPA = \"transitGatewayPeeringAttachment\";\nconst _tGPAr = \"transitGatewayPeeringAttachments\";\nconst _tGPLR = \"transitGatewayPrefixListReference\";\nconst _tGPLRS = \"transitGatewayPrefixListReferenceSet\";\nconst _tGPT = \"transitGatewayPolicyTable\";\nconst _tGPTE = \"transitGatewayPolicyTableEntries\";\nconst _tGPTI = \"transitGatewayPolicyTableId\";\nconst _tGPTr = \"transitGatewayPolicyTables\";\nconst _tGRT = \"transitGatewayRouteTable\";\nconst _tGRTA = \"transitGatewayRouteTableAnnouncement\";\nconst _tGRTAI = \"transitGatewayRouteTableAnnouncementId\";\nconst _tGRTAr = \"transitGatewayRouteTableAnnouncements\";\nconst _tGRTI = \"transitGatewayRouteTableId\";\nconst _tGRTP = \"transitGatewayRouteTablePropagations\";\nconst _tGRTR = \"transitGatewayRouteTableRoute\";\nconst _tGRTr = \"transitGatewayRouteTables\";\nconst _tGS = \"transitGatewaySet\";\nconst _tGVA = \"transitGatewayVpcAttachment\";\nconst _tGVAr = \"transitGatewayVpcAttachments\";\nconst _tGa = \"targetGroups\";\nconst _tHP = \"totalHourlyPrice\";\nconst _tI = \"targetId\";\nconst _tIC = \"totalInstanceCount\";\nconst _tICu = \"tunnelInsideCidr\";\nconst _tII = \"trunkInterfaceId\";\nconst _tIIC = \"tunnelInsideIpv6Cidr\";\nconst _tIIV = \"tunnelInsideIpVersion\";\nconst _tIMIMB = \"totalInferenceMemoryInMiB\";\nconst _tIWE = \"terminateInstancesWithExpiration\";\nconst _tIa = \"targetIops\";\nconst _tIe = \"tenantId\";\nconst _tLSGB = \"totalLocalStorageGB\";\nconst _tMAE = \"targetMultiAttachEnabled\";\nconst _tMF = \"trafficMirrorFilter\";\nconst _tMFI = \"trafficMirrorFilterId\";\nconst _tMFR = \"trafficMirrorFilterRule\";\nconst _tMFRI = \"trafficMirrorFilterRuleId\";\nconst _tMFRS = \"trafficMirrorFilterRuleSet\";\nconst _tMFS = \"trafficMirrorFilterSet\";\nconst _tMMIMB = \"totalMediaMemoryInMiB\";\nconst _tMS = \"trafficMirrorSession\";\nconst _tMSI = \"trafficMirrorSessionId\";\nconst _tMSS = \"trafficMirrorSessionSet\";\nconst _tMT = \"trafficMirrorTarget\";\nconst _tMTI = \"trafficMirrorTargetId\";\nconst _tMTS = \"trafficMirrorTargetSet\";\nconst _tN = \"tokenName\";\nconst _tNDMIMB = \"totalNeuronDeviceMemoryInMiB\";\nconst _tNI = \"targetNetworkId\";\nconst _tOAT = \"transferOfferAcceptedTimestamp\";\nconst _tOET = \"transferOfferExpirationTimestamp\";\nconst _tOS = \"tunnelOptionSet\";\nconst _tP = \"transportProtocol\";\nconst _tPC = \"threadsPerCore\";\nconst _tPT = \"trustProviderType\";\nconst _tPo = \"toPort\";\nconst _tRC = \"targetResourceCount\";\nconst _tRS = \"throughResourceSet\";\nconst _tRSi = \"timeRangeSet\";\nconst _tRTI = \"targetRouteTableId\";\nconst _tS = \"tagSet\";\nconst _tSD = \"termStartDate\";\nconst _tSIGB = \"totalSizeInGB\";\nconst _tSIH = \"totalScheduledInstanceHours\";\nconst _tSS = \"tagSpecificationSet\";\nconst _tST = \"tieringStartTime\";\nconst _tSTa = \"taskStartTime\";\nconst _tSa = \"targetSubnet\";\nconst _tSar = \"targetSize\";\nconst _tSas = \"taskState\";\nconst _tSp = \"tpmSupport\";\nconst _tT = \"trafficType\";\nconst _tTC = \"totalTargetCapacity\";\nconst _tTGAI = \"transportTransitGatewayAttachmentId\";\nconst _tTa = \"taskType\";\nconst _tTar = \"targetThroughput\";\nconst _tTr = \"transferType\";\nconst _tUP = \"totalUpfrontPrice\";\nconst _tV = \"tokenValue\";\nconst _tVC = \"totalVCpus\";\nconst _tVT = \"targetVolumeType\";\nconst _ta = \"tags\";\nconst _tag = \"tag\";\nconst _te = \"term\";\nconst _th = \"throughput\";\nconst _ti = \"timestamp\";\nconst _tie = \"tier\";\nconst _to = \"to\";\nconst _ty = \"type\";\nconst _u = \"unsuccessful\";\nconst _uB = \"userBucket\";\nconst _uD = \"uefiData\";\nconst _uDLTVS = \"unsuccessfullyDeletedLaunchTemplateVersionSet\";\nconst _uDp = \"updatedDate\";\nconst _uDpd = \"updateDate\";\nconst _uDs = \"userData\";\nconst _uF = \"upfrontFee\";\nconst _uFDS = \"unsuccessfulFleetDeletionSet\";\nconst _uFRS = \"unsuccessfulFleetRequestSet\";\nconst _uI = \"userId\";\nconst _uIA = \"unassignedIpv6Addresses\";\nconst _uIC = \"usedInstanceCount\";\nconst _uICSS = \"unsuccessfulInstanceCreditSpecificationSet\";\nconst _uIE = \"userInfoEndpoint\";\nconst _uIPS = \"unknownIpPermissionSet\";\nconst _uIPSn = \"unassignedIpv6PrefixSet\";\nconst _uLI = \"useLongIds\";\nconst _uLIA = \"useLongIdsAggregated\";\nconst _uO = \"usageOperation\";\nconst _uOUT = \"usageOperationUpdateTime\";\nconst _uP = \"upfrontPrice\";\nconst _uPS = \"uploadPolicySignature\";\nconst _uPp = \"uploadPolicy\";\nconst _uPs = \"usagePrice\";\nconst _uRBOI = \"unusedReservationBillingOwnerId\";\nconst _uS = \"usageStrategy\";\nconst _uST = \"udpStreamTimeout\";\nconst _uT = \"updateTime\";\nconst _uTP = \"userTrustProvider\";\nconst _uTPT = \"userTrustProviderType\";\nconst _uTd = \"udpTimeout\";\nconst _ur = \"url\";\nconst _us = \"username\";\nconst _v = \"value\";\nconst _vAE = \"verifiedAccessEndpoint\";\nconst _vAEI = \"verifiedAccessEndpointId\";\nconst _vAES = \"verifiedAccessEndpointSet\";\nconst _vAETD = \"verifiedAccessEndpointTargetDns\";\nconst _vAETIA = \"verifiedAccessEndpointTargetIpAddress\";\nconst _vAETS = \"verifiedAccessEndpointTargetSet\";\nconst _vAG = \"verifiedAccessGroup\";\nconst _vAGA = \"verifiedAccessGroupArn\";\nconst _vAGI = \"verifiedAccessGroupId\";\nconst _vAGS = \"verifiedAccessGroupSet\";\nconst _vAI = \"verifiedAccessInstance\";\nconst _vAII = \"verifiedAccessInstanceId\";\nconst _vAIS = \"verifiedAccessInstanceSet\";\nconst _vATP = \"verifiedAccessTrustProvider\";\nconst _vATPI = \"verifiedAccessTrustProviderId\";\nconst _vATPS = \"verifiedAccessTrustProviderSet\";\nconst _vBPAE = \"vpcBlockPublicAccessExclusion\";\nconst _vBPAES = \"vpcBlockPublicAccessExclusionSet\";\nconst _vBPAO = \"vpcBlockPublicAccessOptions\";\nconst _vC = \"vpnConnection\";\nconst _vCC = \"vCpuCount\";\nconst _vCDSC = \"vpnConnectionDeviceSampleConfiguration\";\nconst _vCDTI = \"vpnConnectionDeviceTypeId\";\nconst _vCDTS = \"vpnConnectionDeviceTypeSet\";\nconst _vCI = \"vpnConnectionId\";\nconst _vCIp = \"vCpuInfo\";\nconst _vCS = \"vpnConnectionSet\";\nconst _vCa = \"validCores\";\nconst _vD = \"versionDescription\";\nconst _vE = \"vpcEndpoint\";\nconst _vEAS = \"vpcEndpointAssociationSet\";\nconst _vECI = \"vpcEncryptionControlId\";\nconst _vECIp = \"vpcEndpointConnectionId\";\nconst _vECS = \"vpcEndpointConnectionSet\";\nconst _vEI = \"vpcEndpointId\";\nconst _vEO = \"vpcEndpointOwner\";\nconst _vEPS = \"vpcEndpointPolicySupported\";\nconst _vER = \"vpcEndpointRegion\";\nconst _vES = \"vpcEndpointService\";\nconst _vESp = \"vpcEndpointSet\";\nconst _vESpc = \"vpcEndpointState\";\nconst _vESpn = \"vpnEcmpSupport\";\nconst _vET = \"vpcEndpointType\";\nconst _vF = \"validFrom\";\nconst _vFR = \"validationFailureReason\";\nconst _vG = \"vpnGateway\";\nconst _vGI = \"vpnGatewayId\";\nconst _vGS = \"vpnGatewaySet\";\nconst _vI = \"vpcId\";\nconst _vIR = \"volumeInitializationRate\";\nconst _vIl = \"vlanId\";\nconst _vIo = \"volumeId\";\nconst _vM = \"volumeModification\";\nconst _vMS = \"volumeModificationSet\";\nconst _vN = \"virtualName\";\nconst _vNI = \"virtualNetworkId\";\nconst _vNe = \"versionNumber\";\nconst _vOI = \"volumeOwnerId\";\nconst _vOIp = \"vpcOwnerId\";\nconst _vP = \"vpnProtocol\";\nconst _vPC = \"vpcPeeringConnection\";\nconst _vPCI = \"vpcPeeringConnectionId\";\nconst _vPCS = \"vpcPeeringConnectionSet\";\nconst _vPG = \"virtualPrivateGateway\";\nconst _vPp = \"vpnPort\";\nconst _vPpc = \"vpcPeering\";\nconst _vS = \"volumeSet\";\nconst _vSS = \"volumeStatusSet\";\nconst _vSa = \"valueSet\";\nconst _vSo = \"volumeSize\";\nconst _vSol = \"volumeStatus\";\nconst _vSp = \"vpcSet\";\nconst _vT = \"volumeType\";\nconst _vTOIA = \"vpnTunnelOutsideIpAddress\";\nconst _vTPC = \"validThreadsPerCore\";\nconst _vTg = \"vgwTelemetry\";\nconst _vTi = \"virtualizationType\";\nconst _vU = \"validUntil\";\nconst _ve = \"version\";\nconst _ven = \"vendor\";\nconst _vl = \"vlan\";\nconst _vo = \"volumes\";\nconst _vol = \"volume\";\nconst _vp = \"vpc\";\nconst _vpc = \"vpcs\";\nconst _w = \"warning\";\nconst _wC = \"weightedCapacity\";\nconst _wM = \"warningMessage\";\nconst _we = \"weight\";\nconst _zI = \"zoneId\";\nconst _zN = \"zoneName\";\nconst _zS = \"zoneState\";\nconst _zT = \"zoneType\";\nconst buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)\n    .map(([key, value]) => __extendedEncodeURIComponent(key) + \"=\" + __extendedEncodeURIComponent(value))\n    .join(\"&\");\nconst loadEc2ErrorCode = (output, data) => {\n    if (data.Errors.Error?.Code !== undefined) {\n        return data.Errors.Error.Code;\n    }\n    if (output.statusCode == 404) {\n        return \"NotFound\";\n    }\n};\n", "import { ServiceException as __ServiceException, } from \"@smithy/smithy-client\";\nexport { __ServiceException };\nexport class EC2ServiceException extends __ServiceException {\n    constructor(options) {\n        super(options);\n        Object.setPrototypeOf(this, EC2ServiceException.prototype);\n    }\n}\n", "import { getEndpointPlugin } from \"@smithy/middleware-endpoint\";\nimport { getSerdePlugin } from \"@smithy/middleware-serde\";\nimport { Command as $Command } from \"@smithy/smithy-client\";\nimport { commonParams } from \"../endpoint/EndpointParameters\";\nimport { de_DescribeInstancesCommand, se_DescribeInstancesCommand } from \"../protocols/Aws_ec2\";\nexport { $Command };\nexport class DescribeInstancesCommand extends $Command\n    .classBuilder()\n    .ep(commonParams)\n    .m(function (Command, cs, config, o) {\n    return [\n        getSerdePlugin(config, this.serialize, this.deserialize),\n        getEndpointPlugin(config, Command.getEndpointParameterInstructions()),\n    ];\n})\n    .s(\"AmazonEC2\", \"DescribeInstances\", {})\n    .n(\"EC2Client\", \"DescribeInstancesCommand\")\n    .f(void 0, void 0)\n    .ser(se_DescribeInstancesCommand)\n    .de(de_DescribeInstancesCommand)\n    .build() {\n}\n", "import { getHostHeaderPlugin, resolveHostHeaderConfig, } from \"@aws-sdk/middleware-host-header\";\nimport { getLoggerPlugin } from \"@aws-sdk/middleware-logger\";\nimport { getRecursionDetectionPlugin } from \"@aws-sdk/middleware-recursion-detection\";\nimport { getUserAgentPlugin, resolveUserAgentConfig, } from \"@aws-sdk/middleware-user-agent\";\nimport { resolveRegionConfig } from \"@smithy/config-resolver\";\nimport { DefaultIdentityProviderConfig, getHttpAuthSchemeEndpointRuleSetPlugin, getHttpSigningPlugin, } from \"@smithy/core\";\nimport { resolveCompressionConfig, } from \"@smithy/middleware-compression\";\nimport { getContentLengthPlugin } from \"@smithy/middleware-content-length\";\nimport { resolveEndpointConfig } from \"@smithy/middleware-endpoint\";\nimport { getRetryPlugin, resolveRetryConfig } from \"@smithy/middleware-retry\";\nimport { Client as __Client, } from \"@smithy/smithy-client\";\nimport { defaultCloudWatchHttpAuthSchemeParametersProvider, resolveHttpAuthSchemeConfig, } from \"./auth/httpAuthSchemeProvider\";\nimport { resolveClientEndpointParameters, } from \"./endpoint/EndpointParameters\";\nimport { getRuntimeConfig as __getRuntimeConfig } from \"./runtimeConfig\";\nimport { resolveRuntimeExtensions } from \"./runtimeExtensions\";\nexport { __Client };\nexport class CloudWatchClient extends __Client {\n    config;\n    constructor(...[configuration]) {\n        const _config_0 = __getRuntimeConfig(configuration || {});\n        super(_config_0);\n        this.initConfig = _config_0;\n        const _config_1 = resolveClientEndpointParameters(_config_0);\n        const _config_2 = resolveUserAgentConfig(_config_1);\n        const _config_3 = resolveRetryConfig(_config_2);\n        const _config_4 = resolveRegionConfig(_config_3);\n        const _config_5 = resolveHostHeaderConfig(_config_4);\n        const _config_6 = resolveEndpointConfig(_config_5);\n        const _config_7 = resolveHttpAuthSchemeConfig(_config_6);\n        const _config_8 = resolveCompressionConfig(_config_7);\n        const _config_9 = resolveRuntimeExtensions(_config_8, configuration?.extensions || []);\n        this.config = _config_9;\n        this.middlewareStack.use(getUserAgentPlugin(this.config));\n        this.middlewareStack.use(getRetryPlugin(this.config));\n        this.middlewareStack.use(getContentLengthPlugin(this.config));\n        this.middlewareStack.use(getHostHeaderPlugin(this.config));\n        this.middlewareStack.use(getLoggerPlugin(this.config));\n        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));\n        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {\n            httpAuthSchemeParametersProvider: defaultCloudWatchHttpAuthSchemeParametersProvider,\n            identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({\n                \"aws.auth#sigv4\": config.credentials,\n            }),\n        }));\n        this.middlewareStack.use(getHttpSigningPlugin(this.config));\n    }\n    destroy() {\n        super.destroy();\n    }\n}\n", "export * from \"./NODE_DISABLE_REQUEST_COMPRESSION_CONFIG_OPTIONS\";\nexport * from \"./NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES_CONFIG_OPTIONS\";\nexport * from \"./compressionMiddleware\";\nexport * from \"./configurations\";\nexport * from \"./getCompressionPlugin\";\nexport * from \"./resolveCompressionConfig\";\n", "import { booleanSelector, SelectorType } from \"@smithy/util-config-provider\";\nexport const NODE_DISABLE_REQUEST_COMPRESSION_ENV_NAME = \"AWS_DISABLE_REQUEST_COMPRESSION\";\nexport const NODE_DISABLE_REQUEST_COMPRESSION_INI_NAME = \"disable_request_compression\";\nexport const DEFAULT_DISABLE_REQUEST_COMPRESSION = false;\nexport const NODE_DISABLE_REQUEST_COMPRESSION_CONFIG_OPTIONS = {\n    environmentVariableSelector: (env) => booleanSelector(env, NODE_DISABLE_REQUEST_COMPRESSION_ENV_NAME, SelectorType.ENV),\n    configFileSelector: (profile) => booleanSelector(profile, NODE_DISABLE_REQUEST_COMPRESSION_INI_NAME, SelectorType.CONFIG),\n    default: DEFAULT_DISABLE_REQUEST_COMPRESSION,\n};\n", "import { numberSelector, SelectorType } from \"@smithy/util-config-provider\";\nexport const NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES_ENV_NAME = \"AWS_REQUEST_MIN_COMPRESSION_SIZE_BYTES\";\nexport const NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES_INI_NAME = \"request_min_compression_size_bytes\";\nexport const DEFAULT_NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES = 10240;\nexport const NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES_CONFIG_OPTIONS = {\n    environmentVariableSelector: (env) => numberSelector(env, NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES_ENV_NAME, SelectorType.ENV),\n    configFileSelector: (profile) => numberSelector(profile, NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES_INI_NAME, SelectorType.CONFIG),\n    default: DEFAULT_NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES,\n};\n", "import { setFeature } from \"@smithy/core\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { compressStream } from \"./compressStream\";\nimport { compressString } from \"./compressString\";\nimport { CLIENT_SUPPORTED_ALGORITHMS } from \"./constants\";\nimport { isStreaming } from \"./isStreaming\";\nexport const compressionMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {\n    if (!HttpRequest.isInstance(args.request)) {\n        return next(args);\n    }\n    const disableRequestCompression = await config.disableRequestCompression();\n    if (disableRequestCompression) {\n        return next(args);\n    }\n    const { request } = args;\n    const { body, headers } = request;\n    const { encodings, streamRequiresLength } = middlewareConfig;\n    let updatedBody = body;\n    let updatedHeaders = headers;\n    for (const algorithm of encodings) {\n        if (CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {\n            let isRequestCompressed = false;\n            if (isStreaming(body)) {\n                if (!streamRequiresLength) {\n                    updatedBody = await compressStream(body);\n                    isRequestCompressed = true;\n                }\n                else {\n                    throw new Error(\"Compression is not supported for streaming blobs that require a length.\");\n                }\n            }\n            else {\n                const bodyLength = config.bodyLengthChecker(body);\n                const requestMinCompressionSizeBytes = await config.requestMinCompressionSizeBytes();\n                if (bodyLength && bodyLength >= requestMinCompressionSizeBytes) {\n                    updatedBody = await compressString(body);\n                    isRequestCompressed = true;\n                }\n            }\n            if (isRequestCompressed) {\n                if (headers[\"content-encoding\"]) {\n                    updatedHeaders = {\n                        ...headers,\n                        \"content-encoding\": `${headers[\"content-encoding\"]}, ${algorithm}`,\n                    };\n                }\n                else {\n                    updatedHeaders = { ...headers, \"content-encoding\": algorithm };\n                }\n                if (updatedHeaders[\"content-encoding\"].includes(\"gzip\")) {\n                    setFeature(context, \"GZIP_REQUEST_COMPRESSION\", \"L\");\n                }\n                break;\n            }\n        }\n    }\n    return next({\n        ...args,\n        request: {\n            ...request,\n            body: updatedBody,\n            headers: updatedHeaders,\n        },\n    });\n};\nexport const compressionMiddlewareOptions = {\n    name: \"compressionMiddleware\",\n    step: \"build\",\n    tags: [\"REQUEST_BODY_COMPRESSION\", \"GZIP\"],\n    override: true,\n    priority: \"high\",\n};\n", "import { AsyncGzip } from \"fflate\";\nexport const compressStream = async (body) => {\n    let endCallback;\n    const asyncGzip = new AsyncGzip();\n    const compressionStream = new TransformStream({\n        start(controller) {\n            asyncGzip.ondata = (err, data, final) => {\n                if (err) {\n                    controller.error(err);\n                }\n                else {\n                    controller.enqueue(data);\n                    if (final) {\n                        if (endCallback)\n                            endCallback();\n                        else\n                            controller.terminate();\n                    }\n                }\n            };\n        },\n        transform(chunk) {\n            asyncGzip.push(chunk);\n        },\n        flush() {\n            return new Promise((resolve) => {\n                endCallback = resolve;\n                asyncGzip.push(new Uint8Array(0), true);\n            });\n        },\n    });\n    return body.pipeThrough(compressionStream);\n};\n", "import { toUint8Array } from \"@smithy/util-utf8\";\nimport { gzip } from \"fflate\";\nexport const compressString = async (body) => new Promise((resolve, reject) => {\n    gzip(toUint8Array(body || \"\"), (err, data) => {\n        if (err) {\n            reject(new Error(\"Failure during compression: \" + err.message));\n        }\n        else {\n            resolve(data);\n        }\n    });\n});\n", "export var CompressionAlgorithm;\n(function (CompressionAlgorithm) {\n    CompressionAlgorithm[\"GZIP\"] = \"gzip\";\n})(CompressionAlgorithm || (CompressionAlgorithm = {}));\nexport const CLIENT_SUPPORTED_ALGORITHMS = [CompressionAlgorithm.GZIP];\n", "import { isArrayBuffer } from \"@smithy/is-array-buffer\";\nexport const isStreaming = (body) => body !== undefined && typeof body !== \"string\" && !ArrayBuffer.isView(body) && !isArrayBuffer(body);\n", "export {};\n", "import { compressionMiddleware, compressionMiddlewareOptions, } from \"./compressionMiddleware\";\nexport const getCompressionPlugin = (config, middlewareConfig) => ({\n    applyToStack: (clientStack) => {\n        clientStack.add(compressionMiddleware(config, middlewareConfig), compressionMiddlewareOptions);\n    },\n});\n", "import { normalizeProvider } from \"@smithy/util-middleware\";\nexport const resolveCompressionConfig = (input) => {\n    const { disableRequestCompression, requestMinCompressionSizeBytes: _requestMinCompressionSizeBytes } = input;\n    return Object.assign(input, {\n        disableRequestCompression: normalizeProvider(disableRequestCompression),\n        requestMinCompressionSizeBytes: async () => {\n            const requestMinCompressionSizeBytes = await normalizeProvider(_requestMinCompressionSizeBytes)();\n            if (requestMinCompressionSizeBytes < 0 || requestMinCompressionSizeBytes > 10485760) {\n                throw new RangeError(\"The value for requestMinCompressionSizeBytes must be between 0 and 10485760 inclusive. \" +\n                    `The provided value ${requestMinCompressionSizeBytes} is outside this range.\"`);\n            }\n            return requestMinCompressionSizeBytes;\n        },\n    });\n};\n", "import { resolveAwsSdkSigV4Config, } from \"@aws-sdk/core\";\nimport { getSmithyContext, normalizeProvider } from \"@smithy/util-middleware\";\nexport const defaultCloudWatchHttpAuthSchemeParametersProvider = async (config, context, input) => {\n    return {\n        operation: getSmithyContext(context).operation,\n        region: (await normalizeProvider(config.region)()) ||\n            (() => {\n                throw new Error(\"expected `region` to be configured for `aws.auth#sigv4`\");\n            })(),\n    };\n};\nfunction createAwsAuthSigv4HttpAuthOption(authParameters) {\n    return {\n        schemeId: \"aws.auth#sigv4\",\n        signingProperties: {\n            name: \"monitoring\",\n            region: authParameters.region,\n        },\n        propertiesExtractor: (config, context) => ({\n            signingProperties: {\n                config,\n                context,\n            },\n        }),\n    };\n}\nexport const defaultCloudWatchHttpAuthSchemeProvider = (authParameters) => {\n    const options = [];\n    switch (authParameters.operation) {\n        default: {\n            options.push(createAwsAuthSigv4HttpAuthOption(authParameters));\n        }\n    }\n    return options;\n};\nexport const resolveHttpAuthSchemeConfig = (config) => {\n    const config_0 = resolveAwsSdkSigV4Config(config);\n    return Object.assign(config_0, {\n        authSchemePreference: normalizeProvider(config.authSchemePreference ?? []),\n    });\n};\n", "export const resolveClientEndpointParameters = (options) => {\n    return Object.assign(options, {\n        useDualstackEndpoint: options.useDualstackEndpoint ?? false,\n        useFipsEndpoint: options.useFipsEndpoint ?? false,\n        defaultSigningName: \"monitoring\",\n    });\n};\nexport const commonParams = {\n    UseFIPS: { type: \"builtInParams\", name: \"useFipsEndpoint\" },\n    Endpoint: { type: \"builtInParams\", name: \"endpoint\" },\n    Region: { type: \"builtInParams\", name: \"region\" },\n    UseDualStack: { type: \"builtInParams\", name: \"useDualstackEndpoint\" },\n};\n", "import packageInfo from \"../package.json\";\nimport { Sha256 } from \"@aws-crypto/sha256-browser\";\nimport { createDefaultUserAgentProvider } from \"@aws-sdk/util-user-agent-browser\";\nimport { DEFAULT_USE_DUALSTACK_ENDPOINT, DEFAULT_USE_FIPS_ENDPOINT } from \"@smithy/config-resolver\";\nimport { FetchHttpHandler as RequestHandler, streamCollector } from \"@smithy/fetch-http-handler\";\nimport { invalidProvider } from \"@smithy/invalid-dependency\";\nimport { DEFAULT_DISABLE_REQUEST_COMPRESSION, DEFAULT_NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES, } from \"@smithy/middleware-compression\";\nimport { calculateBodyLength } from \"@smithy/util-body-length-browser\";\nimport { DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_MODE } from \"@smithy/util-retry\";\nimport { getRuntimeConfig as getSharedRuntimeConfig } from \"./runtimeConfig.shared\";\nimport { loadConfigsForDefaultMode } from \"@smithy/smithy-client\";\nimport { resolveDefaultsModeConfig } from \"@smithy/util-defaults-mode-browser\";\nexport const getRuntimeConfig = (config) => {\n    const defaultsMode = resolveDefaultsModeConfig(config);\n    const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);\n    const clientSharedValues = getSharedRuntimeConfig(config);\n    return {\n        ...clientSharedValues,\n        ...config,\n        runtime: \"browser\",\n        defaultsMode,\n        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,\n        credentialDefaultProvider: config?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error(\"Credential is missing\"))),\n        defaultUserAgentProvider: config?.defaultUserAgentProvider ??\n            createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo.version }),\n        disableRequestCompression: config?.disableRequestCompression ?? DEFAULT_DISABLE_REQUEST_COMPRESSION,\n        maxAttempts: config?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS,\n        region: config?.region ?? invalidProvider(\"Region is missing\"),\n        requestHandler: RequestHandler.create(config?.requestHandler ?? defaultConfigProvider),\n        requestMinCompressionSizeBytes: config?.requestMinCompressionSizeBytes ?? DEFAULT_NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES,\n        retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),\n        sha256: config?.sha256 ?? Sha256,\n        streamCollector: config?.streamCollector ?? streamCollector,\n        useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),\n        useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT)),\n    };\n};\n", "{\n  \"name\": \"@aws-sdk/client-cloudwatch\",\n  \"description\": \"AWS SDK for JavaScript Cloudwatch Client for Node.js, Browser and React Native\",\n  \"version\": \"3.817.0\",\n  \"scripts\": {\n    \"build\": \"concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'\",\n    \"build:cjs\": \"node ../../scripts/compilation/inline client-cloudwatch\",\n    \"build:es\": \"tsc -p tsconfig.es.json\",\n    \"build:include:deps\": \"lerna run --scope $npm_package_name --include-dependencies build\",\n    \"build:types\": \"tsc -p tsconfig.types.json\",\n    \"build:types:downlevel\": \"downlevel-dts dist-types dist-types/ts3.4\",\n    \"clean\": \"rimraf ./dist-* && rimraf *.tsbuildinfo\",\n    \"extract:docs\": \"api-extractor run --local\",\n    \"generate:client\": \"node ../../scripts/generate-clients/single-service --solo cloudwatch\"\n  },\n  \"main\": \"./dist-cjs/index.js\",\n  \"types\": \"./dist-types/index.d.ts\",\n  \"module\": \"./dist-es/index.js\",\n  \"sideEffects\": false,\n  \"dependencies\": {\n    \"@aws-crypto/sha256-browser\": \"5.2.0\",\n    \"@aws-crypto/sha256-js\": \"5.2.0\",\n    \"@aws-sdk/core\": \"3.816.0\",\n    \"@aws-sdk/credential-provider-node\": \"3.817.0\",\n    \"@aws-sdk/middleware-host-header\": \"3.804.0\",\n    \"@aws-sdk/middleware-logger\": \"3.804.0\",\n    \"@aws-sdk/middleware-recursion-detection\": \"3.804.0\",\n    \"@aws-sdk/middleware-user-agent\": \"3.816.0\",\n    \"@aws-sdk/region-config-resolver\": \"3.808.0\",\n    \"@aws-sdk/types\": \"3.804.0\",\n    \"@aws-sdk/util-endpoints\": \"3.808.0\",\n    \"@aws-sdk/util-user-agent-browser\": \"3.804.0\",\n    \"@aws-sdk/util-user-agent-node\": \"3.816.0\",\n    \"@smithy/config-resolver\": \"^4.1.2\",\n    \"@smithy/core\": \"^3.3.3\",\n    \"@smithy/fetch-http-handler\": \"^5.0.2\",\n    \"@smithy/hash-node\": \"^4.0.2\",\n    \"@smithy/invalid-dependency\": \"^4.0.2\",\n    \"@smithy/middleware-compression\": \"^4.1.6\",\n    \"@smithy/middleware-content-length\": \"^4.0.2\",\n    \"@smithy/middleware-endpoint\": \"^4.1.6\",\n    \"@smithy/middleware-retry\": \"^4.1.7\",\n    \"@smithy/middleware-serde\": \"^4.0.5\",\n    \"@smithy/middleware-stack\": \"^4.0.2\",\n    \"@smithy/node-config-provider\": \"^4.1.1\",\n    \"@smithy/node-http-handler\": \"^4.0.4\",\n    \"@smithy/protocol-http\": \"^5.1.0\",\n    \"@smithy/smithy-client\": \"^4.2.6\",\n    \"@smithy/types\": \"^4.2.0\",\n    \"@smithy/url-parser\": \"^4.0.2\",\n    \"@smithy/util-base64\": \"^4.0.0\",\n    \"@smithy/util-body-length-browser\": \"^4.0.0\",\n    \"@smithy/util-body-length-node\": \"^4.0.0\",\n    \"@smithy/util-defaults-mode-browser\": \"^4.0.14\",\n    \"@smithy/util-defaults-mode-node\": \"^4.0.14\",\n    \"@smithy/util-endpoints\": \"^3.0.4\",\n    \"@smithy/util-middleware\": \"^4.0.2\",\n    \"@smithy/util-retry\": \"^4.0.3\",\n    \"@smithy/util-utf8\": \"^4.0.0\",\n    \"@smithy/util-waiter\": \"^4.0.3\",\n    \"tslib\": \"^2.6.2\"\n  },\n  \"devDependencies\": {\n    \"@tsconfig/node18\": \"18.2.4\",\n    \"@types/node\": \"^18.19.69\",\n    \"concurrently\": \"7.0.0\",\n    \"downlevel-dts\": \"0.10.1\",\n    \"rimraf\": \"3.0.2\",\n    \"typescript\": \"~5.8.3\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"typesVersions\": {\n    \"<4.0\": {\n      \"dist-types/*\": [\n        \"dist-types/ts3.4/*\"\n      ]\n    }\n  },\n  \"files\": [\n    \"dist-*/**\"\n  ],\n  \"author\": {\n    \"name\": \"AWS SDK for JavaScript Team\",\n    \"url\": \"https://aws.amazon.com/javascript/\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"browser\": {\n    \"./dist-es/runtimeConfig\": \"./dist-es/runtimeConfig.browser\"\n  },\n  \"react-native\": {\n    \"./dist-es/runtimeConfig\": \"./dist-es/runtimeConfig.native\"\n  },\n  \"homepage\": \"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cloudwatch\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/aws/aws-sdk-js-v3.git\",\n    \"directory\": \"clients/client-cloudwatch\"\n  }\n}\n", "import { AwsSdkSigV4Signer } from \"@aws-sdk/core\";\nimport { NoOpLogger } from \"@smithy/smithy-client\";\nimport { parseUrl } from \"@smithy/url-parser\";\nimport { fromBase64, toBase64 } from \"@smithy/util-base64\";\nimport { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nimport { defaultCloudWatchHttpAuthSchemeProvider } from \"./auth/httpAuthSchemeProvider\";\nimport { defaultEndpointResolver } from \"./endpoint/endpointResolver\";\nexport const getRuntimeConfig = (config) => {\n    return {\n        apiVersion: \"2010-08-01\",\n        base64Decoder: config?.base64Decoder ?? fromBase64,\n        base64Encoder: config?.base64Encoder ?? toBase64,\n        disableHostPrefix: config?.disableHostPrefix ?? false,\n        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,\n        extensions: config?.extensions ?? [],\n        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultCloudWatchHttpAuthSchemeProvider,\n        httpAuthSchemes: config?.httpAuthSchemes ?? [\n            {\n                schemeId: \"aws.auth#sigv4\",\n                identityProvider: (ipc) => ipc.getIdentityProvider(\"aws.auth#sigv4\"),\n                signer: new AwsSdkSigV4Signer(),\n            },\n        ],\n        logger: config?.logger ?? new NoOpLogger(),\n        serviceId: config?.serviceId ?? \"CloudWatch\",\n        urlParser: config?.urlParser ?? parseUrl,\n        utf8Decoder: config?.utf8Decoder ?? fromUtf8,\n        utf8Encoder: config?.utf8Encoder ?? toUtf8,\n    };\n};\n", "import { awsEndpointFunctions } from \"@aws-sdk/util-endpoints\";\nimport { customEndpointFunctions, EndpointCache, resolveEndpoint } from \"@smithy/util-endpoints\";\nimport { ruleSet } from \"./ruleset\";\nconst cache = new EndpointCache({\n    size: 50,\n    params: [\"Endpoint\", \"Region\", \"UseDualStack\", \"UseFIPS\"],\n});\nexport const defaultEndpointResolver = (endpointParams, context = {}) => {\n    return cache.get(endpointParams, () => resolveEndpoint(ruleSet, {\n        endpointParams: endpointParams,\n        logger: context.logger,\n    }));\n};\ncustomEndpointFunctions.aws = awsEndpointFunctions;\n", "const u = \"required\", v = \"fn\", w = \"argv\", x = \"ref\";\nconst a = true, b = \"isSet\", c = \"booleanEquals\", d = \"error\", e = \"endpoint\", f = \"tree\", g = \"PartitionResult\", h = \"getAttr\", i = { [u]: false, \"type\": \"String\" }, j = { [u]: true, \"default\": false, \"type\": \"Boolean\" }, k = { [x]: \"Endpoint\" }, l = { [v]: c, [w]: [{ [x]: \"UseFIPS\" }, true] }, m = { [v]: c, [w]: [{ [x]: \"UseDualStack\" }, true] }, n = {}, o = { [v]: h, [w]: [{ [x]: g }, \"supportsFIPS\"] }, p = { [x]: g }, q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, \"supportsDualStack\"] }] }, r = [l], s = [m], t = [{ [x]: \"Region\" }];\nconst _data = { version: \"1.0\", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: \"Invalid Configuration: FIPS and custom endpoint are not supported\", type: d }, { conditions: s, error: \"Invalid Configuration: Dualstack and custom endpoint are not supported\", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: \"aws.partition\", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: \"https://monitoring-fips.{Region}.{PartitionResult#dualStackDnsSuffix}\", properties: n, headers: n }, type: e }], type: f }, { error: \"FIPS and DualStack are enabled, but this partition does not support one or both\", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: \"stringEquals\", [w]: [{ [v]: h, [w]: [p, \"name\"] }, \"aws-us-gov\"] }], endpoint: { url: \"https://monitoring.{Region}.amazonaws.com\", properties: n, headers: n }, type: e }, { endpoint: { url: \"https://monitoring-fips.{Region}.{PartitionResult#dnsSuffix}\", properties: n, headers: n }, type: e }], type: f }, { error: \"FIPS is enabled but this partition does not support FIPS\", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: \"https://monitoring.{Region}.{PartitionResult#dualStackDnsSuffix}\", properties: n, headers: n }, type: e }], type: f }, { error: \"DualStack is enabled but this partition does not support DualStack\", type: d }], type: f }, { endpoint: { url: \"https://monitoring.{Region}.{PartitionResult#dnsSuffix}\", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: \"Invalid Configuration: Missing Region\", type: d }] };\nexport const ruleSet = _data;\n", "import { getAwsRegionExtensionConfiguration, resolveAwsRegionExtensionConfiguration, } from \"@aws-sdk/region-config-resolver\";\nimport { getHttpHandlerExtensionConfiguration, resolveHttpHandlerRuntimeConfig } from \"@smithy/protocol-http\";\nimport { getDefaultExtensionConfiguration, resolveDefaultRuntimeConfig } from \"@smithy/smithy-client\";\nimport { getHttpAuthExtensionConfiguration, resolveHttpAuthRuntimeConfig } from \"./auth/httpAuthExtensionConfiguration\";\nexport const resolveRuntimeExtensions = (runtimeConfig, extensions) => {\n    const extensionConfiguration = Object.assign(getAwsRegionExtensionConfiguration(runtimeConfig), getDefaultExtensionConfiguration(runtimeConfig), getHttpHandlerExtensionConfiguration(runtimeConfig), getHttpAuthExtensionConfiguration(runtimeConfig));\n    extensions.forEach((extension) => extension.configure(extensionConfiguration));\n    return Object.assign(runtimeConfig, resolveAwsRegionExtensionConfiguration(extensionConfiguration), resolveDefaultRuntimeConfig(extensionConfiguration), resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));\n};\n", "export const getHttpAuthExtensionConfiguration = (runtimeConfig) => {\n    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;\n    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;\n    let _credentials = runtimeConfig.credentials;\n    return {\n        setHttpAuthScheme(httpAuthScheme) {\n            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);\n            if (index === -1) {\n                _httpAuthSchemes.push(httpAuthScheme);\n            }\n            else {\n                _httpAuthSchemes.splice(index, 1, httpAuthScheme);\n            }\n        },\n        httpAuthSchemes() {\n            return _httpAuthSchemes;\n        },\n        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {\n            _httpAuthSchemeProvider = httpAuthSchemeProvider;\n        },\n        httpAuthSchemeProvider() {\n            return _httpAuthSchemeProvider;\n        },\n        setCredentials(credentials) {\n            _credentials = credentials;\n        },\n        credentials() {\n            return _credentials;\n        },\n    };\n};\nexport const resolveHttpAuthRuntimeConfig = (config) => {\n    return {\n        httpAuthSchemes: config.httpAuthSchemes(),\n        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),\n        credentials: config.credentials(),\n    };\n};\n", "import { parseXmlBody as parseBody, parseXmlErrorBody as parseErrorBody } from \"@aws-sdk/core\";\nimport { HttpRequest as __HttpRequest } from \"@smithy/protocol-http\";\nimport { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, serializeDateTime as __serializeDateTime, serializeFloat as __serializeFloat, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, strictParseLong as __strictParseLong, withBaseException, } from \"@smithy/smithy-client\";\nimport { CloudWatchServiceException as __BaseException } from \"../models/CloudWatchServiceException\";\nimport { ConcurrentModificationException, ConflictException, DashboardInvalidInputError, InternalServiceFault, InvalidFormatFault, InvalidNextToken, InvalidParameterCombinationException, InvalidParameterValueException, LimitExceededException, LimitExceededFault, MissingRequiredParameterException, ResourceNotFound, ResourceNotFoundException, } from \"../models/models_0\";\nexport const se_DeleteAlarmsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteAlarmsInput(input, context),\n        [_A]: _DA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteAnomalyDetectorCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteAnomalyDetectorInput(input, context),\n        [_A]: _DAD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteDashboardsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteDashboardsInput(input, context),\n        [_A]: _DD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteInsightRulesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteInsightRulesInput(input, context),\n        [_A]: _DIR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DeleteMetricStreamCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DeleteMetricStreamInput(input, context),\n        [_A]: _DMS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeAlarmHistoryCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeAlarmHistoryInput(input, context),\n        [_A]: _DAH,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeAlarmsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeAlarmsInput(input, context),\n        [_A]: _DAe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeAlarmsForMetricCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeAlarmsForMetricInput(input, context),\n        [_A]: _DAFM,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeAnomalyDetectorsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeAnomalyDetectorsInput(input, context),\n        [_A]: _DADe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DescribeInsightRulesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DescribeInsightRulesInput(input, context),\n        [_A]: _DIRe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableAlarmActionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableAlarmActionsInput(input, context),\n        [_A]: _DAA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_DisableInsightRulesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_DisableInsightRulesInput(input, context),\n        [_A]: _DIRi,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableAlarmActionsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableAlarmActionsInput(input, context),\n        [_A]: _EAA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_EnableInsightRulesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_EnableInsightRulesInput(input, context),\n        [_A]: _EIR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetDashboardCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetDashboardInput(input, context),\n        [_A]: _GD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetInsightRuleReportCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetInsightRuleReportInput(input, context),\n        [_A]: _GIRR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetMetricDataCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetMetricDataInput(input, context),\n        [_A]: _GMD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetMetricStatisticsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetMetricStatisticsInput(input, context),\n        [_A]: _GMS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetMetricStreamCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetMetricStreamInput(input, context),\n        [_A]: _GMSe,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_GetMetricWidgetImageCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_GetMetricWidgetImageInput(input, context),\n        [_A]: _GMWI,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ListDashboardsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ListDashboardsInput(input, context),\n        [_A]: _LD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ListManagedInsightRulesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ListManagedInsightRulesInput(input, context),\n        [_A]: _LMIR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ListMetricsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ListMetricsInput(input, context),\n        [_A]: _LM,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ListMetricStreamsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ListMetricStreamsInput(input, context),\n        [_A]: _LMS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_ListTagsForResourceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_ListTagsForResourceInput(input, context),\n        [_A]: _LTFR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PutAnomalyDetectorCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PutAnomalyDetectorInput(input, context),\n        [_A]: _PAD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PutCompositeAlarmCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PutCompositeAlarmInput(input, context),\n        [_A]: _PCA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PutDashboardCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PutDashboardInput(input, context),\n        [_A]: _PD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PutInsightRuleCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PutInsightRuleInput(input, context),\n        [_A]: _PIR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PutManagedInsightRulesCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PutManagedInsightRulesInput(input, context),\n        [_A]: _PMIR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PutMetricAlarmCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PutMetricAlarmInput(input, context),\n        [_A]: _PMA,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PutMetricDataCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PutMetricDataInput(input, context),\n        [_A]: _PMD,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_PutMetricStreamCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_PutMetricStreamInput(input, context),\n        [_A]: _PMS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_SetAlarmStateCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_SetAlarmStateInput(input, context),\n        [_A]: _SAS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_StartMetricStreamsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_StartMetricStreamsInput(input, context),\n        [_A]: _SMS,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_StopMetricStreamsCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_StopMetricStreamsInput(input, context),\n        [_A]: _SMSt,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_TagResourceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_TagResourceInput(input, context),\n        [_A]: _TR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const se_UntagResourceCommand = async (input, context) => {\n    const headers = SHARED_HEADERS;\n    let body;\n    body = buildFormUrlencodedString({\n        ...se_UntagResourceInput(input, context),\n        [_A]: _UR,\n        [_V]: _,\n    });\n    return buildHttpRpcRequest(context, headers, \"/\", undefined, body);\n};\nexport const de_DeleteAlarmsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DeleteAnomalyDetectorCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteAnomalyDetectorOutput(data.DeleteAnomalyDetectorResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteDashboardsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteDashboardsOutput(data.DeleteDashboardsResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteInsightRulesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteInsightRulesOutput(data.DeleteInsightRulesResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DeleteMetricStreamCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DeleteMetricStreamOutput(data.DeleteMetricStreamResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeAlarmHistoryCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeAlarmHistoryOutput(data.DescribeAlarmHistoryResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeAlarmsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeAlarmsOutput(data.DescribeAlarmsResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeAlarmsForMetricCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeAlarmsForMetricOutput(data.DescribeAlarmsForMetricResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeAnomalyDetectorsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeAnomalyDetectorsOutput(data.DescribeAnomalyDetectorsResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DescribeInsightRulesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DescribeInsightRulesOutput(data.DescribeInsightRulesResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_DisableAlarmActionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_DisableInsightRulesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_DisableInsightRulesOutput(data.DisableInsightRulesResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_EnableAlarmActionsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_EnableInsightRulesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_EnableInsightRulesOutput(data.EnableInsightRulesResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetDashboardCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetDashboardOutput(data.GetDashboardResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetInsightRuleReportCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetInsightRuleReportOutput(data.GetInsightRuleReportResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetMetricDataCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetMetricDataOutput(data.GetMetricDataResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetMetricStatisticsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetMetricStatisticsOutput(data.GetMetricStatisticsResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetMetricStreamCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetMetricStreamOutput(data.GetMetricStreamResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_GetMetricWidgetImageCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_GetMetricWidgetImageOutput(data.GetMetricWidgetImageResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ListDashboardsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ListDashboardsOutput(data.ListDashboardsResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ListManagedInsightRulesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ListManagedInsightRulesOutput(data.ListManagedInsightRulesResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ListMetricsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ListMetricsOutput(data.ListMetricsResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ListMetricStreamsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ListMetricStreamsOutput(data.ListMetricStreamsResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_ListTagsForResourceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_ListTagsForResourceOutput(data.ListTagsForResourceResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_PutAnomalyDetectorCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_PutAnomalyDetectorOutput(data.PutAnomalyDetectorResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_PutCompositeAlarmCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_PutDashboardCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_PutDashboardOutput(data.PutDashboardResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_PutInsightRuleCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_PutInsightRuleOutput(data.PutInsightRuleResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_PutManagedInsightRulesCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_PutManagedInsightRulesOutput(data.PutManagedInsightRulesResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_PutMetricAlarmCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_PutMetricDataCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_PutMetricStreamCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_PutMetricStreamOutput(data.PutMetricStreamResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_SetAlarmStateCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    await collectBody(output.body, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n    };\n    return response;\n};\nexport const de_StartMetricStreamsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_StartMetricStreamsOutput(data.StartMetricStreamsResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_StopMetricStreamsCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_StopMetricStreamsOutput(data.StopMetricStreamsResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_TagResourceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_TagResourceOutput(data.TagResourceResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nexport const de_UntagResourceCommand = async (output, context) => {\n    if (output.statusCode >= 300) {\n        return de_CommandError(output, context);\n    }\n    const data = await parseBody(output.body, context);\n    let contents = {};\n    contents = de_UntagResourceOutput(data.UntagResourceResult, context);\n    const response = {\n        $metadata: deserializeMetadata(output),\n        ...contents,\n    };\n    return response;\n};\nconst de_CommandError = async (output, context) => {\n    const parsedOutput = {\n        ...output,\n        body: await parseErrorBody(output.body, context),\n    };\n    const errorCode = loadQueryErrorCode(output, parsedOutput.body);\n    switch (errorCode) {\n        case \"ResourceNotFound\":\n        case \"com.amazonaws.cloudwatch#ResourceNotFound\":\n            throw await de_ResourceNotFoundRes(parsedOutput, context);\n        case \"InternalServiceError\":\n        case \"com.amazonaws.cloudwatch#InternalServiceFault\":\n            throw await de_InternalServiceFaultRes(parsedOutput, context);\n        case \"InvalidParameterCombination\":\n        case \"com.amazonaws.cloudwatch#InvalidParameterCombinationException\":\n            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);\n        case \"InvalidParameterValue\":\n        case \"com.amazonaws.cloudwatch#InvalidParameterValueException\":\n            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);\n        case \"MissingParameter\":\n        case \"com.amazonaws.cloudwatch#MissingRequiredParameterException\":\n            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);\n        case \"ResourceNotFoundException\":\n        case \"com.amazonaws.cloudwatch#ResourceNotFoundException\":\n            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);\n        case \"ConflictException\":\n        case \"com.amazonaws.cloudwatch#ConflictException\":\n            throw await de_ConflictExceptionRes(parsedOutput, context);\n        case \"InvalidNextToken\":\n        case \"com.amazonaws.cloudwatch#InvalidNextToken\":\n            throw await de_InvalidNextTokenRes(parsedOutput, context);\n        case \"LimitExceededException\":\n        case \"com.amazonaws.cloudwatch#LimitExceededException\":\n            throw await de_LimitExceededExceptionRes(parsedOutput, context);\n        case \"LimitExceeded\":\n        case \"com.amazonaws.cloudwatch#LimitExceededFault\":\n            throw await de_LimitExceededFaultRes(parsedOutput, context);\n        case \"InvalidParameterInput\":\n        case \"com.amazonaws.cloudwatch#DashboardInvalidInputError\":\n            throw await de_DashboardInvalidInputErrorRes(parsedOutput, context);\n        case \"ConcurrentModificationException\":\n        case \"com.amazonaws.cloudwatch#ConcurrentModificationException\":\n            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);\n        case \"InvalidFormat\":\n        case \"com.amazonaws.cloudwatch#InvalidFormatFault\":\n            throw await de_InvalidFormatFaultRes(parsedOutput, context);\n        default:\n            const parsedBody = parsedOutput.body;\n            return throwDefaultError({\n                output,\n                parsedBody: parsedBody.Error,\n                errorCode,\n            });\n    }\n};\nconst de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_ConcurrentModificationException(body.Error, context);\n    const exception = new ConcurrentModificationException({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_ConflictExceptionRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_ConflictException(body.Error, context);\n    const exception = new ConflictException({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_DashboardInvalidInputErrorRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_DashboardInvalidInputError(body.Error, context);\n    const exception = new DashboardInvalidInputError({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_InternalServiceFaultRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_InternalServiceFault(body.Error, context);\n    const exception = new InternalServiceFault({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_InvalidFormatFaultRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_InvalidFormatFault(body.Error, context);\n    const exception = new InvalidFormatFault({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_InvalidNextTokenRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_InvalidNextToken(body.Error, context);\n    const exception = new InvalidNextToken({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_InvalidParameterCombinationExceptionRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_InvalidParameterCombinationException(body.Error, context);\n    const exception = new InvalidParameterCombinationException({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_InvalidParameterValueExceptionRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_InvalidParameterValueException(body.Error, context);\n    const exception = new InvalidParameterValueException({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_LimitExceededExceptionRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_LimitExceededException(body.Error, context);\n    const exception = new LimitExceededException({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_LimitExceededFaultRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_LimitExceededFault(body.Error, context);\n    const exception = new LimitExceededFault({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_MissingRequiredParameterExceptionRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_MissingRequiredParameterException(body.Error, context);\n    const exception = new MissingRequiredParameterException({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_ResourceNotFoundRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_ResourceNotFound(body.Error, context);\n    const exception = new ResourceNotFound({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {\n    const body = parsedOutput.body;\n    const deserialized = de_ResourceNotFoundException(body.Error, context);\n    const exception = new ResourceNotFoundException({\n        $metadata: deserializeMetadata(parsedOutput),\n        ...deserialized,\n    });\n    return __decorateServiceException(exception, body);\n};\nconst se_AlarmNames = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_AlarmTypes = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_AnomalyDetectorConfiguration = (input, context) => {\n    const entries = {};\n    if (input[_ETR] != null) {\n        const memberEntries = se_AnomalyDetectorExcludedTimeRanges(input[_ETR], context);\n        if (input[_ETR]?.length === 0) {\n            entries.ExcludedTimeRanges = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExcludedTimeRanges.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MT] != null) {\n        entries[_MT] = input[_MT];\n    }\n    return entries;\n};\nconst se_AnomalyDetectorExcludedTimeRanges = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Range(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_AnomalyDetectorTypes = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_Counts = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = __serializeFloat(entry);\n        counter++;\n    }\n    return entries;\n};\nconst se_DashboardNames = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_DeleteAlarmsInput = (input, context) => {\n    const entries = {};\n    if (input[_AN] != null) {\n        const memberEntries = se_AlarmNames(input[_AN], context);\n        if (input[_AN]?.length === 0) {\n            entries.AlarmNames = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AlarmNames.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeleteAnomalyDetectorInput = (input, context) => {\n    const entries = {};\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_MN] != null) {\n        entries[_MN] = input[_MN];\n    }\n    if (input[_D] != null) {\n        const memberEntries = se_Dimensions(input[_D], context);\n        if (input[_D]?.length === 0) {\n            entries.Dimensions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Dimensions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_S] != null) {\n        entries[_S] = input[_S];\n    }\n    if (input[_SMAD] != null) {\n        const memberEntries = se_SingleMetricAnomalyDetector(input[_SMAD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SingleMetricAnomalyDetector.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MMAD] != null) {\n        const memberEntries = se_MetricMathAnomalyDetector(input[_MMAD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MetricMathAnomalyDetector.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeleteDashboardsInput = (input, context) => {\n    const entries = {};\n    if (input[_DN] != null) {\n        const memberEntries = se_DashboardNames(input[_DN], context);\n        if (input[_DN]?.length === 0) {\n            entries.DashboardNames = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `DashboardNames.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeleteInsightRulesInput = (input, context) => {\n    const entries = {};\n    if (input[_RN] != null) {\n        const memberEntries = se_InsightRuleNames(input[_RN], context);\n        if (input[_RN]?.length === 0) {\n            entries.RuleNames = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RuleNames.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DeleteMetricStreamInput = (input, context) => {\n    const entries = {};\n    if (input[_Na] != null) {\n        entries[_Na] = input[_Na];\n    }\n    return entries;\n};\nconst se_DescribeAlarmHistoryInput = (input, context) => {\n    const entries = {};\n    if (input[_ANl] != null) {\n        entries[_ANl] = input[_ANl];\n    }\n    if (input[_AT] != null) {\n        const memberEntries = se_AlarmTypes(input[_AT], context);\n        if (input[_AT]?.length === 0) {\n            entries.AlarmTypes = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AlarmTypes.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_HIT] != null) {\n        entries[_HIT] = input[_HIT];\n    }\n    if (input[_SD] != null) {\n        entries[_SD] = __serializeDateTime(input[_SD]);\n    }\n    if (input[_ED] != null) {\n        entries[_ED] = __serializeDateTime(input[_ED]);\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_SB] != null) {\n        entries[_SB] = input[_SB];\n    }\n    return entries;\n};\nconst se_DescribeAlarmsForMetricInput = (input, context) => {\n    const entries = {};\n    if (input[_MN] != null) {\n        entries[_MN] = input[_MN];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_St] != null) {\n        entries[_St] = input[_St];\n    }\n    if (input[_ES] != null) {\n        entries[_ES] = input[_ES];\n    }\n    if (input[_D] != null) {\n        const memberEntries = se_Dimensions(input[_D], context);\n        if (input[_D]?.length === 0) {\n            entries.Dimensions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Dimensions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_U] != null) {\n        entries[_U] = input[_U];\n    }\n    return entries;\n};\nconst se_DescribeAlarmsInput = (input, context) => {\n    const entries = {};\n    if (input[_AN] != null) {\n        const memberEntries = se_AlarmNames(input[_AN], context);\n        if (input[_AN]?.length === 0) {\n            entries.AlarmNames = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AlarmNames.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ANP] != null) {\n        entries[_ANP] = input[_ANP];\n    }\n    if (input[_AT] != null) {\n        const memberEntries = se_AlarmTypes(input[_AT], context);\n        if (input[_AT]?.length === 0) {\n            entries.AlarmTypes = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AlarmTypes.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_COAN] != null) {\n        entries[_COAN] = input[_COAN];\n    }\n    if (input[_POAN] != null) {\n        entries[_POAN] = input[_POAN];\n    }\n    if (input[_SV] != null) {\n        entries[_SV] = input[_SV];\n    }\n    if (input[_AP] != null) {\n        entries[_AP] = input[_AP];\n    }\n    if (input[_MR] != null) {\n        entries[_MR] = input[_MR];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_DescribeAnomalyDetectorsInput = (input, context) => {\n    const entries = {};\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MRa] != null) {\n        entries[_MRa] = input[_MRa];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_MN] != null) {\n        entries[_MN] = input[_MN];\n    }\n    if (input[_D] != null) {\n        const memberEntries = se_Dimensions(input[_D], context);\n        if (input[_D]?.length === 0) {\n            entries.Dimensions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Dimensions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ADT] != null) {\n        const memberEntries = se_AnomalyDetectorTypes(input[_ADT], context);\n        if (input[_ADT]?.length === 0) {\n            entries.AnomalyDetectorTypes = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AnomalyDetectorTypes.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DescribeInsightRulesInput = (input, context) => {\n    const entries = {};\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MRa] != null) {\n        entries[_MRa] = input[_MRa];\n    }\n    return entries;\n};\nconst se_Dimension = (input, context) => {\n    const entries = {};\n    if (input[_Na] != null) {\n        entries[_Na] = input[_Na];\n    }\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_DimensionFilter = (input, context) => {\n    const entries = {};\n    if (input[_Na] != null) {\n        entries[_Na] = input[_Na];\n    }\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_DimensionFilters = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_DimensionFilter(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Dimensions = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Dimension(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_DisableAlarmActionsInput = (input, context) => {\n    const entries = {};\n    if (input[_AN] != null) {\n        const memberEntries = se_AlarmNames(input[_AN], context);\n        if (input[_AN]?.length === 0) {\n            entries.AlarmNames = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AlarmNames.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_DisableInsightRulesInput = (input, context) => {\n    const entries = {};\n    if (input[_RN] != null) {\n        const memberEntries = se_InsightRuleNames(input[_RN], context);\n        if (input[_RN]?.length === 0) {\n            entries.RuleNames = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RuleNames.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_EnableAlarmActionsInput = (input, context) => {\n    const entries = {};\n    if (input[_AN] != null) {\n        const memberEntries = se_AlarmNames(input[_AN], context);\n        if (input[_AN]?.length === 0) {\n            entries.AlarmNames = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AlarmNames.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_EnableInsightRulesInput = (input, context) => {\n    const entries = {};\n    if (input[_RN] != null) {\n        const memberEntries = se_InsightRuleNames(input[_RN], context);\n        if (input[_RN]?.length === 0) {\n            entries.RuleNames = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `RuleNames.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_Entity = (input, context) => {\n    const entries = {};\n    if (input[_KA] != null) {\n        const memberEntries = se_EntityKeyAttributesMap(input[_KA], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `KeyAttributes.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_At] != null) {\n        const memberEntries = se_EntityAttributesMap(input[_At], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Attributes.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_EntityAttributesMap = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    Object.keys(input)\n        .filter((key) => input[key] != null)\n        .forEach((key) => {\n        entries[`entry.${counter}.key`] = key;\n        entries[`entry.${counter}.value`] = input[key];\n        counter++;\n    });\n    return entries;\n};\nconst se_EntityKeyAttributesMap = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    Object.keys(input)\n        .filter((key) => input[key] != null)\n        .forEach((key) => {\n        entries[`entry.${counter}.key`] = key;\n        entries[`entry.${counter}.value`] = input[key];\n        counter++;\n    });\n    return entries;\n};\nconst se_EntityMetricData = (input, context) => {\n    const entries = {};\n    if (input[_E] != null) {\n        const memberEntries = se_Entity(input[_E], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Entity.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MD] != null) {\n        const memberEntries = se_MetricData(input[_MD], context);\n        if (input[_MD]?.length === 0) {\n            entries.MetricData = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MetricData.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_EntityMetricDataList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_EntityMetricData(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_ExtendedStatistics = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_GetDashboardInput = (input, context) => {\n    const entries = {};\n    if (input[_DNa] != null) {\n        entries[_DNa] = input[_DNa];\n    }\n    return entries;\n};\nconst se_GetInsightRuleReportInput = (input, context) => {\n    const entries = {};\n    if (input[_RNu] != null) {\n        entries[_RNu] = input[_RNu];\n    }\n    if (input[_ST] != null) {\n        entries[_ST] = __serializeDateTime(input[_ST]);\n    }\n    if (input[_ET] != null) {\n        entries[_ET] = __serializeDateTime(input[_ET]);\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_MCC] != null) {\n        entries[_MCC] = input[_MCC];\n    }\n    if (input[_M] != null) {\n        const memberEntries = se_InsightRuleMetricList(input[_M], context);\n        if (input[_M]?.length === 0) {\n            entries.Metrics = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Metrics.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_OB] != null) {\n        entries[_OB] = input[_OB];\n    }\n    return entries;\n};\nconst se_GetMetricDataInput = (input, context) => {\n    const entries = {};\n    if (input[_MDQ] != null) {\n        const memberEntries = se_MetricDataQueries(input[_MDQ], context);\n        if (input[_MDQ]?.length === 0) {\n            entries.MetricDataQueries = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MetricDataQueries.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ST] != null) {\n        entries[_ST] = __serializeDateTime(input[_ST]);\n    }\n    if (input[_ET] != null) {\n        entries[_ET] = __serializeDateTime(input[_ET]);\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_SB] != null) {\n        entries[_SB] = input[_SB];\n    }\n    if (input[_MDa] != null) {\n        entries[_MDa] = input[_MDa];\n    }\n    if (input[_LO] != null) {\n        const memberEntries = se_LabelOptions(input[_LO], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `LabelOptions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_GetMetricStatisticsInput = (input, context) => {\n    const entries = {};\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_MN] != null) {\n        entries[_MN] = input[_MN];\n    }\n    if (input[_D] != null) {\n        const memberEntries = se_Dimensions(input[_D], context);\n        if (input[_D]?.length === 0) {\n            entries.Dimensions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Dimensions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ST] != null) {\n        entries[_ST] = __serializeDateTime(input[_ST]);\n    }\n    if (input[_ET] != null) {\n        entries[_ET] = __serializeDateTime(input[_ET]);\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_Sta] != null) {\n        const memberEntries = se_Statistics(input[_Sta], context);\n        if (input[_Sta]?.length === 0) {\n            entries.Statistics = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Statistics.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ESx] != null) {\n        const memberEntries = se_ExtendedStatistics(input[_ESx], context);\n        if (input[_ESx]?.length === 0) {\n            entries.ExtendedStatistics = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExtendedStatistics.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_U] != null) {\n        entries[_U] = input[_U];\n    }\n    return entries;\n};\nconst se_GetMetricStreamInput = (input, context) => {\n    const entries = {};\n    if (input[_Na] != null) {\n        entries[_Na] = input[_Na];\n    }\n    return entries;\n};\nconst se_GetMetricWidgetImageInput = (input, context) => {\n    const entries = {};\n    if (input[_MW] != null) {\n        entries[_MW] = input[_MW];\n    }\n    if (input[_OF] != null) {\n        entries[_OF] = input[_OF];\n    }\n    return entries;\n};\nconst se_InsightRuleMetricList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_InsightRuleNames = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_LabelOptions = (input, context) => {\n    const entries = {};\n    if (input[_T] != null) {\n        entries[_T] = input[_T];\n    }\n    return entries;\n};\nconst se_ListDashboardsInput = (input, context) => {\n    const entries = {};\n    if (input[_DNP] != null) {\n        entries[_DNP] = input[_DNP];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    return entries;\n};\nconst se_ListManagedInsightRulesInput = (input, context) => {\n    const entries = {};\n    if (input[_RARN] != null) {\n        entries[_RARN] = input[_RARN];\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MRa] != null) {\n        entries[_MRa] = input[_MRa];\n    }\n    return entries;\n};\nconst se_ListMetricsInput = (input, context) => {\n    const entries = {};\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_MN] != null) {\n        entries[_MN] = input[_MN];\n    }\n    if (input[_D] != null) {\n        const memberEntries = se_DimensionFilters(input[_D], context);\n        if (input[_D]?.length === 0) {\n            entries.Dimensions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Dimensions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_RA] != null) {\n        entries[_RA] = input[_RA];\n    }\n    if (input[_ILA] != null) {\n        entries[_ILA] = input[_ILA];\n    }\n    if (input[_OA] != null) {\n        entries[_OA] = input[_OA];\n    }\n    return entries;\n};\nconst se_ListMetricStreamsInput = (input, context) => {\n    const entries = {};\n    if (input[_NT] != null) {\n        entries[_NT] = input[_NT];\n    }\n    if (input[_MRa] != null) {\n        entries[_MRa] = input[_MRa];\n    }\n    return entries;\n};\nconst se_ListTagsForResourceInput = (input, context) => {\n    const entries = {};\n    if (input[_RARN] != null) {\n        entries[_RARN] = input[_RARN];\n    }\n    return entries;\n};\nconst se_ManagedRule = (input, context) => {\n    const entries = {};\n    if (input[_TN] != null) {\n        entries[_TN] = input[_TN];\n    }\n    if (input[_RARN] != null) {\n        entries[_RARN] = input[_RARN];\n    }\n    if (input[_Ta] != null) {\n        const memberEntries = se_TagList(input[_Ta], context);\n        if (input[_Ta]?.length === 0) {\n            entries.Tags = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Tags.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_ManagedRules = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_ManagedRule(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_Metric = (input, context) => {\n    const entries = {};\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_MN] != null) {\n        entries[_MN] = input[_MN];\n    }\n    if (input[_D] != null) {\n        const memberEntries = se_Dimensions(input[_D], context);\n        if (input[_D]?.length === 0) {\n            entries.Dimensions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Dimensions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_MetricCharacteristics = (input, context) => {\n    const entries = {};\n    if (input[_PS] != null) {\n        entries[_PS] = input[_PS];\n    }\n    return entries;\n};\nconst se_MetricData = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_MetricDatum(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_MetricDataQueries = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_MetricDataQuery(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_MetricDataQuery = (input, context) => {\n    const entries = {};\n    if (input[_I] != null) {\n        entries[_I] = input[_I];\n    }\n    if (input[_MS] != null) {\n        const memberEntries = se_MetricStat(input[_MS], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MetricStat.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ex] != null) {\n        entries[_Ex] = input[_Ex];\n    }\n    if (input[_L] != null) {\n        entries[_L] = input[_L];\n    }\n    if (input[_RD] != null) {\n        entries[_RD] = input[_RD];\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_AI] != null) {\n        entries[_AI] = input[_AI];\n    }\n    return entries;\n};\nconst se_MetricDatum = (input, context) => {\n    const entries = {};\n    if (input[_MN] != null) {\n        entries[_MN] = input[_MN];\n    }\n    if (input[_D] != null) {\n        const memberEntries = se_Dimensions(input[_D], context);\n        if (input[_D]?.length === 0) {\n            entries.Dimensions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Dimensions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ti] != null) {\n        entries[_Ti] = __serializeDateTime(input[_Ti]);\n    }\n    if (input[_Va] != null) {\n        entries[_Va] = __serializeFloat(input[_Va]);\n    }\n    if (input[_SVt] != null) {\n        const memberEntries = se_StatisticSet(input[_SVt], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `StatisticValues.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Val] != null) {\n        const memberEntries = se_Values(input[_Val], context);\n        if (input[_Val]?.length === 0) {\n            entries.Values = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Values.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_C] != null) {\n        const memberEntries = se_Counts(input[_C], context);\n        if (input[_C]?.length === 0) {\n            entries.Counts = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Counts.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_U] != null) {\n        entries[_U] = input[_U];\n    }\n    if (input[_SR] != null) {\n        entries[_SR] = input[_SR];\n    }\n    return entries;\n};\nconst se_MetricMathAnomalyDetector = (input, context) => {\n    const entries = {};\n    if (input[_MDQ] != null) {\n        const memberEntries = se_MetricDataQueries(input[_MDQ], context);\n        if (input[_MDQ]?.length === 0) {\n            entries.MetricDataQueries = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MetricDataQueries.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_MetricStat = (input, context) => {\n    const entries = {};\n    if (input[_Me] != null) {\n        const memberEntries = se_Metric(input[_Me], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Metric.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_S] != null) {\n        entries[_S] = input[_S];\n    }\n    if (input[_U] != null) {\n        entries[_U] = input[_U];\n    }\n    return entries;\n};\nconst se_MetricStreamFilter = (input, context) => {\n    const entries = {};\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_MNe] != null) {\n        const memberEntries = se_MetricStreamFilterMetricNames(input[_MNe], context);\n        if (input[_MNe]?.length === 0) {\n            entries.MetricNames = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MetricNames.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_MetricStreamFilterMetricNames = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_MetricStreamFilters = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_MetricStreamFilter(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_MetricStreamNames = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_MetricStreamStatisticsAdditionalStatistics = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_MetricStreamStatisticsConfiguration = (input, context) => {\n    const entries = {};\n    if (input[_IM] != null) {\n        const memberEntries = se_MetricStreamStatisticsIncludeMetrics(input[_IM], context);\n        if (input[_IM]?.length === 0) {\n            entries.IncludeMetrics = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IncludeMetrics.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AS] != null) {\n        const memberEntries = se_MetricStreamStatisticsAdditionalStatistics(input[_AS], context);\n        if (input[_AS]?.length === 0) {\n            entries.AdditionalStatistics = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AdditionalStatistics.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_MetricStreamStatisticsConfigurations = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_MetricStreamStatisticsConfiguration(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_MetricStreamStatisticsIncludeMetrics = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_MetricStreamStatisticsMetric(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_MetricStreamStatisticsMetric = (input, context) => {\n    const entries = {};\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_MN] != null) {\n        entries[_MN] = input[_MN];\n    }\n    return entries;\n};\nconst se_PutAnomalyDetectorInput = (input, context) => {\n    const entries = {};\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_MN] != null) {\n        entries[_MN] = input[_MN];\n    }\n    if (input[_D] != null) {\n        const memberEntries = se_Dimensions(input[_D], context);\n        if (input[_D]?.length === 0) {\n            entries.Dimensions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Dimensions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_S] != null) {\n        entries[_S] = input[_S];\n    }\n    if (input[_Co] != null) {\n        const memberEntries = se_AnomalyDetectorConfiguration(input[_Co], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Configuration.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MC] != null) {\n        const memberEntries = se_MetricCharacteristics(input[_MC], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MetricCharacteristics.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SMAD] != null) {\n        const memberEntries = se_SingleMetricAnomalyDetector(input[_SMAD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `SingleMetricAnomalyDetector.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MMAD] != null) {\n        const memberEntries = se_MetricMathAnomalyDetector(input[_MMAD], context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MetricMathAnomalyDetector.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_PutCompositeAlarmInput = (input, context) => {\n    const entries = {};\n    if (input[_AE] != null) {\n        entries[_AE] = input[_AE];\n    }\n    if (input[_AA] != null) {\n        const memberEntries = se_ResourceList(input[_AA], context);\n        if (input[_AA]?.length === 0) {\n            entries.AlarmActions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AlarmActions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AD] != null) {\n        entries[_AD] = input[_AD];\n    }\n    if (input[_ANl] != null) {\n        entries[_ANl] = input[_ANl];\n    }\n    if (input[_AR] != null) {\n        entries[_AR] = input[_AR];\n    }\n    if (input[_IDA] != null) {\n        const memberEntries = se_ResourceList(input[_IDA], context);\n        if (input[_IDA]?.length === 0) {\n            entries.InsufficientDataActions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InsufficientDataActions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_OKA] != null) {\n        const memberEntries = se_ResourceList(input[_OKA], context);\n        if (input[_OKA]?.length === 0) {\n            entries.OKActions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `OKActions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ta] != null) {\n        const memberEntries = se_TagList(input[_Ta], context);\n        if (input[_Ta]?.length === 0) {\n            entries.Tags = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Tags.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ASc] != null) {\n        entries[_ASc] = input[_ASc];\n    }\n    if (input[_ASWP] != null) {\n        entries[_ASWP] = input[_ASWP];\n    }\n    if (input[_ASEP] != null) {\n        entries[_ASEP] = input[_ASEP];\n    }\n    return entries;\n};\nconst se_PutDashboardInput = (input, context) => {\n    const entries = {};\n    if (input[_DNa] != null) {\n        entries[_DNa] = input[_DNa];\n    }\n    if (input[_DB] != null) {\n        entries[_DB] = input[_DB];\n    }\n    return entries;\n};\nconst se_PutInsightRuleInput = (input, context) => {\n    const entries = {};\n    if (input[_RNu] != null) {\n        entries[_RNu] = input[_RNu];\n    }\n    if (input[_RS] != null) {\n        entries[_RS] = input[_RS];\n    }\n    if (input[_RDu] != null) {\n        entries[_RDu] = input[_RDu];\n    }\n    if (input[_Ta] != null) {\n        const memberEntries = se_TagList(input[_Ta], context);\n        if (input[_Ta]?.length === 0) {\n            entries.Tags = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Tags.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AOTL] != null) {\n        entries[_AOTL] = input[_AOTL];\n    }\n    return entries;\n};\nconst se_PutManagedInsightRulesInput = (input, context) => {\n    const entries = {};\n    if (input[_MRan] != null) {\n        const memberEntries = se_ManagedRules(input[_MRan], context);\n        if (input[_MRan]?.length === 0) {\n            entries.ManagedRules = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ManagedRules.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_PutMetricAlarmInput = (input, context) => {\n    const entries = {};\n    if (input[_ANl] != null) {\n        entries[_ANl] = input[_ANl];\n    }\n    if (input[_AD] != null) {\n        entries[_AD] = input[_AD];\n    }\n    if (input[_AE] != null) {\n        entries[_AE] = input[_AE];\n    }\n    if (input[_OKA] != null) {\n        const memberEntries = se_ResourceList(input[_OKA], context);\n        if (input[_OKA]?.length === 0) {\n            entries.OKActions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `OKActions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_AA] != null) {\n        const memberEntries = se_ResourceList(input[_AA], context);\n        if (input[_AA]?.length === 0) {\n            entries.AlarmActions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `AlarmActions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_IDA] != null) {\n        const memberEntries = se_ResourceList(input[_IDA], context);\n        if (input[_IDA]?.length === 0) {\n            entries.InsufficientDataActions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `InsufficientDataActions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_MN] != null) {\n        entries[_MN] = input[_MN];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_St] != null) {\n        entries[_St] = input[_St];\n    }\n    if (input[_ES] != null) {\n        entries[_ES] = input[_ES];\n    }\n    if (input[_D] != null) {\n        const memberEntries = se_Dimensions(input[_D], context);\n        if (input[_D]?.length === 0) {\n            entries.Dimensions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Dimensions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_P] != null) {\n        entries[_P] = input[_P];\n    }\n    if (input[_U] != null) {\n        entries[_U] = input[_U];\n    }\n    if (input[_EP] != null) {\n        entries[_EP] = input[_EP];\n    }\n    if (input[_DTA] != null) {\n        entries[_DTA] = input[_DTA];\n    }\n    if (input[_Th] != null) {\n        entries[_Th] = __serializeFloat(input[_Th]);\n    }\n    if (input[_CO] != null) {\n        entries[_CO] = input[_CO];\n    }\n    if (input[_TMD] != null) {\n        entries[_TMD] = input[_TMD];\n    }\n    if (input[_ELSCP] != null) {\n        entries[_ELSCP] = input[_ELSCP];\n    }\n    if (input[_M] != null) {\n        const memberEntries = se_MetricDataQueries(input[_M], context);\n        if (input[_M]?.length === 0) {\n            entries.Metrics = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Metrics.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_Ta] != null) {\n        const memberEntries = se_TagList(input[_Ta], context);\n        if (input[_Ta]?.length === 0) {\n            entries.Tags = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Tags.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_TMI] != null) {\n        entries[_TMI] = input[_TMI];\n    }\n    return entries;\n};\nconst se_PutMetricDataInput = (input, context) => {\n    const entries = {};\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_MD] != null) {\n        const memberEntries = se_MetricData(input[_MD], context);\n        if (input[_MD]?.length === 0) {\n            entries.MetricData = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `MetricData.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EMD] != null) {\n        const memberEntries = se_EntityMetricDataList(input[_EMD], context);\n        if (input[_EMD]?.length === 0) {\n            entries.EntityMetricData = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `EntityMetricData.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SEV] != null) {\n        entries[_SEV] = input[_SEV];\n    }\n    return entries;\n};\nconst se_PutMetricStreamInput = (input, context) => {\n    const entries = {};\n    if (input[_Na] != null) {\n        entries[_Na] = input[_Na];\n    }\n    if (input[_IF] != null) {\n        const memberEntries = se_MetricStreamFilters(input[_IF], context);\n        if (input[_IF]?.length === 0) {\n            entries.IncludeFilters = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `IncludeFilters.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_EF] != null) {\n        const memberEntries = se_MetricStreamFilters(input[_EF], context);\n        if (input[_EF]?.length === 0) {\n            entries.ExcludeFilters = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `ExcludeFilters.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_FA] != null) {\n        entries[_FA] = input[_FA];\n    }\n    if (input[_RAo] != null) {\n        entries[_RAo] = input[_RAo];\n    }\n    if (input[_OF] != null) {\n        entries[_OF] = input[_OF];\n    }\n    if (input[_Ta] != null) {\n        const memberEntries = se_TagList(input[_Ta], context);\n        if (input[_Ta]?.length === 0) {\n            entries.Tags = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Tags.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_SC] != null) {\n        const memberEntries = se_MetricStreamStatisticsConfigurations(input[_SC], context);\n        if (input[_SC]?.length === 0) {\n            entries.StatisticsConfigurations = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `StatisticsConfigurations.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_ILAM] != null) {\n        entries[_ILAM] = input[_ILAM];\n    }\n    return entries;\n};\nconst se_Range = (input, context) => {\n    const entries = {};\n    if (input[_ST] != null) {\n        entries[_ST] = __serializeDateTime(input[_ST]);\n    }\n    if (input[_ET] != null) {\n        entries[_ET] = __serializeDateTime(input[_ET]);\n    }\n    return entries;\n};\nconst se_ResourceList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_SetAlarmStateInput = (input, context) => {\n    const entries = {};\n    if (input[_ANl] != null) {\n        entries[_ANl] = input[_ANl];\n    }\n    if (input[_SV] != null) {\n        entries[_SV] = input[_SV];\n    }\n    if (input[_SRt] != null) {\n        entries[_SRt] = input[_SRt];\n    }\n    if (input[_SRD] != null) {\n        entries[_SRD] = input[_SRD];\n    }\n    return entries;\n};\nconst se_SingleMetricAnomalyDetector = (input, context) => {\n    const entries = {};\n    if (input[_AI] != null) {\n        entries[_AI] = input[_AI];\n    }\n    if (input[_N] != null) {\n        entries[_N] = input[_N];\n    }\n    if (input[_MN] != null) {\n        entries[_MN] = input[_MN];\n    }\n    if (input[_D] != null) {\n        const memberEntries = se_Dimensions(input[_D], context);\n        if (input[_D]?.length === 0) {\n            entries.Dimensions = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Dimensions.${key}`;\n            entries[loc] = value;\n        });\n    }\n    if (input[_S] != null) {\n        entries[_S] = input[_S];\n    }\n    return entries;\n};\nconst se_StartMetricStreamsInput = (input, context) => {\n    const entries = {};\n    if (input[_Nam] != null) {\n        const memberEntries = se_MetricStreamNames(input[_Nam], context);\n        if (input[_Nam]?.length === 0) {\n            entries.Names = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Names.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_Statistics = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_StatisticSet = (input, context) => {\n    const entries = {};\n    if (input[_SCa] != null) {\n        entries[_SCa] = __serializeFloat(input[_SCa]);\n    }\n    if (input[_Su] != null) {\n        entries[_Su] = __serializeFloat(input[_Su]);\n    }\n    if (input[_Mi] != null) {\n        entries[_Mi] = __serializeFloat(input[_Mi]);\n    }\n    if (input[_Ma] != null) {\n        entries[_Ma] = __serializeFloat(input[_Ma]);\n    }\n    return entries;\n};\nconst se_StopMetricStreamsInput = (input, context) => {\n    const entries = {};\n    if (input[_Nam] != null) {\n        const memberEntries = se_MetricStreamNames(input[_Nam], context);\n        if (input[_Nam]?.length === 0) {\n            entries.Names = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Names.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_Tag = (input, context) => {\n    const entries = {};\n    if (input[_K] != null) {\n        entries[_K] = input[_K];\n    }\n    if (input[_Va] != null) {\n        entries[_Va] = input[_Va];\n    }\n    return entries;\n};\nconst se_TagKeyList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = entry;\n        counter++;\n    }\n    return entries;\n};\nconst se_TagList = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        const memberEntries = se_Tag(entry, context);\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            entries[`member.${counter}.${key}`] = value;\n        });\n        counter++;\n    }\n    return entries;\n};\nconst se_TagResourceInput = (input, context) => {\n    const entries = {};\n    if (input[_RARN] != null) {\n        entries[_RARN] = input[_RARN];\n    }\n    if (input[_Ta] != null) {\n        const memberEntries = se_TagList(input[_Ta], context);\n        if (input[_Ta]?.length === 0) {\n            entries.Tags = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `Tags.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_UntagResourceInput = (input, context) => {\n    const entries = {};\n    if (input[_RARN] != null) {\n        entries[_RARN] = input[_RARN];\n    }\n    if (input[_TK] != null) {\n        const memberEntries = se_TagKeyList(input[_TK], context);\n        if (input[_TK]?.length === 0) {\n            entries.TagKeys = [];\n        }\n        Object.entries(memberEntries).forEach(([key, value]) => {\n            const loc = `TagKeys.${key}`;\n            entries[loc] = value;\n        });\n    }\n    return entries;\n};\nconst se_Values = (input, context) => {\n    const entries = {};\n    let counter = 1;\n    for (const entry of input) {\n        if (entry === null) {\n            continue;\n        }\n        entries[`member.${counter}`] = __serializeFloat(entry);\n        counter++;\n    }\n    return entries;\n};\nconst de_AlarmHistoryItem = (output, context) => {\n    const contents = {};\n    if (output[_ANl] != null) {\n        contents[_ANl] = __expectString(output[_ANl]);\n    }\n    if (output[_ATl] != null) {\n        contents[_ATl] = __expectString(output[_ATl]);\n    }\n    if (output[_Ti] != null) {\n        contents[_Ti] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ti]));\n    }\n    if (output[_HIT] != null) {\n        contents[_HIT] = __expectString(output[_HIT]);\n    }\n    if (output[_HS] != null) {\n        contents[_HS] = __expectString(output[_HS]);\n    }\n    if (output[_HD] != null) {\n        contents[_HD] = __expectString(output[_HD]);\n    }\n    return contents;\n};\nconst de_AlarmHistoryItems = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AlarmHistoryItem(entry, context);\n    });\n};\nconst de_AnomalyDetector = (output, context) => {\n    const contents = {};\n    if (output[_N] != null) {\n        contents[_N] = __expectString(output[_N]);\n    }\n    if (output[_MN] != null) {\n        contents[_MN] = __expectString(output[_MN]);\n    }\n    if (output.Dimensions === \"\") {\n        contents[_D] = [];\n    }\n    else if (output[_D] != null && output[_D][_m] != null) {\n        contents[_D] = de_Dimensions(__getArrayIfSingleItem(output[_D][_m]), context);\n    }\n    if (output[_S] != null) {\n        contents[_S] = __expectString(output[_S]);\n    }\n    if (output[_Co] != null) {\n        contents[_Co] = de_AnomalyDetectorConfiguration(output[_Co], context);\n    }\n    if (output[_SV] != null) {\n        contents[_SV] = __expectString(output[_SV]);\n    }\n    if (output[_MC] != null) {\n        contents[_MC] = de_MetricCharacteristics(output[_MC], context);\n    }\n    if (output[_SMAD] != null) {\n        contents[_SMAD] = de_SingleMetricAnomalyDetector(output[_SMAD], context);\n    }\n    if (output[_MMAD] != null) {\n        contents[_MMAD] = de_MetricMathAnomalyDetector(output[_MMAD], context);\n    }\n    return contents;\n};\nconst de_AnomalyDetectorConfiguration = (output, context) => {\n    const contents = {};\n    if (output.ExcludedTimeRanges === \"\") {\n        contents[_ETR] = [];\n    }\n    else if (output[_ETR] != null && output[_ETR][_m] != null) {\n        contents[_ETR] = de_AnomalyDetectorExcludedTimeRanges(__getArrayIfSingleItem(output[_ETR][_m]), context);\n    }\n    if (output[_MT] != null) {\n        contents[_MT] = __expectString(output[_MT]);\n    }\n    return contents;\n};\nconst de_AnomalyDetectorExcludedTimeRanges = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Range(entry, context);\n    });\n};\nconst de_AnomalyDetectors = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_AnomalyDetector(entry, context);\n    });\n};\nconst de_BatchFailures = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_PartialFailure(entry, context);\n    });\n};\nconst de_CompositeAlarm = (output, context) => {\n    const contents = {};\n    if (output[_AE] != null) {\n        contents[_AE] = __parseBoolean(output[_AE]);\n    }\n    if (output.AlarmActions === \"\") {\n        contents[_AA] = [];\n    }\n    else if (output[_AA] != null && output[_AA][_m] != null) {\n        contents[_AA] = de_ResourceList(__getArrayIfSingleItem(output[_AA][_m]), context);\n    }\n    if (output[_AAl] != null) {\n        contents[_AAl] = __expectString(output[_AAl]);\n    }\n    if (output[_ACUT] != null) {\n        contents[_ACUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ACUT]));\n    }\n    if (output[_AD] != null) {\n        contents[_AD] = __expectString(output[_AD]);\n    }\n    if (output[_ANl] != null) {\n        contents[_ANl] = __expectString(output[_ANl]);\n    }\n    if (output[_AR] != null) {\n        contents[_AR] = __expectString(output[_AR]);\n    }\n    if (output.InsufficientDataActions === \"\") {\n        contents[_IDA] = [];\n    }\n    else if (output[_IDA] != null && output[_IDA][_m] != null) {\n        contents[_IDA] = de_ResourceList(__getArrayIfSingleItem(output[_IDA][_m]), context);\n    }\n    if (output.OKActions === \"\") {\n        contents[_OKA] = [];\n    }\n    else if (output[_OKA] != null && output[_OKA][_m] != null) {\n        contents[_OKA] = de_ResourceList(__getArrayIfSingleItem(output[_OKA][_m]), context);\n    }\n    if (output[_SRt] != null) {\n        contents[_SRt] = __expectString(output[_SRt]);\n    }\n    if (output[_SRD] != null) {\n        contents[_SRD] = __expectString(output[_SRD]);\n    }\n    if (output[_SUT] != null) {\n        contents[_SUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SUT]));\n    }\n    if (output[_SV] != null) {\n        contents[_SV] = __expectString(output[_SV]);\n    }\n    if (output[_STT] != null) {\n        contents[_STT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_STT]));\n    }\n    if (output[_ASB] != null) {\n        contents[_ASB] = __expectString(output[_ASB]);\n    }\n    if (output[_ASR] != null) {\n        contents[_ASR] = __expectString(output[_ASR]);\n    }\n    if (output[_ASc] != null) {\n        contents[_ASc] = __expectString(output[_ASc]);\n    }\n    if (output[_ASWP] != null) {\n        contents[_ASWP] = __strictParseInt32(output[_ASWP]);\n    }\n    if (output[_ASEP] != null) {\n        contents[_ASEP] = __strictParseInt32(output[_ASEP]);\n    }\n    return contents;\n};\nconst de_CompositeAlarms = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_CompositeAlarm(entry, context);\n    });\n};\nconst de_ConcurrentModificationException = (output, context) => {\n    const contents = {};\n    if (output[_Mes] != null) {\n        contents[_Mes] = __expectString(output[_Mes]);\n    }\n    return contents;\n};\nconst de_ConflictException = (output, context) => {\n    const contents = {};\n    if (output[_Mes] != null) {\n        contents[_Mes] = __expectString(output[_Mes]);\n    }\n    return contents;\n};\nconst de_DashboardEntries = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DashboardEntry(entry, context);\n    });\n};\nconst de_DashboardEntry = (output, context) => {\n    const contents = {};\n    if (output[_DNa] != null) {\n        contents[_DNa] = __expectString(output[_DNa]);\n    }\n    if (output[_DAa] != null) {\n        contents[_DAa] = __expectString(output[_DAa]);\n    }\n    if (output[_LMa] != null) {\n        contents[_LMa] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LMa]));\n    }\n    if (output[_Si] != null) {\n        contents[_Si] = __strictParseLong(output[_Si]);\n    }\n    return contents;\n};\nconst de_DashboardInvalidInputError = (output, context) => {\n    const contents = {};\n    if (output[_me] != null) {\n        contents[_me] = __expectString(output[_me]);\n    }\n    if (output.dashboardValidationMessages === \"\") {\n        contents[_dVM] = [];\n    }\n    else if (output[_dVM] != null && output[_dVM][_m] != null) {\n        contents[_dVM] = de_DashboardValidationMessages(__getArrayIfSingleItem(output[_dVM][_m]), context);\n    }\n    return contents;\n};\nconst de_DashboardValidationMessage = (output, context) => {\n    const contents = {};\n    if (output[_DP] != null) {\n        contents[_DP] = __expectString(output[_DP]);\n    }\n    if (output[_Mes] != null) {\n        contents[_Mes] = __expectString(output[_Mes]);\n    }\n    return contents;\n};\nconst de_DashboardValidationMessages = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_DashboardValidationMessage(entry, context);\n    });\n};\nconst de_Datapoint = (output, context) => {\n    const contents = {};\n    if (output[_Ti] != null) {\n        contents[_Ti] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ti]));\n    }\n    if (output[_SCa] != null) {\n        contents[_SCa] = __strictParseFloat(output[_SCa]);\n    }\n    if (output[_Av] != null) {\n        contents[_Av] = __strictParseFloat(output[_Av]);\n    }\n    if (output[_Su] != null) {\n        contents[_Su] = __strictParseFloat(output[_Su]);\n    }\n    if (output[_Mi] != null) {\n        contents[_Mi] = __strictParseFloat(output[_Mi]);\n    }\n    if (output[_Ma] != null) {\n        contents[_Ma] = __strictParseFloat(output[_Ma]);\n    }\n    if (output[_U] != null) {\n        contents[_U] = __expectString(output[_U]);\n    }\n    if (output.ExtendedStatistics === \"\") {\n        contents[_ESx] = {};\n    }\n    else if (output[_ESx] != null && output[_ESx][_e] != null) {\n        contents[_ESx] = de_DatapointValueMap(__getArrayIfSingleItem(output[_ESx][_e]), context);\n    }\n    return contents;\n};\nconst de_Datapoints = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Datapoint(entry, context);\n    });\n};\nconst de_DatapointValueMap = (output, context) => {\n    return output.reduce((acc, pair) => {\n        if (pair[\"value\"] === null) {\n            return acc;\n        }\n        acc[pair[\"key\"]] = __strictParseFloat(pair[\"value\"]);\n        return acc;\n    }, {});\n};\nconst de_DatapointValues = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __strictParseFloat(entry);\n    });\n};\nconst de_DeleteAnomalyDetectorOutput = (output, context) => {\n    const contents = {};\n    return contents;\n};\nconst de_DeleteDashboardsOutput = (output, context) => {\n    const contents = {};\n    return contents;\n};\nconst de_DeleteInsightRulesOutput = (output, context) => {\n    const contents = {};\n    if (output.Failures === \"\") {\n        contents[_F] = [];\n    }\n    else if (output[_F] != null && output[_F][_m] != null) {\n        contents[_F] = de_BatchFailures(__getArrayIfSingleItem(output[_F][_m]), context);\n    }\n    return contents;\n};\nconst de_DeleteMetricStreamOutput = (output, context) => {\n    const contents = {};\n    return contents;\n};\nconst de_DescribeAlarmHistoryOutput = (output, context) => {\n    const contents = {};\n    if (output.AlarmHistoryItems === \"\") {\n        contents[_AHI] = [];\n    }\n    else if (output[_AHI] != null && output[_AHI][_m] != null) {\n        contents[_AHI] = de_AlarmHistoryItems(__getArrayIfSingleItem(output[_AHI][_m]), context);\n    }\n    if (output[_NT] != null) {\n        contents[_NT] = __expectString(output[_NT]);\n    }\n    return contents;\n};\nconst de_DescribeAlarmsForMetricOutput = (output, context) => {\n    const contents = {};\n    if (output.MetricAlarms === \"\") {\n        contents[_MA] = [];\n    }\n    else if (output[_MA] != null && output[_MA][_m] != null) {\n        contents[_MA] = de_MetricAlarms(__getArrayIfSingleItem(output[_MA][_m]), context);\n    }\n    return contents;\n};\nconst de_DescribeAlarmsOutput = (output, context) => {\n    const contents = {};\n    if (output.CompositeAlarms === \"\") {\n        contents[_CA] = [];\n    }\n    else if (output[_CA] != null && output[_CA][_m] != null) {\n        contents[_CA] = de_CompositeAlarms(__getArrayIfSingleItem(output[_CA][_m]), context);\n    }\n    if (output.MetricAlarms === \"\") {\n        contents[_MA] = [];\n    }\n    else if (output[_MA] != null && output[_MA][_m] != null) {\n        contents[_MA] = de_MetricAlarms(__getArrayIfSingleItem(output[_MA][_m]), context);\n    }\n    if (output[_NT] != null) {\n        contents[_NT] = __expectString(output[_NT]);\n    }\n    return contents;\n};\nconst de_DescribeAnomalyDetectorsOutput = (output, context) => {\n    const contents = {};\n    if (output.AnomalyDetectors === \"\") {\n        contents[_ADn] = [];\n    }\n    else if (output[_ADn] != null && output[_ADn][_m] != null) {\n        contents[_ADn] = de_AnomalyDetectors(__getArrayIfSingleItem(output[_ADn][_m]), context);\n    }\n    if (output[_NT] != null) {\n        contents[_NT] = __expectString(output[_NT]);\n    }\n    return contents;\n};\nconst de_DescribeInsightRulesOutput = (output, context) => {\n    const contents = {};\n    if (output[_NT] != null) {\n        contents[_NT] = __expectString(output[_NT]);\n    }\n    if (output.InsightRules === \"\") {\n        contents[_IR] = [];\n    }\n    else if (output[_IR] != null && output[_IR][_m] != null) {\n        contents[_IR] = de_InsightRules(__getArrayIfSingleItem(output[_IR][_m]), context);\n    }\n    return contents;\n};\nconst de_Dimension = (output, context) => {\n    const contents = {};\n    if (output[_Na] != null) {\n        contents[_Na] = __expectString(output[_Na]);\n    }\n    if (output[_Va] != null) {\n        contents[_Va] = __expectString(output[_Va]);\n    }\n    return contents;\n};\nconst de_Dimensions = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Dimension(entry, context);\n    });\n};\nconst de_DisableInsightRulesOutput = (output, context) => {\n    const contents = {};\n    if (output.Failures === \"\") {\n        contents[_F] = [];\n    }\n    else if (output[_F] != null && output[_F][_m] != null) {\n        contents[_F] = de_BatchFailures(__getArrayIfSingleItem(output[_F][_m]), context);\n    }\n    return contents;\n};\nconst de_EnableInsightRulesOutput = (output, context) => {\n    const contents = {};\n    if (output.Failures === \"\") {\n        contents[_F] = [];\n    }\n    else if (output[_F] != null && output[_F][_m] != null) {\n        contents[_F] = de_BatchFailures(__getArrayIfSingleItem(output[_F][_m]), context);\n    }\n    return contents;\n};\nconst de_GetDashboardOutput = (output, context) => {\n    const contents = {};\n    if (output[_DAa] != null) {\n        contents[_DAa] = __expectString(output[_DAa]);\n    }\n    if (output[_DB] != null) {\n        contents[_DB] = __expectString(output[_DB]);\n    }\n    if (output[_DNa] != null) {\n        contents[_DNa] = __expectString(output[_DNa]);\n    }\n    return contents;\n};\nconst de_GetInsightRuleReportOutput = (output, context) => {\n    const contents = {};\n    if (output.KeyLabels === \"\") {\n        contents[_KL] = [];\n    }\n    else if (output[_KL] != null && output[_KL][_m] != null) {\n        contents[_KL] = de_InsightRuleContributorKeyLabels(__getArrayIfSingleItem(output[_KL][_m]), context);\n    }\n    if (output[_ASg] != null) {\n        contents[_ASg] = __expectString(output[_ASg]);\n    }\n    if (output[_AV] != null) {\n        contents[_AV] = __strictParseFloat(output[_AV]);\n    }\n    if (output[_AUC] != null) {\n        contents[_AUC] = __strictParseLong(output[_AUC]);\n    }\n    if (output.Contributors === \"\") {\n        contents[_Con] = [];\n    }\n    else if (output[_Con] != null && output[_Con][_m] != null) {\n        contents[_Con] = de_InsightRuleContributors(__getArrayIfSingleItem(output[_Con][_m]), context);\n    }\n    if (output.MetricDatapoints === \"\") {\n        contents[_MDe] = [];\n    }\n    else if (output[_MDe] != null && output[_MDe][_m] != null) {\n        contents[_MDe] = de_InsightRuleMetricDatapoints(__getArrayIfSingleItem(output[_MDe][_m]), context);\n    }\n    return contents;\n};\nconst de_GetMetricDataOutput = (output, context) => {\n    const contents = {};\n    if (output.MetricDataResults === \"\") {\n        contents[_MDR] = [];\n    }\n    else if (output[_MDR] != null && output[_MDR][_m] != null) {\n        contents[_MDR] = de_MetricDataResults(__getArrayIfSingleItem(output[_MDR][_m]), context);\n    }\n    if (output[_NT] != null) {\n        contents[_NT] = __expectString(output[_NT]);\n    }\n    if (output.Messages === \"\") {\n        contents[_Mess] = [];\n    }\n    else if (output[_Mess] != null && output[_Mess][_m] != null) {\n        contents[_Mess] = de_MetricDataResultMessages(__getArrayIfSingleItem(output[_Mess][_m]), context);\n    }\n    return contents;\n};\nconst de_GetMetricStatisticsOutput = (output, context) => {\n    const contents = {};\n    if (output[_L] != null) {\n        contents[_L] = __expectString(output[_L]);\n    }\n    if (output.Datapoints === \"\") {\n        contents[_Da] = [];\n    }\n    else if (output[_Da] != null && output[_Da][_m] != null) {\n        contents[_Da] = de_Datapoints(__getArrayIfSingleItem(output[_Da][_m]), context);\n    }\n    return contents;\n};\nconst de_GetMetricStreamOutput = (output, context) => {\n    const contents = {};\n    if (output[_Ar] != null) {\n        contents[_Ar] = __expectString(output[_Ar]);\n    }\n    if (output[_Na] != null) {\n        contents[_Na] = __expectString(output[_Na]);\n    }\n    if (output.IncludeFilters === \"\") {\n        contents[_IF] = [];\n    }\n    else if (output[_IF] != null && output[_IF][_m] != null) {\n        contents[_IF] = de_MetricStreamFilters(__getArrayIfSingleItem(output[_IF][_m]), context);\n    }\n    if (output.ExcludeFilters === \"\") {\n        contents[_EF] = [];\n    }\n    else if (output[_EF] != null && output[_EF][_m] != null) {\n        contents[_EF] = de_MetricStreamFilters(__getArrayIfSingleItem(output[_EF][_m]), context);\n    }\n    if (output[_FA] != null) {\n        contents[_FA] = __expectString(output[_FA]);\n    }\n    if (output[_RAo] != null) {\n        contents[_RAo] = __expectString(output[_RAo]);\n    }\n    if (output[_Stat] != null) {\n        contents[_Stat] = __expectString(output[_Stat]);\n    }\n    if (output[_CD] != null) {\n        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));\n    }\n    if (output[_LUD] != null) {\n        contents[_LUD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LUD]));\n    }\n    if (output[_OF] != null) {\n        contents[_OF] = __expectString(output[_OF]);\n    }\n    if (output.StatisticsConfigurations === \"\") {\n        contents[_SC] = [];\n    }\n    else if (output[_SC] != null && output[_SC][_m] != null) {\n        contents[_SC] = de_MetricStreamStatisticsConfigurations(__getArrayIfSingleItem(output[_SC][_m]), context);\n    }\n    if (output[_ILAM] != null) {\n        contents[_ILAM] = __parseBoolean(output[_ILAM]);\n    }\n    return contents;\n};\nconst de_GetMetricWidgetImageOutput = (output, context) => {\n    const contents = {};\n    if (output[_MWI] != null) {\n        contents[_MWI] = context.base64Decoder(output[_MWI]);\n    }\n    return contents;\n};\nconst de_InsightRule = (output, context) => {\n    const contents = {};\n    if (output[_Na] != null) {\n        contents[_Na] = __expectString(output[_Na]);\n    }\n    if (output[_Stat] != null) {\n        contents[_Stat] = __expectString(output[_Stat]);\n    }\n    if (output[_Sc] != null) {\n        contents[_Sc] = __expectString(output[_Sc]);\n    }\n    if (output[_De] != null) {\n        contents[_De] = __expectString(output[_De]);\n    }\n    if (output[_MRana] != null) {\n        contents[_MRana] = __parseBoolean(output[_MRana]);\n    }\n    if (output[_AOTL] != null) {\n        contents[_AOTL] = __parseBoolean(output[_AOTL]);\n    }\n    return contents;\n};\nconst de_InsightRuleContributor = (output, context) => {\n    const contents = {};\n    if (output.Keys === \"\") {\n        contents[_Ke] = [];\n    }\n    else if (output[_Ke] != null && output[_Ke][_m] != null) {\n        contents[_Ke] = de_InsightRuleContributorKeys(__getArrayIfSingleItem(output[_Ke][_m]), context);\n    }\n    if (output[_AAV] != null) {\n        contents[_AAV] = __strictParseFloat(output[_AAV]);\n    }\n    if (output.Datapoints === \"\") {\n        contents[_Da] = [];\n    }\n    else if (output[_Da] != null && output[_Da][_m] != null) {\n        contents[_Da] = de_InsightRuleContributorDatapoints(__getArrayIfSingleItem(output[_Da][_m]), context);\n    }\n    return contents;\n};\nconst de_InsightRuleContributorDatapoint = (output, context) => {\n    const contents = {};\n    if (output[_Ti] != null) {\n        contents[_Ti] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ti]));\n    }\n    if (output[_AVp] != null) {\n        contents[_AVp] = __strictParseFloat(output[_AVp]);\n    }\n    return contents;\n};\nconst de_InsightRuleContributorDatapoints = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InsightRuleContributorDatapoint(entry, context);\n    });\n};\nconst de_InsightRuleContributorKeyLabels = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_InsightRuleContributorKeys = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_InsightRuleContributors = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InsightRuleContributor(entry, context);\n    });\n};\nconst de_InsightRuleMetricDatapoint = (output, context) => {\n    const contents = {};\n    if (output[_Ti] != null) {\n        contents[_Ti] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ti]));\n    }\n    if (output[_UC] != null) {\n        contents[_UC] = __strictParseFloat(output[_UC]);\n    }\n    if (output[_MCV] != null) {\n        contents[_MCV] = __strictParseFloat(output[_MCV]);\n    }\n    if (output[_SCa] != null) {\n        contents[_SCa] = __strictParseFloat(output[_SCa]);\n    }\n    if (output[_Av] != null) {\n        contents[_Av] = __strictParseFloat(output[_Av]);\n    }\n    if (output[_Su] != null) {\n        contents[_Su] = __strictParseFloat(output[_Su]);\n    }\n    if (output[_Mi] != null) {\n        contents[_Mi] = __strictParseFloat(output[_Mi]);\n    }\n    if (output[_Ma] != null) {\n        contents[_Ma] = __strictParseFloat(output[_Ma]);\n    }\n    return contents;\n};\nconst de_InsightRuleMetricDatapoints = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InsightRuleMetricDatapoint(entry, context);\n    });\n};\nconst de_InsightRules = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_InsightRule(entry, context);\n    });\n};\nconst de_InternalServiceFault = (output, context) => {\n    const contents = {};\n    if (output[_Mes] != null) {\n        contents[_Mes] = __expectString(output[_Mes]);\n    }\n    return contents;\n};\nconst de_InvalidFormatFault = (output, context) => {\n    const contents = {};\n    if (output[_me] != null) {\n        contents[_me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_InvalidNextToken = (output, context) => {\n    const contents = {};\n    if (output[_me] != null) {\n        contents[_me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_InvalidParameterCombinationException = (output, context) => {\n    const contents = {};\n    if (output[_me] != null) {\n        contents[_me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_InvalidParameterValueException = (output, context) => {\n    const contents = {};\n    if (output[_me] != null) {\n        contents[_me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_LimitExceededException = (output, context) => {\n    const contents = {};\n    if (output[_Mes] != null) {\n        contents[_Mes] = __expectString(output[_Mes]);\n    }\n    return contents;\n};\nconst de_LimitExceededFault = (output, context) => {\n    const contents = {};\n    if (output[_me] != null) {\n        contents[_me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_ListDashboardsOutput = (output, context) => {\n    const contents = {};\n    if (output.DashboardEntries === \"\") {\n        contents[_DE] = [];\n    }\n    else if (output[_DE] != null && output[_DE][_m] != null) {\n        contents[_DE] = de_DashboardEntries(__getArrayIfSingleItem(output[_DE][_m]), context);\n    }\n    if (output[_NT] != null) {\n        contents[_NT] = __expectString(output[_NT]);\n    }\n    return contents;\n};\nconst de_ListManagedInsightRulesOutput = (output, context) => {\n    const contents = {};\n    if (output.ManagedRules === \"\") {\n        contents[_MRan] = [];\n    }\n    else if (output[_MRan] != null && output[_MRan][_m] != null) {\n        contents[_MRan] = de_ManagedRuleDescriptions(__getArrayIfSingleItem(output[_MRan][_m]), context);\n    }\n    if (output[_NT] != null) {\n        contents[_NT] = __expectString(output[_NT]);\n    }\n    return contents;\n};\nconst de_ListMetricsOutput = (output, context) => {\n    const contents = {};\n    if (output.Metrics === \"\") {\n        contents[_M] = [];\n    }\n    else if (output[_M] != null && output[_M][_m] != null) {\n        contents[_M] = de_Metrics(__getArrayIfSingleItem(output[_M][_m]), context);\n    }\n    if (output[_NT] != null) {\n        contents[_NT] = __expectString(output[_NT]);\n    }\n    if (output.OwningAccounts === \"\") {\n        contents[_OAw] = [];\n    }\n    else if (output[_OAw] != null && output[_OAw][_m] != null) {\n        contents[_OAw] = de_OwningAccounts(__getArrayIfSingleItem(output[_OAw][_m]), context);\n    }\n    return contents;\n};\nconst de_ListMetricStreamsOutput = (output, context) => {\n    const contents = {};\n    if (output[_NT] != null) {\n        contents[_NT] = __expectString(output[_NT]);\n    }\n    if (output.Entries === \"\") {\n        contents[_En] = [];\n    }\n    else if (output[_En] != null && output[_En][_m] != null) {\n        contents[_En] = de_MetricStreamEntries(__getArrayIfSingleItem(output[_En][_m]), context);\n    }\n    return contents;\n};\nconst de_ListTagsForResourceOutput = (output, context) => {\n    const contents = {};\n    if (output.Tags === \"\") {\n        contents[_Ta] = [];\n    }\n    else if (output[_Ta] != null && output[_Ta][_m] != null) {\n        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_Ta][_m]), context);\n    }\n    return contents;\n};\nconst de_ManagedRuleDescription = (output, context) => {\n    const contents = {};\n    if (output[_TN] != null) {\n        contents[_TN] = __expectString(output[_TN]);\n    }\n    if (output[_RARN] != null) {\n        contents[_RARN] = __expectString(output[_RARN]);\n    }\n    if (output[_RS] != null) {\n        contents[_RS] = de_ManagedRuleState(output[_RS], context);\n    }\n    return contents;\n};\nconst de_ManagedRuleDescriptions = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_ManagedRuleDescription(entry, context);\n    });\n};\nconst de_ManagedRuleState = (output, context) => {\n    const contents = {};\n    if (output[_RNu] != null) {\n        contents[_RNu] = __expectString(output[_RNu]);\n    }\n    if (output[_Stat] != null) {\n        contents[_Stat] = __expectString(output[_Stat]);\n    }\n    return contents;\n};\nconst de_MessageData = (output, context) => {\n    const contents = {};\n    if (output[_Cod] != null) {\n        contents[_Cod] = __expectString(output[_Cod]);\n    }\n    if (output[_Va] != null) {\n        contents[_Va] = __expectString(output[_Va]);\n    }\n    return contents;\n};\nconst de_Metric = (output, context) => {\n    const contents = {};\n    if (output[_N] != null) {\n        contents[_N] = __expectString(output[_N]);\n    }\n    if (output[_MN] != null) {\n        contents[_MN] = __expectString(output[_MN]);\n    }\n    if (output.Dimensions === \"\") {\n        contents[_D] = [];\n    }\n    else if (output[_D] != null && output[_D][_m] != null) {\n        contents[_D] = de_Dimensions(__getArrayIfSingleItem(output[_D][_m]), context);\n    }\n    return contents;\n};\nconst de_MetricAlarm = (output, context) => {\n    const contents = {};\n    if (output[_ANl] != null) {\n        contents[_ANl] = __expectString(output[_ANl]);\n    }\n    if (output[_AAl] != null) {\n        contents[_AAl] = __expectString(output[_AAl]);\n    }\n    if (output[_AD] != null) {\n        contents[_AD] = __expectString(output[_AD]);\n    }\n    if (output[_ACUT] != null) {\n        contents[_ACUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ACUT]));\n    }\n    if (output[_AE] != null) {\n        contents[_AE] = __parseBoolean(output[_AE]);\n    }\n    if (output.OKActions === \"\") {\n        contents[_OKA] = [];\n    }\n    else if (output[_OKA] != null && output[_OKA][_m] != null) {\n        contents[_OKA] = de_ResourceList(__getArrayIfSingleItem(output[_OKA][_m]), context);\n    }\n    if (output.AlarmActions === \"\") {\n        contents[_AA] = [];\n    }\n    else if (output[_AA] != null && output[_AA][_m] != null) {\n        contents[_AA] = de_ResourceList(__getArrayIfSingleItem(output[_AA][_m]), context);\n    }\n    if (output.InsufficientDataActions === \"\") {\n        contents[_IDA] = [];\n    }\n    else if (output[_IDA] != null && output[_IDA][_m] != null) {\n        contents[_IDA] = de_ResourceList(__getArrayIfSingleItem(output[_IDA][_m]), context);\n    }\n    if (output[_SV] != null) {\n        contents[_SV] = __expectString(output[_SV]);\n    }\n    if (output[_SRt] != null) {\n        contents[_SRt] = __expectString(output[_SRt]);\n    }\n    if (output[_SRD] != null) {\n        contents[_SRD] = __expectString(output[_SRD]);\n    }\n    if (output[_SUT] != null) {\n        contents[_SUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SUT]));\n    }\n    if (output[_MN] != null) {\n        contents[_MN] = __expectString(output[_MN]);\n    }\n    if (output[_N] != null) {\n        contents[_N] = __expectString(output[_N]);\n    }\n    if (output[_St] != null) {\n        contents[_St] = __expectString(output[_St]);\n    }\n    if (output[_ES] != null) {\n        contents[_ES] = __expectString(output[_ES]);\n    }\n    if (output.Dimensions === \"\") {\n        contents[_D] = [];\n    }\n    else if (output[_D] != null && output[_D][_m] != null) {\n        contents[_D] = de_Dimensions(__getArrayIfSingleItem(output[_D][_m]), context);\n    }\n    if (output[_P] != null) {\n        contents[_P] = __strictParseInt32(output[_P]);\n    }\n    if (output[_U] != null) {\n        contents[_U] = __expectString(output[_U]);\n    }\n    if (output[_EP] != null) {\n        contents[_EP] = __strictParseInt32(output[_EP]);\n    }\n    if (output[_DTA] != null) {\n        contents[_DTA] = __strictParseInt32(output[_DTA]);\n    }\n    if (output[_Th] != null) {\n        contents[_Th] = __strictParseFloat(output[_Th]);\n    }\n    if (output[_CO] != null) {\n        contents[_CO] = __expectString(output[_CO]);\n    }\n    if (output[_TMD] != null) {\n        contents[_TMD] = __expectString(output[_TMD]);\n    }\n    if (output[_ELSCP] != null) {\n        contents[_ELSCP] = __expectString(output[_ELSCP]);\n    }\n    if (output.Metrics === \"\") {\n        contents[_M] = [];\n    }\n    else if (output[_M] != null && output[_M][_m] != null) {\n        contents[_M] = de_MetricDataQueries(__getArrayIfSingleItem(output[_M][_m]), context);\n    }\n    if (output[_TMI] != null) {\n        contents[_TMI] = __expectString(output[_TMI]);\n    }\n    if (output[_ESv] != null) {\n        contents[_ESv] = __expectString(output[_ESv]);\n    }\n    if (output[_STT] != null) {\n        contents[_STT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_STT]));\n    }\n    return contents;\n};\nconst de_MetricAlarms = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MetricAlarm(entry, context);\n    });\n};\nconst de_MetricCharacteristics = (output, context) => {\n    const contents = {};\n    if (output[_PS] != null) {\n        contents[_PS] = __parseBoolean(output[_PS]);\n    }\n    return contents;\n};\nconst de_MetricDataQueries = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MetricDataQuery(entry, context);\n    });\n};\nconst de_MetricDataQuery = (output, context) => {\n    const contents = {};\n    if (output[_I] != null) {\n        contents[_I] = __expectString(output[_I]);\n    }\n    if (output[_MS] != null) {\n        contents[_MS] = de_MetricStat(output[_MS], context);\n    }\n    if (output[_Ex] != null) {\n        contents[_Ex] = __expectString(output[_Ex]);\n    }\n    if (output[_L] != null) {\n        contents[_L] = __expectString(output[_L]);\n    }\n    if (output[_RD] != null) {\n        contents[_RD] = __parseBoolean(output[_RD]);\n    }\n    if (output[_P] != null) {\n        contents[_P] = __strictParseInt32(output[_P]);\n    }\n    if (output[_AI] != null) {\n        contents[_AI] = __expectString(output[_AI]);\n    }\n    return contents;\n};\nconst de_MetricDataResult = (output, context) => {\n    const contents = {};\n    if (output[_I] != null) {\n        contents[_I] = __expectString(output[_I]);\n    }\n    if (output[_L] != null) {\n        contents[_L] = __expectString(output[_L]);\n    }\n    if (output.Timestamps === \"\") {\n        contents[_Tim] = [];\n    }\n    else if (output[_Tim] != null && output[_Tim][_m] != null) {\n        contents[_Tim] = de_Timestamps(__getArrayIfSingleItem(output[_Tim][_m]), context);\n    }\n    if (output.Values === \"\") {\n        contents[_Val] = [];\n    }\n    else if (output[_Val] != null && output[_Val][_m] != null) {\n        contents[_Val] = de_DatapointValues(__getArrayIfSingleItem(output[_Val][_m]), context);\n    }\n    if (output[_SCt] != null) {\n        contents[_SCt] = __expectString(output[_SCt]);\n    }\n    if (output.Messages === \"\") {\n        contents[_Mess] = [];\n    }\n    else if (output[_Mess] != null && output[_Mess][_m] != null) {\n        contents[_Mess] = de_MetricDataResultMessages(__getArrayIfSingleItem(output[_Mess][_m]), context);\n    }\n    return contents;\n};\nconst de_MetricDataResultMessages = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MessageData(entry, context);\n    });\n};\nconst de_MetricDataResults = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MetricDataResult(entry, context);\n    });\n};\nconst de_MetricMathAnomalyDetector = (output, context) => {\n    const contents = {};\n    if (output.MetricDataQueries === \"\") {\n        contents[_MDQ] = [];\n    }\n    else if (output[_MDQ] != null && output[_MDQ][_m] != null) {\n        contents[_MDQ] = de_MetricDataQueries(__getArrayIfSingleItem(output[_MDQ][_m]), context);\n    }\n    return contents;\n};\nconst de_Metrics = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Metric(entry, context);\n    });\n};\nconst de_MetricStat = (output, context) => {\n    const contents = {};\n    if (output[_Me] != null) {\n        contents[_Me] = de_Metric(output[_Me], context);\n    }\n    if (output[_P] != null) {\n        contents[_P] = __strictParseInt32(output[_P]);\n    }\n    if (output[_S] != null) {\n        contents[_S] = __expectString(output[_S]);\n    }\n    if (output[_U] != null) {\n        contents[_U] = __expectString(output[_U]);\n    }\n    return contents;\n};\nconst de_MetricStreamEntries = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MetricStreamEntry(entry, context);\n    });\n};\nconst de_MetricStreamEntry = (output, context) => {\n    const contents = {};\n    if (output[_Ar] != null) {\n        contents[_Ar] = __expectString(output[_Ar]);\n    }\n    if (output[_CD] != null) {\n        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));\n    }\n    if (output[_LUD] != null) {\n        contents[_LUD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LUD]));\n    }\n    if (output[_Na] != null) {\n        contents[_Na] = __expectString(output[_Na]);\n    }\n    if (output[_FA] != null) {\n        contents[_FA] = __expectString(output[_FA]);\n    }\n    if (output[_Stat] != null) {\n        contents[_Stat] = __expectString(output[_Stat]);\n    }\n    if (output[_OF] != null) {\n        contents[_OF] = __expectString(output[_OF]);\n    }\n    return contents;\n};\nconst de_MetricStreamFilter = (output, context) => {\n    const contents = {};\n    if (output[_N] != null) {\n        contents[_N] = __expectString(output[_N]);\n    }\n    if (output.MetricNames === \"\") {\n        contents[_MNe] = [];\n    }\n    else if (output[_MNe] != null && output[_MNe][_m] != null) {\n        contents[_MNe] = de_MetricStreamFilterMetricNames(__getArrayIfSingleItem(output[_MNe][_m]), context);\n    }\n    return contents;\n};\nconst de_MetricStreamFilterMetricNames = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_MetricStreamFilters = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MetricStreamFilter(entry, context);\n    });\n};\nconst de_MetricStreamStatisticsAdditionalStatistics = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_MetricStreamStatisticsConfiguration = (output, context) => {\n    const contents = {};\n    if (output.IncludeMetrics === \"\") {\n        contents[_IM] = [];\n    }\n    else if (output[_IM] != null && output[_IM][_m] != null) {\n        contents[_IM] = de_MetricStreamStatisticsIncludeMetrics(__getArrayIfSingleItem(output[_IM][_m]), context);\n    }\n    if (output.AdditionalStatistics === \"\") {\n        contents[_AS] = [];\n    }\n    else if (output[_AS] != null && output[_AS][_m] != null) {\n        contents[_AS] = de_MetricStreamStatisticsAdditionalStatistics(__getArrayIfSingleItem(output[_AS][_m]), context);\n    }\n    return contents;\n};\nconst de_MetricStreamStatisticsConfigurations = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MetricStreamStatisticsConfiguration(entry, context);\n    });\n};\nconst de_MetricStreamStatisticsIncludeMetrics = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_MetricStreamStatisticsMetric(entry, context);\n    });\n};\nconst de_MetricStreamStatisticsMetric = (output, context) => {\n    const contents = {};\n    if (output[_N] != null) {\n        contents[_N] = __expectString(output[_N]);\n    }\n    if (output[_MN] != null) {\n        contents[_MN] = __expectString(output[_MN]);\n    }\n    return contents;\n};\nconst de_MissingRequiredParameterException = (output, context) => {\n    const contents = {};\n    if (output[_me] != null) {\n        contents[_me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_OwningAccounts = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_PartialFailure = (output, context) => {\n    const contents = {};\n    if (output[_FR] != null) {\n        contents[_FR] = __expectString(output[_FR]);\n    }\n    if (output[_ETx] != null) {\n        contents[_ETx] = __expectString(output[_ETx]);\n    }\n    if (output[_FC] != null) {\n        contents[_FC] = __expectString(output[_FC]);\n    }\n    if (output[_FD] != null) {\n        contents[_FD] = __expectString(output[_FD]);\n    }\n    return contents;\n};\nconst de_PutAnomalyDetectorOutput = (output, context) => {\n    const contents = {};\n    return contents;\n};\nconst de_PutDashboardOutput = (output, context) => {\n    const contents = {};\n    if (output.DashboardValidationMessages === \"\") {\n        contents[_DVM] = [];\n    }\n    else if (output[_DVM] != null && output[_DVM][_m] != null) {\n        contents[_DVM] = de_DashboardValidationMessages(__getArrayIfSingleItem(output[_DVM][_m]), context);\n    }\n    return contents;\n};\nconst de_PutInsightRuleOutput = (output, context) => {\n    const contents = {};\n    return contents;\n};\nconst de_PutManagedInsightRulesOutput = (output, context) => {\n    const contents = {};\n    if (output.Failures === \"\") {\n        contents[_F] = [];\n    }\n    else if (output[_F] != null && output[_F][_m] != null) {\n        contents[_F] = de_BatchFailures(__getArrayIfSingleItem(output[_F][_m]), context);\n    }\n    return contents;\n};\nconst de_PutMetricStreamOutput = (output, context) => {\n    const contents = {};\n    if (output[_Ar] != null) {\n        contents[_Ar] = __expectString(output[_Ar]);\n    }\n    return contents;\n};\nconst de_Range = (output, context) => {\n    const contents = {};\n    if (output[_ST] != null) {\n        contents[_ST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ST]));\n    }\n    if (output[_ET] != null) {\n        contents[_ET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ET]));\n    }\n    return contents;\n};\nconst de_ResourceList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectString(entry);\n    });\n};\nconst de_ResourceNotFound = (output, context) => {\n    const contents = {};\n    if (output[_me] != null) {\n        contents[_me] = __expectString(output[_me]);\n    }\n    return contents;\n};\nconst de_ResourceNotFoundException = (output, context) => {\n    const contents = {};\n    if (output[_RT] != null) {\n        contents[_RT] = __expectString(output[_RT]);\n    }\n    if (output[_RI] != null) {\n        contents[_RI] = __expectString(output[_RI]);\n    }\n    if (output[_Mes] != null) {\n        contents[_Mes] = __expectString(output[_Mes]);\n    }\n    return contents;\n};\nconst de_SingleMetricAnomalyDetector = (output, context) => {\n    const contents = {};\n    if (output[_AI] != null) {\n        contents[_AI] = __expectString(output[_AI]);\n    }\n    if (output[_N] != null) {\n        contents[_N] = __expectString(output[_N]);\n    }\n    if (output[_MN] != null) {\n        contents[_MN] = __expectString(output[_MN]);\n    }\n    if (output.Dimensions === \"\") {\n        contents[_D] = [];\n    }\n    else if (output[_D] != null && output[_D][_m] != null) {\n        contents[_D] = de_Dimensions(__getArrayIfSingleItem(output[_D][_m]), context);\n    }\n    if (output[_S] != null) {\n        contents[_S] = __expectString(output[_S]);\n    }\n    return contents;\n};\nconst de_StartMetricStreamsOutput = (output, context) => {\n    const contents = {};\n    return contents;\n};\nconst de_StopMetricStreamsOutput = (output, context) => {\n    const contents = {};\n    return contents;\n};\nconst de_Tag = (output, context) => {\n    const contents = {};\n    if (output[_K] != null) {\n        contents[_K] = __expectString(output[_K]);\n    }\n    if (output[_Va] != null) {\n        contents[_Va] = __expectString(output[_Va]);\n    }\n    return contents;\n};\nconst de_TagList = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return de_Tag(entry, context);\n    });\n};\nconst de_TagResourceOutput = (output, context) => {\n    const contents = {};\n    return contents;\n};\nconst de_Timestamps = (output, context) => {\n    return (output || [])\n        .filter((e) => e != null)\n        .map((entry) => {\n        return __expectNonNull(__parseRfc3339DateTimeWithOffset(entry));\n    });\n};\nconst de_UntagResourceOutput = (output, context) => {\n    const contents = {};\n    return contents;\n};\nconst deserializeMetadata = (output) => ({\n    httpStatusCode: output.statusCode,\n    requestId: output.headers[\"x-amzn-requestid\"] ?? output.headers[\"x-amzn-request-id\"] ?? output.headers[\"x-amz-request-id\"],\n    extendedRequestId: output.headers[\"x-amz-id-2\"],\n    cfId: output.headers[\"x-amz-cf-id\"],\n});\nconst collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));\nconst throwDefaultError = withBaseException(__BaseException);\nconst buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {\n    const { hostname, protocol = \"https\", port, path: basePath } = await context.endpoint();\n    const contents = {\n        protocol,\n        hostname,\n        port,\n        method: \"POST\",\n        path: basePath.endsWith(\"/\") ? basePath.slice(0, -1) + path : basePath + path,\n        headers,\n    };\n    if (resolvedHostname !== undefined) {\n        contents.hostname = resolvedHostname;\n    }\n    if (body !== undefined) {\n        contents.body = body;\n    }\n    return new __HttpRequest(contents);\n};\nconst SHARED_HEADERS = {\n    \"content-type\": \"application/x-www-form-urlencoded\",\n};\nconst _ = \"2010-08-01\";\nconst _A = \"Action\";\nconst _AA = \"AlarmActions\";\nconst _AAV = \"ApproximateAggregateValue\";\nconst _AAl = \"AlarmArn\";\nconst _ACUT = \"AlarmConfigurationUpdatedTimestamp\";\nconst _AD = \"AlarmDescription\";\nconst _ADT = \"AnomalyDetectorTypes\";\nconst _ADn = \"AnomalyDetectors\";\nconst _AE = \"ActionsEnabled\";\nconst _AHI = \"AlarmHistoryItems\";\nconst _AI = \"AccountId\";\nconst _AN = \"AlarmNames\";\nconst _ANP = \"AlarmNamePrefix\";\nconst _ANl = \"AlarmName\";\nconst _AOTL = \"ApplyOnTransformedLogs\";\nconst _AP = \"ActionPrefix\";\nconst _AR = \"AlarmRule\";\nconst _AS = \"AdditionalStatistics\";\nconst _ASB = \"ActionsSuppressedBy\";\nconst _ASEP = \"ActionsSuppressorExtensionPeriod\";\nconst _ASR = \"ActionsSuppressedReason\";\nconst _ASWP = \"ActionsSuppressorWaitPeriod\";\nconst _ASc = \"ActionsSuppressor\";\nconst _ASg = \"AggregationStatistic\";\nconst _AT = \"AlarmTypes\";\nconst _ATl = \"AlarmType\";\nconst _AUC = \"ApproximateUniqueCount\";\nconst _AV = \"AggregateValue\";\nconst _AVp = \"ApproximateValue\";\nconst _Ar = \"Arn\";\nconst _At = \"Attributes\";\nconst _Av = \"Average\";\nconst _C = \"Counts\";\nconst _CA = \"CompositeAlarms\";\nconst _CD = \"CreationDate\";\nconst _CO = \"ComparisonOperator\";\nconst _COAN = \"ChildrenOfAlarmName\";\nconst _Co = \"Configuration\";\nconst _Cod = \"Code\";\nconst _Con = \"Contributors\";\nconst _D = \"Dimensions\";\nconst _DA = \"DeleteAlarms\";\nconst _DAA = \"DisableAlarmActions\";\nconst _DAD = \"DeleteAnomalyDetector\";\nconst _DADe = \"DescribeAnomalyDetectors\";\nconst _DAFM = \"DescribeAlarmsForMetric\";\nconst _DAH = \"DescribeAlarmHistory\";\nconst _DAa = \"DashboardArn\";\nconst _DAe = \"DescribeAlarms\";\nconst _DB = \"DashboardBody\";\nconst _DD = \"DeleteDashboards\";\nconst _DE = \"DashboardEntries\";\nconst _DIR = \"DeleteInsightRules\";\nconst _DIRe = \"DescribeInsightRules\";\nconst _DIRi = \"DisableInsightRules\";\nconst _DMS = \"DeleteMetricStream\";\nconst _DN = \"DashboardNames\";\nconst _DNP = \"DashboardNamePrefix\";\nconst _DNa = \"DashboardName\";\nconst _DP = \"DataPath\";\nconst _DTA = \"DatapointsToAlarm\";\nconst _DVM = \"DashboardValidationMessages\";\nconst _Da = \"Datapoints\";\nconst _De = \"Definition\";\nconst _E = \"Entity\";\nconst _EAA = \"EnableAlarmActions\";\nconst _ED = \"EndDate\";\nconst _EF = \"ExcludeFilters\";\nconst _EIR = \"EnableInsightRules\";\nconst _ELSCP = \"EvaluateLowSampleCountPercentile\";\nconst _EMD = \"EntityMetricData\";\nconst _EP = \"EvaluationPeriods\";\nconst _ES = \"ExtendedStatistic\";\nconst _ESv = \"EvaluationState\";\nconst _ESx = \"ExtendedStatistics\";\nconst _ET = \"EndTime\";\nconst _ETR = \"ExcludedTimeRanges\";\nconst _ETx = \"ExceptionType\";\nconst _En = \"Entries\";\nconst _Ex = \"Expression\";\nconst _F = \"Failures\";\nconst _FA = \"FirehoseArn\";\nconst _FC = \"FailureCode\";\nconst _FD = \"FailureDescription\";\nconst _FR = \"FailureResource\";\nconst _GD = \"GetDashboard\";\nconst _GIRR = \"GetInsightRuleReport\";\nconst _GMD = \"GetMetricData\";\nconst _GMS = \"GetMetricStatistics\";\nconst _GMSe = \"GetMetricStream\";\nconst _GMWI = \"GetMetricWidgetImage\";\nconst _HD = \"HistoryData\";\nconst _HIT = \"HistoryItemType\";\nconst _HS = \"HistorySummary\";\nconst _I = \"Id\";\nconst _IDA = \"InsufficientDataActions\";\nconst _IF = \"IncludeFilters\";\nconst _ILA = \"IncludeLinkedAccounts\";\nconst _ILAM = \"IncludeLinkedAccountsMetrics\";\nconst _IM = \"IncludeMetrics\";\nconst _IR = \"InsightRules\";\nconst _K = \"Key\";\nconst _KA = \"KeyAttributes\";\nconst _KL = \"KeyLabels\";\nconst _Ke = \"Keys\";\nconst _L = \"Label\";\nconst _LD = \"ListDashboards\";\nconst _LM = \"ListMetrics\";\nconst _LMIR = \"ListManagedInsightRules\";\nconst _LMS = \"ListMetricStreams\";\nconst _LMa = \"LastModified\";\nconst _LO = \"LabelOptions\";\nconst _LTFR = \"ListTagsForResource\";\nconst _LUD = \"LastUpdateDate\";\nconst _M = \"Metrics\";\nconst _MA = \"MetricAlarms\";\nconst _MC = \"MetricCharacteristics\";\nconst _MCC = \"MaxContributorCount\";\nconst _MCV = \"MaxContributorValue\";\nconst _MD = \"MetricData\";\nconst _MDQ = \"MetricDataQueries\";\nconst _MDR = \"MetricDataResults\";\nconst _MDa = \"MaxDatapoints\";\nconst _MDe = \"MetricDatapoints\";\nconst _MMAD = \"MetricMathAnomalyDetector\";\nconst _MN = \"MetricName\";\nconst _MNe = \"MetricNames\";\nconst _MR = \"MaxRecords\";\nconst _MRa = \"MaxResults\";\nconst _MRan = \"ManagedRules\";\nconst _MRana = \"ManagedRule\";\nconst _MS = \"MetricStat\";\nconst _MT = \"MetricTimezone\";\nconst _MW = \"MetricWidget\";\nconst _MWI = \"MetricWidgetImage\";\nconst _Ma = \"Maximum\";\nconst _Me = \"Metric\";\nconst _Mes = \"Message\";\nconst _Mess = \"Messages\";\nconst _Mi = \"Minimum\";\nconst _N = \"Namespace\";\nconst _NT = \"NextToken\";\nconst _Na = \"Name\";\nconst _Nam = \"Names\";\nconst _OA = \"OwningAccount\";\nconst _OAw = \"OwningAccounts\";\nconst _OB = \"OrderBy\";\nconst _OF = \"OutputFormat\";\nconst _OKA = \"OKActions\";\nconst _P = \"Period\";\nconst _PAD = \"PutAnomalyDetector\";\nconst _PCA = \"PutCompositeAlarm\";\nconst _PD = \"PutDashboard\";\nconst _PIR = \"PutInsightRule\";\nconst _PMA = \"PutMetricAlarm\";\nconst _PMD = \"PutMetricData\";\nconst _PMIR = \"PutManagedInsightRules\";\nconst _PMS = \"PutMetricStream\";\nconst _POAN = \"ParentsOfAlarmName\";\nconst _PS = \"PeriodicSpikes\";\nconst _RA = \"RecentlyActive\";\nconst _RARN = \"ResourceARN\";\nconst _RAo = \"RoleArn\";\nconst _RD = \"ReturnData\";\nconst _RDu = \"RuleDefinition\";\nconst _RI = \"ResourceId\";\nconst _RN = \"RuleNames\";\nconst _RNu = \"RuleName\";\nconst _RS = \"RuleState\";\nconst _RT = \"ResourceType\";\nconst _S = \"Stat\";\nconst _SAS = \"SetAlarmState\";\nconst _SB = \"ScanBy\";\nconst _SC = \"StatisticsConfigurations\";\nconst _SCa = \"SampleCount\";\nconst _SCt = \"StatusCode\";\nconst _SD = \"StartDate\";\nconst _SEV = \"StrictEntityValidation\";\nconst _SMAD = \"SingleMetricAnomalyDetector\";\nconst _SMS = \"StartMetricStreams\";\nconst _SMSt = \"StopMetricStreams\";\nconst _SR = \"StorageResolution\";\nconst _SRD = \"StateReasonData\";\nconst _SRt = \"StateReason\";\nconst _ST = \"StartTime\";\nconst _STT = \"StateTransitionedTimestamp\";\nconst _SUT = \"StateUpdatedTimestamp\";\nconst _SV = \"StateValue\";\nconst _SVt = \"StatisticValues\";\nconst _Sc = \"Schema\";\nconst _Si = \"Size\";\nconst _St = \"Statistic\";\nconst _Sta = \"Statistics\";\nconst _Stat = \"State\";\nconst _Su = \"Sum\";\nconst _T = \"Timezone\";\nconst _TK = \"TagKeys\";\nconst _TMD = \"TreatMissingData\";\nconst _TMI = \"ThresholdMetricId\";\nconst _TN = \"TemplateName\";\nconst _TR = \"TagResource\";\nconst _Ta = \"Tags\";\nconst _Th = \"Threshold\";\nconst _Ti = \"Timestamp\";\nconst _Tim = \"Timestamps\";\nconst _U = \"Unit\";\nconst _UC = \"UniqueContributors\";\nconst _UR = \"UntagResource\";\nconst _V = \"Version\";\nconst _Va = \"Value\";\nconst _Val = \"Values\";\nconst _dVM = \"dashboardValidationMessages\";\nconst _e = \"entry\";\nconst _m = \"member\";\nconst _me = \"message\";\nconst buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)\n    .map(([key, value]) => __extendedEncodeURIComponent(key) + \"=\" + __extendedEncodeURIComponent(value))\n    .join(\"&\");\nconst loadQueryErrorCode = (output, data) => {\n    if (data.Error?.Code !== undefined) {\n        return data.Error.Code;\n    }\n    if (output.statusCode == 404) {\n        return \"NotFound\";\n    }\n};\n", "import { ServiceException as __ServiceException, } from \"@smithy/smithy-client\";\nexport { __ServiceException };\nexport class CloudWatchServiceException extends __ServiceException {\n    constructor(options) {\n        super(options);\n        Object.setPrototypeOf(this, CloudWatchServiceException.prototype);\n    }\n}\n", "import { CloudWatchServiceException as __BaseException } from \"./CloudWatchServiceException\";\nexport const ActionsSuppressedBy = {\n    Alarm: \"Alarm\",\n    ExtensionPeriod: \"ExtensionPeriod\",\n    WaitPeriod: \"WaitPeriod\",\n};\nexport const AlarmType = {\n    CompositeAlarm: \"CompositeAlarm\",\n    MetricAlarm: \"MetricAlarm\",\n};\nexport const HistoryItemType = {\n    Action: \"Action\",\n    ConfigurationUpdate: \"ConfigurationUpdate\",\n    StateUpdate: \"StateUpdate\",\n};\nexport const StandardUnit = {\n    Bits: \"Bits\",\n    Bits_Second: \"Bits/Second\",\n    Bytes: \"Bytes\",\n    Bytes_Second: \"Bytes/Second\",\n    Count: \"Count\",\n    Count_Second: \"Count/Second\",\n    Gigabits: \"Gigabits\",\n    Gigabits_Second: \"Gigabits/Second\",\n    Gigabytes: \"Gigabytes\",\n    Gigabytes_Second: \"Gigabytes/Second\",\n    Kilobits: \"Kilobits\",\n    Kilobits_Second: \"Kilobits/Second\",\n    Kilobytes: \"Kilobytes\",\n    Kilobytes_Second: \"Kilobytes/Second\",\n    Megabits: \"Megabits\",\n    Megabits_Second: \"Megabits/Second\",\n    Megabytes: \"Megabytes\",\n    Megabytes_Second: \"Megabytes/Second\",\n    Microseconds: \"Microseconds\",\n    Milliseconds: \"Milliseconds\",\n    None: \"None\",\n    Percent: \"Percent\",\n    Seconds: \"Seconds\",\n    Terabits: \"Terabits\",\n    Terabits_Second: \"Terabits/Second\",\n    Terabytes: \"Terabytes\",\n    Terabytes_Second: \"Terabytes/Second\",\n};\nexport const AnomalyDetectorStateValue = {\n    PENDING_TRAINING: \"PENDING_TRAINING\",\n    TRAINED: \"TRAINED\",\n    TRAINED_INSUFFICIENT_DATA: \"TRAINED_INSUFFICIENT_DATA\",\n};\nexport const AnomalyDetectorType = {\n    METRIC_MATH: \"METRIC_MATH\",\n    SINGLE_METRIC: \"SINGLE_METRIC\",\n};\nexport const ComparisonOperator = {\n    GreaterThanOrEqualToThreshold: \"GreaterThanOrEqualToThreshold\",\n    GreaterThanThreshold: \"GreaterThanThreshold\",\n    GreaterThanUpperThreshold: \"GreaterThanUpperThreshold\",\n    LessThanLowerOrGreaterThanUpperThreshold: \"LessThanLowerOrGreaterThanUpperThreshold\",\n    LessThanLowerThreshold: \"LessThanLowerThreshold\",\n    LessThanOrEqualToThreshold: \"LessThanOrEqualToThreshold\",\n    LessThanThreshold: \"LessThanThreshold\",\n};\nexport const StateValue = {\n    ALARM: \"ALARM\",\n    INSUFFICIENT_DATA: \"INSUFFICIENT_DATA\",\n    OK: \"OK\",\n};\nexport class ConcurrentModificationException extends __BaseException {\n    name = \"ConcurrentModificationException\";\n    $fault = \"client\";\n    Message;\n    constructor(opts) {\n        super({\n            name: \"ConcurrentModificationException\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, ConcurrentModificationException.prototype);\n        this.Message = opts.Message;\n    }\n}\nexport class ConflictException extends __BaseException {\n    name = \"ConflictException\";\n    $fault = \"client\";\n    Message;\n    constructor(opts) {\n        super({\n            name: \"ConflictException\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, ConflictException.prototype);\n        this.Message = opts.Message;\n    }\n}\nexport class DashboardInvalidInputError extends __BaseException {\n    name = \"DashboardInvalidInputError\";\n    $fault = \"client\";\n    dashboardValidationMessages;\n    constructor(opts) {\n        super({\n            name: \"DashboardInvalidInputError\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, DashboardInvalidInputError.prototype);\n        this.dashboardValidationMessages = opts.dashboardValidationMessages;\n    }\n}\nexport class DashboardNotFoundError extends __BaseException {\n    name = \"DashboardNotFoundError\";\n    $fault = \"client\";\n    constructor(opts) {\n        super({\n            name: \"DashboardNotFoundError\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, DashboardNotFoundError.prototype);\n    }\n}\nexport class ResourceNotFound extends __BaseException {\n    name = \"ResourceNotFound\";\n    $fault = \"client\";\n    constructor(opts) {\n        super({\n            name: \"ResourceNotFound\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, ResourceNotFound.prototype);\n    }\n}\nexport class InternalServiceFault extends __BaseException {\n    name = \"InternalServiceFault\";\n    $fault = \"server\";\n    Message;\n    constructor(opts) {\n        super({\n            name: \"InternalServiceFault\",\n            $fault: \"server\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, InternalServiceFault.prototype);\n        this.Message = opts.Message;\n    }\n}\nexport class InvalidParameterCombinationException extends __BaseException {\n    name = \"InvalidParameterCombinationException\";\n    $fault = \"client\";\n    constructor(opts) {\n        super({\n            name: \"InvalidParameterCombinationException\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, InvalidParameterCombinationException.prototype);\n    }\n}\nexport class InvalidParameterValueException extends __BaseException {\n    name = \"InvalidParameterValueException\";\n    $fault = \"client\";\n    constructor(opts) {\n        super({\n            name: \"InvalidParameterValueException\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, InvalidParameterValueException.prototype);\n    }\n}\nexport class MissingRequiredParameterException extends __BaseException {\n    name = \"MissingRequiredParameterException\";\n    $fault = \"client\";\n    constructor(opts) {\n        super({\n            name: \"MissingRequiredParameterException\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, MissingRequiredParameterException.prototype);\n    }\n}\nexport class ResourceNotFoundException extends __BaseException {\n    name = \"ResourceNotFoundException\";\n    $fault = \"client\";\n    ResourceType;\n    ResourceId;\n    Message;\n    constructor(opts) {\n        super({\n            name: \"ResourceNotFoundException\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);\n        this.ResourceType = opts.ResourceType;\n        this.ResourceId = opts.ResourceId;\n        this.Message = opts.Message;\n    }\n}\nexport const ScanBy = {\n    TIMESTAMP_ASCENDING: \"TimestampAscending\",\n    TIMESTAMP_DESCENDING: \"TimestampDescending\",\n};\nexport class InvalidNextToken extends __BaseException {\n    name = \"InvalidNextToken\";\n    $fault = \"client\";\n    constructor(opts) {\n        super({\n            name: \"InvalidNextToken\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, InvalidNextToken.prototype);\n    }\n}\nexport const EvaluationState = {\n    PARTIAL_DATA: \"PARTIAL_DATA\",\n};\nexport const Statistic = {\n    Average: \"Average\",\n    Maximum: \"Maximum\",\n    Minimum: \"Minimum\",\n    SampleCount: \"SampleCount\",\n    Sum: \"Sum\",\n};\nexport class LimitExceededException extends __BaseException {\n    name = \"LimitExceededException\";\n    $fault = \"client\";\n    Message;\n    constructor(opts) {\n        super({\n            name: \"LimitExceededException\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, LimitExceededException.prototype);\n        this.Message = opts.Message;\n    }\n}\nexport const StatusCode = {\n    COMPLETE: \"Complete\",\n    FORBIDDEN: \"Forbidden\",\n    INTERNAL_ERROR: \"InternalError\",\n    PARTIAL_DATA: \"PartialData\",\n};\nexport const MetricStreamOutputFormat = {\n    JSON: \"json\",\n    OPEN_TELEMETRY_0_7: \"opentelemetry0.7\",\n    OPEN_TELEMETRY_1_0: \"opentelemetry1.0\",\n};\nexport const RecentlyActive = {\n    PT3H: \"PT3H\",\n};\nexport class LimitExceededFault extends __BaseException {\n    name = \"LimitExceededFault\";\n    $fault = \"client\";\n    constructor(opts) {\n        super({\n            name: \"LimitExceededFault\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, LimitExceededFault.prototype);\n    }\n}\nexport class InvalidFormatFault extends __BaseException {\n    name = \"InvalidFormatFault\";\n    $fault = \"client\";\n    constructor(opts) {\n        super({\n            name: \"InvalidFormatFault\",\n            $fault: \"client\",\n            ...opts,\n        });\n        Object.setPrototypeOf(this, InvalidFormatFault.prototype);\n    }\n}\n", "import { getEndpointPlugin } from \"@smithy/middleware-endpoint\";\nimport { getSerdePlugin } from \"@smithy/middleware-serde\";\nimport { Command as $Command } from \"@smithy/smithy-client\";\nimport { commonParams } from \"../endpoint/EndpointParameters\";\nimport { de_GetMetricStatisticsCommand, se_GetMetricStatisticsCommand } from \"../protocols/Aws_query\";\nexport { $Command };\nexport class GetMetricStatisticsCommand extends $Command\n    .classBuilder()\n    .ep(commonParams)\n    .m(function (Command, cs, config, o) {\n    return [\n        getSerdePlugin(config, this.serialize, this.deserialize),\n        getEndpointPlugin(config, Command.getEndpointParameterInstructions()),\n    ];\n})\n    .s(\"GraniteServiceVersion20100801\", \"GetMetricStatistics\", {})\n    .n(\"CloudWatchClient\", \"GetMetricStatisticsCommand\")\n    .f(void 0, void 0)\n    .ser(se_GetMetricStatisticsCommand)\n    .de(de_GetMetricStatisticsCommand)\n    .build() {\n}\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n"],
  "mappings": "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ACX,QAAQ;AAAA,MACR,iBAAiB;AAAA,IAClB;AAAA;AAAA;;;AC7NA,IAEM,eACO,kBACE,MAAM,UAAU,UAGzB,cAMJ,OACA,aACA,6BACA,qCACA,qCACA,aACA,mBACA,MACA,MACA,OACA,OACA,QACA,WACA,mBACA,iBACA,UACA,KACA,WACA,QACA,YACA,MACA,aACA,KACA,YACA,UACA,UACA,cACA,UACA,wBACA,iBACAC,SACA,MACA,WACA,eACA,aACA,IACA,KACA,MACA,KACA,MACA,iBACA,qBACA,cACA,SACA,oBACA,gBACA,QACA,eACA,iBACA,sBACA,QACA,OACA,QACA,OACA,kBACA,kBACA,OACA,QACA,SACA,UACA,QACA,YACA,gBACA,YACA,WACAC,SACA,SACA,MACA,UACA,SACA,SACA,SACA,QACA,WACA,QACA,SACA,SACA,QACA,WACA,QACA,YACA,YACA,SACA,cACA,UACA,eACA,WACA,eACA,iBACA,mBACA,oBACA,OACA,kBACA,WACA,4BACA,2BACA,eACA,aACA,cACA,iBACA,UACA,OACA,gBAEI,UA8GC;AAnOP,IAAAC,gBAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAAA;AACA;AACA,IAAM,gBAAgB,WAAW,SAAS;AACnC,IAAM,mBAAmB,cAAc;AACvC,KAAM,EAAE,MAAM,UAAU,aAAa;AAAA,MAC1C;AAAA,IACF;AACA,IAAM,eAAe,IAAI,QAAa;AAAA,MACpC,KAAK,cAAc;AAAA,MACnB;AAAA,MACA;AAAA,IACF,CAAC;AACM,KAAM;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAH;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACE;AACJ,IAAM,WAAW;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,MAEA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,IAAO,kBAAQ;AAAA;AAAA;;;ACnOf;AAAA;AAAA,IAAAG;AACA,eAAW,UAAU;AAAA;AAAA;;;ACDrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAAA;AAAA;;;ACAA;AAAA;AAGA;AAAA;AAAA;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAEA,QAAM,gBAAgB;AACtB,QAAM,WAAW,gBAAgB;AACjC,QAAM,aAAa,MAAM,gBAAgB,OAAO,WAAW;AAC3D,QAAM,YAAY,IAAI,OAAO,MAAM,aAAa,GAAG;AAEnD,QAAM,gBAAgB,gCAAS,QAAQ,OAAO;AAC5C,YAAM,UAAU,CAAC;AACjB,UAAI,QAAQ,MAAM,KAAK,MAAM;AAC7B,aAAO,OAAO;AACZ,cAAM,aAAa,CAAC;AACpB,mBAAW,aAAa,MAAM,YAAY,MAAM,CAAC,EAAE;AACnD,cAAM,MAAM,MAAM;AAClB,iBAAS,QAAQ,GAAG,QAAQ,KAAK,SAAS;AACxC,qBAAW,KAAK,MAAM,KAAK,CAAC;AAAA,QAC9B;AACA,gBAAQ,KAAK,UAAU;AACvB,gBAAQ,MAAM,KAAK,MAAM;AAAA,MAC3B;AACA,aAAO;AAAA,IACT,GAdsB;AAgBtB,QAAM,SAAS,gCAAS,QAAQ;AAC9B,YAAM,QAAQ,UAAU,KAAK,MAAM;AACnC,aAAO,EAAE,UAAU,QAAQ,OAAO,UAAU;AAAA,IAC9C,GAHe;AAKf,YAAQ,UAAU,SAASC,IAAG;AAC5B,aAAO,OAAOA,OAAM;AAAA,IACtB;AAEA,YAAQ,gBAAgB,SAAS,KAAK;AACpC,aAAO,OAAO,KAAK,GAAG,EAAE,WAAW;AAAA,IACrC;AAOA,YAAQ,QAAQ,SAAS,QAAQC,IAAG,WAAW;AAC7C,UAAIA,IAAG;AACL,cAAM,OAAO,OAAO,KAAKA,EAAC;AAC1B,cAAM,MAAM,KAAK;AACjB,iBAASC,KAAI,GAAGA,KAAI,KAAKA,MAAK;AAC5B,cAAI,cAAc,UAAU;AAC1B,mBAAO,KAAKA,EAAC,CAAC,IAAI,CAAED,GAAE,KAAKC,EAAC,CAAC,CAAE;AAAA,UACjC,OAAO;AACL,mBAAO,KAAKA,EAAC,CAAC,IAAID,GAAE,KAAKC,EAAC,CAAC;AAAA,UAC7B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAKA,YAAQ,WAAW,SAASF,IAAG;AAC7B,UAAI,QAAQ,QAAQA,EAAC,GAAG;AACtB,eAAOA;AAAA,MACT,OAAO;AACL,eAAO;AAAA,MACT;AAAA,IACF;AAKA,YAAQ,SAAS;AACjB,YAAQ,gBAAgB;AACxB,YAAQ,aAAa;AAAA;AAAA;;;ACvErB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAG;AAEA,QAAM,OAAO;AAEb,QAAM,iBAAiB;AAAA,MACrB,wBAAwB;AAAA;AAAA,MACxB,cAAc,CAAC;AAAA,IACjB;AAGA,YAAQ,WAAW,SAAU,SAAS,SAAS;AAC7C,gBAAU,OAAO,OAAO,CAAC,GAAG,gBAAgB,OAAO;AAKnD,YAAM,OAAO,CAAC;AACd,UAAI,WAAW;AAGf,UAAI,cAAc;AAElB,UAAI,QAAQ,CAAC,MAAM,UAAU;AAE3B,kBAAU,QAAQ,OAAO,CAAC;AAAA,MAC5B;AAEA,eAASC,KAAI,GAAGA,KAAI,QAAQ,QAAQA,MAAK;AAEvC,YAAI,QAAQA,EAAC,MAAM,OAAO,QAAQA,KAAE,CAAC,MAAM,KAAK;AAC9C,UAAAA,MAAG;AACH,UAAAA,KAAI,OAAO,SAAQA,EAAC;AACpB,cAAIA,GAAE,IAAK,QAAOA;AAAA,QACpB,WAAU,QAAQA,EAAC,MAAM,KAAK;AAG5B,cAAI,cAAcA;AAClB,UAAAA;AAEA,cAAI,QAAQA,EAAC,MAAM,KAAK;AACtB,YAAAA,KAAI,oBAAoB,SAASA,EAAC;AAClC;AAAA,UACF,OAAO;AACL,gBAAI,aAAa;AACjB,gBAAI,QAAQA,EAAC,MAAM,KAAK;AAEtB,2BAAa;AACb,cAAAA;AAAA,YACF;AAEA,gBAAI,UAAU;AACd,mBAAOA,KAAI,QAAQ,UACjB,QAAQA,EAAC,MAAM,OACf,QAAQA,EAAC,MAAM,OACf,QAAQA,EAAC,MAAM,OACf,QAAQA,EAAC,MAAM,QACf,QAAQA,EAAC,MAAM,MAAMA,MACrB;AACA,yBAAW,QAAQA,EAAC;AAAA,YACtB;AACA,sBAAU,QAAQ,KAAK;AAGvB,gBAAI,QAAQ,QAAQ,SAAS,CAAC,MAAM,KAAK;AAEvC,wBAAU,QAAQ,UAAU,GAAG,QAAQ,SAAS,CAAC;AAEjD,cAAAA;AAAA,YACF;AACA,gBAAI,CAAC,gBAAgB,OAAO,GAAG;AAC7B,kBAAI;AACJ,kBAAI,QAAQ,KAAK,EAAE,WAAW,GAAG;AAC/B,sBAAM;AAAA,cACR,OAAO;AACL,sBAAM,UAAQ,UAAQ;AAAA,cACxB;AACA,qBAAO,eAAe,cAAc,KAAK,yBAAyB,SAASA,EAAC,CAAC;AAAA,YAC/E;AAEA,kBAAM,SAAS,iBAAiB,SAASA,EAAC;AAC1C,gBAAI,WAAW,OAAO;AACpB,qBAAO,eAAe,eAAe,qBAAmB,UAAQ,sBAAsB,yBAAyB,SAASA,EAAC,CAAC;AAAA,YAC5H;AACA,gBAAI,UAAU,OAAO;AACrB,YAAAA,KAAI,OAAO;AAEX,gBAAI,QAAQ,QAAQ,SAAS,CAAC,MAAM,KAAK;AAEvC,oBAAM,eAAeA,KAAI,QAAQ;AACjC,wBAAU,QAAQ,UAAU,GAAG,QAAQ,SAAS,CAAC;AACjD,oBAAM,UAAU,wBAAwB,SAAS,OAAO;AACxD,kBAAI,YAAY,MAAM;AACpB,2BAAW;AAAA,cAEb,OAAO;AAIL,uBAAO,eAAe,QAAQ,IAAI,MAAM,QAAQ,IAAI,KAAK,yBAAyB,SAAS,eAAe,QAAQ,IAAI,IAAI,CAAC;AAAA,cAC7H;AAAA,YACF,WAAW,YAAY;AACrB,kBAAI,CAAC,OAAO,WAAW;AACrB,uBAAO,eAAe,cAAc,kBAAgB,UAAQ,kCAAkC,yBAAyB,SAASA,EAAC,CAAC;AAAA,cACpI,WAAW,QAAQ,KAAK,EAAE,SAAS,GAAG;AACpC,uBAAO,eAAe,cAAc,kBAAgB,UAAQ,gDAAgD,yBAAyB,SAAS,WAAW,CAAC;AAAA,cAC5J,WAAW,KAAK,WAAW,GAAG;AAC5B,uBAAO,eAAe,cAAc,kBAAgB,UAAQ,0BAA0B,yBAAyB,SAAS,WAAW,CAAC;AAAA,cACtI,OAAO;AACL,sBAAM,MAAM,KAAK,IAAI;AACrB,oBAAI,YAAY,IAAI,SAAS;AAC3B,sBAAI,UAAU,yBAAyB,SAAS,IAAI,WAAW;AAC/D,yBAAO;AAAA,oBAAe;AAAA,oBACpB,2BAAyB,IAAI,UAAQ,uBAAqB,QAAQ,OAAK,WAAS,QAAQ,MAAI,+BAA6B,UAAQ;AAAA,oBACjI,yBAAyB,SAAS,WAAW;AAAA,kBAAC;AAAA,gBAClD;AAGA,oBAAI,KAAK,UAAU,GAAG;AACpB,gCAAc;AAAA,gBAChB;AAAA,cACF;AAAA,YACF,OAAO;AACL,oBAAM,UAAU,wBAAwB,SAAS,OAAO;AACxD,kBAAI,YAAY,MAAM;AAIpB,uBAAO,eAAe,QAAQ,IAAI,MAAM,QAAQ,IAAI,KAAK,yBAAyB,SAASA,KAAI,QAAQ,SAAS,QAAQ,IAAI,IAAI,CAAC;AAAA,cACnI;AAGA,kBAAI,gBAAgB,MAAM;AACxB,uBAAO,eAAe,cAAc,uCAAuC,yBAAyB,SAASA,EAAC,CAAC;AAAA,cACjH,WAAU,QAAQ,aAAa,QAAQ,OAAO,MAAM,IAAG;AAAA,cAEvD,OAAO;AACL,qBAAK,KAAK,EAAC,SAAS,YAAW,CAAC;AAAA,cAClC;AACA,yBAAW;AAAA,YACb;AAIA,iBAAKA,MAAKA,KAAI,QAAQ,QAAQA,MAAK;AACjC,kBAAI,QAAQA,EAAC,MAAM,KAAK;AACtB,oBAAI,QAAQA,KAAI,CAAC,MAAM,KAAK;AAE1B,kBAAAA;AACA,kBAAAA,KAAI,oBAAoB,SAASA,EAAC;AAClC;AAAA,gBACF,WAAW,QAAQA,KAAE,CAAC,MAAM,KAAK;AAC/B,kBAAAA,KAAI,OAAO,SAAS,EAAEA,EAAC;AACvB,sBAAIA,GAAE,IAAK,QAAOA;AAAA,gBACpB,OAAM;AACJ;AAAA,gBACF;AAAA,cACF,WAAW,QAAQA,EAAC,MAAM,KAAK;AAC7B,sBAAM,WAAW,kBAAkB,SAASA,EAAC;AAC7C,oBAAI,YAAY;AACd,yBAAO,eAAe,eAAe,6BAA6B,yBAAyB,SAASA,EAAC,CAAC;AACxG,gBAAAA,KAAI;AAAA,cACN,OAAK;AACH,oBAAI,gBAAgB,QAAQ,CAAC,aAAa,QAAQA,EAAC,CAAC,GAAG;AACrD,yBAAO,eAAe,cAAc,yBAAyB,yBAAyB,SAASA,EAAC,CAAC;AAAA,gBACnG;AAAA,cACF;AAAA,YACF;AACA,gBAAI,QAAQA,EAAC,MAAM,KAAK;AACtB,cAAAA;AAAA,YACF;AAAA,UACF;AAAA,QACF,OAAO;AACL,cAAK,aAAa,QAAQA,EAAC,CAAC,GAAG;AAC7B;AAAA,UACF;AACA,iBAAO,eAAe,eAAe,WAAS,QAAQA,EAAC,IAAE,sBAAsB,yBAAyB,SAASA,EAAC,CAAC;AAAA,QACrH;AAAA,MACF;AAEA,UAAI,CAAC,UAAU;AACb,eAAO,eAAe,cAAc,uBAAuB,CAAC;AAAA,MAC9D,WAAU,KAAK,UAAU,GAAG;AACxB,eAAO,eAAe,cAAc,mBAAiB,KAAK,CAAC,EAAE,UAAQ,MAAM,yBAAyB,SAAS,KAAK,CAAC,EAAE,WAAW,CAAC;AAAA,MACrI,WAAU,KAAK,SAAS,GAAG;AACvB,eAAO,eAAe,cAAc,cAChC,KAAK,UAAU,KAAK,IAAI,CAAAC,OAAKA,GAAE,OAAO,GAAG,MAAM,CAAC,EAAE,QAAQ,UAAU,EAAE,IACtE,YAAY,EAAC,MAAM,GAAG,KAAK,EAAC,CAAC;AAAA,MACrC;AAEA,aAAO;AAAA,IACT;AAEA,aAAS,aAAa,MAAK;AACzB,aAAO,SAAS,OAAO,SAAS,OAAQ,SAAS,QAAS,SAAS;AAAA,IACrE;AAFS;AAQT,aAAS,OAAO,SAASD,IAAG;AAC1B,YAAM,QAAQA;AACd,aAAOA,KAAI,QAAQ,QAAQA,MAAK;AAC9B,YAAI,QAAQA,EAAC,KAAK,OAAO,QAAQA,EAAC,KAAK,KAAK;AAE1C,gBAAM,UAAU,QAAQ,OAAO,OAAOA,KAAI,KAAK;AAC/C,cAAIA,KAAI,KAAK,YAAY,OAAO;AAC9B,mBAAO,eAAe,cAAc,8DAA8D,yBAAyB,SAASA,EAAC,CAAC;AAAA,UACxI,WAAW,QAAQA,EAAC,KAAK,OAAO,QAAQA,KAAI,CAAC,KAAK,KAAK;AAErD,YAAAA;AACA;AAAA,UACF,OAAO;AACL;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAOA;AAAA,IACT;AAlBS;AAoBT,aAAS,oBAAoB,SAASA,IAAG;AACvC,UAAI,QAAQ,SAASA,KAAI,KAAK,QAAQA,KAAI,CAAC,MAAM,OAAO,QAAQA,KAAI,CAAC,MAAM,KAAK;AAE9E,aAAKA,MAAK,GAAGA,KAAI,QAAQ,QAAQA,MAAK;AACpC,cAAI,QAAQA,EAAC,MAAM,OAAO,QAAQA,KAAI,CAAC,MAAM,OAAO,QAAQA,KAAI,CAAC,MAAM,KAAK;AAC1E,YAAAA,MAAK;AACL;AAAA,UACF;AAAA,QACF;AAAA,MACF,WACE,QAAQ,SAASA,KAAI,KACrB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,KACnB;AACA,YAAI,qBAAqB;AACzB,aAAKA,MAAK,GAAGA,KAAI,QAAQ,QAAQA,MAAK;AACpC,cAAI,QAAQA,EAAC,MAAM,KAAK;AACtB;AAAA,UACF,WAAW,QAAQA,EAAC,MAAM,KAAK;AAC7B;AACA,gBAAI,uBAAuB,GAAG;AAC5B;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF,WACE,QAAQ,SAASA,KAAI,KACrB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,KACnB;AACA,aAAKA,MAAK,GAAGA,KAAI,QAAQ,QAAQA,MAAK;AACpC,cAAI,QAAQA,EAAC,MAAM,OAAO,QAAQA,KAAI,CAAC,MAAM,OAAO,QAAQA,KAAI,CAAC,MAAM,KAAK;AAC1E,YAAAA,MAAK;AACL;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAOA;AAAA,IACT;AAjDS;AAmDT,QAAM,cAAc;AACpB,QAAM,cAAc;AAOpB,aAAS,iBAAiB,SAASA,IAAG;AACpC,UAAI,UAAU;AACd,UAAI,YAAY;AAChB,UAAI,YAAY;AAChB,aAAOA,KAAI,QAAQ,QAAQA,MAAK;AAC9B,YAAI,QAAQA,EAAC,MAAM,eAAe,QAAQA,EAAC,MAAM,aAAa;AAC5D,cAAI,cAAc,IAAI;AACpB,wBAAY,QAAQA,EAAC;AAAA,UACvB,WAAW,cAAc,QAAQA,EAAC,GAAG;AAAA,UAErC,OAAO;AACL,wBAAY;AAAA,UACd;AAAA,QACF,WAAW,QAAQA,EAAC,MAAM,KAAK;AAC7B,cAAI,cAAc,IAAI;AACpB,wBAAY;AACZ;AAAA,UACF;AAAA,QACF;AACA,mBAAW,QAAQA,EAAC;AAAA,MACtB;AACA,UAAI,cAAc,IAAI;AACpB,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,QACL,OAAO;AAAA,QACP,OAAOA;AAAA,QACP;AAAA,MACF;AAAA,IACF;AA9BS;AAmCT,QAAM,oBAAoB,IAAI,OAAO,0DAA2D,GAAG;AAInG,aAAS,wBAAwB,SAAS,SAAS;AAKjD,YAAM,UAAU,KAAK,cAAc,SAAS,iBAAiB;AAC7D,YAAM,YAAY,CAAC;AAEnB,eAASA,KAAI,GAAGA,KAAI,QAAQ,QAAQA,MAAK;AACvC,YAAI,QAAQA,EAAC,EAAE,CAAC,EAAE,WAAW,GAAG;AAE9B,iBAAO,eAAe,eAAe,gBAAc,QAAQA,EAAC,EAAE,CAAC,IAAE,+BAA+B,qBAAqB,QAAQA,EAAC,CAAC,CAAC;AAAA,QAClI,WAAW,QAAQA,EAAC,EAAE,CAAC,MAAM,UAAa,QAAQA,EAAC,EAAE,CAAC,MAAM,QAAW;AACrE,iBAAO,eAAe,eAAe,gBAAc,QAAQA,EAAC,EAAE,CAAC,IAAE,uBAAuB,qBAAqB,QAAQA,EAAC,CAAC,CAAC;AAAA,QAC1H,WAAW,QAAQA,EAAC,EAAE,CAAC,MAAM,UAAa,CAAC,QAAQ,wBAAwB;AAEzE,iBAAO,eAAe,eAAe,wBAAsB,QAAQA,EAAC,EAAE,CAAC,IAAE,qBAAqB,qBAAqB,QAAQA,EAAC,CAAC,CAAC;AAAA,QAChI;AAIA,cAAM,WAAW,QAAQA,EAAC,EAAE,CAAC;AAC7B,YAAI,CAAC,iBAAiB,QAAQ,GAAG;AAC/B,iBAAO,eAAe,eAAe,gBAAc,WAAS,yBAAyB,qBAAqB,QAAQA,EAAC,CAAC,CAAC;AAAA,QACvH;AACA,YAAI,CAAC,UAAU,eAAe,QAAQ,GAAG;AAEvC,oBAAU,QAAQ,IAAI;AAAA,QACxB,OAAO;AACL,iBAAO,eAAe,eAAe,gBAAc,WAAS,kBAAkB,qBAAqB,QAAQA,EAAC,CAAC,CAAC;AAAA,QAChH;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAlCS;AAoCT,aAAS,wBAAwB,SAASA,IAAG;AAC3C,UAAI,KAAK;AACT,UAAI,QAAQA,EAAC,MAAM,KAAK;AACtB,QAAAA;AACA,aAAK;AAAA,MACP;AACA,aAAOA,KAAI,QAAQ,QAAQA,MAAK;AAC9B,YAAI,QAAQA,EAAC,MAAM;AACjB,iBAAOA;AACT,YAAI,CAAC,QAAQA,EAAC,EAAE,MAAM,EAAE;AACtB;AAAA,MACJ;AACA,aAAO;AAAA,IACT;AAbS;AAeT,aAAS,kBAAkB,SAASA,IAAG;AAErC,MAAAA;AACA,UAAI,QAAQA,EAAC,MAAM;AACjB,eAAO;AACT,UAAI,QAAQA,EAAC,MAAM,KAAK;AACtB,QAAAA;AACA,eAAO,wBAAwB,SAASA,EAAC;AAAA,MAC3C;AACA,UAAIE,SAAQ;AACZ,aAAOF,KAAI,QAAQ,QAAQA,MAAKE,UAAS;AACvC,YAAI,QAAQF,EAAC,EAAE,MAAM,IAAI,KAAKE,SAAQ;AACpC;AACF,YAAI,QAAQF,EAAC,MAAM;AACjB;AACF,eAAO;AAAA,MACT;AACA,aAAOA;AAAA,IACT;AAlBS;AAoBT,aAAS,eAAe,MAAM,SAAS,YAAY;AACjD,aAAO;AAAA,QACL,KAAK;AAAA,UACH;AAAA,UACA,KAAK;AAAA,UACL,MAAM,WAAW,QAAQ;AAAA,UACzB,KAAK,WAAW;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AATS;AAWT,aAAS,iBAAiB,UAAU;AAClC,aAAO,KAAK,OAAO,QAAQ;AAAA,IAC7B;AAFS;AAMT,aAAS,gBAAgB,SAAS;AAChC,aAAO,KAAK,OAAO,OAAO;AAAA,IAC5B;AAFS;AAKT,aAAS,yBAAyB,SAAS,OAAO;AAChD,YAAM,QAAQ,QAAQ,UAAU,GAAG,KAAK,EAAE,MAAM,OAAO;AACvD,aAAO;AAAA,QACL,MAAM,MAAM;AAAA;AAAA,QAGZ,KAAK,MAAM,MAAM,SAAS,CAAC,EAAE,SAAS;AAAA,MACxC;AAAA,IACF;AARS;AAWT,aAAS,qBAAqB,OAAO;AACnC,aAAO,MAAM,aAAa,MAAM,CAAC,EAAE;AAAA,IACrC;AAFS;AAAA;AAAA;;;ACtaT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAG;AACA,QAAM,iBAAiB;AAAA,MACnB,eAAe;AAAA,MACf,qBAAqB;AAAA,MACrB,qBAAqB;AAAA,MACrB,cAAc;AAAA,MACd,kBAAkB;AAAA,MAClB,gBAAgB;AAAA;AAAA,MAChB,wBAAwB;AAAA;AAAA;AAAA,MAExB,eAAe;AAAA,MACf,qBAAqB;AAAA,MACrB,YAAY;AAAA;AAAA,MACZ,eAAe;AAAA,MACf,oBAAoB;AAAA,QAClB,KAAK;AAAA,QACL,cAAc;AAAA,QACd,WAAW;AAAA,MACb;AAAA,MACA,mBAAmB,gCAAS,SAASC,MAAK;AACxC,eAAOA;AAAA,MACT,GAFmB;AAAA,MAGnB,yBAAyB,gCAAS,UAAUA,MAAK;AAC/C,eAAOA;AAAA,MACT,GAFyB;AAAA,MAGzB,WAAW,CAAC;AAAA;AAAA,MACZ,sBAAsB;AAAA,MACtB,SAAS,6BAAM,OAAN;AAAA,MACT,iBAAiB;AAAA,MACjB,cAAc,CAAC;AAAA,MACf,iBAAiB;AAAA,MACjB,cAAc;AAAA,MACd,mBAAmB;AAAA,MACnB,cAAc;AAAA,MACd,kBAAkB;AAAA,MAClB,wBAAwB;AAAA,MACxB,WAAW,gCAAS,SAAS,OAAO,OAAM;AACxC,eAAO;AAAA,MACT,GAFW;AAAA;AAAA,IAIf;AAEA,QAAM,eAAe,gCAAS,SAAS;AACnC,aAAO,OAAO,OAAO,CAAC,GAAG,gBAAgB,OAAO;AAAA,IACpD,GAFqB;AAIrB,YAAQ,eAAe;AACvB,YAAQ,iBAAiB;AAAA;AAAA;;;AC/CzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAEA,QAAM,UAAN,MAAa;AAAA,MAFb,OAEa;AAAA;AAAA;AAAA,MACX,YAAY,SAAS;AACnB,aAAK,UAAU;AACf,aAAK,QAAQ,CAAC;AACd,aAAK,IAAI,IAAI,CAAC;AAAA,MAChB;AAAA,MACA,IAAI,KAAIC,MAAI;AAEV,YAAG,QAAQ,YAAa,OAAM;AAC9B,aAAK,MAAM,KAAM,EAAC,CAAC,GAAG,GAAGA,KAAI,CAAC;AAAA,MAChC;AAAA,MACA,SAAS,MAAM;AACb,YAAG,KAAK,YAAY,YAAa,MAAK,UAAU;AAChD,YAAG,KAAK,IAAI,KAAK,OAAO,KAAK,KAAK,IAAI,CAAC,EAAE,SAAS,GAAE;AAClD,eAAK,MAAM,KAAM,EAAE,CAAC,KAAK,OAAO,GAAG,KAAK,OAAO,CAAC,IAAI,GAAG,KAAK,IAAI,EAAE,CAAC;AAAA,QACrE,OAAK;AACH,eAAK,MAAM,KAAM,EAAE,CAAC,KAAK,OAAO,GAAG,KAAK,MAAM,CAAC;AAAA,QACjD;AAAA,MACF;AAAA,IACF;AAGA,WAAO,UAAU;AAAA;AAAA;;;ACxBjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAAA,QAAM,OAAO;AAGb,aAAS,YAAY,SAASC,IAAE;AAE5B,YAAM,WAAW,CAAC;AAClB,UAAI,QAAQA,KAAI,CAAC,MAAM,OAClB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,OACnB,QAAQA,KAAI,CAAC,MAAM,KACxB;AACI,QAAAA,KAAIA,KAAE;AACN,YAAI,qBAAqB;AACzB,YAAI,UAAU,OAAO,UAAU;AAC/B,YAAI,MAAM;AACV,eAAKA,KAAE,QAAQ,QAAOA,MAAI;AACtB,cAAI,QAAQA,EAAC,MAAM,OAAO,CAAC,SAAS;AAChC,gBAAI,WAAW,SAAS,SAASA,EAAC,GAAE;AAChC,cAAAA,MAAK;AACL,eAAC,YAAY,KAAIA,EAAC,IAAI,cAAc,SAAQA,KAAE,CAAC;AAC/C,kBAAG,IAAI,QAAQ,GAAG,MAAM;AACpB,yBAAU,mBAAmB,UAAU,CAAE,IAAI;AAAA,kBACzC,MAAO,OAAQ,IAAI,UAAU,KAAI,GAAG;AAAA,kBACpC;AAAA,gBACJ;AAAA,YACR,WACS,WAAW,UAAU,SAASA,EAAC,EAAI,CAAAA,MAAK;AAAA,qBACxC,WAAW,UAAU,SAASA,EAAC,EAAI,CAAAA,MAAK;AAAA,qBACxC,WAAW,WAAW,SAASA,EAAC,EAAG,CAAAA,MAAK;AAAA,qBACxC,UAAmC,WAAU;AAAA,gBACV,OAAM,IAAI,MAAM,iBAAiB;AAE7E;AACA,kBAAM;AAAA,UACV,WAAW,QAAQA,EAAC,MAAM,KAAK;AAC3B,gBAAG,SAAQ;AACP,kBAAI,QAAQA,KAAI,CAAC,MAAM,OAAO,QAAQA,KAAI,CAAC,MAAM,KAAI;AACjD,0BAAU;AACV;AAAA,cACJ;AAAA,YACJ,OAAK;AACD;AAAA,YACJ;AACA,gBAAI,uBAAuB,GAAG;AAC5B;AAAA,YACF;AAAA,UACJ,WAAU,QAAQA,EAAC,MAAM,KAAI;AACzB,sBAAU;AAAA,UACd,OAAK;AACD,mBAAO,QAAQA,EAAC;AAAA,UACpB;AAAA,QACJ;AACA,YAAG,uBAAuB,GAAE;AACxB,gBAAM,IAAI,MAAM,kBAAkB;AAAA,QACtC;AAAA,MACJ,OAAK;AACD,cAAM,IAAI,MAAM,gCAAgC;AAAA,MACpD;AACA,aAAO,EAAC,UAAU,GAAAA,GAAC;AAAA,IACvB;AA1DS;AA4DT,aAAS,cAAc,SAAQA,IAAE;AAW7B,UAAIC,cAAa;AACjB,aAAOD,KAAI,QAAQ,WAAW,QAAQA,EAAC,MAAM,OAAO,QAAQA,EAAC,MAAM,MAAOA,MAAK;AAG3E,QAAAC,eAAc,QAAQD,EAAC;AAAA,MAC3B;AACA,MAAAC,cAAaA,YAAW,KAAK;AAC7B,UAAGA,YAAW,QAAQ,GAAG,MAAM,GAAI,OAAM,IAAI,MAAM,oCAAoC;AAGvF,YAAM,YAAY,QAAQD,IAAG;AAC7B,UAAIE,OAAM;AACV,aAAOF,KAAI,QAAQ,UAAU,QAAQA,EAAC,MAAM,WAAYA,MAAK;AACzD,QAAAE,QAAO,QAAQF,EAAC;AAAA,MACpB;AACA,aAAO,CAACC,aAAYC,MAAKF,EAAC;AAAA,IAC9B;AA3BS;AA6BT,aAAS,UAAU,SAASA,IAAE;AAC1B,UAAG,QAAQA,KAAE,CAAC,MAAM,OACpB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,IAAK,QAAO;AAC7B,aAAO;AAAA,IACX;AALS;AAMT,aAAS,SAAS,SAASA,IAAE;AACzB,UAAG,QAAQA,KAAE,CAAC,MAAM,OACpB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,IAAK,QAAO;AAC7B,aAAO;AAAA,IACX;AATS;AAUT,aAAS,UAAU,SAASA,IAAE;AAC1B,UAAG,QAAQA,KAAE,CAAC,MAAM,OACpB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,IAAK,QAAO;AAC7B,aAAO;AAAA,IACX;AAVS;AAYT,aAAS,UAAU,SAASA,IAAE;AAC1B,UAAG,QAAQA,KAAE,CAAC,MAAM,OACpB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,IAAK,QAAO;AAC7B,aAAO;AAAA,IACX;AAVS;AAWT,aAAS,WAAW,SAASA,IAAE;AAC3B,UAAG,QAAQA,KAAE,CAAC,MAAM,OACpB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,OACjB,QAAQA,KAAE,CAAC,MAAM,IAAK,QAAO;AAC7B,aAAO;AAAA,IACX;AAXS;AAaT,aAAS,mBAAmB,MAAK;AAC7B,UAAI,KAAK,OAAO,IAAI;AACvB,eAAO;AAAA;AAEA,cAAM,IAAI,MAAM,uBAAuB,IAAI,EAAE;AAAA,IACrD;AALS;AAOT,WAAO,UAAU;AAAA;AAAA;;;ACvJjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAG;AAAA,QAAM,WAAW;AACjB,QAAM,WAAW;AAKjB,QAAM,WAAW;AAAA,MACb,KAAO;AAAA;AAAA,MAEP,cAAc;AAAA,MACd,cAAc;AAAA,MACd,WAAW;AAAA;AAAA,IAEf;AAEA,aAAS,SAAS,KAAK,UAAU,CAAC,GAAE;AAChC,gBAAU,OAAO,OAAO,CAAC,GAAG,UAAU,OAAQ;AAC9C,UAAG,CAAC,OAAO,OAAO,QAAQ,SAAW,QAAO;AAE5C,UAAI,aAAc,IAAI,KAAK;AAE3B,UAAG,QAAQ,aAAa,UAAa,QAAQ,SAAS,KAAK,UAAU,EAAG,QAAO;AAAA,eACvE,QAAM,IAAK,QAAO;AAAA,eACjB,QAAQ,OAAO,SAAS,KAAK,UAAU,GAAG;AAC/C,eAAO,UAAU,YAAY,EAAE;AAAA,MAGnC,WAAU,WAAW,OAAO,MAAM,MAAK,IAAI;AACvC,cAAM,WAAW,WAAW,MAAM,mDAAmD;AAErF,YAAG,UAAS;AAER,cAAG,QAAQ,cAAa;AACpB,0BAAc,SAAS,CAAC,KAAK,MAAM,SAAS,CAAC;AAAA,UACjD,OAAK;AACD,gBAAG,SAAS,CAAC,MAAM,OAAO,SAAS,CAAC,EAAE,CAAC,MAAK,KAAI;AAAA,YAChD,OAAK;AACD,qBAAO;AAAA,YACX;AAAA,UACJ;AACA,iBAAO,QAAQ,YAAY,OAAO,UAAU,IAAI;AAAA,QACpD,OAAK;AACD,iBAAO;AAAA,QACX;AAAA,MAGJ,OAAK;AAED,cAAM,QAAQ,SAAS,KAAK,UAAU;AAEtC,YAAG,OAAM;AACL,gBAAM,OAAO,MAAM,CAAC;AACpB,gBAAM,eAAe,MAAM,CAAC;AAC5B,cAAI,oBAAoB,UAAU,MAAM,CAAC,CAAC;AAG1C,cAAG,CAAC,QAAQ,gBAAgB,aAAa,SAAS,KAAK,QAAQ,WAAW,CAAC,MAAM,IAAK,QAAO;AAAA,mBACrF,CAAC,QAAQ,gBAAgB,aAAa,SAAS,KAAK,CAAC,QAAQ,WAAW,CAAC,MAAM,IAAK,QAAO;AAAA,mBAC3F,QAAQ,gBAAgB,iBAAe,IAAK,QAAO;AAAA,eAEvD;AACA,kBAAM,MAAM,OAAO,UAAU;AAC7B,kBAAM,SAAS,KAAK;AAEpB,gBAAG,OAAO,OAAO,MAAM,MAAM,IAAG;AAC5B,kBAAG,QAAQ,UAAW,QAAO;AAAA,kBACxB,QAAO;AAAA,YAChB,WAAS,WAAW,QAAQ,GAAG,MAAM,IAAG;AACpC,kBAAG,WAAW,OAAQ,sBAAsB,GAAM,QAAO;AAAA,uBACjD,WAAW,kBAAmB,QAAO;AAAA,uBACpC,QAAQ,WAAW,MAAI,kBAAmB,QAAO;AAAA,kBACrD,QAAO;AAAA,YAChB;AAEA,gBAAG,cAAa;AACZ,qBAAQ,sBAAsB,UAAY,OAAK,sBAAsB,SAAU,MAAM;AAAA,YACzF,OAAO;AACH,qBAAQ,eAAe,UAAY,eAAe,OAAK,SAAU,MAAM;AAAA,YAC3E;AAAA,UACJ;AAAA,QACJ,OAAK;AACD,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AArES;AA4ET,aAAS,UAAU,QAAO;AACtB,UAAG,UAAU,OAAO,QAAQ,GAAG,MAAM,IAAG;AACpC,iBAAS,OAAO,QAAQ,OAAO,EAAE;AACjC,YAAG,WAAW,IAAM,UAAS;AAAA,iBACrB,OAAO,CAAC,MAAM,IAAM,UAAS,MAAI;AAAA,iBACjC,OAAO,OAAO,SAAO,CAAC,MAAM,IAAM,UAAS,OAAO,OAAO,GAAE,OAAO,SAAO,CAAC;AAClF,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AATS;AAWT,aAAS,UAAU,QAAQ,MAAK;AAE5B,UAAG,SAAU,QAAO,SAAS,QAAQ,IAAI;AAAA,eACjC,OAAO,SAAU,QAAO,OAAO,SAAS,QAAQ,IAAI;AAAA,eACpD,UAAU,OAAO,SAAU,QAAO,OAAO,SAAS,QAAQ,IAAI;AAAA,UACjE,OAAM,IAAI,MAAM,8DAA8D;AAAA,IACvF;AANS;AAQT,WAAO,UAAU;AAAA;AAAA;;;AC9GjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAGA,QAAM,OAAO;AACb,QAAM,UAAU;AAChB,QAAM,cAAc;AACpB,QAAM,WAAW;AASjB,QAAM,mBAAN,MAAsB;AAAA,MAftB,OAesB;AAAA;AAAA;AAAA,MACpB,YAAY,SAAQ;AAClB,aAAK,UAAU;AACf,aAAK,cAAc;AACnB,aAAK,gBAAgB,CAAC;AACtB,aAAK,kBAAkB,CAAC;AACxB,aAAK,eAAe;AAAA,UAClB,QAAS,EAAE,OAAO,sBAAsB,KAAM,IAAG;AAAA,UACjD,MAAO,EAAE,OAAO,oBAAoB,KAAM,IAAG;AAAA,UAC7C,MAAO,EAAE,OAAO,oBAAoB,KAAM,IAAG;AAAA,UAC7C,QAAS,EAAE,OAAO,sBAAsB,KAAM,IAAI;AAAA,QACpD;AACA,aAAK,YAAY,EAAE,OAAO,qBAAqB,KAAM,IAAG;AACxD,aAAK,eAAe;AAAA,UAClB,SAAS,EAAE,OAAO,kBAAkB,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAM7C,QAAS,EAAE,OAAO,kBAAkB,KAAK,OAAI;AAAA,UAC7C,SAAU,EAAE,OAAO,mBAAmB,KAAK,OAAI;AAAA,UAC/C,OAAQ,EAAE,OAAO,iBAAiB,KAAK,OAAI;AAAA,UAC3C,QAAS,EAAE,OAAO,mBAAmB,KAAK,SAAI;AAAA,UAC9C,aAAc,EAAE,OAAO,kBAAkB,KAAK,OAAI;AAAA,UAClD,OAAQ,EAAE,OAAO,iBAAiB,KAAK,OAAI;AAAA,UAC3C,OAAQ,EAAE,OAAO,kBAAkB,KAAK,SAAI;AAAA,UAC5C,WAAW,EAAE,OAAO,oBAAoB,KAAM,wBAACC,IAAG,QAAQ,OAAO,aAAa,OAAO,SAAS,KAAK,EAAE,CAAC,GAAxD,OAA0D;AAAA,UACxG,WAAW,EAAE,OAAO,2BAA2B,KAAM,wBAACA,IAAG,QAAQ,OAAO,aAAa,OAAO,SAAS,KAAK,EAAE,CAAC,GAAxD,OAA0D;AAAA,QACjH;AACA,aAAK,sBAAsB;AAC3B,aAAK,WAAW;AAChB,aAAK,gBAAgB;AACrB,aAAK,mBAAmB;AACxB,aAAK,qBAAqB;AAC1B,aAAK,eAAe;AACpB,aAAK,uBAAuB;AAC5B,aAAK,mBAAmB;AACxB,aAAK,sBAAsB;AAC3B,aAAK,WAAW;AAAA,MAClB;AAAA,IAEF;AAEA,aAAS,oBAAoB,kBAAiB;AAC5C,YAAM,UAAU,OAAO,KAAK,gBAAgB;AAC5C,eAASC,KAAI,GAAGA,KAAI,QAAQ,QAAQA,MAAK;AACvC,cAAM,MAAM,QAAQA,EAAC;AACrB,aAAK,aAAa,GAAG,IAAI;AAAA,UACtB,OAAO,IAAI,OAAO,MAAI,MAAI,KAAI,GAAG;AAAA,UACjC,KAAM,iBAAiB,GAAG;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AATS;AAoBT,aAAS,cAAcC,MAAK,SAAS,OAAO,UAAU,eAAe,YAAY,gBAAgB;AAC/F,UAAIA,SAAQ,QAAW;AACrB,YAAI,KAAK,QAAQ,cAAc,CAAC,UAAU;AACxC,UAAAA,OAAMA,KAAI,KAAK;AAAA,QACjB;AACA,YAAGA,KAAI,SAAS,GAAE;AAChB,cAAG,CAAC,eAAgB,CAAAA,OAAM,KAAK,qBAAqBA,IAAG;AAEvD,gBAAM,SAAS,KAAK,QAAQ,kBAAkB,SAASA,MAAK,OAAO,eAAe,UAAU;AAC5F,cAAG,WAAW,QAAQ,WAAW,QAAU;AAEzC,mBAAOA;AAAA,UACT,WAAS,OAAO,WAAW,OAAOA,QAAO,WAAWA,MAAI;AAEtD,mBAAO;AAAA,UACT,WAAS,KAAK,QAAQ,YAAW;AAC/B,mBAAO,WAAWA,MAAK,KAAK,QAAQ,eAAe,KAAK,QAAQ,kBAAkB;AAAA,UACpF,OAAK;AACH,kBAAM,aAAaA,KAAI,KAAK;AAC5B,gBAAG,eAAeA,MAAI;AACpB,qBAAO,WAAWA,MAAK,KAAK,QAAQ,eAAe,KAAK,QAAQ,kBAAkB;AAAA,YACpF,OAAK;AACH,qBAAOA;AAAA,YACT;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AA3BS;AA6BT,aAAS,iBAAiB,SAAS;AACjC,UAAI,KAAK,QAAQ,gBAAgB;AAC/B,cAAM,OAAO,QAAQ,MAAM,GAAG;AAC9B,cAAM,SAAS,QAAQ,OAAO,CAAC,MAAM,MAAM,MAAM;AACjD,YAAI,KAAK,CAAC,MAAM,SAAS;AACvB,iBAAO;AAAA,QACT;AACA,YAAI,KAAK,WAAW,GAAG;AACrB,oBAAU,SAAS,KAAK,CAAC;AAAA,QAC3B;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAZS;AAgBT,QAAM,YAAY,IAAI,OAAO,+CAAgD,IAAI;AAEjF,aAAS,mBAAmB,SAAS,OAAO,SAAS;AACnD,UAAI,CAAC,KAAK,QAAQ,oBAAoB,OAAO,YAAY,UAAU;AAIjE,cAAM,UAAU,KAAK,cAAc,SAAS,SAAS;AACrD,cAAM,MAAM,QAAQ;AACpB,cAAM,QAAQ,CAAC;AACf,iBAASD,KAAI,GAAGA,KAAI,KAAKA,MAAK;AAC5B,gBAAM,WAAW,KAAK,iBAAiB,QAAQA,EAAC,EAAE,CAAC,CAAC;AACpD,cAAI,SAAS,QAAQA,EAAC,EAAE,CAAC;AACzB,cAAI,QAAQ,KAAK,QAAQ,sBAAsB;AAC/C,cAAI,SAAS,QAAQ;AACnB,gBAAI,KAAK,QAAQ,wBAAwB;AACvC,sBAAQ,KAAK,QAAQ,uBAAuB,KAAK;AAAA,YACnD;AACA,gBAAG,UAAU,YAAa,SAAS;AACnC,gBAAI,WAAW,QAAW;AACxB,kBAAI,KAAK,QAAQ,YAAY;AAC3B,yBAAS,OAAO,KAAK;AAAA,cACvB;AACA,uBAAS,KAAK,qBAAqB,MAAM;AACzC,oBAAM,SAAS,KAAK,QAAQ,wBAAwB,UAAU,QAAQ,KAAK;AAC3E,kBAAG,WAAW,QAAQ,WAAW,QAAU;AAEzC,sBAAM,KAAK,IAAI;AAAA,cACjB,WAAS,OAAO,WAAW,OAAO,UAAU,WAAW,QAAO;AAE5D,sBAAM,KAAK,IAAI;AAAA,cACjB,OAAK;AAEH,sBAAM,KAAK,IAAI;AAAA,kBACb;AAAA,kBACA,KAAK,QAAQ;AAAA,kBACb,KAAK,QAAQ;AAAA,gBACf;AAAA,cACF;AAAA,YACF,WAAW,KAAK,QAAQ,wBAAwB;AAC9C,oBAAM,KAAK,IAAI;AAAA,YACjB;AAAA,UACF;AAAA,QACF;AACA,YAAI,CAAC,OAAO,KAAK,KAAK,EAAE,QAAQ;AAC9B;AAAA,QACF;AACA,YAAI,KAAK,QAAQ,qBAAqB;AACpC,gBAAM,iBAAiB,CAAC;AACxB,yBAAe,KAAK,QAAQ,mBAAmB,IAAI;AACnD,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT;AAAA,IACF;AApDS;AAsDT,QAAM,WAAW,gCAAS,SAAS;AACjC,gBAAU,QAAQ,QAAQ,UAAU,IAAI;AACxC,YAAM,SAAS,IAAI,QAAQ,MAAM;AACjC,UAAI,cAAc;AAClB,UAAI,WAAW;AACf,UAAI,QAAQ;AACZ,eAAQA,KAAE,GAAGA,KAAG,QAAQ,QAAQA,MAAI;AAClC,cAAM,KAAK,QAAQA,EAAC;AACpB,YAAG,OAAO,KAAI;AAGZ,cAAI,QAAQA,KAAE,CAAC,MAAM,KAAK;AACxB,kBAAM,aAAa,iBAAiB,SAAS,KAAKA,IAAG,4BAA4B;AACjF,gBAAI,UAAU,QAAQ,UAAUA,KAAE,GAAE,UAAU,EAAE,KAAK;AAErD,gBAAG,KAAK,QAAQ,gBAAe;AAC7B,oBAAM,aAAa,QAAQ,QAAQ,GAAG;AACtC,kBAAG,eAAe,IAAG;AACnB,0BAAU,QAAQ,OAAO,aAAW,CAAC;AAAA,cACvC;AAAA,YACF;AAEA,gBAAG,KAAK,QAAQ,kBAAkB;AAChC,wBAAU,KAAK,QAAQ,iBAAiB,OAAO;AAAA,YACjD;AAEA,gBAAG,aAAY;AACb,yBAAW,KAAK,oBAAoB,UAAU,aAAa,KAAK;AAAA,YAClE;AAGA,kBAAM,cAAc,MAAM,UAAU,MAAM,YAAY,GAAG,IAAE,CAAC;AAC5D,gBAAG,WAAW,KAAK,QAAQ,aAAa,QAAQ,OAAO,MAAM,IAAI;AAC/D,oBAAM,IAAI,MAAM,kDAAkD,OAAO,GAAG;AAAA,YAC9E;AACA,gBAAI,YAAY;AAChB,gBAAG,eAAe,KAAK,QAAQ,aAAa,QAAQ,WAAW,MAAM,IAAI;AACvE,0BAAY,MAAM,YAAY,KAAK,MAAM,YAAY,GAAG,IAAE,CAAC;AAC3D,mBAAK,cAAc,IAAI;AAAA,YACzB,OAAK;AACH,0BAAY,MAAM,YAAY,GAAG;AAAA,YACnC;AACA,oBAAQ,MAAM,UAAU,GAAG,SAAS;AAEpC,0BAAc,KAAK,cAAc,IAAI;AACrC,uBAAW;AACX,YAAAA,KAAI;AAAA,UACN,WAAW,QAAQA,KAAE,CAAC,MAAM,KAAK;AAE/B,gBAAI,UAAU,WAAW,SAAQA,IAAG,OAAO,IAAI;AAC/C,gBAAG,CAAC,QAAS,OAAM,IAAI,MAAM,uBAAuB;AAEpD,uBAAW,KAAK,oBAAoB,UAAU,aAAa,KAAK;AAChE,gBAAK,KAAK,QAAQ,qBAAqB,QAAQ,YAAY,UAAW,KAAK,QAAQ,cAAa;AAAA,YAEhG,OAAK;AAEH,oBAAM,YAAY,IAAI,QAAQ,QAAQ,OAAO;AAC7C,wBAAU,IAAI,KAAK,QAAQ,cAAc,EAAE;AAE3C,kBAAG,QAAQ,YAAY,QAAQ,UAAU,QAAQ,gBAAe;AAC9D,0BAAU,IAAI,IAAI,KAAK,mBAAmB,QAAQ,QAAQ,OAAO,QAAQ,OAAO;AAAA,cAClF;AACA,mBAAK,SAAS,aAAa,WAAW,KAAK;AAAA,YAE7C;AAGA,YAAAA,KAAI,QAAQ,aAAa;AAAA,UAC3B,WAAU,QAAQ,OAAOA,KAAI,GAAG,CAAC,MAAM,OAAO;AAC5C,kBAAM,WAAW,iBAAiB,SAAS,OAAOA,KAAE,GAAG,wBAAwB;AAC/E,gBAAG,KAAK,QAAQ,iBAAgB;AAC9B,oBAAM,UAAU,QAAQ,UAAUA,KAAI,GAAG,WAAW,CAAC;AAErD,yBAAW,KAAK,oBAAoB,UAAU,aAAa,KAAK;AAEhE,0BAAY,IAAI,KAAK,QAAQ,iBAAiB,CAAE,EAAE,CAAC,KAAK,QAAQ,YAAY,GAAI,QAAQ,CAAE,CAAC;AAAA,YAC7F;AACA,YAAAA,KAAI;AAAA,UACN,WAAW,QAAQ,OAAOA,KAAI,GAAG,CAAC,MAAM,MAAM;AAC5C,kBAAM,SAAS,YAAY,SAASA,EAAC;AACrC,iBAAK,kBAAkB,OAAO;AAC9B,YAAAA,KAAI,OAAO;AAAA,UACb,WAAS,QAAQ,OAAOA,KAAI,GAAG,CAAC,MAAM,MAAM;AAC1C,kBAAM,aAAa,iBAAiB,SAAS,OAAOA,IAAG,sBAAsB,IAAI;AACjF,kBAAM,SAAS,QAAQ,UAAUA,KAAI,GAAE,UAAU;AAEjD,uBAAW,KAAK,oBAAoB,UAAU,aAAa,KAAK;AAEhE,gBAAIC,OAAM,KAAK,cAAc,QAAQ,YAAY,SAAS,OAAO,MAAM,OAAO,MAAM,IAAI;AACxF,gBAAGA,QAAO,OAAW,CAAAA,OAAM;AAG3B,gBAAG,KAAK,QAAQ,eAAc;AAC5B,0BAAY,IAAI,KAAK,QAAQ,eAAe,CAAE,EAAE,CAAC,KAAK,QAAQ,YAAY,GAAI,OAAO,CAAE,CAAC;AAAA,YAC1F,OAAK;AACH,0BAAY,IAAI,KAAK,QAAQ,cAAcA,IAAG;AAAA,YAChD;AAEA,YAAAD,KAAI,aAAa;AAAA,UACnB,OAAM;AACJ,gBAAI,SAAS,WAAW,SAAQA,IAAG,KAAK,QAAQ,cAAc;AAC9D,gBAAI,UAAS,OAAO;AACpB,kBAAM,aAAa,OAAO;AAC1B,gBAAI,SAAS,OAAO;AACpB,gBAAI,iBAAiB,OAAO;AAC5B,gBAAI,aAAa,OAAO;AAExB,gBAAI,KAAK,QAAQ,kBAAkB;AACjC,wBAAU,KAAK,QAAQ,iBAAiB,OAAO;AAAA,YACjD;AAGA,gBAAI,eAAe,UAAU;AAC3B,kBAAG,YAAY,YAAY,QAAO;AAEhC,2BAAW,KAAK,oBAAoB,UAAU,aAAa,OAAO,KAAK;AAAA,cACzE;AAAA,YACF;AAGA,kBAAM,UAAU;AAChB,gBAAG,WAAW,KAAK,QAAQ,aAAa,QAAQ,QAAQ,OAAO,MAAM,IAAI;AACvE,4BAAc,KAAK,cAAc,IAAI;AACrC,sBAAQ,MAAM,UAAU,GAAG,MAAM,YAAY,GAAG,CAAC;AAAA,YACnD;AACA,gBAAG,YAAY,OAAO,SAAQ;AAC5B,uBAAS,QAAQ,MAAM,UAAU;AAAA,YACnC;AACA,gBAAI,KAAK,aAAa,KAAK,QAAQ,WAAW,OAAO,OAAO,GAAG;AAC7D,kBAAI,aAAa;AAEjB,kBAAG,OAAO,SAAS,KAAK,OAAO,YAAY,GAAG,MAAM,OAAO,SAAS,GAAE;AACpE,oBAAG,QAAQ,QAAQ,SAAS,CAAC,MAAM,KAAI;AACrC,4BAAU,QAAQ,OAAO,GAAG,QAAQ,SAAS,CAAC;AAC9C,0BAAQ,MAAM,OAAO,GAAG,MAAM,SAAS,CAAC;AACxC,2BAAS;AAAA,gBACX,OAAK;AACH,2BAAS,OAAO,OAAO,GAAG,OAAO,SAAS,CAAC;AAAA,gBAC7C;AACA,gBAAAA,KAAI,OAAO;AAAA,cACb,WAEQ,KAAK,QAAQ,aAAa,QAAQ,OAAO,MAAM,IAAG;AAExD,gBAAAA,KAAI,OAAO;AAAA,cACb,OAEI;AAEF,sBAAME,UAAS,KAAK,iBAAiB,SAAS,YAAY,aAAa,CAAC;AACxE,oBAAG,CAACA,QAAQ,OAAM,IAAI,MAAM,qBAAqB,UAAU,EAAE;AAC7D,gBAAAF,KAAIE,QAAO;AACX,6BAAaA,QAAO;AAAA,cACtB;AAEA,oBAAM,YAAY,IAAI,QAAQ,OAAO;AACrC,kBAAG,YAAY,UAAU,gBAAe;AACtC,0BAAU,IAAI,IAAI,KAAK,mBAAmB,QAAQ,OAAO,OAAO;AAAA,cAClE;AACA,kBAAG,YAAY;AACb,6BAAa,KAAK,cAAc,YAAY,SAAS,OAAO,MAAM,gBAAgB,MAAM,IAAI;AAAA,cAC9F;AAEA,sBAAQ,MAAM,OAAO,GAAG,MAAM,YAAY,GAAG,CAAC;AAC9C,wBAAU,IAAI,KAAK,QAAQ,cAAc,UAAU;AAEnD,mBAAK,SAAS,aAAa,WAAW,KAAK;AAAA,YAC7C,OAAK;AAEH,kBAAG,OAAO,SAAS,KAAK,OAAO,YAAY,GAAG,MAAM,OAAO,SAAS,GAAE;AACpE,oBAAG,QAAQ,QAAQ,SAAS,CAAC,MAAM,KAAI;AACrC,4BAAU,QAAQ,OAAO,GAAG,QAAQ,SAAS,CAAC;AAC9C,0BAAQ,MAAM,OAAO,GAAG,MAAM,SAAS,CAAC;AACxC,2BAAS;AAAA,gBACX,OAAK;AACH,2BAAS,OAAO,OAAO,GAAG,OAAO,SAAS,CAAC;AAAA,gBAC7C;AAEA,oBAAG,KAAK,QAAQ,kBAAkB;AAChC,4BAAU,KAAK,QAAQ,iBAAiB,OAAO;AAAA,gBACjD;AAEA,sBAAM,YAAY,IAAI,QAAQ,OAAO;AACrC,oBAAG,YAAY,UAAU,gBAAe;AACtC,4BAAU,IAAI,IAAI,KAAK,mBAAmB,QAAQ,OAAO,OAAO;AAAA,gBAClE;AACA,qBAAK,SAAS,aAAa,WAAW,KAAK;AAC3C,wBAAQ,MAAM,OAAO,GAAG,MAAM,YAAY,GAAG,CAAC;AAAA,cAChD,OAEI;AACF,sBAAM,YAAY,IAAI,QAAS,OAAO;AACtC,qBAAK,cAAc,KAAK,WAAW;AAEnC,oBAAG,YAAY,UAAU,gBAAe;AACtC,4BAAU,IAAI,IAAI,KAAK,mBAAmB,QAAQ,OAAO,OAAO;AAAA,gBAClE;AACA,qBAAK,SAAS,aAAa,WAAW,KAAK;AAC3C,8BAAc;AAAA,cAChB;AACA,yBAAW;AACX,cAAAF,KAAI;AAAA,YACN;AAAA,UACF;AAAA,QACF,OAAK;AACH,sBAAY,QAAQA,EAAC;AAAA,QACvB;AAAA,MACF;AACA,aAAO,OAAO;AAAA,IAChB,GAlNiB;AAoNjB,aAAS,SAAS,aAAa,WAAW,OAAM;AAC9C,YAAM,SAAS,KAAK,QAAQ,UAAU,UAAU,SAAS,OAAO,UAAU,IAAI,CAAC;AAC/E,UAAG,WAAW,OAAM;AAAA,MACpB,WAAS,OAAO,WAAW,UAAS;AAClC,kBAAU,UAAU;AACpB,oBAAY,SAAS,SAAS;AAAA,MAChC,OAAK;AACH,oBAAY,SAAS,SAAS;AAAA,MAChC;AAAA,IACF;AATS;AAWT,QAAM,uBAAuB,gCAASC,MAAI;AAExC,UAAG,KAAK,QAAQ,iBAAgB;AAC9B,iBAAQE,eAAc,KAAK,iBAAgB;AACzC,gBAAM,SAAS,KAAK,gBAAgBA,WAAU;AAC9C,UAAAF,OAAMA,KAAI,QAAS,OAAO,MAAM,OAAO,GAAG;AAAA,QAC5C;AACA,iBAAQE,eAAc,KAAK,cAAa;AACtC,gBAAM,SAAS,KAAK,aAAaA,WAAU;AAC3C,UAAAF,OAAMA,KAAI,QAAS,OAAO,OAAO,OAAO,GAAG;AAAA,QAC7C;AACA,YAAG,KAAK,QAAQ,cAAa;AAC3B,mBAAQE,eAAc,KAAK,cAAa;AACtC,kBAAM,SAAS,KAAK,aAAaA,WAAU;AAC3C,YAAAF,OAAMA,KAAI,QAAS,OAAO,OAAO,OAAO,GAAG;AAAA,UAC7C;AAAA,QACF;AACA,QAAAA,OAAMA,KAAI,QAAS,KAAK,UAAU,OAAO,KAAK,UAAU,GAAG;AAAA,MAC7D;AACA,aAAOA;AAAA,IACT,GApB6B;AAqB7B,aAAS,oBAAoB,UAAU,aAAa,OAAO,YAAY;AACrE,UAAI,UAAU;AACZ,YAAG,eAAe,OAAW,cAAa,OAAO,KAAK,YAAY,KAAK,EAAE,WAAW;AAEpF,mBAAW,KAAK;AAAA,UAAc;AAAA,UAC5B,YAAY;AAAA,UACZ;AAAA,UACA;AAAA,UACA,YAAY,IAAI,IAAI,OAAO,KAAK,YAAY,IAAI,CAAC,EAAE,WAAW,IAAI;AAAA,UAClE;AAAA,QAAU;AAEZ,YAAI,aAAa,UAAa,aAAa;AACzC,sBAAY,IAAI,KAAK,QAAQ,cAAc,QAAQ;AACrD,mBAAW;AAAA,MACb;AACA,aAAO;AAAA,IACT;AAhBS;AAyBT,aAAS,aAAa,WAAW,OAAO,gBAAe;AACrD,YAAM,cAAc,OAAO;AAC3B,iBAAW,gBAAgB,WAAW;AACpC,cAAM,cAAc,UAAU,YAAY;AAC1C,YAAI,gBAAgB,eAAe,UAAU,YAAe,QAAO;AAAA,MACrE;AACA,aAAO;AAAA,IACT;AAPS;AAeT,aAAS,uBAAuB,SAASD,IAAG,cAAc,KAAI;AAC5D,UAAI;AACJ,UAAI,SAAS;AACb,eAAS,QAAQA,IAAG,QAAQ,QAAQ,QAAQ,SAAS;AACnD,YAAI,KAAK,QAAQ,KAAK;AACtB,YAAI,cAAc;AACd,cAAI,OAAO,aAAc,gBAAe;AAAA,QAC5C,WAAW,OAAO,OAAO,OAAO,KAAK;AACjC,yBAAe;AAAA,QACnB,WAAW,OAAO,YAAY,CAAC,GAAG;AAChC,cAAG,YAAY,CAAC,GAAE;AAChB,gBAAG,QAAQ,QAAQ,CAAC,MAAM,YAAY,CAAC,GAAE;AACvC,qBAAO;AAAA,gBACL,MAAM;AAAA,gBACN;AAAA,cACF;AAAA,YACF;AAAA,UACF,OAAK;AACH,mBAAO;AAAA,cACL,MAAM;AAAA,cACN;AAAA,YACF;AAAA,UACF;AAAA,QACF,WAAW,OAAO,KAAM;AACtB,eAAK;AAAA,QACP;AACA,kBAAU;AAAA,MACZ;AAAA,IACF;AA5BS;AA8BT,aAAS,iBAAiB,SAAS,KAAKA,IAAG,QAAO;AAChD,YAAM,eAAe,QAAQ,QAAQ,KAAKA,EAAC;AAC3C,UAAG,iBAAiB,IAAG;AACrB,cAAM,IAAI,MAAM,MAAM;AAAA,MACxB,OAAK;AACH,eAAO,eAAe,IAAI,SAAS;AAAA,MACrC;AAAA,IACF;AAPS;AAST,aAAS,WAAW,SAAQA,IAAG,gBAAgB,cAAc,KAAI;AAC/D,YAAM,SAAS,uBAAuB,SAASA,KAAE,GAAG,WAAW;AAC/D,UAAG,CAAC,OAAQ;AACZ,UAAI,SAAS,OAAO;AACpB,YAAM,aAAa,OAAO;AAC1B,YAAM,iBAAiB,OAAO,OAAO,IAAI;AACzC,UAAI,UAAU;AACd,UAAI,iBAAiB;AACrB,UAAG,mBAAmB,IAAG;AACvB,kBAAU,OAAO,UAAU,GAAG,cAAc;AAC5C,iBAAS,OAAO,UAAU,iBAAiB,CAAC,EAAE,UAAU;AAAA,MAC1D;AAEA,YAAM,aAAa;AACnB,UAAG,gBAAe;AAChB,cAAM,aAAa,QAAQ,QAAQ,GAAG;AACtC,YAAG,eAAe,IAAG;AACnB,oBAAU,QAAQ,OAAO,aAAW,CAAC;AACrC,2BAAiB,YAAY,OAAO,KAAK,OAAO,aAAa,CAAC;AAAA,QAChE;AAAA,MACF;AAEA,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AA7BS;AAoCT,aAAS,iBAAiB,SAAS,SAASA,IAAE;AAC5C,YAAM,aAAaA;AAEnB,UAAI,eAAe;AAEnB,aAAOA,KAAI,QAAQ,QAAQA,MAAK;AAC9B,YAAI,QAAQA,EAAC,MAAM,KAAI;AACrB,cAAI,QAAQA,KAAE,CAAC,MAAM,KAAK;AACtB,kBAAM,aAAa,iBAAiB,SAAS,KAAKA,IAAG,GAAG,OAAO,gBAAgB;AAC/E,gBAAI,eAAe,QAAQ,UAAUA,KAAE,GAAE,UAAU,EAAE,KAAK;AAC1D,gBAAG,iBAAiB,SAAQ;AAC1B;AACA,kBAAI,iBAAiB,GAAG;AACtB,uBAAO;AAAA,kBACL,YAAY,QAAQ,UAAU,YAAYA,EAAC;AAAA,kBAC3C,GAAI;AAAA,gBACN;AAAA,cACF;AAAA,YACF;AACA,YAAAA,KAAE;AAAA,UACJ,WAAU,QAAQA,KAAE,CAAC,MAAM,KAAK;AAC9B,kBAAM,aAAa,iBAAiB,SAAS,MAAMA,KAAE,GAAG,yBAAyB;AACjF,YAAAA,KAAE;AAAA,UACJ,WAAU,QAAQ,OAAOA,KAAI,GAAG,CAAC,MAAM,OAAO;AAC5C,kBAAM,aAAa,iBAAiB,SAAS,OAAOA,KAAE,GAAG,yBAAyB;AAClF,YAAAA,KAAE;AAAA,UACJ,WAAU,QAAQ,OAAOA,KAAI,GAAG,CAAC,MAAM,MAAM;AAC3C,kBAAM,aAAa,iBAAiB,SAAS,OAAOA,IAAG,yBAAyB,IAAI;AACpF,YAAAA,KAAE;AAAA,UACJ,OAAO;AACL,kBAAM,UAAU,WAAW,SAASA,IAAG,GAAG;AAE1C,gBAAI,SAAS;AACX,oBAAM,cAAc,WAAW,QAAQ;AACvC,kBAAI,gBAAgB,WAAW,QAAQ,OAAO,QAAQ,OAAO,SAAO,CAAC,MAAM,KAAK;AAC9E;AAAA,cACF;AACA,cAAAA,KAAE,QAAQ;AAAA,YACZ;AAAA,UACF;AAAA,QACF;AAAA,MACJ;AAAA,IACF;AA1CS;AA4CT,aAAS,WAAWC,MAAK,aAAa,SAAS;AAC7C,UAAI,eAAe,OAAOA,SAAQ,UAAU;AAE1C,cAAM,SAASA,KAAI,KAAK;AACxB,YAAG,WAAW,OAAS,QAAO;AAAA,iBACtB,WAAW,QAAU,QAAO;AAAA,YAC/B,QAAO,SAASA,MAAK,OAAO;AAAA,MACnC,OAAO;AACL,YAAI,KAAK,QAAQA,IAAG,GAAG;AACrB,iBAAOA;AAAA,QACT,OAAO;AACL,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAdS;AAiBT,WAAO,UAAU;AAAA;AAAA;;;ACxlBjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAG;AAQA,aAAS,SAAS,MAAM,SAAQ;AAC9B,aAAO,SAAU,MAAM,OAAO;AAAA,IAChC;AAFS;AAWT,aAAS,SAAS,KAAK,SAAS,OAAM;AACpC,UAAI;AACJ,YAAM,gBAAgB,CAAC;AACvB,eAASC,KAAI,GAAGA,KAAI,IAAI,QAAQA,MAAK;AACnC,cAAM,SAAS,IAAIA,EAAC;AACpB,cAAM,WAAW,SAAS,MAAM;AAChC,YAAI,WAAW;AACf,YAAG,UAAU,OAAW,YAAW;AAAA,YAC9B,YAAW,QAAQ,MAAM;AAE9B,YAAG,aAAa,QAAQ,cAAa;AACnC,cAAG,SAAS,OAAW,QAAO,OAAO,QAAQ;AAAA,cACxC,SAAQ,KAAK,OAAO,QAAQ;AAAA,QACnC,WAAS,aAAa,QAAU;AAC9B;AAAA,QACF,WAAS,OAAO,QAAQ,GAAE;AAExB,cAAIC,OAAM,SAAS,OAAO,QAAQ,GAAG,SAAS,QAAQ;AACtD,gBAAM,SAAS,UAAUA,MAAK,OAAO;AAErC,cAAG,OAAO,IAAI,GAAE;AACd,6BAAkBA,MAAK,OAAO,IAAI,GAAG,UAAU,OAAO;AAAA,UACxD,WAAS,OAAO,KAAKA,IAAG,EAAE,WAAW,KAAKA,KAAI,QAAQ,YAAY,MAAM,UAAa,CAAC,QAAQ,sBAAqB;AACjH,YAAAA,OAAMA,KAAI,QAAQ,YAAY;AAAA,UAChC,WAAS,OAAO,KAAKA,IAAG,EAAE,WAAW,GAAE;AACrC,gBAAG,QAAQ,qBAAsB,CAAAA,KAAI,QAAQ,YAAY,IAAI;AAAA,gBACxD,CAAAA,OAAM;AAAA,UACb;AAEA,cAAG,cAAc,QAAQ,MAAM,UAAa,cAAc,eAAe,QAAQ,GAAG;AAClF,gBAAG,CAAC,MAAM,QAAQ,cAAc,QAAQ,CAAC,GAAG;AACxC,4BAAc,QAAQ,IAAI,CAAE,cAAc,QAAQ,CAAE;AAAA,YACxD;AACA,0BAAc,QAAQ,EAAE,KAAKA,IAAG;AAAA,UAClC,OAAK;AAGH,gBAAI,QAAQ,QAAQ,UAAU,UAAU,MAAO,GAAG;AAChD,4BAAc,QAAQ,IAAI,CAACA,IAAG;AAAA,YAChC,OAAK;AACH,4BAAc,QAAQ,IAAIA;AAAA,YAC5B;AAAA,UACF;AAAA,QACF;AAAA,MAEF;AAEA,UAAG,OAAO,SAAS,UAAS;AAC1B,YAAG,KAAK,SAAS,EAAG,eAAc,QAAQ,YAAY,IAAI;AAAA,MAC5D,WAAS,SAAS,OAAW,eAAc,QAAQ,YAAY,IAAI;AACnE,aAAO;AAAA,IACT;AAnDS;AAqDT,aAAS,SAAS,KAAI;AACpB,YAAM,OAAO,OAAO,KAAK,GAAG;AAC5B,eAASD,KAAI,GAAGA,KAAI,KAAK,QAAQA,MAAK;AACpC,cAAM,MAAM,KAAKA,EAAC;AAClB,YAAG,QAAQ,KAAM,QAAO;AAAA,MAC1B;AAAA,IACF;AANS;AAQT,aAAS,iBAAiB,KAAK,SAAS,OAAO,SAAQ;AACrD,UAAI,SAAS;AACX,cAAM,OAAO,OAAO,KAAK,OAAO;AAChC,cAAM,MAAM,KAAK;AACjB,iBAASA,KAAI,GAAGA,KAAI,KAAKA,MAAK;AAC5B,gBAAM,WAAW,KAAKA,EAAC;AACvB,cAAI,QAAQ,QAAQ,UAAU,QAAQ,MAAM,UAAU,MAAM,IAAI,GAAG;AACjE,gBAAI,QAAQ,IAAI,CAAE,QAAQ,QAAQ,CAAE;AAAA,UACtC,OAAO;AACL,gBAAI,QAAQ,IAAI,QAAQ,QAAQ;AAAA,UAClC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAbS;AAeT,aAAS,UAAU,KAAK,SAAQ;AAC9B,YAAM,EAAE,aAAa,IAAI;AACzB,YAAM,YAAY,OAAO,KAAK,GAAG,EAAE;AAEnC,UAAI,cAAc,GAAG;AACnB,eAAO;AAAA,MACT;AAEA,UACE,cAAc,MACb,IAAI,YAAY,KAAK,OAAO,IAAI,YAAY,MAAM,aAAa,IAAI,YAAY,MAAM,IACtF;AACA,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,IACT;AAhBS;AAiBT,YAAQ,WAAW;AAAA;AAAA;;;AChHnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAE;AAAA,QAAM,EAAE,aAAY,IAAI;AACxB,QAAM,mBAAmB;AACzB,QAAM,EAAE,SAAQ,IAAI;AACpB,QAAM,YAAY;AAElB,QAAMC,aAAN,MAAe;AAAA,MALf,OAKe;AAAA;AAAA;AAAA,MAEX,YAAY,SAAQ;AAChB,aAAK,mBAAmB,CAAC;AACzB,aAAK,UAAU,aAAa,OAAO;AAAA,MAEvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,MAAM,SAAQ,kBAAiB;AAC3B,YAAG,OAAO,YAAY,UAAS;AAAA,QAC/B,WAAU,QAAQ,UAAS;AACvB,oBAAU,QAAQ,SAAS;AAAA,QAC/B,OAAK;AACD,gBAAM,IAAI,MAAM,iDAAiD;AAAA,QACrE;AACA,YAAI,kBAAiB;AACjB,cAAG,qBAAqB,KAAM,oBAAmB,CAAC;AAElD,gBAAM,SAAS,UAAU,SAAS,SAAS,gBAAgB;AAC3D,cAAI,WAAW,MAAM;AACnB,kBAAM,MAAO,GAAG,OAAO,IAAI,GAAG,IAAI,OAAO,IAAI,IAAI,IAAI,OAAO,IAAI,GAAG,EAAG;AAAA,UACxE;AAAA,QACF;AACF,cAAM,mBAAmB,IAAI,iBAAiB,KAAK,OAAO;AAC1D,yBAAiB,oBAAoB,KAAK,gBAAgB;AAC1D,cAAM,gBAAgB,iBAAiB,SAAS,OAAO;AACvD,YAAG,KAAK,QAAQ,iBAAiB,kBAAkB,OAAW,QAAO;AAAA,YAChE,QAAO,SAAS,eAAe,KAAK,OAAO;AAAA,MACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,UAAU,KAAK,OAAM;AACjB,YAAG,MAAM,QAAQ,GAAG,MAAM,IAAG;AACzB,gBAAM,IAAI,MAAM,6BAA6B;AAAA,QACjD,WAAS,IAAI,QAAQ,GAAG,MAAM,MAAM,IAAI,QAAQ,GAAG,MAAM,IAAG;AACxD,gBAAM,IAAI,MAAM,sEAAsE;AAAA,QAC1F,WAAS,UAAU,KAAI;AACnB,gBAAM,IAAI,MAAM,2CAA2C;AAAA,QAC/D,OAAK;AACD,eAAK,iBAAiB,GAAG,IAAI;AAAA,QACjC;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO,UAAUA;AAAA;AAAA;;;ACzDjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAAA,QAAM,MAAM;AAQZ,aAAS,MAAM,QAAQ,SAAS;AAC5B,UAAI,cAAc;AAClB,UAAI,QAAQ,UAAU,QAAQ,SAAS,SAAS,GAAG;AAC/C,sBAAc;AAAA,MAClB;AACA,aAAO,SAAS,QAAQ,SAAS,IAAI,WAAW;AAAA,IACpD;AANS;AAQT,aAAS,SAAS,KAAK,SAAS,OAAO,aAAa;AAChD,UAAI,SAAS;AACb,UAAI,uBAAuB;AAE3B,eAASC,KAAI,GAAGA,KAAI,IAAI,QAAQA,MAAK;AACjC,cAAM,SAAS,IAAIA,EAAC;AACpB,cAAM,UAAU,SAAS,MAAM;AAC/B,YAAG,YAAY,OAAW;AAE1B,YAAI,WAAW;AACf,YAAI,MAAM,WAAW,EAAG,YAAW;AAAA,YAC9B,YAAW,GAAG,KAAK,IAAI,OAAO;AAEnC,YAAI,YAAY,QAAQ,cAAc;AAClC,cAAI,UAAU,OAAO,OAAO;AAC5B,cAAI,CAAC,WAAW,UAAU,OAAO,GAAG;AAChC,sBAAU,QAAQ,kBAAkB,SAAS,OAAO;AACpD,sBAAU,qBAAqB,SAAS,OAAO;AAAA,UACnD;AACA,cAAI,sBAAsB;AACtB,sBAAU;AAAA,UACd;AACA,oBAAU;AACV,iCAAuB;AACvB;AAAA,QACJ,WAAW,YAAY,QAAQ,eAAe;AAC1C,cAAI,sBAAsB;AACtB,sBAAU;AAAA,UACd;AACA,oBAAU,YAAY,OAAO,OAAO,EAAE,CAAC,EAAE,QAAQ,YAAY,CAAC;AAC9D,iCAAuB;AACvB;AAAA,QACJ,WAAW,YAAY,QAAQ,iBAAiB;AAC5C,oBAAU,cAAc,OAAO,OAAO,OAAO,EAAE,CAAC,EAAE,QAAQ,YAAY,CAAC;AACvE,iCAAuB;AACvB;AAAA,QACJ,WAAW,QAAQ,CAAC,MAAM,KAAK;AAC3B,gBAAMC,UAAS,YAAY,OAAO,IAAI,GAAG,OAAO;AAChD,gBAAM,UAAU,YAAY,SAAS,KAAK;AAC1C,cAAI,iBAAiB,OAAO,OAAO,EAAE,CAAC,EAAE,QAAQ,YAAY;AAC5D,2BAAiB,eAAe,WAAW,IAAI,MAAM,iBAAiB;AACtE,oBAAU,UAAU,IAAI,OAAO,GAAG,cAAc,GAAGA,OAAM;AACzD,iCAAuB;AACvB;AAAA,QACJ;AACA,YAAI,gBAAgB;AACpB,YAAI,kBAAkB,IAAI;AACtB,2BAAiB,QAAQ;AAAA,QAC7B;AACA,cAAM,SAAS,YAAY,OAAO,IAAI,GAAG,OAAO;AAChD,cAAM,WAAW,cAAc,IAAI,OAAO,GAAG,MAAM;AACnD,cAAM,WAAW,SAAS,OAAO,OAAO,GAAG,SAAS,UAAU,aAAa;AAC3E,YAAI,QAAQ,aAAa,QAAQ,OAAO,MAAM,IAAI;AAC9C,cAAI,QAAQ,qBAAsB,WAAU,WAAW;AAAA,cAClD,WAAU,WAAW;AAAA,QAC9B,YAAY,CAAC,YAAY,SAAS,WAAW,MAAM,QAAQ,mBAAmB;AAC1E,oBAAU,WAAW;AAAA,QACzB,WAAW,YAAY,SAAS,SAAS,GAAG,GAAG;AAC3C,oBAAU,WAAW,IAAI,QAAQ,GAAG,WAAW,KAAK,OAAO;AAAA,QAC/D,OAAO;AACH,oBAAU,WAAW;AACrB,cAAI,YAAY,gBAAgB,OAAO,SAAS,SAAS,IAAI,KAAK,SAAS,SAAS,IAAI,IAAI;AACxF,sBAAU,cAAc,QAAQ,WAAW,WAAW;AAAA,UAC1D,OAAO;AACH,sBAAU;AAAA,UACd;AACA,oBAAU,KAAK,OAAO;AAAA,QAC1B;AACA,+BAAuB;AAAA,MAC3B;AAEA,aAAO;AAAA,IACX;AAxES;AA0ET,aAAS,SAAS,KAAK;AACnB,YAAM,OAAO,OAAO,KAAK,GAAG;AAC5B,eAASD,KAAI,GAAGA,KAAI,KAAK,QAAQA,MAAK;AAClC,cAAM,MAAM,KAAKA,EAAC;AAClB,YAAG,CAAC,IAAI,eAAe,GAAG,EAAG;AAC7B,YAAI,QAAQ,KAAM,QAAO;AAAA,MAC7B;AAAA,IACJ;AAPS;AAST,aAAS,YAAY,SAAS,SAAS;AACnC,UAAI,UAAU;AACd,UAAI,WAAW,CAAC,QAAQ,kBAAkB;AACtC,iBAAS,QAAQ,SAAS;AACtB,cAAG,CAAC,QAAQ,eAAe,IAAI,EAAG;AAClC,cAAI,UAAU,QAAQ,wBAAwB,MAAM,QAAQ,IAAI,CAAC;AACjE,oBAAU,qBAAqB,SAAS,OAAO;AAC/C,cAAI,YAAY,QAAQ,QAAQ,2BAA2B;AACvD,uBAAW,IAAI,KAAK,OAAO,QAAQ,oBAAoB,MAAM,CAAC;AAAA,UAClE,OAAO;AACH,uBAAW,IAAI,KAAK,OAAO,QAAQ,oBAAoB,MAAM,CAAC,KAAK,OAAO;AAAA,UAC9E;AAAA,QACJ;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAfS;AAiBT,aAAS,WAAW,OAAO,SAAS;AAChC,cAAQ,MAAM,OAAO,GAAG,MAAM,SAAS,QAAQ,aAAa,SAAS,CAAC;AACtE,UAAI,UAAU,MAAM,OAAO,MAAM,YAAY,GAAG,IAAI,CAAC;AACrD,eAAS,SAAS,QAAQ,WAAW;AACjC,YAAI,QAAQ,UAAU,KAAK,MAAM,SAAS,QAAQ,UAAU,KAAK,MAAM,OAAO,QAAS,QAAO;AAAA,MAClG;AACA,aAAO;AAAA,IACX;AAPS;AAST,aAAS,qBAAqB,WAAW,SAAS;AAC9C,UAAI,aAAa,UAAU,SAAS,KAAK,QAAQ,iBAAiB;AAC9D,iBAASA,KAAI,GAAGA,KAAI,QAAQ,SAAS,QAAQA,MAAK;AAC9C,gBAAM,SAAS,QAAQ,SAASA,EAAC;AACjC,sBAAY,UAAU,QAAQ,OAAO,OAAO,OAAO,GAAG;AAAA,QAC1D;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AARS;AAST,WAAO,UAAU;AAAA;AAAA;;;ACtIjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAE;AAEA,QAAM,qBAAqB;AAE3B,QAAM,iBAAiB;AAAA,MACrB,qBAAqB;AAAA,MACrB,qBAAqB;AAAA,MACrB,cAAc;AAAA,MACd,kBAAkB;AAAA,MAClB,eAAe;AAAA,MACf,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,mBAAmB;AAAA,MACnB,sBAAsB;AAAA,MACtB,2BAA2B;AAAA,MAC3B,mBAAmB,gCAAS,KAAKC,IAAG;AAClC,eAAOA;AAAA,MACT,GAFmB;AAAA,MAGnB,yBAAyB,gCAAS,UAAUA,IAAG;AAC7C,eAAOA;AAAA,MACT,GAFyB;AAAA,MAGzB,eAAe;AAAA,MACf,iBAAiB;AAAA,MACjB,cAAc,CAAC;AAAA,MACf,UAAU;AAAA,QACR,EAAE,OAAO,IAAI,OAAO,KAAK,GAAG,GAAG,KAAK,QAAQ;AAAA;AAAA,QAC5C,EAAE,OAAO,IAAI,OAAO,KAAK,GAAG,GAAG,KAAK,OAAO;AAAA,QAC3C,EAAE,OAAO,IAAI,OAAO,KAAK,GAAG,GAAG,KAAK,OAAO;AAAA,QAC3C,EAAE,OAAO,IAAI,OAAO,KAAM,GAAG,GAAG,KAAK,SAAS;AAAA,QAC9C,EAAE,OAAO,IAAI,OAAO,KAAM,GAAG,GAAG,KAAK,SAAS;AAAA,MAChD;AAAA,MACA,iBAAiB;AAAA,MACjB,WAAW,CAAC;AAAA;AAAA;AAAA,MAGZ,cAAc;AAAA,IAChB;AAEA,aAAS,QAAQ,SAAS;AACxB,WAAK,UAAU,OAAO,OAAO,CAAC,GAAG,gBAAgB,OAAO;AACxD,UAAI,KAAK,QAAQ,oBAAoB,KAAK,QAAQ,qBAAqB;AACrE,aAAK,cAAc,WAAgB;AACjC,iBAAO;AAAA,QACT;AAAA,MACF,OAAO;AACL,aAAK,gBAAgB,KAAK,QAAQ,oBAAoB;AACtD,aAAK,cAAc;AAAA,MACrB;AAEA,WAAK,uBAAuB;AAE5B,UAAI,KAAK,QAAQ,QAAQ;AACvB,aAAK,YAAY;AACjB,aAAK,aAAa;AAClB,aAAK,UAAU;AAAA,MACjB,OAAO;AACL,aAAK,YAAY,WAAW;AAC1B,iBAAO;AAAA,QACT;AACA,aAAK,aAAa;AAClB,aAAK,UAAU;AAAA,MACjB;AAAA,IACF;AAxBS;AA0BT,YAAQ,UAAU,QAAQ,SAAS,MAAM;AACvC,UAAG,KAAK,QAAQ,eAAc;AAC5B,eAAO,mBAAmB,MAAM,KAAK,OAAO;AAAA,MAC9C,OAAM;AACJ,YAAG,MAAM,QAAQ,IAAI,KAAK,KAAK,QAAQ,iBAAiB,KAAK,QAAQ,cAAc,SAAS,GAAE;AAC5F,iBAAO;AAAA,YACL,CAAC,KAAK,QAAQ,aAAa,GAAI;AAAA,UACjC;AAAA,QACF;AACA,eAAO,KAAK,IAAI,MAAM,CAAC,EAAE;AAAA,MAC3B;AAAA,IACF;AAEA,YAAQ,UAAU,MAAM,SAAS,MAAM,OAAO;AAC5C,UAAI,UAAU;AACd,UAAIC,OAAM;AACV,eAAS,OAAO,MAAM;AACpB,YAAG,CAAC,OAAO,UAAU,eAAe,KAAK,MAAM,GAAG,EAAG;AACrD,YAAI,OAAO,KAAK,GAAG,MAAM,aAAa;AAEpC,cAAI,KAAK,YAAY,GAAG,GAAG;AACzB,YAAAA,QAAO;AAAA,UACT;AAAA,QACF,WAAW,KAAK,GAAG,MAAM,MAAM;AAE7B,cAAI,KAAK,YAAY,GAAG,GAAG;AACzB,YAAAA,QAAO;AAAA,UACT,WAAW,IAAI,CAAC,MAAM,KAAK;AACzB,YAAAA,QAAO,KAAK,UAAU,KAAK,IAAI,MAAM,MAAM,MAAM,KAAK;AAAA,UACxD,OAAO;AACL,YAAAA,QAAO,KAAK,UAAU,KAAK,IAAI,MAAM,MAAM,MAAM,KAAK;AAAA,UACxD;AAAA,QAEF,WAAW,KAAK,GAAG,aAAa,MAAM;AACpC,UAAAA,QAAO,KAAK,iBAAiB,KAAK,GAAG,GAAG,KAAK,IAAI,KAAK;AAAA,QACxD,WAAW,OAAO,KAAK,GAAG,MAAM,UAAU;AAExC,gBAAM,OAAO,KAAK,YAAY,GAAG;AACjC,cAAI,MAAM;AACR,uBAAW,KAAK,iBAAiB,MAAM,KAAK,KAAK,GAAG,CAAC;AAAA,UACvD,OAAM;AAEJ,gBAAI,QAAQ,KAAK,QAAQ,cAAc;AACrC,kBAAI,SAAS,KAAK,QAAQ,kBAAkB,KAAK,KAAK,KAAK,GAAG,CAAC;AAC/D,cAAAA,QAAO,KAAK,qBAAqB,MAAM;AAAA,YACzC,OAAO;AACL,cAAAA,QAAO,KAAK,iBAAiB,KAAK,GAAG,GAAG,KAAK,IAAI,KAAK;AAAA,YACxD;AAAA,UACF;AAAA,QACF,WAAW,MAAM,QAAQ,KAAK,GAAG,CAAC,GAAG;AAEnC,gBAAM,SAAS,KAAK,GAAG,EAAE;AACzB,cAAI,aAAa;AACjB,cAAI,cAAc;AAClB,mBAASC,KAAI,GAAGA,KAAI,QAAQA,MAAK;AAC/B,kBAAM,OAAO,KAAK,GAAG,EAAEA,EAAC;AACxB,gBAAI,OAAO,SAAS,aAAa;AAAA,YAEjC,WAAW,SAAS,MAAM;AACxB,kBAAG,IAAI,CAAC,MAAM,IAAK,CAAAD,QAAO,KAAK,UAAU,KAAK,IAAI,MAAM,MAAM,MAAM,KAAK;AAAA,kBACpE,CAAAA,QAAO,KAAK,UAAU,KAAK,IAAI,MAAM,MAAM,MAAM,KAAK;AAAA,YAE7D,WAAW,OAAO,SAAS,UAAU;AACnC,kBAAG,KAAK,QAAQ,cAAa;AAC3B,sBAAM,SAAS,KAAK,IAAI,MAAM,QAAQ,CAAC;AACvC,8BAAc,OAAO;AACrB,oBAAI,KAAK,QAAQ,uBAAuB,KAAK,eAAe,KAAK,QAAQ,mBAAmB,GAAG;AAC7F,iCAAe,OAAO;AAAA,gBACxB;AAAA,cACF,OAAK;AACH,8BAAc,KAAK,qBAAqB,MAAM,KAAK,KAAK;AAAA,cAC1D;AAAA,YACF,OAAO;AACL,kBAAI,KAAK,QAAQ,cAAc;AAC7B,oBAAI,YAAY,KAAK,QAAQ,kBAAkB,KAAK,IAAI;AACxD,4BAAY,KAAK,qBAAqB,SAAS;AAC/C,8BAAc;AAAA,cAChB,OAAO;AACL,8BAAc,KAAK,iBAAiB,MAAM,KAAK,IAAI,KAAK;AAAA,cAC1D;AAAA,YACF;AAAA,UACF;AACA,cAAG,KAAK,QAAQ,cAAa;AAC3B,yBAAa,KAAK,gBAAgB,YAAY,KAAK,aAAa,KAAK;AAAA,UACvE;AACA,UAAAA,QAAO;AAAA,QACT,OAAO;AAEL,cAAI,KAAK,QAAQ,uBAAuB,QAAQ,KAAK,QAAQ,qBAAqB;AAChF,kBAAM,KAAK,OAAO,KAAK,KAAK,GAAG,CAAC;AAChC,kBAAM,IAAI,GAAG;AACb,qBAASC,KAAI,GAAGA,KAAI,GAAGA,MAAK;AAC1B,yBAAW,KAAK,iBAAiB,GAAGA,EAAC,GAAG,KAAK,KAAK,GAAG,EAAE,GAAGA,EAAC,CAAC,CAAC;AAAA,YAC/D;AAAA,UACF,OAAO;AACL,YAAAD,QAAO,KAAK,qBAAqB,KAAK,GAAG,GAAG,KAAK,KAAK;AAAA,UACxD;AAAA,QACF;AAAA,MACF;AACA,aAAO,EAAC,SAAkB,KAAKA,KAAG;AAAA,IACpC;AAEA,YAAQ,UAAU,mBAAmB,SAAS,UAAUA,MAAI;AAC1D,MAAAA,OAAM,KAAK,QAAQ,wBAAwB,UAAU,KAAKA,IAAG;AAC7D,MAAAA,OAAM,KAAK,qBAAqBA,IAAG;AACnC,UAAI,KAAK,QAAQ,6BAA6BA,SAAQ,QAAQ;AAC5D,eAAO,MAAM;AAAA,MACf,MAAO,QAAO,MAAM,WAAW,OAAOA,OAAM;AAAA,IAC9C;AAEA,aAAS,qBAAsB,QAAQ,KAAK,OAAO;AACjD,YAAM,SAAS,KAAK,IAAI,QAAQ,QAAQ,CAAC;AACzC,UAAI,OAAO,KAAK,QAAQ,YAAY,MAAM,UAAa,OAAO,KAAK,MAAM,EAAE,WAAW,GAAG;AACvF,eAAO,KAAK,iBAAiB,OAAO,KAAK,QAAQ,YAAY,GAAG,KAAK,OAAO,SAAS,KAAK;AAAA,MAC5F,OAAO;AACL,eAAO,KAAK,gBAAgB,OAAO,KAAK,KAAK,OAAO,SAAS,KAAK;AAAA,MACpE;AAAA,IACF;AAPS;AAST,YAAQ,UAAU,kBAAkB,SAASA,MAAK,KAAK,SAAS,OAAO;AACrE,UAAGA,SAAQ,IAAG;AACZ,YAAG,IAAI,CAAC,MAAM,IAAK,QAAQ,KAAK,UAAU,KAAK,IAAI,MAAM,MAAM,UAAS,MAAM,KAAK;AAAA,aAC9E;AACH,iBAAO,KAAK,UAAU,KAAK,IAAI,MAAM,MAAM,UAAU,KAAK,SAAS,GAAG,IAAI,KAAK;AAAA,QACjF;AAAA,MACF,OAAK;AAEH,YAAI,YAAY,OAAO,MAAM,KAAK;AAClC,YAAI,gBAAgB;AAEpB,YAAG,IAAI,CAAC,MAAM,KAAK;AACjB,0BAAgB;AAChB,sBAAY;AAAA,QACd;AAGA,aAAK,WAAW,YAAY,OAAOA,KAAI,QAAQ,GAAG,MAAM,IAAI;AAC1D,iBAAS,KAAK,UAAU,KAAK,IAAI,MAAO,MAAM,UAAU,gBAAgB,MAAMA,OAAM;AAAA,QACtF,WAAW,KAAK,QAAQ,oBAAoB,SAAS,QAAQ,KAAK,QAAQ,mBAAmB,cAAc,WAAW,GAAG;AACvH,iBAAO,KAAK,UAAU,KAAK,IAAI,OAAOA,IAAG,QAAQ,KAAK;AAAA,QACxD,OAAM;AACJ,iBACE,KAAK,UAAU,KAAK,IAAI,MAAM,MAAM,UAAU,gBAAgB,KAAK,aACnEA,OACA,KAAK,UAAU,KAAK,IAAI;AAAA,QAC5B;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,UAAU,WAAW,SAAS,KAAI;AACxC,UAAI,WAAW;AACf,UAAG,KAAK,QAAQ,aAAa,QAAQ,GAAG,MAAM,IAAG;AAC/C,YAAG,CAAC,KAAK,QAAQ,qBAAsB,YAAW;AAAA,MACpD,WAAS,KAAK,QAAQ,mBAAkB;AACtC,mBAAW;AAAA,MACb,OAAK;AACH,mBAAW,MAAM,GAAG;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AAcA,YAAQ,UAAU,mBAAmB,SAASA,MAAK,KAAK,SAAS,OAAO;AACtE,UAAI,KAAK,QAAQ,kBAAkB,SAAS,QAAQ,KAAK,QAAQ,eAAe;AAC9E,eAAO,KAAK,UAAU,KAAK,IAAI,YAAYA,IAAG,QAAS,KAAK;AAAA,MAC9D,WAAU,KAAK,QAAQ,oBAAoB,SAAS,QAAQ,KAAK,QAAQ,iBAAiB;AACxF,eAAO,KAAK,UAAU,KAAK,IAAI,OAAOA,IAAG,QAAS,KAAK;AAAA,MACzD,WAAS,IAAI,CAAC,MAAM,KAAK;AACvB,eAAQ,KAAK,UAAU,KAAK,IAAI,MAAM,MAAM,UAAS,MAAM,KAAK;AAAA,MAClE,OAAK;AACH,YAAI,YAAY,KAAK,QAAQ,kBAAkB,KAAKA,IAAG;AACvD,oBAAY,KAAK,qBAAqB,SAAS;AAE/C,YAAI,cAAc,IAAG;AACnB,iBAAO,KAAK,UAAU,KAAK,IAAI,MAAM,MAAM,UAAU,KAAK,SAAS,GAAG,IAAI,KAAK;AAAA,QACjF,OAAK;AACH,iBAAO,KAAK,UAAU,KAAK,IAAI,MAAM,MAAM,UAAU,MAClD,YACD,OAAO,MAAM,KAAK;AAAA,QACtB;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,UAAU,uBAAuB,SAAS,WAAU;AAC1D,UAAG,aAAa,UAAU,SAAS,KAAK,KAAK,QAAQ,iBAAgB;AACnE,iBAASE,KAAE,GAAGA,KAAE,KAAK,QAAQ,SAAS,QAAQA,MAAK;AACjD,gBAAM,SAAS,KAAK,QAAQ,SAASA,EAAC;AACtC,sBAAY,UAAU,QAAQ,OAAO,OAAO,OAAO,GAAG;AAAA,QACxD;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,aAAS,UAAU,OAAO;AACxB,aAAO,KAAK,QAAQ,SAAS,OAAO,KAAK;AAAA,IAC3C;AAFS;AAIT,aAAS,YAAY,MAAoB;AACvC,UAAI,KAAK,WAAW,KAAK,QAAQ,mBAAmB,KAAK,SAAS,KAAK,QAAQ,cAAc;AAC3F,eAAO,KAAK,OAAO,KAAK,aAAa;AAAA,MACvC,OAAO;AACL,eAAO;AAAA,MACT;AAAA,IACF;AANS;AAQT,WAAO,UAAU;AAAA;AAAA;;;ACxRjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAEA,QAAM,YAAY;AAClB,QAAMC,aAAY;AAClB,QAAM,aAAa;AAEnB,WAAO,UAAU;AAAA,MACf,WAAWA;AAAA,MACX,cAAc;AAAA,MACd;AAAA,IACF;AAAA;AAAA;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAAA,KAAC,SAASC,IAAEC,IAAE;AAAC,kBAAU,OAAO,WAAS,YAAU,OAAO,SAAO,OAAO,UAAQA,GAAE,IAAE,cAAY,OAAO,UAAQ,OAAO,MAAI,OAAO,CAAC,GAAEA,EAAC,IAAE,YAAU,OAAO,UAAQ,QAAQ,SAAOA,GAAE,IAAED,GAAE,SAAOC,GAAE;AAAA,IAAC,EAAE,SAAM,WAAU;AAAC,aAAO,SAASD,IAAE;AAAC,YAAIC,KAAE,CAAC;AAAE,iBAASC,GAAEC,IAAE;AAAC,cAAGF,GAAEE,EAAC,EAAE,QAAOF,GAAEE,EAAC,EAAE;AAAQ,cAAIC,KAAEH,GAAEE,EAAC,IAAE,EAAC,GAAEA,IAAE,GAAE,OAAG,SAAQ,CAAC,EAAC;AAAE,iBAAOH,GAAEG,EAAC,EAAE,KAAKC,GAAE,SAAQA,IAAEA,GAAE,SAAQF,EAAC,GAAEE,GAAE,IAAE,MAAGA,GAAE;AAAA,QAAO;AAA5H,eAAAF,IAAA;AAA6H,eAAOA,GAAE,IAAEF,IAAEE,GAAE,IAAED,IAAEC,GAAE,IAAE,SAASF,IAAEC,IAAEE,IAAE;AAAC,UAAAD,GAAE,EAAEF,IAAEC,EAAC,KAAG,OAAO,eAAeD,IAAEC,IAAE,EAAC,YAAW,MAAG,KAAIE,GAAC,CAAC;AAAA,QAAC,GAAED,GAAE,IAAE,SAASF,IAAE;AAAC,yBAAa,OAAO,UAAQ,OAAO,eAAa,OAAO,eAAeA,IAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,GAAE,OAAO,eAAeA,IAAE,cAAa,EAAC,OAAM,KAAE,CAAC;AAAA,QAAC,GAAEE,GAAE,IAAE,SAASF,IAAEC,IAAE;AAAC,cAAG,IAAEA,OAAID,KAAEE,GAAEF,EAAC,IAAG,IAAEC,GAAE,QAAOD;AAAE,cAAG,IAAEC,MAAG,YAAU,OAAOD,MAAGA,MAAGA,GAAE,WAAW,QAAOA;AAAE,cAAIG,KAAE,uBAAO,OAAO,IAAI;AAAE,cAAGD,GAAE,EAAEC,EAAC,GAAE,OAAO,eAAeA,IAAE,WAAU,EAAC,YAAW,MAAG,OAAMH,GAAC,CAAC,GAAE,IAAEC,MAAG,YAAU,OAAOD,GAAE,UAAQI,MAAKJ,GAAE,CAAAE,GAAE,EAAEC,IAAEC,IAAE,SAASH,IAAE;AAAC,mBAAOD,GAAEC,EAAC;AAAA,UAAC,EAAE,KAAK,MAAKG,EAAC,CAAC;AAAE,iBAAOD;AAAA,QAAC,GAAED,GAAE,IAAE,SAASF,IAAE;AAAC,cAAIC,KAAED,MAAGA,GAAE,aAAW,WAAU;AAAC,mBAAOA,GAAE;AAAA,UAAO,IAAE,WAAU;AAAC,mBAAOA;AAAA,UAAC;AAAE,iBAAOE,GAAE,EAAED,IAAE,KAAIA,EAAC,GAAEA;AAAA,QAAC,GAAEC,GAAE,IAAE,SAASF,IAAEC,IAAE;AAAC,iBAAO,OAAO,UAAU,eAAe,KAAKD,IAAEC,EAAC;AAAA,QAAC,GAAEC,GAAE,IAAE,IAAGA,GAAEA,GAAE,IAAE,EAAE;AAAA,MAAC,EAAE,EAAC,IAAG,SAASF,IAAEC,IAAEC,IAAE;AAAC;AAAa,QAAAD,GAAE,aAAW,MAAGA,GAAE,UAAQ;AAAO,YAAIE,KAAED,GAAE,EAAE,GAAEE,KAAE,WAAU;AAAC,mBAASJ,KAAG;AAAA,UAAC;AAAJ,iBAAAA,IAAA;AAAK,iBAAOA,GAAE,gBAAc,SAASA,IAAEC,IAAE;AAAC,gBAAIC,KAAED,GAAE,MAAMD,EAAC;AAAE,mBAAOE,MAAGA,GAAE,SAAO,KAAGA,GAAE,CAAC,KAAG;AAAA,UAAE,GAAEF,GAAE,iBAAe,SAASA,IAAEC,IAAE;AAAC,gBAAIC,KAAED,GAAE,MAAMD,EAAC;AAAE,mBAAOE,MAAGA,GAAE,SAAO,KAAGA,GAAE,CAAC,KAAG;AAAA,UAAE,GAAEF,GAAE,sBAAoB,SAASA,IAAEC,IAAEC,IAAE;AAAC,gBAAGF,GAAE,KAAKC,EAAC,EAAE,QAAOC;AAAA,UAAC,GAAEF,GAAE,wBAAsB,SAASA,IAAE;AAAC,oBAAOA,IAAE;AAAA,cAAC,KAAI;AAAK,uBAAM;AAAA,cAAK,KAAI;AAAK,uBAAM;AAAA,cAAK,KAAI;AAAS,uBAAM;AAAA,cAAO,KAAI;AAAS,uBAAM;AAAA,cAAK,KAAI;AAAS,uBAAM;AAAA,cAAO,KAAI;AAAS,uBAAM;AAAA,cAAQ,KAAI;AAAS,uBAAM;AAAA,cAAI,KAAI;AAAS,uBAAM;AAAA,cAAI,KAAI;AAAS,uBAAM;AAAA,cAAM,KAAI;AAAU,uBAAM;AAAA,cAAK;AAAQ;AAAA,YAAM;AAAA,UAAC,GAAEA,GAAE,sBAAoB,SAASA,IAAE;AAAC,gBAAIC,KAAED,GAAE,MAAM,GAAG,EAAE,OAAO,GAAE,CAAC,EAAE,IAAK,SAASA,IAAE;AAAC,qBAAO,SAASA,IAAE,EAAE,KAAG;AAAA,YAAC,CAAE;AAAE,gBAAGC,GAAE,KAAK,CAAC,GAAE,OAAKA,GAAE,CAAC,EAAE,SAAOA,GAAE,CAAC,GAAE;AAAA,cAAC,KAAK;AAAE,uBAAM;AAAA,cAAU,KAAK;AAAE,uBAAM;AAAA,cAAe,KAAK;AAAE,uBAAM;AAAA,cAAO,KAAK;AAAE,uBAAM;AAAA,cAAgB,KAAK;AAAE,uBAAM;AAAA,cAAY,KAAK;AAAG,uBAAM;AAAA,cAAW,KAAK;AAAG,uBAAM;AAAA,cAAa,KAAK;AAAG,uBAAM;AAAA,cAAS,KAAK;AAAG,uBAAM;AAAA,cAAc,KAAK;AAAG,uBAAM;AAAA,cAAS,KAAK;AAAG,uBAAM;AAAA,cAAW;AAAQ;AAAA,YAAM;AAAA,UAAC,GAAED,GAAE,wBAAsB,SAASA,IAAE;AAAC,gBAAIC,KAAED,GAAE,MAAM,GAAG,EAAE,OAAO,GAAE,CAAC,EAAE,IAAK,SAASA,IAAE;AAAC,qBAAO,SAASA,IAAE,EAAE,KAAG;AAAA,YAAC,CAAE;AAAE,gBAAGC,GAAE,KAAK,CAAC,GAAE,EAAE,MAAIA,GAAE,CAAC,KAAGA,GAAE,CAAC,IAAE,GAAG,QAAO,MAAIA,GAAE,CAAC,KAAGA,GAAE,CAAC,IAAE,IAAE,YAAU,MAAIA,GAAE,CAAC,KAAGA,GAAE,CAAC,KAAG,IAAE,UAAQ,MAAIA,GAAE,CAAC,KAAGA,GAAE,CAAC,IAAE,IAAE,WAAS,MAAIA,GAAE,CAAC,KAAG,MAAIA,GAAE,CAAC,IAAE,UAAQ,MAAIA,GAAE,CAAC,KAAGA,GAAE,CAAC,IAAE,IAAE,gBAAc,MAAIA,GAAE,CAAC,IAAE,cAAY,MAAIA,GAAE,CAAC,KAAGA,GAAE,CAAC,IAAE,IAAE,uBAAqB,MAAIA,GAAE,CAAC,KAAGA,GAAE,CAAC,IAAE,IAAE,eAAa,MAAIA,GAAE,CAAC,KAAGA,GAAE,CAAC,KAAG,IAAE,WAAS,MAAIA,GAAE,CAAC,IAAE,aAAW,MAAIA,GAAE,CAAC,IAAE,gBAAc,MAAIA,GAAE,CAAC,IAAE,WAAS,MAAIA,GAAE,CAAC,IAAE,SAAO,MAAIA,GAAE,CAAC,IAAE,QAAM;AAAA,UAAM,GAAED,GAAE,sBAAoB,SAASA,IAAE;AAAC,mBAAOA,GAAE,MAAM,GAAG,EAAE;AAAA,UAAM,GAAEA,GAAE,kBAAgB,SAASC,IAAEC,IAAEC,IAAE;AAAC,uBAASA,OAAIA,KAAE;AAAI,gBAAIC,KAAEJ,GAAE,oBAAoBC,EAAC,GAAEI,KAAEL,GAAE,oBAAoBE,EAAC,GAAEI,KAAE,KAAK,IAAIF,IAAEC,EAAC,GAAEE,KAAE,GAAEC,KAAER,GAAE,IAAI,CAACC,IAAEC,EAAC,GAAG,SAASD,IAAE;AAAC,kBAAIC,KAAEI,KAAEN,GAAE,oBAAoBC,EAAC,GAAEE,KAAEF,KAAE,IAAI,MAAMC,KAAE,CAAC,EAAE,KAAK,IAAI;AAAE,qBAAOF,GAAE,IAAIG,GAAE,MAAM,GAAG,GAAG,SAASH,IAAE;AAAC,uBAAO,IAAI,MAAM,KAAGA,GAAE,MAAM,EAAE,KAAK,GAAG,IAAEA;AAAA,cAAC,CAAE,EAAE,QAAQ;AAAA,YAAC,CAAE;AAAE,iBAAIG,OAAII,KAAED,KAAE,KAAK,IAAIF,IAAEC,EAAC,IAAGC,MAAG,GAAEA,MAAGC,MAAG;AAAC,kBAAGC,GAAE,CAAC,EAAEF,EAAC,IAAEE,GAAE,CAAC,EAAEF,EAAC,EAAE,QAAO;AAAE,kBAAGE,GAAE,CAAC,EAAEF,EAAC,MAAIE,GAAE,CAAC,EAAEF,EAAC,GAAE;AAAC,oBAAGA,OAAIC,GAAE,QAAO;AAAE,gBAAAD,MAAG;AAAA,cAAC,WAASE,GAAE,CAAC,EAAEF,EAAC,IAAEE,GAAE,CAAC,EAAEF,EAAC,EAAE,QAAM;AAAA,YAAE;AAAA,UAAC,GAAEN,GAAE,MAAI,SAASA,IAAEC,IAAE;AAAC,gBAAIC,IAAEC,KAAE,CAAC;AAAE,gBAAG,MAAM,UAAU,IAAI,QAAO,MAAM,UAAU,IAAI,KAAKH,IAAEC,EAAC;AAAE,iBAAIC,KAAE,GAAEA,KAAEF,GAAE,QAAOE,MAAG,EAAE,CAAAC,GAAE,KAAKF,GAAED,GAAEE,EAAC,CAAC,CAAC;AAAE,mBAAOC;AAAA,UAAC,GAAEH,GAAE,OAAK,SAASA,IAAEC,IAAE;AAAC,gBAAIC,IAAEC;AAAE,gBAAG,MAAM,UAAU,KAAK,QAAO,MAAM,UAAU,KAAK,KAAKH,IAAEC,EAAC;AAAE,iBAAIC,KAAE,GAAEC,KAAEH,GAAE,QAAOE,KAAEC,IAAED,MAAG,GAAE;AAAC,kBAAIE,KAAEJ,GAAEE,EAAC;AAAE,kBAAGD,GAAEG,IAAEF,EAAC,EAAE,QAAOE;AAAA,YAAC;AAAA,UAAC,GAAEJ,GAAE,SAAO,SAASA,IAAE;AAAC,qBAAQC,IAAEC,IAAEC,KAAEH,IAAEI,KAAE,UAAU,QAAOC,KAAE,IAAI,MAAMD,KAAE,IAAEA,KAAE,IAAE,CAAC,GAAEE,KAAE,GAAEA,KAAEF,IAAEE,KAAI,CAAAD,GAAEC,KAAE,CAAC,IAAE,UAAUA,EAAC;AAAE,gBAAG,OAAO,OAAO,QAAO,OAAO,OAAO,MAAM,QAAO,CAACN,EAAC,EAAE,OAAOK,EAAC,CAAC;AAAE,gBAAIE,KAAE,kCAAU;AAAC,kBAAIP,KAAEK,GAAEJ,EAAC;AAAE,0BAAU,OAAOD,MAAG,SAAOA,MAAG,OAAO,KAAKA,EAAC,EAAE,QAAS,SAASC,IAAE;AAAC,gBAAAE,GAAEF,EAAC,IAAED,GAAEC,EAAC;AAAA,cAAC,CAAE;AAAA,YAAC,GAApG;AAAsG,iBAAIA,KAAE,GAAEC,KAAEG,GAAE,QAAOJ,KAAEC,IAAED,MAAG,EAAE,CAAAM,GAAE;AAAE,mBAAOP;AAAA,UAAC,GAAEA,GAAE,kBAAgB,SAASA,IAAE;AAAC,mBAAOG,GAAE,oBAAoBH,EAAC;AAAA,UAAC,GAAEA,GAAE,wBAAsB,SAASA,IAAE;AAAC,mBAAOG,GAAE,YAAYH,EAAC,KAAG;AAAA,UAAE,GAAEA;AAAA,QAAC,EAAE;AAAE,QAAAC,GAAE,UAAQG,IAAEJ,GAAE,UAAQC,GAAE;AAAA,MAAO,GAAE,IAAG,SAASD,IAAEC,IAAEC,IAAE;AAAC;AAAa,QAAAD,GAAE,aAAW,MAAGA,GAAE,aAAWA,GAAE,SAAOA,GAAE,gBAAcA,GAAE,cAAYA,GAAE,sBAAoB;AAAO,QAAAA,GAAE,sBAAoB,EAAC,eAAc,eAAc,mBAAkB,WAAU,MAAK,QAAO,YAAW,cAAa,QAAO,UAAS,UAAS,YAAW,UAAS,YAAW,UAAS,YAAW,SAAQ,WAAU,OAAM,SAAQ,SAAQ,WAAU,iBAAgB,iBAAgB,WAAU,aAAY,qBAAoB,MAAK,YAAW,YAAW,SAAQ,WAAU,kBAAiB,QAAO,cAAa,MAAK,uBAAsB,SAAQ,OAAM,SAAQ,eAAc,eAAc,WAAU,aAAY,QAAO,UAAS,UAAS,YAAW,IAAG,MAAK,QAAO,UAAS,QAAO,UAAS,UAAS,YAAW,gCAA+B,oBAAmB,WAAU,aAAY,UAAS,YAAW,OAAM,SAAQ,OAAM,SAAQ,cAAa,MAAK,SAAQ,WAAU,iBAAgB,SAAQ,QAAO,UAAS,kBAAiB,UAAS,MAAK,OAAM;AAAE,QAAAA,GAAE,cAAY,EAAC,aAAY,eAAc,SAAQ,mBAAkB,MAAK,QAAO,YAAW,cAAa,QAAO,UAAS,UAAS,YAAW,UAAS,YAAW,UAAS,YAAW,SAAQ,WAAU,OAAM,SAAQ,SAAQ,WAAU,WAAU,aAAY,eAAc,iBAAgB,IAAG,qBAAoB,UAAS,YAAW,SAAQ,WAAU,MAAK,kBAAiB,IAAG,cAAa,OAAM,uBAAsB,OAAM,SAAQ,aAAY,eAAc,WAAU,aAAY,QAAO,UAAS,UAAS,YAAW,IAAG,cAAa,QAAO,mBAAkB,QAAO,UAAS,UAAS,YAAW,kBAAiB,gCAA+B,WAAU,aAAY,UAAS,YAAW,OAAM,SAAQ,OAAM,SAAQ,IAAG,cAAa,SAAQ,WAAU,OAAM,iBAAgB,QAAO,UAAS,QAAO,iBAAgB;AAAE,QAAAA,GAAE,gBAAc,EAAC,QAAO,UAAS,QAAO,UAAS,SAAQ,WAAU,IAAG,KAAI;AAAE,QAAAA,GAAE,SAAO,EAAC,cAAa,iBAAgB,SAAQ,WAAU,OAAM,SAAQ,KAAI,OAAM,SAAQ,WAAU,OAAM,SAAQ,YAAW,cAAa,MAAK,QAAO,OAAM,SAAQ,OAAM,SAAQ,UAAS,aAAY,cAAa,iBAAgB,MAAK,OAAM;AAAE,QAAAA,GAAE,aAAW,EAAC,UAAS,YAAW,OAAM,SAAQ,SAAQ,WAAU,QAAO,UAAS,OAAM,SAAQ,QAAO,SAAQ;AAAA,MAAC,GAAE,IAAG,SAASD,IAAEC,IAAEC,IAAE;AAAC;AAAa,QAAAD,GAAE,aAAW,MAAGA,GAAE,UAAQ;AAAO,YAAIE,IAAEC,MAAGD,KAAED,GAAE,EAAE,MAAIC,GAAE,aAAWA,KAAE,EAAC,SAAQA,GAAC,GAAEE,KAAEH,GAAE,EAAE;AAAE,iBAASI,GAAEN,IAAEC,IAAE;AAAC,mBAAQC,KAAE,GAAEA,KAAED,GAAE,QAAOC,MAAI;AAAC,gBAAIC,KAAEF,GAAEC,EAAC;AAAE,YAAAC,GAAE,aAAWA,GAAE,cAAY,OAAGA,GAAE,eAAa,MAAG,WAAUA,OAAIA,GAAE,WAAS,OAAI,OAAO,eAAeH,IAAEG,GAAE,KAAIA,EAAC;AAAA,UAAC;AAAA,QAAC;AAA5J,eAAAG,IAAA;AAA6J,YAAIC,KAAE,WAAU;AAAC,mBAASP,KAAG;AAAA,UAAC;AAAJ,iBAAAA,IAAA;AAAK,cAAIC,IAAEC,IAAEC;AAAE,iBAAOH,GAAE,YAAU,SAASA,IAAEC,IAAE;AAAC,gBAAG,WAASA,OAAIA,KAAE,QAAI,YAAU,OAAOD,GAAE,OAAM,IAAI,MAAM,8BAA8B;AAAE,mBAAO,IAAII,GAAE,QAAQJ,IAAEC,EAAC;AAAA,UAAC,GAAED,GAAE,QAAM,SAASA,IAAE;AAAC,mBAAO,IAAII,GAAE,QAAQJ,EAAC,EAAE,UAAU;AAAA,UAAC,GAAEC,KAAED,IAAEG,KAAE,CAAC,EAAC,KAAI,eAAc,KAAI,kCAAU;AAAC,mBAAOE,GAAE;AAAA,UAAW,GAA/B,OAAgC,GAAE,EAAC,KAAI,cAAa,KAAI,kCAAU;AAAC,mBAAOA,GAAE;AAAA,UAAU,GAA9B,OAA+B,GAAE,EAAC,KAAI,UAAS,KAAI,kCAAU;AAAC,mBAAOA,GAAE;AAAA,UAAM,GAA1B,OAA2B,GAAE,EAAC,KAAI,iBAAgB,KAAI,kCAAU;AAAC,mBAAOA,GAAE;AAAA,UAAa,GAAjC,OAAkC,CAAC,IAAGH,KAAE,SAAOI,GAAEL,GAAE,WAAUC,EAAC,GAAEC,MAAGG,GAAEL,IAAEE,EAAC,GAAEH;AAAA,QAAC,EAAE;AAAE,QAAAC,GAAE,UAAQM,IAAEP,GAAE,UAAQC,GAAE;AAAA,MAAO,GAAE,IAAG,SAASD,IAAEC,IAAEC,IAAE;AAAC;AAAa,QAAAD,GAAE,aAAW,MAAGA,GAAE,UAAQ;AAAO,YAAIE,KAAEK,GAAEN,GAAE,EAAE,CAAC,GAAEE,KAAEI,GAAEN,GAAE,EAAE,CAAC,GAAEG,KAAEG,GAAEN,GAAE,EAAE,CAAC,GAAEI,KAAEE,GAAEN,GAAE,EAAE,CAAC,GAAEK,KAAEC,GAAEN,GAAE,EAAE,CAAC;AAAE,iBAASM,GAAER,IAAE;AAAC,iBAAOA,MAAGA,GAAE,aAAWA,KAAE,EAAC,SAAQA,GAAC;AAAA,QAAC;AAAzC,eAAAQ,IAAA;AAA0C,YAAIC,KAAE,WAAU;AAAC,mBAAST,GAAEA,IAAEC,IAAE;AAAC,gBAAG,WAASA,OAAIA,KAAE,QAAI,QAAMD,MAAG,OAAKA,GAAE,OAAM,IAAI,MAAM,oCAAoC;AAAE,iBAAK,MAAIA,IAAE,KAAK,eAAa,CAAC,GAAE,SAAKC,MAAG,KAAK,MAAM;AAAA,UAAC;AAAvJ,iBAAAD,IAAA;AAAwJ,cAAIC,KAAED,GAAE;AAAU,iBAAOC,GAAE,QAAM,WAAU;AAAC,mBAAO,KAAK;AAAA,UAAG,GAAEA,GAAE,OAAK,SAASD,IAAE;AAAC,mBAAOA,GAAE,KAAK,KAAK,GAAG;AAAA,UAAC,GAAEC,GAAE,eAAa,WAAU;AAAC,gBAAID,KAAE;AAAK,iBAAK,aAAa,UAAQ,CAAC;AAAE,gBAAIC,KAAEM,GAAE,QAAQ,KAAKJ,GAAE,SAAS,SAASF,IAAE;AAAC,kBAAG,cAAY,OAAOA,GAAE,KAAK,QAAOA,GAAE,KAAKD,EAAC;AAAE,kBAAGC,GAAE,gBAAgB,MAAM,QAAOA,GAAE,KAAK,KAAM,SAASA,IAAE;AAAC,uBAAOD,GAAE,KAAKC,EAAC;AAAA,cAAC,CAAE;AAAE,oBAAM,IAAI,MAAM,sCAAsC;AAAA,YAAC,CAAE;AAAE,mBAAOA,OAAI,KAAK,aAAa,UAAQA,GAAE,SAAS,KAAK,MAAM,CAAC,IAAG,KAAK,aAAa;AAAA,UAAO,GAAEA,GAAE,aAAW,WAAU;AAAC,mBAAO,KAAK,aAAa,UAAQ,KAAK,aAAa,UAAQ,KAAK,aAAa;AAAA,UAAC,GAAEA,GAAE,iBAAe,SAASD,IAAE;AAAC,mBAAOA,KAAE,OAAO,KAAK,WAAW,EAAE,IAAI,EAAE,YAAY,KAAG,KAAG,KAAK,WAAW,EAAE,QAAM;AAAA,UAAE,GAAEC,GAAE,oBAAkB,WAAU;AAAC,mBAAO,KAAK,WAAW,EAAE;AAAA,UAAO,GAAEA,GAAE,QAAM,WAAU;AAAC,mBAAO,KAAK,aAAa,KAAG,KAAK,aAAa,KAAG,KAAK,QAAQ;AAAA,UAAC,GAAEA,GAAE,UAAQ,WAAU;AAAC,gBAAID,KAAE;AAAK,iBAAK,aAAa,KAAG,CAAC;AAAE,gBAAIC,KAAEM,GAAE,QAAQ,KAAKH,GAAE,SAAS,SAASH,IAAE;AAAC,kBAAG,cAAY,OAAOA,GAAE,KAAK,QAAOA,GAAE,KAAKD,EAAC;AAAE,kBAAGC,GAAE,gBAAgB,MAAM,QAAOA,GAAE,KAAK,KAAM,SAASA,IAAE;AAAC,uBAAOD,GAAE,KAAKC,EAAC;AAAA,cAAC,CAAE;AAAE,oBAAM,IAAI,MAAM,sCAAsC;AAAA,YAAC,CAAE;AAAE,mBAAOA,OAAI,KAAK,aAAa,KAAGA,GAAE,SAAS,KAAK,MAAM,CAAC,IAAG,KAAK,aAAa;AAAA,UAAE,GAAEA,GAAE,YAAU,SAASD,IAAE;AAAC,gBAAIC,KAAE,KAAK,MAAM,EAAE;AAAK,mBAAOD,KAAE,OAAOC,EAAC,EAAE,YAAY,KAAG,KAAGA,MAAG;AAAA,UAAE,GAAEA,GAAE,eAAa,WAAU;AAAC,mBAAO,KAAK,MAAM,EAAE;AAAA,UAAO,GAAEA,GAAE,cAAY,WAAU;AAAC,mBAAO,KAAK,aAAa,WAAS,KAAK,aAAa,WAAS,KAAK,cAAc;AAAA,UAAC,GAAEA,GAAE,kBAAgB,SAASD,IAAE;AAAC,uBAASA,OAAIA,KAAE;AAAI,gBAAIC,KAAE,KAAK,YAAY,EAAE;AAAK,mBAAOD,KAAE,OAAOC,EAAC,EAAE,YAAY,KAAG,KAAGA,MAAG;AAAA,UAAE,GAAEA,GAAE,gBAAc,WAAU;AAAC,gBAAID,KAAE;AAAK,iBAAK,aAAa,WAAS,CAAC;AAAE,gBAAIC,KAAEM,GAAE,QAAQ,KAAKF,GAAE,SAAS,SAASJ,IAAE;AAAC,kBAAG,cAAY,OAAOA,GAAE,KAAK,QAAOA,GAAE,KAAKD,EAAC;AAAE,kBAAGC,GAAE,gBAAgB,MAAM,QAAOA,GAAE,KAAK,KAAM,SAASA,IAAE;AAAC,uBAAOD,GAAE,KAAKC,EAAC;AAAA,cAAC,CAAE;AAAE,oBAAM,IAAI,MAAM,sCAAsC;AAAA,YAAC,CAAE;AAAE,mBAAOA,OAAI,KAAK,aAAa,WAASA,GAAE,SAAS,KAAK,MAAM,CAAC,IAAG,KAAK,aAAa;AAAA,UAAQ,GAAEA,GAAE,YAAU,WAAU;AAAC,mBAAO,KAAK,aAAa,SAAO,KAAK,aAAa,SAAO,KAAK,YAAY;AAAA,UAAC,GAAEA,GAAE,gBAAc,SAASD,IAAE;AAAC,mBAAOA,KAAE,OAAO,KAAK,UAAU,EAAE,IAAI,EAAE,YAAY,KAAG,KAAG,KAAK,UAAU,EAAE,QAAM;AAAA,UAAE,GAAEC,GAAE,cAAY,WAAU;AAAC,gBAAID,KAAE;AAAK,iBAAK,aAAa,SAAO,CAAC;AAAE,gBAAIC,KAAEM,GAAE,QAAQ,KAAKD,GAAE,SAAS,SAASL,IAAE;AAAC,kBAAG,cAAY,OAAOA,GAAE,KAAK,QAAOA,GAAE,KAAKD,EAAC;AAAE,kBAAGC,GAAE,gBAAgB,MAAM,QAAOA,GAAE,KAAK,KAAM,SAASA,IAAE;AAAC,uBAAOD,GAAE,KAAKC,EAAC;AAAA,cAAC,CAAE;AAAE,oBAAM,IAAI,MAAM,sCAAsC;AAAA,YAAC,CAAE;AAAE,mBAAOA,OAAI,KAAK,aAAa,SAAOA,GAAE,SAAS,KAAK,MAAM,CAAC,IAAG,KAAK,aAAa;AAAA,UAAM,GAAEA,GAAE,QAAM,WAAU;AAAC,mBAAO,KAAK,aAAa,GAAE,KAAK,QAAQ,GAAE,KAAK,cAAc,GAAE,KAAK,YAAY,GAAE;AAAA,UAAI,GAAEA,GAAE,YAAU,WAAU;AAAC,mBAAOM,GAAE,QAAQ,OAAO,CAAC,GAAE,KAAK,YAAY;AAAA,UAAC,GAAEN,GAAE,YAAU,SAASD,IAAE;AAAC,gBAAIC,KAAE,MAAKC,KAAE,CAAC,GAAEC,KAAE,GAAEC,KAAE,CAAC,GAAEC,KAAE;AAAE,gBAAG,OAAO,KAAKL,EAAC,EAAE,QAAS,SAASC,IAAE;AAAC,kBAAIK,KAAEN,GAAEC,EAAC;AAAE,0BAAU,OAAOK,MAAGF,GAAEH,EAAC,IAAEK,IAAED,MAAG,KAAG,YAAU,OAAOC,OAAIJ,GAAED,EAAC,IAAEK,IAAEH,MAAG;AAAA,YAAE,CAAE,GAAEA,KAAE,GAAE;AAAC,kBAAIG,KAAE,OAAO,KAAKJ,EAAC,GAAEM,KAAED,GAAE,QAAQ,KAAKD,IAAG,SAASN,IAAE;AAAC,uBAAOC,GAAE,KAAKD,EAAC;AAAA,cAAC,CAAE;AAAE,kBAAGQ,IAAE;AAAC,oBAAIC,KAAE,KAAK,UAAUP,GAAEM,EAAC,CAAC;AAAE,oBAAG,WAASC,GAAE,QAAOA;AAAA,cAAC;AAAC,kBAAIC,KAAEH,GAAE,QAAQ,KAAKD,IAAG,SAASN,IAAE;AAAC,uBAAOC,GAAE,WAAWD,EAAC;AAAA,cAAC,CAAE;AAAE,kBAAGU,IAAE;AAAC,oBAAIC,KAAE,KAAK,UAAUT,GAAEQ,EAAC,CAAC;AAAE,oBAAG,WAASC,GAAE,QAAOA;AAAA,cAAC;AAAA,YAAC;AAAC,gBAAGN,KAAE,GAAE;AAAC,kBAAIO,KAAE,OAAO,KAAKR,EAAC,GAAES,KAAEN,GAAE,QAAQ,KAAKK,IAAG,SAASZ,IAAE;AAAC,uBAAOC,GAAE,UAAUD,IAAE,IAAE;AAAA,cAAC,CAAE;AAAE,kBAAG,WAASa,GAAE,QAAO,KAAK,eAAeT,GAAES,EAAC,CAAC;AAAA,YAAC;AAAA,UAAC,GAAEZ,GAAE,YAAU,SAASD,IAAEC,IAAE;AAAC,uBAASA,OAAIA,KAAE;AAAI,gBAAIC,KAAE,KAAK,eAAe,EAAE,YAAY,GAAEC,KAAEH,GAAE,YAAY,GAAEI,KAAEG,GAAE,QAAQ,sBAAsBJ,EAAC;AAAE,mBAAOF,MAAGG,OAAID,KAAEC,GAAE,YAAY,IAAGD,OAAID;AAAA,UAAC,GAAED,GAAE,iBAAe,SAASD,IAAE;AAAC,gBAAIC,KAAE,CAAC,CAAC,GAAEC,KAAEF,IAAEG,KAAE,OAAGC,KAAE,KAAK,kBAAkB;AAAE,gBAAG,YAAU,OAAOA,GAAE,QAAM,QAAMJ,GAAE,CAAC,KAAG,QAAMA,GAAE,CAAC,KAAGE,KAAEF,GAAE,OAAO,CAAC,GAAE,QAAMA,GAAE,CAAC,KAAGG,KAAE,MAAGD,KAAEF,GAAE,OAAO,CAAC,KAAGC,KAAE,CAAC,GAAE,QAAMD,GAAE,CAAC,IAAEC,GAAE,KAAK,CAAC,IAAEA,GAAE,KAAK,EAAE,KAAG,QAAMD,GAAE,CAAC,IAAEE,KAAEF,GAAE,OAAO,CAAC,IAAE,QAAMA,GAAE,CAAC,MAAIG,KAAE,MAAGD,KAAEF,GAAE,OAAO,CAAC,IAAGC,GAAE,QAAQM,GAAE,QAAQ,gBAAgBH,IAAEF,IAAEC,EAAC,CAAC,IAAE;AAAA,UAAE,GAAEF,GAAE,OAAK,SAASD,IAAE;AAAC,mBAAO,KAAK,UAAU,IAAE,MAAI,OAAOA,EAAC,EAAE,YAAY;AAAA,UAAC,GAAEC,GAAE,aAAW,SAASD,IAAE;AAAC,mBAAO,KAAK,gBAAgB,IAAE,MAAI,OAAOA,EAAC,EAAE,YAAY;AAAA,UAAC,GAAEC,GAAE,WAAS,SAASD,IAAE;AAAC,mBAAO,KAAK,cAAc,IAAE,MAAI,OAAOA,EAAC,EAAE,YAAY;AAAA,UAAC,GAAEC,GAAE,KAAG,SAASD,IAAEC,IAAE;AAAC,mBAAO,WAASA,OAAIA,KAAE,QAAI,KAAK,UAAUD,IAAEC,EAAC,KAAG,KAAK,KAAKD,EAAC,KAAG,KAAK,WAAWA,EAAC;AAAA,UAAC,GAAEC,GAAE,OAAK,SAASD,IAAE;AAAC,gBAAIC,KAAE;AAAK,mBAAO,WAASD,OAAIA,KAAE,CAAC,IAAGA,GAAE,KAAM,SAASA,IAAE;AAAC,qBAAOC,GAAE,GAAGD,EAAC;AAAA,YAAC,CAAE;AAAA,UAAC,GAAEA;AAAA,QAAC,EAAE;AAAE,QAAAC,GAAE,UAAQQ,IAAET,GAAE,UAAQC,GAAE;AAAA,MAAO,GAAE,IAAG,SAASD,IAAEC,IAAEC,IAAE;AAAC;AAAa,QAAAD,GAAE,aAAW,MAAGA,GAAE,UAAQ;AAAO,YAAIE,IAAEC,MAAGD,KAAED,GAAE,EAAE,MAAIC,GAAE,aAAWA,KAAE,EAAC,SAAQA,GAAC;AAAE,YAAIE,KAAE,8BAA6BC,KAAE,CAAC,EAAC,MAAK,CAAC,YAAY,GAAE,UAAS,gCAASN,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,YAAW,GAAEC,KAAEE,GAAE,QAAQ,cAAc,4BAA2BJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAApJ,YAAqJ,GAAE,EAAC,MAAK,CAAC,QAAQ,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,QAAO,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,mCAAkCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAvJ,YAAwJ,GAAE,EAAC,MAAK,CAAC,cAAc,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,QAAO,GAAEC,KAAEE,GAAE,QAAQ,cAAc,4BAA2BJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAhJ,YAAiJ,GAAE,EAAC,MAAK,CAAC,iBAAiB,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,+BAA8B,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,4CAA2CJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAvL,YAAwL,GAAE,EAAC,MAAK,CAAC,QAAQ,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,sBAAqB,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,kCAAiCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAApK,YAAqK,GAAE,EAAC,MAAK,CAAC,YAAY,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,aAAY,GAAEC,KAAEE,GAAE,QAAQ,cAAc,sCAAqCJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA/J,YAAgK,GAAE,EAAC,MAAK,CAAC,QAAQ,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,QAAO,GAAEC,KAAEE,GAAE,QAAQ,cAAc,kCAAiCJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAtJ,YAAuJ,GAAE,EAAC,MAAK,CAAC,QAAQ,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,QAAO,GAAEC,KAAEE,GAAE,QAAQ,cAAc,kCAAiCJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAtJ,YAAuJ,GAAE,EAAC,MAAK,CAAC,QAAQ,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,cAAa,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,mCAAkCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA7J,YAA8J,GAAE,EAAC,MAAK,CAAC,uBAAuB,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,cAAa,GAAEC,KAAEE,GAAE,QAAQ,cAAc,iCAAgCJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA3J,YAA4J,GAAE,EAAC,MAAK,CAAC,YAAY,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,iBAAgB,GAAEC,KAAEE,GAAE,QAAQ,cAAc,uCAAsCJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAApK,YAAqK,GAAE,EAAC,MAAK,CAAC,YAAY,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,aAAY,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,uCAAsCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAhK,YAAiK,GAAE,EAAC,MAAK,CAAC,gBAAgB,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,UAAS,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,2CAA0CJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAjK,YAAkK,GAAE,EAAC,MAAK,CAAC,WAAW,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,WAAU,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,sCAAqCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA7J,YAA8J,GAAE,EAAC,MAAK,CAAC,SAAS,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,SAAQ,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,oCAAmCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAzJ,YAA0J,GAAE,EAAC,MAAK,CAAC,WAAW,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,WAAU,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,sCAAqCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA7J,YAA8J,GAAE,EAAC,MAAK,CAAC,WAAW,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,WAAU,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,sCAAqCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA7J,YAA8J,GAAE,EAAC,MAAK,CAAC,iBAAiB,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,SAAQ,GAAEC,KAAEE,GAAE,QAAQ,cAAc,4CAA2CJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAjK,YAAkK,GAAE,EAAC,MAAK,CAAC,YAAY,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,iBAAiB,KAAKD,EAAC,IAAE,oBAAkB,aAAY,GAAEE,KAAEE,GAAE,QAAQ,cAAc,mDAAkDJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAvN,YAAwN,GAAE,EAAC,MAAK,CAAC,eAAe,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,oBAAmB,GAAEC,KAAEE,GAAE,QAAQ,cAAc,kCAAiCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAApI,YAAqI,GAAE,EAAC,MAAK,CAAC,UAAU,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,iBAAgB,GAAEC,KAAEE,GAAE,QAAQ,cAAc,4BAA2BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA3H,YAA4H,GAAE,EAAC,MAAK,CAAC,gBAAgB,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,iBAAgB,GAAEC,KAAEE,GAAE,QAAQ,eAAe,oCAAmCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAApI,YAAqI,GAAE,EAAC,MAAK,CAAC,UAAU,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,UAAS,GAAEC,KAAEE,GAAE,QAAQ,cAAc,8BAA6BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAtH,YAAuH,GAAE,EAAC,MAAK,CAAC,YAAY,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,YAAW,GAAEC,KAAEE,GAAE,QAAQ,cAAc,gCAA+BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA1H,YAA2H,GAAE,EAAC,MAAK,CAAC,WAAW,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,WAAU,GAAEC,KAAEE,GAAE,QAAQ,cAAc,sCAAqCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA/H,YAAgI,GAAE,EAAC,MAAK,CAAC,OAAO,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,cAAa,GAAEC,KAAEE,GAAE,QAAQ,cAAc,2BAA0BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAvH,YAAwH,GAAE,EAAC,MAAK,CAAC,UAAU,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,YAAW,GAAEC,KAAEE,GAAE,QAAQ,cAAc,gCAA+BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA1H,YAA2H,GAAE,EAAC,MAAK,CAAC,WAAW,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,WAAU,GAAEC,KAAEE,GAAE,QAAQ,cAAc,+BAA8BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAxH,YAAyH,GAAE,EAAC,MAAK,CAAC,uBAAsB,cAAc,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,aAAY,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,sCAAqCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA/J,YAAgK,GAAE,EAAC,MAAK,CAAC,iBAAiB,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,gBAAe,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC,KAAGI,GAAE,QAAQ,cAAc,2CAA0CJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAvK,YAAwK,GAAE,EAAC,MAAK,CAAC,OAAO,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,OAAM,GAAEC,KAAEE,GAAE,QAAQ,cAAc,6BAA4BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAlH,YAAmH,GAAE,EAAC,MAAK,CAAC,QAAQ,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,QAAO,GAAEC,KAAEE,GAAE,QAAQ,cAAc,2CAA0CJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA/J,YAAgK,GAAE,EAAC,MAAK,CAAC,WAAW,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,WAAU,GAAEC,KAAEE,GAAE,QAAQ,cAAc,sCAAqCJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA7J,YAA8J,GAAE,EAAC,MAAK,CAAC,0BAA0B,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,UAAS,GAAEC,KAAEE,GAAE,QAAQ,cAAc,qDAAoDJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA7I,YAA8I,GAAE,EAAC,MAAK,CAAC,WAAW,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,WAAU,GAAEC,KAAEE,GAAE,QAAQ,cAAc,mCAAkCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA5H,YAA6H,GAAE,EAAC,MAAK,CAAC,cAAc,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,OAAM,GAAEC,KAAEE,GAAE,QAAQ,cAAc,yCAAwCJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA9H,YAA+H,GAAE,EAAC,MAAK,CAAC,WAAW,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,WAAU,GAAEC,KAAEE,GAAE,QAAQ,cAAc,sCAAqCJ,EAAC,KAAGI,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA7J,YAA8J,GAAE,EAAC,MAAK,CAAC,oBAAoB,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,SAAQ,GAAEC,KAAEE,GAAE,QAAQ,cAAc,4CAA2CJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAnI,YAAoI,GAAE,EAAC,MAAK,CAAC,MAAM,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,gBAAe,GAAEC,KAAEE,GAAE,QAAQ,cAAc,8BAA6BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA5H,YAA6H,GAAE,EAAC,MAAK,gCAASD,IAAE;AAAC,cAAIC,KAAE,CAACD,GAAE,KAAK,eAAe,GAAEE,KAAEF,GAAE,KAAK,UAAU;AAAE,iBAAOC,MAAGC;AAAA,QAAC,GAA3E,SAA6E,UAAS,gCAASF,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,kBAAiB,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAnG,YAAoG,GAAE,EAAC,MAAK,CAAC,gBAAgB,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,gBAAe,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAjG,YAAkG,GAAE,EAAC,MAAK,CAAC,qBAAqB,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAK,SAAQ,GAAEC,KAAEE,GAAE,QAAQ,cAAcC,IAAEL,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA1F,YAA2F,GAAE,EAAC,MAAK,CAAC,KAAK,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,OAAKD,GAAE,OAAO,KAAK,IAAE,2BAAyB;AAAe,iBAAM,EAAC,MAAKI,GAAE,QAAQ,cAAcH,IAAED,EAAC,GAAE,SAAQI,GAAE,QAAQ,eAAeH,IAAED,EAAC,EAAC;AAAA,QAAC,GAA9J,YAA+J,CAAC;AAAE,QAAAC,GAAE,UAAQK,IAAEN,GAAE,UAAQC,GAAE;AAAA,MAAO,GAAE,IAAG,SAASD,IAAEC,IAAEC,IAAE;AAAC;AAAa,QAAAD,GAAE,aAAW,MAAGA,GAAE,UAAQ;AAAO,YAAIE,IAAEC,MAAGD,KAAED,GAAE,EAAE,MAAIC,GAAE,aAAWA,KAAE,EAAC,SAAQA,GAAC,GAAEE,KAAEH,GAAE,EAAE;AAAE,YAAII,KAAE,CAAC,EAAC,MAAK,CAAC,WAAW,GAAE,UAAS,gCAASN,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,yBAAwBJ,EAAC;AAAE,iBAAM,EAAC,MAAKK,GAAE,OAAO,MAAK,SAAQJ,GAAC;AAAA,QAAC,GAAzG,YAA0G,GAAE,EAAC,MAAK,CAAC,gBAAgB,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,0CAAyCJ,EAAC;AAAE,iBAAM,EAAC,MAAKK,GAAE,OAAO,cAAa,SAAQJ,GAAC;AAAA,QAAC,GAAlI,YAAmI,GAAE,EAAC,MAAK,CAAC,WAAW,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,kCAAiCJ,EAAC,GAAEE,KAAEE,GAAE,QAAQ,sBAAsBH,EAAC;AAAE,iBAAM,EAAC,MAAKI,GAAE,OAAO,SAAQ,SAAQJ,IAAE,aAAYC,GAAC;AAAA,QAAC,GAAxK,YAAyK,GAAE,EAAC,MAAK,CAAC,6BAA6B,GAAE,UAAS,gCAASF,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAKI,GAAE,OAAO,IAAG,GAAEH,KAAEE,GAAE,QAAQ,eAAe,yBAAwBJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAArH,YAAsH,GAAE,EAAC,MAAK,CAAC,YAAY,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,8BAA6BJ,EAAC,EAAE,QAAQ,UAAS,GAAG,GAAEE,KAAEE,GAAE,QAAQ,oBAAoBH,EAAC,GAAEE,KAAE,EAAC,MAAKE,GAAE,OAAO,OAAM,SAAQJ,GAAC;AAAE,iBAAOC,OAAIC,GAAE,cAAYD,KAAGC;AAAA,QAAC,GAAlM,YAAmM,GAAE,EAAC,MAAK,CAAC,qBAAqB,GAAE,UAAS,gCAASH,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,sCAAqCJ,EAAC,EAAE,QAAQ,UAAS,GAAG;AAAE,iBAAM,EAAC,MAAKK,GAAE,OAAO,KAAI,SAAQJ,GAAC;AAAA,QAAC,GAA3I,YAA4I,GAAE,EAAC,MAAK,gCAASD,IAAE;AAAC,cAAIC,KAAE,CAACD,GAAE,KAAK,eAAe,GAAEE,KAAEF,GAAE,KAAK,UAAU;AAAE,iBAAOC,MAAGC;AAAA,QAAC,GAA3E,SAA6E,UAAS,gCAASF,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,+BAA8BJ,EAAC,GAAEE,KAAEE,GAAE,QAAQ,sBAAsBH,EAAC,GAAEE,KAAE,EAAC,MAAKE,GAAE,OAAO,SAAQ,SAAQJ,GAAC;AAAE,iBAAOC,OAAIC,GAAE,cAAYD,KAAGC;AAAA,QAAC,GAAjL,YAAkL,GAAE,EAAC,MAAK,CAAC,iBAAiB,GAAE,UAAS,gCAASH,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,oCAAmCJ,EAAC,GAAEE,KAAE,EAAC,MAAKG,GAAE,OAAO,MAAK;AAAE,iBAAOJ,MAAGA,GAAE,WAASC,GAAE,UAAQD,KAAGC;AAAA,QAAC,GAA3I,YAA4I,GAAE,EAAC,MAAK,CAAC,uBAAsB,cAAc,GAAE,UAAS,gCAASF,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,mCAAkCJ,EAAC,KAAGI,GAAE,QAAQ,cAAc,oCAAmCJ,EAAC,KAAGI,GAAE,QAAQ,cAAc,cAAaJ,EAAC;AAAE,iBAAM,EAAC,MAAKK,GAAE,OAAO,YAAW,SAAQJ,GAAC;AAAA,QAAC,GAAjO,YAAkO,GAAE,EAAC,MAAK,CAAC,OAAO,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,wBAAuBJ,EAAC;AAAE,iBAAM,EAAC,MAAKK,GAAE,OAAO,MAAK,SAAQJ,GAAC;AAAA,QAAC,GAAxG,YAAyG,GAAE,EAAC,MAAK,CAAC,QAAQ,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,4BAA2BJ,EAAC;AAAE,iBAAM,EAAC,MAAKK,GAAE,OAAO,OAAM,SAAQJ,GAAC;AAAA,QAAC,GAA7G,YAA8G,GAAE,EAAC,MAAK,CAAC,QAAQ,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKI,GAAE,OAAO,MAAK;AAAA,QAAC,GAAtC,YAAuC,GAAE,EAAC,MAAK,CAAC,MAAM,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKA,GAAE,OAAO,SAAQ;AAAA,QAAC,GAAzC,YAA0C,GAAE,EAAC,MAAK,CAAC,eAAe,GAAE,UAAS,gCAASL,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,oCAAmCJ,EAAC;AAAE,iBAAM,EAAC,MAAKK,GAAE,OAAO,cAAa,SAAQJ,GAAC;AAAA,QAAC,GAA5H,YAA6H,CAAC;AAAE,QAAAA,GAAE,UAAQK,IAAEN,GAAE,UAAQC,GAAE;AAAA,MAAO,GAAE,IAAG,SAASD,IAAEC,IAAEC,IAAE;AAAC;AAAa,QAAAD,GAAE,aAAW,MAAGA,GAAE,UAAQ;AAAO,YAAIE,IAAEC,MAAGD,KAAED,GAAE,EAAE,MAAIC,GAAE,aAAWA,KAAE,EAAC,SAAQA,GAAC,GAAEE,KAAEH,GAAE,EAAE;AAAE,YAAII,KAAE,CAAC,EAAC,MAAK,CAAC,YAAY,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAK,OAAM,QAAO,SAAQ;AAAA,QAAC,GAA7C,YAA8C,GAAE,EAAC,MAAK,CAAC,SAAS,GAAE,UAAS,gCAASN,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,cAAaJ,EAAC,KAAG,QAAOE,KAAE,EAAC,MAAKG,GAAE,cAAc,QAAO,QAAO,SAAQ;AAAE,iBAAOJ,OAAIC,GAAE,QAAMD,KAAGC;AAAA,QAAC,GAAzI,YAA0I,GAAE,EAAC,MAAK,CAAC,yBAAyB,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKG,GAAE,cAAc,QAAO,QAAO,QAAO;AAAA,QAAC,GAA7D,YAA8D,GAAE,EAAC,MAAK,CAAC,OAAO,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKA,GAAE,cAAc,QAAO,QAAO,SAAQ,OAAM,OAAM;AAAA,QAAC,GAA1E,YAA2E,GAAE,EAAC,MAAK,CAAC,6BAA6B,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKA,GAAE,cAAc,QAAO,QAAO,SAAQ,OAAM,OAAM;AAAA,QAAC,GAA1E,YAA2E,GAAE,EAAC,MAAK,CAAC,aAAa,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKA,GAAE,cAAc,QAAO,QAAO,UAAS,OAAM,mBAAkB;AAAA,QAAC,GAAvF,YAAwF,GAAE,EAAC,MAAK,CAAC,OAAO,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKA,GAAE,cAAc,QAAO,QAAO,SAAQ;AAAA,QAAC,GAA9D,YAA+D,GAAE,EAAC,MAAK,CAAC,gBAAgB,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKA,GAAE,cAAc,OAAM;AAAA,QAAC,GAA9C,YAA+C,GAAE,EAAC,MAAK,gCAASL,IAAE;AAAC,cAAIC,KAAED,GAAE,KAAK,cAAc,GAAEE,KAAEF,GAAE,KAAK,qBAAqB;AAAE,iBAAOC,MAAG,CAACC;AAAA,QAAC,GAArF,SAAuF,UAAS,gCAASF,IAAE;AAAC,cAAIC,KAAEG,GAAE,QAAQ,cAAc,kBAAiBJ,EAAC;AAAE,iBAAM,EAAC,MAAKK,GAAE,cAAc,QAAO,QAAO,SAAQ,OAAMJ,GAAC;AAAA,QAAC,GAAxH,YAAyH,GAAE,EAAC,MAAK,CAAC,oBAAmB,eAAe,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKI,GAAE,cAAc,QAAO,QAAO,QAAO;AAAA,QAAC,GAA7D,YAA8D,GAAE,EAAC,MAAK,CAAC,WAAW,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKA,GAAE,cAAc,OAAM;AAAA,QAAC,GAA9C,YAA+C,GAAE,EAAC,MAAK,gCAASL,IAAE;AAAC,iBAAM,iBAAeA,GAAE,eAAe,IAAE;AAAA,QAAC,GAArD,SAAuD,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKK,GAAE,cAAc,QAAO,QAAO,aAAY;AAAA,QAAC,GAAlE,YAAmE,GAAE,EAAC,MAAK,gCAASL,IAAE;AAAC,iBAAM,WAASA,GAAE,eAAe,IAAE;AAAA,QAAC,GAA/C,SAAiD,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKK,GAAE,cAAc,OAAM;AAAA,QAAC,GAA9C,YAA+C,GAAE,EAAC,MAAK,gCAASL,IAAE;AAAC,iBAAM,oBAAkBA,GAAE,eAAe;AAAA,QAAC,GAAtD,SAAwD,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKK,GAAE,cAAc,QAAO,QAAO,YAAW;AAAA,QAAC,GAAjE,YAAkE,GAAE,EAAC,MAAK,gCAASL,IAAE;AAAC,cAAIC,KAAE,OAAO,OAAOD,GAAE,aAAa,CAAC,EAAE,MAAM,GAAG,EAAE,CAAC,CAAC;AAAE,iBAAM,cAAYA,GAAE,UAAU,IAAE,KAAGC,MAAG;AAAA,QAAC,GAAxG,SAA0G,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKI,GAAE,cAAc,OAAM;AAAA,QAAC,GAA9C,YAA+C,GAAE,EAAC,MAAK,gCAASL,IAAE;AAAC,iBAAM,cAAYA,GAAE,UAAU,IAAE;AAAA,QAAC,GAA7C,SAA+C,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKK,GAAE,cAAc,OAAM;AAAA,QAAC,GAA9C,YAA+C,GAAE,EAAC,MAAK,gCAASL,IAAE;AAAC,iBAAM,YAAUA,GAAE,UAAU,IAAE;AAAA,QAAC,GAA3C,SAA6C,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKK,GAAE,cAAc,SAAQ,QAAO,QAAO;AAAA,QAAC,GAA9D,YAA+D,GAAE,EAAC,MAAK,gCAASL,IAAE;AAAC,iBAAM,cAAYA,GAAE,UAAU,IAAE;AAAA,QAAC,GAA7C,SAA+C,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKK,GAAE,cAAc,QAAO;AAAA,QAAC,GAA/C,YAAgD,GAAE,EAAC,MAAK,gCAASL,IAAE;AAAC,iBAAM,YAAUA,GAAE,UAAU,IAAE;AAAA,QAAC,GAA3C,SAA6C,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKK,GAAE,cAAc,QAAO;AAAA,QAAC,GAA/C,YAAgD,GAAE,EAAC,MAAK,gCAASL,IAAE;AAAC,iBAAM,oBAAkBA,GAAE,UAAU,IAAE;AAAA,QAAC,GAAnD,SAAqD,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKK,GAAE,cAAc,GAAE;AAAA,QAAC,GAA1C,YAA2C,GAAE,EAAC,MAAK,gCAASL,IAAE;AAAC,iBAAM,WAASA,GAAE,UAAU,IAAE;AAAA,QAAC,GAA1C,SAA4C,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKK,GAAE,cAAc,GAAE;AAAA,QAAC,GAA1C,YAA2C,CAAC;AAAE,QAAAJ,GAAE,UAAQK,IAAEN,GAAE,UAAQC,GAAE;AAAA,MAAO,GAAE,IAAG,SAASD,IAAEC,IAAEC,IAAE;AAAC;AAAa,QAAAD,GAAE,aAAW,MAAGA,GAAE,UAAQ;AAAO,YAAIE,IAAEC,MAAGD,KAAED,GAAE,EAAE,MAAIC,GAAE,aAAWA,KAAE,EAAC,SAAQA,GAAC,GAAEE,KAAEH,GAAE,EAAE;AAAE,YAAII,KAAE,CAAC,EAAC,MAAK,gCAASN,IAAE;AAAC,iBAAM,qBAAmBA,GAAE,eAAe,IAAE;AAAA,QAAC,GAAzD,SAA2D,UAAS,gCAASA,IAAE;AAAC,cAAG,WAAW,KAAKA,EAAC,EAAE,QAAM,EAAC,MAAKK,GAAE,WAAW,MAAK;AAAE,cAAIJ,KAAEG,GAAE,QAAQ,cAAc,2BAA0BJ,EAAC;AAAE,iBAAM,EAAC,MAAKK,GAAE,WAAW,UAAS,SAAQJ,GAAC;AAAA,QAAC,GAAzK,YAA0K,GAAE,EAAC,MAAK,CAAC,UAAU,GAAE,UAAS,gCAASD,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAKI,GAAE,WAAW,QAAO,GAAEH,KAAEE,GAAE,QAAQ,cAAc,8BAA6BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAAjI,YAAkI,GAAE,EAAC,MAAK,gCAASD,IAAE;AAAC,iBAAOA,GAAE,KAAK,SAAS;AAAA,QAAC,GAApC,SAAsC,UAAS,gCAASA,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAKI,GAAE,WAAW,OAAM,GAAEH,KAAEE,GAAE,QAAQ,cAAc,6BAA4BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA/H,YAAgI,GAAE,EAAC,MAAK,gCAASD,IAAE;AAAC,cAAIC,KAAED,GAAE,KAAK,QAAQ,GAAEE,KAAEF,GAAE,KAAK,aAAa;AAAE,iBAAOC,MAAG,CAACC;AAAA,QAAC,GAAvE,SAAyE,UAAS,gCAASF,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAKI,GAAE,WAAW,MAAK,GAAEH,KAAEE,GAAE,QAAQ,cAAc,4BAA2BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA7H,YAA8H,GAAE,EAAC,MAAK,CAAC,0BAA0B,GAAE,UAAS,kCAAU;AAAC,iBAAM,EAAC,MAAKI,GAAE,WAAW,MAAK;AAAA,QAAC,GAA1C,YAA2C,GAAE,EAAC,MAAK,CAAC,iBAAiB,GAAE,UAAS,gCAASL,IAAE;AAAC,cAAIC,KAAE,EAAC,MAAKI,GAAE,WAAW,OAAM,GAAEH,KAAEE,GAAE,QAAQ,cAAc,6BAA4BJ,EAAC;AAAE,iBAAOE,OAAID,GAAE,UAAQC,KAAGD;AAAA,QAAC,GAA/H,YAAgI,CAAC;AAAE,QAAAA,GAAE,UAAQK,IAAEN,GAAE,UAAQC,GAAE;AAAA,MAAO,EAAC,CAAC;AAAA,IAAC,CAAE;AAAA;AAAA;;;ACA14yB;AAAA;AAAA;AAAA;AAAAa;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,uCAAuC,wBAAC,kBAAkB;AACnE,SAAO;AAAA,IACH,eAAe,SAAS;AACpB,oBAAc,cAAc;AAAA,IAChC;AAAA,IACA,cAAc;AACV,aAAO,cAAc;AAAA,IACzB;AAAA,IACA,uBAAuB,KAAK,OAAO;AAC/B,oBAAc,aAAa,uBAAuB,KAAK,KAAK;AAAA,IAChE;AAAA,IACA,qBAAqB;AACjB,aAAO,cAAc,YAAY,mBAAmB;AAAA,IACxD;AAAA,EACJ;AACJ,GAfoD;AAgB7C,IAAM,kCAAkC,wBAAC,sCAAsC;AAClF,SAAO;AAAA,IACH,aAAa,kCAAkC,YAAY;AAAA,EAC/D;AACJ,GAJ+C;;;AChB/C;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAI;AAAA,CACV,SAAUC,mBAAkB;AACzB,EAAAA,kBAAiB,QAAQ,IAAI;AAC7B,EAAAA,kBAAiB,OAAO,IAAI;AAChC,GAAG,qBAAqB,mBAAmB,CAAC,EAAE;;;ACJ9C;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAI;AAAA,CACV,SAAUC,yBAAwB;AAC/B,EAAAA,wBAAuB,QAAQ,IAAI;AACnC,EAAAA,wBAAuB,OAAO,IAAI;AACtC,GAAG,2BAA2B,yBAAyB,CAAC,EAAE;;;ACJ1D;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAI;AAAA,CACV,SAAUC,oBAAmB;AAC1B,EAAAA,mBAAkB,MAAM,IAAI;AAC5B,EAAAA,mBAAkB,OAAO,IAAI;AACjC,GAAG,sBAAsB,oBAAoB,CAAC,EAAE;;;ACJhD;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAI;AAAA,CACV,SAAUC,cAAa;AACpB,EAAAA,aAAY,KAAK,IAAI;AACrB,EAAAA,aAAY,OAAO,IAAI;AACvB,EAAAA,aAAY,QAAQ,IAAI;AACxB,EAAAA,aAAY,MAAM,IAAI;AACtB,EAAAA,aAAY,QAAQ,IAAI;AAC5B,GAAG,gBAAgB,cAAc,CAAC,EAAE;;;ACPpC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAI;AAAA,CACV,SAAUC,gBAAe;AACtB,EAAAA,eAAcA,eAAc,QAAQ,IAAI,CAAC,IAAI;AAC7C,EAAAA,eAAcA,eAAc,SAAS,IAAI,CAAC,IAAI;AAClD,GAAG,kBAAkB,gBAAgB,CAAC,EAAE;;;ACJxC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,qBAAqB;;;ACAlC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAI;AAAA,CACV,SAAUC,iBAAgB;AACvB,EAAAA,gBAAe,SAAS,IAAI;AAC5B,EAAAA,gBAAe,aAAa,IAAI;AAChC,EAAAA,gBAAe,UAAU,IAAI;AACjC,GAAG,mBAAmB,iBAAiB,CAAC,EAAE;;;ACL1C;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAI;AAAA,CACV,SAAUC,yBAAwB;AAC/B,EAAAA,wBAAuB,UAAU,IAAI;AACrC,EAAAA,wBAAuB,UAAU,IAAI;AACrC,EAAAA,wBAAuB,SAAS,IAAI;AACxC,GAAG,2BAA2B,yBAAyB,CAAC,EAAE;;;ACL1D;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,cAAN,MAAM,aAAY;AAAA,EAAzB,OAAyB;AAAA;AAAA;AAAA,EACrB,YAAY,SAAS;AACjB,SAAK,SAAS,QAAQ,UAAU;AAChC,SAAK,WAAW,QAAQ,YAAY;AACpC,SAAK,OAAO,QAAQ;AACpB,SAAK,QAAQ,QAAQ,SAAS,CAAC;AAC/B,SAAK,UAAU,QAAQ,WAAW,CAAC;AACnC,SAAK,OAAO,QAAQ;AACpB,SAAK,WAAW,QAAQ,WAClB,QAAQ,SAAS,MAAM,EAAE,MAAM,MAC3B,GAAG,QAAQ,QAAQ,MACnB,QAAQ,WACZ;AACN,SAAK,OAAO,QAAQ,OAAQ,QAAQ,KAAK,OAAO,CAAC,MAAM,MAAM,IAAI,QAAQ,IAAI,KAAK,QAAQ,OAAQ;AAClG,SAAK,WAAW,QAAQ;AACxB,SAAK,WAAW,QAAQ;AACxB,SAAK,WAAW,QAAQ;AAAA,EAC5B;AAAA,EACA,OAAO,MAAM,SAAS;AAClB,UAAM,SAAS,IAAI,aAAY;AAAA,MAC3B,GAAG;AAAA,MACH,SAAS,EAAE,GAAG,QAAQ,QAAQ;AAAA,IAClC,CAAC;AACD,QAAI,OAAO,OAAO;AACd,aAAO,QAAQ,WAAW,OAAO,KAAK;AAAA,IAC1C;AACA,WAAO;AAAA,EACX;AAAA,EACA,OAAO,WAAW,SAAS;AACvB,QAAI,CAAC,SAAS;AACV,aAAO;AAAA,IACX;AACA,UAAM,MAAM;AACZ,WAAQ,YAAY,OAChB,cAAc,OACd,cAAc,OACd,UAAU,OACV,OAAO,IAAI,OAAO,MAAM,YACxB,OAAO,IAAI,SAAS,MAAM;AAAA,EAClC;AAAA,EACA,QAAQ;AACJ,WAAO,aAAY,MAAM,IAAI;AAAA,EACjC;AACJ;AACA,SAAS,WAAW,OAAO;AACvB,SAAO,OAAO,KAAK,KAAK,EAAE,OAAO,CAAC,OAAO,cAAc;AACnD,UAAM,QAAQ,MAAM,SAAS;AAC7B,WAAO;AAAA,MACH,GAAG;AAAA,MACH,CAAC,SAAS,GAAG,MAAM,QAAQ,KAAK,IAAI,CAAC,GAAG,KAAK,IAAI;AAAA,IACrD;AAAA,EACJ,GAAG,CAAC,CAAC;AACT;AARS;;;AC5CT;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,eAAN,MAAmB;AAAA,EAA1B,OAA0B;AAAA;AAAA;AAAA,EACtB,YAAY,SAAS;AACjB,SAAK,aAAa,QAAQ;AAC1B,SAAK,SAAS,QAAQ;AACtB,SAAK,UAAU,QAAQ,WAAW,CAAC;AACnC,SAAK,OAAO,QAAQ;AAAA,EACxB;AAAA,EACA,OAAO,WAAW,UAAU;AACxB,QAAI,CAAC;AACD,aAAO;AACX,UAAM,OAAO;AACb,WAAO,OAAO,KAAK,eAAe,YAAY,OAAO,KAAK,YAAY;AAAA,EAC1E;AACJ;;;ACbA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;AxECO,SAAS,wBAAwB,OAAO;AAC3C,SAAO;AACX;AAFgB;AAGT,IAAM,uBAAuB,wBAAC,YAAY,CAAC,SAAS,OAAO,SAAS;AACvE,MAAI,CAAC,YAAY,WAAW,KAAK,OAAO;AACpC,WAAO,KAAK,IAAI;AACpB,QAAM,EAAE,QAAQ,IAAI;AACpB,QAAM,EAAE,kBAAkB,GAAG,IAAI,QAAQ,eAAe,YAAY,CAAC;AACrE,MAAI,gBAAgB,QAAQ,IAAI,KAAK,KAAK,CAAC,QAAQ,QAAQ,YAAY,GAAG;AACtE,WAAO,QAAQ,QAAQ,MAAM;AAC7B,YAAQ,QAAQ,YAAY,IAAI,QAAQ,YAAY,QAAQ,OAAO,MAAM,QAAQ,OAAO;AAAA,EAC5F,WACS,CAAC,QAAQ,QAAQ,MAAM,GAAG;AAC/B,QAAI,OAAO,QAAQ;AACnB,QAAI,QAAQ,QAAQ;AAChB,cAAQ,IAAI,QAAQ,IAAI;AAC5B,YAAQ,QAAQ,MAAM,IAAI;AAAA,EAC9B;AACA,SAAO,KAAK,IAAI;AACpB,GAhBoC;AAiB7B,IAAM,8BAA8B;AAAA,EACvC,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,MAAM,CAAC,MAAM;AAAA,EACb,UAAU;AACd;AACO,IAAM,sBAAsB,wBAAC,aAAa;AAAA,EAC7C,cAAc,wBAAC,gBAAgB;AAC3B,gBAAY,IAAI,qBAAqB,OAAO,GAAG,2BAA2B;AAAA,EAC9E,GAFc;AAGlB,IAJmC;;;AyE5BnC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,mBAAmB,6BAAM,CAAC,MAAMC,aAAY,OAAO,SAAS;AACrE,MAAI;AACA,UAAM,WAAW,MAAM,KAAK,IAAI;AAChC,UAAM,EAAE,YAAY,aAAa,QAAAC,SAAQ,gCAAgC,CAAC,EAAE,IAAID;AAChF,UAAM,EAAE,iCAAiC,iCAAiC,IAAI;AAC9E,UAAM,0BAA0B,mCAAmCA,SAAQ;AAC3E,UAAM,2BAA2B,oCAAoCA,SAAQ;AAC7E,UAAM,EAAE,WAAW,GAAG,sBAAsB,IAAI,SAAS;AACzD,IAAAC,SAAQ,OAAO;AAAA,MACX;AAAA,MACA;AAAA,MACA,OAAO,wBAAwB,KAAK,KAAK;AAAA,MACzC,QAAQ,yBAAyB,qBAAqB;AAAA,MACtD,UAAU;AAAA,IACd,CAAC;AACD,WAAO;AAAA,EACX,SACOC,QAAO;AACV,UAAM,EAAE,YAAY,aAAa,QAAAD,SAAQ,gCAAgC,CAAC,EAAE,IAAID;AAChF,UAAM,EAAE,gCAAgC,IAAI;AAC5C,UAAM,0BAA0B,mCAAmCA,SAAQ;AAC3E,IAAAC,SAAQ,QAAQ;AAAA,MACZ;AAAA,MACA;AAAA,MACA,OAAO,wBAAwB,KAAK,KAAK;AAAA,MACzC,OAAAC;AAAA,MACA,UAAUA,OAAM;AAAA,IACpB,CAAC;AACD,UAAMA;AAAA,EACV;AACJ,GA9BgC;AA+BzB,IAAM,0BAA0B;AAAA,EACnC,MAAM;AAAA,EACN,MAAM,CAAC,QAAQ;AAAA,EACf,MAAM;AAAA,EACN,UAAU;AACd;AACO,IAAM,kBAAkB,wBAAC,aAAa;AAAA,EACzC,cAAc,wBAAC,gBAAgB;AAC3B,gBAAY,IAAI,iBAAiB,GAAG,uBAAuB;AAAA,EAC/D,GAFc;AAGlB,IAJ+B;;;ACrC/B;AAAA;AAAA;AAAA;AAAAC;AACA,IAAM,uBAAuB;AAC7B,IAAM,2BAA2B;AACjC,IAAM,eAAe;AACd,IAAM,+BAA+B,wBAAC,YAAY,CAAC,SAAS,OAAO,SAAS;AAC/E,QAAM,EAAE,QAAQ,IAAI;AACpB,MAAI,CAAC,YAAY,WAAW,OAAO,KAAK,QAAQ,YAAY,QAAQ;AAChE,WAAO,KAAK,IAAI;AAAA,EACpB;AACA,QAAM,gBAAgB,OAAO,KAAK,QAAQ,WAAW,CAAC,CAAC,EAAE,KAAK,CAACC,OAAMA,GAAE,YAAY,MAAM,qBAAqB,YAAY,CAAC,KACvH;AACJ,MAAI,QAAQ,QAAQ,eAAe,aAAa,GAAG;AAC/C,WAAO,KAAK,IAAI;AAAA,EACpB;AACA,QAAM,eAAe,QAAQ,IAAI,wBAAwB;AACzD,QAAM,UAAU,QAAQ,IAAI,YAAY;AACxC,QAAM,iBAAiB,wBAAC,QAAQ,OAAO,QAAQ,YAAY,IAAI,SAAS,GAAjD;AACvB,MAAI,eAAe,YAAY,KAAK,eAAe,OAAO,GAAG;AACzD,YAAQ,QAAQ,oBAAoB,IAAI;AAAA,EAC5C;AACA,SAAO,KAAK;AAAA,IACR,GAAG;AAAA,IACH;AAAA,EACJ,CAAC;AACL,GApB4C;AAqBrC,IAAM,yCAAyC;AAAA,EAClD,MAAM;AAAA,EACN,MAAM,CAAC,qBAAqB;AAAA,EAC5B,MAAM;AAAA,EACN,UAAU;AAAA,EACV,UAAU;AACd;AACO,IAAM,8BAA8B,wBAAC,aAAa;AAAA,EACrD,cAAc,wBAAC,gBAAgB;AAC3B,gBAAY,IAAI,6BAA6B,OAAO,GAAG,sCAAsC;AAAA,EACjG,GAFc;AAGlB,IAJ2C;;;AChC3C;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,mBAAmB,wBAACC,aAAYA,SAAQ,kBAAkB,MAAMA,SAAQ,kBAAkB,IAAI,CAAC,IAA5E;;;ACDhC;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,oBAAoB,wBAAC,UAAU;AACxC,MAAI,OAAO,UAAU;AACjB,WAAO;AACX,QAAM,cAAc,QAAQ,QAAQ,KAAK;AACzC,SAAO,MAAM;AACjB,GALiC;;;ACAjC;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,qBAAqB,wBAAC,sBAAsB,yBAAyB;AAC9E,MAAI,CAAC,wBAAwB,qBAAqB,WAAW,GAAG;AAC5D,WAAO;AAAA,EACX;AACA,QAAM,uBAAuB,CAAC;AAC9B,aAAW,uBAAuB,sBAAsB;AACpD,eAAW,uBAAuB,sBAAsB;AACpD,YAAM,0BAA0B,oBAAoB,SAAS,MAAM,GAAG,EAAE,CAAC;AACzE,UAAI,4BAA4B,qBAAqB;AACjD,6BAAqB,KAAK,mBAAmB;AAAA,MACjD;AAAA,IACJ;AAAA,EACJ;AACA,aAAW,uBAAuB,sBAAsB;AACpD,QAAI,CAAC,qBAAqB,KAAK,CAAC,EAAE,SAAS,MAAM,aAAa,oBAAoB,QAAQ,GAAG;AACzF,2BAAqB,KAAK,mBAAmB;AAAA,IACjD;AAAA,EACJ;AACA,SAAO;AACX,GAnBkC;;;AJGlC,SAAS,4BAA4B,iBAAiB;AAClD,QAAM,MAAM,oBAAI,IAAI;AACpB,aAAW,UAAU,iBAAiB;AAClC,QAAI,IAAI,OAAO,UAAU,MAAM;AAAA,EACnC;AACA,SAAO;AACX;AANS;AAOF,IAAM,2BAA2B,wBAACC,SAAQ,cAAc,CAAC,MAAMC,aAAY,OAAO,SAAS;AAC9F,QAAM,UAAUD,QAAO,uBAAuB,MAAM,UAAU,iCAAiCA,SAAQC,UAAS,KAAK,KAAK,CAAC;AAC3H,QAAM,uBAAuBD,QAAO,uBAAuB,MAAMA,QAAO,qBAAqB,IAAI,CAAC;AAClG,QAAM,kBAAkB,mBAAmB,SAAS,oBAAoB;AACxE,QAAM,cAAc,4BAA4BA,QAAO,eAAe;AACtE,QAAM,gBAAgB,iBAAiBC,QAAO;AAC9C,QAAM,iBAAiB,CAAC;AACxB,aAAW,UAAU,iBAAiB;AAClC,UAAM,SAAS,YAAY,IAAI,OAAO,QAAQ;AAC9C,QAAI,CAAC,QAAQ;AACT,qBAAe,KAAK,oBAAoB,OAAO,QAAQ,sCAAsC;AAC7F;AAAA,IACJ;AACA,UAAM,mBAAmB,OAAO,iBAAiB,MAAM,UAAU,+BAA+BD,OAAM,CAAC;AACvG,QAAI,CAAC,kBAAkB;AACnB,qBAAe,KAAK,oBAAoB,OAAO,QAAQ,iDAAiD;AACxG;AAAA,IACJ;AACA,UAAM,EAAE,qBAAqB,CAAC,GAAG,oBAAoB,CAAC,EAAE,IAAI,OAAO,sBAAsBA,SAAQC,QAAO,KAAK,CAAC;AAC9G,WAAO,qBAAqB,OAAO,OAAO,OAAO,sBAAsB,CAAC,GAAG,kBAAkB;AAC7F,WAAO,oBAAoB,OAAO,OAAO,OAAO,qBAAqB,CAAC,GAAG,iBAAiB;AAC1F,kBAAc,yBAAyB;AAAA,MACnC,gBAAgB;AAAA,MAChB,UAAU,MAAM,iBAAiB,OAAO,kBAAkB;AAAA,MAC1D,QAAQ,OAAO;AAAA,IACnB;AACA;AAAA,EACJ;AACA,MAAI,CAAC,cAAc,wBAAwB;AACvC,UAAM,IAAI,MAAM,eAAe,KAAK,IAAI,CAAC;AAAA,EAC7C;AACA,SAAO,KAAK,IAAI;AACpB,GAhCwC;;;AKVxC;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,iDAAiD;AAAA,EAC1D,MAAM;AAAA,EACN,MAAM,CAAC,kBAAkB;AAAA,EACzB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,UAAU;AAAA,EACV,cAAc;AAClB;AACO,IAAM,yCAAyC,wBAACC,SAAQ,EAAE,kCAAkC,+BAAgC,OAAO;AAAA,EACtI,cAAc,wBAAC,gBAAgB;AAC3B,gBAAY,cAAc,yBAAyBA,SAAQ;AAAA,MACvD;AAAA,MACA;AAAA,IACJ,CAAC,GAAG,8CAA8C;AAAA,EACtD,GALc;AAMlB,IAPsD;;;ACTtD;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,yBAAyB,wBAAC,SAAS,iBAAiB,CAAC,MAAMC,aAAY,OAAO,SAAS;AAChG,QAAM,EAAE,SAAS,IAAI,MAAM,KAAK,IAAI;AACpC,MAAI;AACA,UAAM,SAAS,MAAM,aAAa,UAAU,OAAO;AACnD,WAAO;AAAA,MACH;AAAA,MACA,QAAQ;AAAA,IACZ;AAAA,EACJ,SACOC,QAAO;AACV,WAAO,eAAeA,QAAO,aAAa;AAAA,MACtC,OAAO;AAAA,IACX,CAAC;AACD,QAAI,EAAE,eAAeA,SAAQ;AACzB,YAAM,OAAO;AACb,UAAI;AACA,QAAAA,OAAM,WAAW,SAAS;AAAA,MAC9B,SACOC,IAAG;AACN,YAAI,CAACF,SAAQ,UAAUA,SAAQ,QAAQ,aAAa,SAAS,cAAc;AACvE,kBAAQ,KAAK,IAAI;AAAA,QACrB,OACK;AACD,UAAAA,SAAQ,QAAQ,OAAO,IAAI;AAAA,QAC/B;AAAA,MACJ;AACA,UAAI,OAAOC,OAAM,sBAAsB,aAAa;AAChD,YAAIA,OAAM,WAAW;AACjB,UAAAA,OAAM,UAAU,OAAOA,OAAM;AAAA,QACjC;AAAA,MACJ;AACA,UAAI;AACA,YAAI,aAAa,WAAW,QAAQ,GAAG;AACnC,gBAAM,EAAE,UAAU,CAAC,EAAE,IAAI;AACzB,gBAAM,gBAAgB,OAAO,QAAQ,OAAO;AAC5C,UAAAA,OAAM,YAAY;AAAA,YACd,gBAAgB,SAAS;AAAA,YACzB,WAAW,WAAW,0BAA0B,aAAa;AAAA,YAC7D,mBAAmB,WAAW,mBAAmB,aAAa;AAAA,YAC9D,MAAM,WAAW,oBAAoB,aAAa;AAAA,UACtD;AAAA,QACJ;AAAA,MACJ,SACOC,IAAG;AAAA,MACV;AAAA,IACJ;AACA,UAAMD;AAAA,EACV;AACJ,GAhDsC;AAiDtC,IAAM,aAAa,wBAAC,SAAS,YAAY;AACrC,UAAQ,QAAQ,KAAK,CAAC,CAACE,EAAC,MAAM;AAC1B,WAAOA,GAAE,MAAM,OAAO;AAAA,EAC1B,CAAC,KAAK,CAAC,QAAQ,MAAM,GAAG,CAAC;AAC7B,GAJmB;;;AClDnB;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,uBAAuB,wBAAC,SAAS,eAAe,CAAC,MAAMC,aAAY,OAAO,SAAS;AAC5F,QAAM,iBAAiB;AACvB,QAAM,WAAWA,SAAQ,YAAY,OAAO,eAAe,YACrD,YAAY,eAAe,UAAUA,SAAQ,WAAW,GAAG,IAC3D,eAAe;AACrB,MAAI,CAAC,UAAU;AACX,UAAM,IAAI,MAAM,uCAAuC;AAAA,EAC3D;AACA,QAAM,UAAU,MAAM,WAAW,KAAK,OAAO,EAAE,GAAG,SAAS,SAAS,CAAC;AACrE,SAAO,KAAK;AAAA,IACR,GAAG;AAAA,IACH;AAAA,EACJ,CAAC;AACL,GAboC;;;ADE7B,IAAM,+BAA+B;AAAA,EACxC,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM,CAAC,cAAc;AAAA,EACrB,UAAU;AACd;AACO,IAAM,6BAA6B;AAAA,EACtC,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM,CAAC,YAAY;AAAA,EACnB,UAAU;AACd;AACO,SAAS,eAAeC,SAAQ,YAAY,cAAc;AAC7D,SAAO;AAAA,IACH,cAAc,wBAAC,iBAAiB;AAC5B,mBAAa,IAAI,uBAAuBA,SAAQ,YAAY,GAAG,4BAA4B;AAC3F,mBAAa,IAAI,qBAAqBA,SAAQ,UAAU,GAAG,0BAA0B;AAAA,IACzF,GAHc;AAAA,EAIlB;AACJ;AAPgB;;;AHZT,IAAM,kCAAkC;AAAA,EAC3C,MAAM;AAAA,EACN,MAAM,CAAC,kBAAkB;AAAA,EACzB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,UAAU;AAAA,EACV,cAAc,2BAA2B;AAC7C;;;AKTA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAGA,IAAM,sBAAsB,wBAAC,sBAAsB,CAACC,WAAU;AAC1D,QAAMA;AACV,GAF4B;AAG5B,IAAM,wBAAwB,wBAAC,cAAc,sBAAsB;AAAE,GAAvC;AACvB,IAAM,wBAAwB,wBAACC,YAAW,CAAC,MAAMC,aAAY,OAAO,SAAS;AAChF,MAAI,CAAC,YAAY,WAAW,KAAK,OAAO,GAAG;AACvC,WAAO,KAAK,IAAI;AAAA,EACpB;AACA,QAAM,gBAAgB,iBAAiBA,QAAO;AAC9C,QAAM,SAAS,cAAc;AAC7B,MAAI,CAAC,QAAQ;AACT,UAAM,IAAI,MAAM,wDAAwD;AAAA,EAC5E;AACA,QAAM,EAAE,gBAAgB,EAAE,oBAAoB,CAAC,EAAE,GAAG,UAAU,OAAQ,IAAI;AAC1E,QAAM,SAAS,MAAM,KAAK;AAAA,IACtB,GAAG;AAAA,IACH,SAAS,MAAM,OAAO,KAAK,KAAK,SAAS,UAAU,iBAAiB;AAAA,EACxE,CAAC,EAAE,OAAO,OAAO,gBAAgB,qBAAqB,iBAAiB,CAAC;AACxE,GAAC,OAAO,kBAAkB,uBAAuB,OAAO,UAAU,iBAAiB;AACnF,SAAO;AACX,GAhBqC;;;ACPrC;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,+BAA+B;AAAA,EACxC,MAAM;AAAA,EACN,MAAM,CAAC,cAAc;AAAA,EACrB,MAAM;AAAA,EACN,SAAS,CAAC,oBAAoB,mBAAmB,mBAAmB;AAAA,EACpE,UAAU;AAAA,EACV,UAAU;AAAA,EACV,cAAc;AAClB;AACO,IAAM,uBAAuB,wBAACC,aAAY;AAAA,EAC7C,cAAc,wBAAC,gBAAgB;AAC3B,gBAAY,cAAc,sBAAsBA,OAAM,GAAG,4BAA4B;AAAA,EACzF,GAFc;AAGlB,IAJoC;;;ACVpC;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAMC,qBAAoB,wBAAC,UAAU;AACxC,MAAI,OAAO,UAAU;AACjB,WAAO;AACX,QAAM,cAAc,QAAQ,QAAQ,KAAK;AACzC,SAAO,MAAM;AACjB,GALiC;;;ACAjC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAM,qBAAqB,CAAC;AAC5B,IAAM,kBAAkB,IAAI,MAAM,EAAE;AACpC,SAASC,KAAI,GAAG,QAAQ,IAAI,WAAW,CAAC,GAAG,QAAQ,IAAI,WAAW,CAAC,GAAGA,KAAI,SAAS,OAAOA,MAAK;AAC3F,QAAM,OAAO,OAAO,aAAaA,KAAI,KAAK;AAC1C,qBAAmB,IAAI,IAAIA;AAC3B,kBAAgBA,EAAC,IAAI;AACzB;AACA,SAASA,KAAI,GAAG,QAAQ,IAAI,WAAW,CAAC,GAAG,QAAQ,IAAI,WAAW,CAAC,GAAGA,KAAI,SAAS,OAAOA,MAAK;AAC3F,QAAM,OAAO,OAAO,aAAaA,KAAI,KAAK;AAC1C,QAAM,QAAQA,KAAI;AAClB,qBAAmB,IAAI,IAAI;AAC3B,kBAAgB,KAAK,IAAI;AAC7B;AACA,SAASA,KAAI,GAAGA,KAAI,IAAIA,MAAK;AACzB,qBAAmBA,GAAE,SAAS,EAAE,CAAC,IAAIA,KAAI;AACzC,QAAM,OAAOA,GAAE,SAAS,EAAE;AAC1B,QAAM,QAAQA,KAAI;AAClB,qBAAmB,IAAI,IAAI;AAC3B,kBAAgB,KAAK,IAAI;AAC7B;AACA,mBAAmB,GAAG,IAAI;AAC1B,gBAAgB,EAAE,IAAI;AACtB,mBAAmB,GAAG,IAAI;AAC1B,gBAAgB,EAAE,IAAI;AACtB,IAAM,gBAAgB;AACtB,IAAM,cAAc;AACpB,IAAM,iBAAiB;;;ADzBhB,IAAM,aAAa,wBAAC,UAAU;AACjC,MAAI,kBAAmB,MAAM,SAAS,IAAK;AAC3C,MAAI,MAAM,MAAM,EAAE,MAAM,MAAM;AAC1B,uBAAmB;AAAA,EACvB,WACS,MAAM,MAAM,EAAE,MAAM,KAAK;AAC9B;AAAA,EACJ;AACA,QAAM,MAAM,IAAI,YAAY,eAAe;AAC3C,QAAM,WAAW,IAAI,SAAS,GAAG;AACjC,WAASC,KAAI,GAAGA,KAAI,MAAM,QAAQA,MAAK,GAAG;AACtC,QAAI,OAAO;AACX,QAAI,YAAY;AAChB,aAASC,KAAID,IAAG,QAAQA,KAAI,GAAGC,MAAK,OAAOA,MAAK;AAC5C,UAAI,MAAMA,EAAC,MAAM,KAAK;AAClB,YAAI,EAAE,MAAMA,EAAC,KAAK,qBAAqB;AACnC,gBAAM,IAAI,UAAU,qBAAqB,MAAMA,EAAC,CAAC,oBAAoB;AAAA,QACzE;AACA,gBAAQ,mBAAmB,MAAMA,EAAC,CAAC,MAAO,QAAQA,MAAK;AACvD,qBAAa;AAAA,MACjB,OACK;AACD,iBAAS;AAAA,MACb;AAAA,IACJ;AACA,UAAM,cAAeD,KAAI,IAAK;AAC9B,aAAS,YAAY;AACrB,UAAM,aAAa,KAAK,MAAM,YAAY,WAAW;AACrD,aAASE,KAAI,GAAGA,KAAI,YAAYA,MAAK;AACjC,YAAM,UAAU,aAAaA,KAAI,KAAK;AACtC,eAAS,SAAS,cAAcA,KAAI,OAAQ,OAAO,WAAY,MAAM;AAAA,IACzE;AAAA,EACJ;AACA,SAAO,IAAI,WAAW,GAAG;AAC7B,GAlC0B;;;AED1B;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,WAAW,wBAAC,UAAU,IAAI,YAAY,EAAE,OAAO,KAAK,GAAzC;;;ACAxB;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,eAAe,wBAAC,SAAS;AAClC,MAAI,OAAO,SAAS,UAAU;AAC1B,WAAO,SAAS,IAAI;AAAA,EACxB;AACA,MAAI,YAAY,OAAO,IAAI,GAAG;AAC1B,WAAO,IAAI,WAAW,KAAK,QAAQ,KAAK,YAAY,KAAK,aAAa,WAAW,iBAAiB;AAAA,EACtG;AACA,SAAO,IAAI,WAAW,IAAI;AAC9B,GAR4B;;;ACD5B;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,SAAS,wBAAC,UAAU;AAC7B,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO;AAAA,EACX;AACA,MAAI,OAAO,UAAU,YAAY,OAAO,MAAM,eAAe,YAAY,OAAO,MAAM,eAAe,UAAU;AAC3G,UAAM,IAAI,MAAM,8EAA8E;AAAA,EAClG;AACA,SAAO,IAAI,YAAY,OAAO,EAAE,OAAO,KAAK;AAChD,GARsB;;;AJEf,SAAS,SAAS,QAAQ;AAC7B,MAAI;AACJ,MAAI,OAAO,WAAW,UAAU;AAC5B,YAAQ,SAAS,MAAM;AAAA,EAC3B,OACK;AACD,YAAQ;AAAA,EACZ;AACA,QAAM,cAAc,OAAO,UAAU,YAAY,OAAO,MAAM,WAAW;AACzE,QAAM,eAAe,OAAO,UAAU,YAClC,OAAO,MAAM,eAAe,YAC5B,OAAO,MAAM,eAAe;AAChC,MAAI,CAAC,eAAe,CAAC,cAAc;AAC/B,UAAM,IAAI,MAAM,kFAAkF;AAAA,EACtG;AACA,MAAI,MAAM;AACV,WAASC,KAAI,GAAGA,KAAI,MAAM,QAAQA,MAAK,GAAG;AACtC,QAAI,OAAO;AACX,QAAI,YAAY;AAChB,aAASC,KAAID,IAAG,QAAQ,KAAK,IAAIA,KAAI,GAAG,MAAM,MAAM,GAAGC,KAAI,OAAOA,MAAK;AACnE,cAAQ,MAAMA,EAAC,MAAO,QAAQA,KAAI,KAAK;AACvC,mBAAa;AAAA,IACjB;AACA,UAAM,kBAAkB,KAAK,KAAK,YAAY,aAAa;AAC3D,aAAS,kBAAkB,gBAAgB;AAC3C,aAASC,KAAI,GAAGA,MAAK,iBAAiBA,MAAK;AACvC,YAAM,UAAU,kBAAkBA,MAAK;AACvC,aAAO,iBAAiB,OAAQ,kBAAkB,WAAY,MAAM;AAAA,IACxE;AACA,WAAO,KAAK,MAAM,GAAG,IAAI,eAAe;AAAA,EAC5C;AACA,SAAO;AACX;AAhCgB;;;AJCT,SAAS,kBAAkB,SAAS,WAAW,SAAS;AAC3D,MAAI,aAAa,UAAU;AACvB,WAAO,SAAS,OAAO;AAAA,EAC3B;AACA,SAAO,OAAO,OAAO;AACzB;AALgB;AAMT,SAAS,oBAAoB,KAAK,UAAU;AAC/C,MAAI,aAAa,UAAU;AACvB,WAAO,sBAAsB,OAAO,WAAW,GAAG,CAAC;AAAA,EACvD;AACA,SAAO,sBAAsB,OAAO,SAAS,GAAG,CAAC;AACrD;AALgB;;;ADRT,IAAM,wBAAN,MAAM,+BAA8B,WAAW;AAAA,EADtD,OACsD;AAAA;AAAA;AAAA,EAClD,OAAO,WAAW,QAAQ,WAAW,SAAS;AAC1C,YAAQ,OAAO,QAAQ;AAAA,MACnB,KAAK;AACD,eAAO,oBAAoB,QAAQ,QAAQ;AAAA,MAC/C;AACI,cAAM,IAAI,MAAM,+BAA+B,OAAO,MAAM,4BAA4B;AAAA,IAChG;AAAA,EACJ;AAAA,EACA,OAAO,OAAO,QAAQ;AAClB,WAAO,eAAe,QAAQ,uBAAsB,SAAS;AAC7D,WAAO;AAAA,EACX;AAAA,EACA,kBAAkB,WAAW,SAAS;AAClC,WAAO,kBAAkB,MAAM,QAAQ;AAAA,EAC3C;AACJ;;;AUjBA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,YAAY,wBAAC,QAAQ,mBAAmB,GAAG,EAAE,QAAQ,YAAY,SAAS,GAA9D;AACzB,IAAM,YAAY,wBAACC,OAAM,IAAIA,GAAE,WAAW,CAAC,EAAE,SAAS,EAAE,EAAE,YAAY,CAAC,IAArD;;;ACDlB;AAAA;AAAA;AAAA;AAAAC;;;AHCO,SAAS,iBAAiB,OAAO;AACpC,QAAM,QAAQ,CAAC;AACf,WAAS,OAAO,OAAO,KAAK,KAAK,EAAE,KAAK,GAAG;AACvC,UAAM,QAAQ,MAAM,GAAG;AACvB,UAAM,UAAU,GAAG;AACnB,QAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,eAASC,KAAI,GAAG,OAAO,MAAM,QAAQA,KAAI,MAAMA,MAAK;AAChD,cAAM,KAAK,GAAG,GAAG,IAAI,UAAU,MAAMA,EAAC,CAAC,CAAC,EAAE;AAAA,MAC9C;AAAA,IACJ,OACK;AACD,UAAI,UAAU;AACd,UAAI,SAAS,OAAO,UAAU,UAAU;AACpC,mBAAW,IAAI,UAAU,KAAK,CAAC;AAAA,MACnC;AACA,YAAM,KAAK,OAAO;AAAA,IACtB;AAAA,EACJ;AACA,SAAO,MAAM,KAAK,GAAG;AACzB;AAnBgB;;;AIDhB;AAAA;AAAA;AAAA;AAAAC;AAAO,SAAS,cAAc,KAAK,gBAAgB;AAC/C,SAAO,IAAI,QAAQ,KAAK,cAAc;AAC1C;AAFgB;;;ACAhB;AAAA;AAAA;AAAA;AAAAC;AAAO,SAAS,eAAe,cAAc,GAAG;AAC5C,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,QAAI,aAAa;AACb,iBAAW,MAAM;AACb,cAAM,eAAe,IAAI,MAAM,mCAAmC,WAAW,KAAK;AAClF,qBAAa,OAAO;AACpB,eAAO,YAAY;AAAA,MACvB,GAAG,WAAW;AAAA,IAClB;AAAA,EACJ,CAAC;AACL;AAVgB;;;ANIT,IAAM,mBAAmB;AAAA,EAC5B,WAAW;AACf;AACO,IAAM,mBAAN,MAAM,kBAAiB;AAAA,EAP9B,OAO8B;AAAA;AAAA;AAAA,EAC1B,OAAO,OAAO,mBAAmB;AAC7B,QAAI,OAAO,mBAAmB,WAAW,YAAY;AACjD,aAAO;AAAA,IACX;AACA,WAAO,IAAI,kBAAiB,iBAAiB;AAAA,EACjD;AAAA,EACA,YAAY,SAAS;AACjB,QAAI,OAAO,YAAY,YAAY;AAC/B,WAAK,iBAAiB,QAAQ,EAAE,KAAK,CAAC,SAAS,QAAQ,CAAC,CAAC;AAAA,IAC7D,OACK;AACD,WAAK,SAAS,WAAW,CAAC;AAC1B,WAAK,iBAAiB,QAAQ,QAAQ,KAAK,MAAM;AAAA,IACrD;AACA,QAAI,iBAAiB,cAAc,QAAW;AAC1C,uBAAiB,YAAY,QAAQ,OAAO,YAAY,eAAe,eAAe,cAAc,eAAe,CAAC;AAAA,IACxH;AAAA,EACJ;AAAA,EACA,UAAU;AAAA,EACV;AAAA,EACA,MAAM,OAAO,SAAS,EAAE,YAAY,IAAI,CAAC,GAAG;AACxC,QAAI,CAAC,KAAK,QAAQ;AACd,WAAK,SAAS,MAAM,KAAK;AAAA,IAC7B;AACA,UAAM,qBAAqB,KAAK,OAAO;AACvC,UAAM,YAAY,KAAK,OAAO,cAAc;AAC5C,UAAM,cAAc,KAAK,OAAO;AAChC,QAAI,aAAa,SAAS;AACtB,YAAM,aAAa,IAAI,MAAM,iBAAiB;AAC9C,iBAAW,OAAO;AAClB,aAAO,QAAQ,OAAO,UAAU;AAAA,IACpC;AACA,QAAI,OAAO,QAAQ;AACnB,UAAM,cAAc,iBAAiB,QAAQ,SAAS,CAAC,CAAC;AACxD,QAAI,aAAa;AACb,cAAQ,IAAI,WAAW;AAAA,IAC3B;AACA,QAAI,QAAQ,UAAU;AAClB,cAAQ,IAAI,QAAQ,QAAQ;AAAA,IAChC;AACA,QAAI,OAAO;AACX,QAAI,QAAQ,YAAY,QAAQ,QAAQ,YAAY,MAAM;AACtD,YAAM,WAAW,QAAQ,YAAY;AACrC,YAAM,WAAW,QAAQ,YAAY;AACrC,aAAO,GAAG,QAAQ,IAAI,QAAQ;AAAA,IAClC;AACA,UAAM,EAAE,MAAM,OAAO,IAAI;AACzB,UAAM,MAAM,GAAG,QAAQ,QAAQ,KAAK,IAAI,GAAG,QAAQ,QAAQ,GAAG,OAAO,IAAI,IAAI,KAAK,EAAE,GAAG,IAAI;AAC3F,UAAM,OAAO,WAAW,SAAS,WAAW,SAAS,SAAY,QAAQ;AACzE,UAAM,iBAAiB;AAAA,MACnB;AAAA,MACA,SAAS,IAAI,QAAQ,QAAQ,OAAO;AAAA,MACpC;AAAA,MACA;AAAA,IACJ;AACA,QAAI,KAAK,QAAQ,OAAO;AACpB,qBAAe,QAAQ,KAAK,OAAO;AAAA,IACvC;AACA,QAAI,MAAM;AACN,qBAAe,SAAS;AAAA,IAC5B;AACA,QAAI,OAAO,oBAAoB,aAAa;AACxC,qBAAe,SAAS;AAAA,IAC5B;AACA,QAAI,iBAAiB,WAAW;AAC5B,qBAAe,YAAY;AAAA,IAC/B;AACA,QAAI,OAAO,KAAK,OAAO,gBAAgB,YAAY;AAC/C,aAAO,OAAO,gBAAgB,KAAK,OAAO,YAAY,OAAO,CAAC;AAAA,IAClE;AACA,QAAI,4BAA4B,6BAAM;AAAA,IAAE,GAAR;AAChC,UAAM,eAAe,cAAc,KAAK,cAAc;AACtD,UAAM,iBAAiB;AAAA,MACnB,MAAM,YAAY,EAAE,KAAK,CAAC,aAAa;AACnC,cAAM,eAAe,SAAS;AAC9B,cAAM,qBAAqB,CAAC;AAC5B,mBAAW,QAAQ,aAAa,QAAQ,GAAG;AACvC,6BAAmB,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC;AAAA,QACxC;AACA,cAAM,oBAAoB,SAAS,QAAQ;AAC3C,YAAI,CAAC,mBAAmB;AACpB,iBAAO,SAAS,KAAK,EAAE,KAAK,CAACC,WAAU;AAAA,YACnC,UAAU,IAAI,aAAa;AAAA,cACvB,SAAS;AAAA,cACT,QAAQ,SAAS;AAAA,cACjB,YAAY,SAAS;AAAA,cACrB,MAAAA;AAAA,YACJ,CAAC;AAAA,UACL,EAAE;AAAA,QACN;AACA,eAAO;AAAA,UACH,UAAU,IAAI,aAAa;AAAA,YACvB,SAAS;AAAA,YACT,QAAQ,SAAS;AAAA,YACjB,YAAY,SAAS;AAAA,YACrB,MAAM,SAAS;AAAA,UACnB,CAAC;AAAA,QACL;AAAA,MACJ,CAAC;AAAA,MACD,eAAe,kBAAkB;AAAA,IACrC;AACA,QAAI,aAAa;AACb,qBAAe,KAAK,IAAI,QAAQ,CAAC,SAAS,WAAW;AACjD,cAAM,UAAU,6BAAM;AAClB,gBAAM,aAAa,IAAI,MAAM,iBAAiB;AAC9C,qBAAW,OAAO;AAClB,iBAAO,UAAU;AAAA,QACrB,GAJgB;AAKhB,YAAI,OAAO,YAAY,qBAAqB,YAAY;AACpD,gBAAM,SAAS;AACf,iBAAO,iBAAiB,SAAS,SAAS,EAAE,MAAM,KAAK,CAAC;AACxD,sCAA4B,6BAAM,OAAO,oBAAoB,SAAS,OAAO,GAAjD;AAAA,QAChC,OACK;AACD,sBAAY,UAAU;AAAA,QAC1B;AAAA,MACJ,CAAC,CAAC;AAAA,IACN;AACA,WAAO,QAAQ,KAAK,cAAc,EAAE,QAAQ,yBAAyB;AAAA,EACzE;AAAA,EACA,uBAAuB,KAAK,OAAO;AAC/B,SAAK,SAAS;AACd,SAAK,iBAAiB,KAAK,eAAe,KAAK,CAACC,YAAW;AACvD,MAAAA,QAAO,GAAG,IAAI;AACd,aAAOA;AAAA,IACX,CAAC;AAAA,EACL;AAAA,EACA,qBAAqB;AACjB,WAAO,KAAK,UAAU,CAAC;AAAA,EAC3B;AACJ;;;AO1IA;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,kBAAkB,8BAAO,WAAW;AAC7C,MAAK,OAAO,SAAS,cAAc,kBAAkB,QAAS,OAAO,aAAa,SAAS,QAAQ;AAC/F,QAAI,KAAK,UAAU,gBAAgB,QAAW;AAC1C,aAAO,IAAI,WAAW,MAAM,OAAO,YAAY,CAAC;AAAA,IACpD;AACA,WAAO,YAAY,MAAM;AAAA,EAC7B;AACA,SAAO,cAAc,MAAM;AAC/B,GAR+B;AAS/B,eAAe,YAAY,MAAM;AAC7B,QAAM,SAAS,MAAM,aAAa,IAAI;AACtC,QAAM,cAAc,WAAW,MAAM;AACrC,SAAO,IAAI,WAAW,WAAW;AACrC;AAJe;AAKf,eAAe,cAAc,QAAQ;AACjC,QAAM,SAAS,CAAC;AAChB,QAAM,SAAS,OAAO,UAAU;AAChC,MAAI,SAAS;AACb,MAAI,SAAS;AACb,SAAO,CAAC,QAAQ;AACZ,UAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,QAAI,OAAO;AACP,aAAO,KAAK,KAAK;AACjB,gBAAU,MAAM;AAAA,IACpB;AACA,aAAS;AAAA,EACb;AACA,QAAM,YAAY,IAAI,WAAW,MAAM;AACvC,MAAI,SAAS;AACb,aAAW,SAAS,QAAQ;AACxB,cAAU,IAAI,OAAO,MAAM;AAC3B,cAAU,MAAM;AAAA,EACpB;AACA,SAAO;AACX;AApBe;AAqBf,SAAS,aAAa,MAAM;AACxB,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,UAAM,SAAS,IAAI,WAAW;AAC9B,WAAO,YAAY,MAAM;AACrB,UAAI,OAAO,eAAe,GAAG;AACzB,eAAO,OAAO,IAAI,MAAM,0BAA0B,CAAC;AAAA,MACvD;AACA,YAAM,SAAU,OAAO,UAAU;AACjC,YAAM,aAAa,OAAO,QAAQ,GAAG;AACrC,YAAM,aAAa,aAAa,KAAK,aAAa,IAAI,OAAO;AAC7D,cAAQ,OAAO,UAAU,UAAU,CAAC;AAAA,IACxC;AACA,WAAO,UAAU,MAAM,OAAO,IAAI,MAAM,cAAc,CAAC;AACvD,WAAO,UAAU,MAAM,OAAO,OAAO,KAAK;AAC1C,WAAO,cAAc,IAAI;AAAA,EAC7B,CAAC;AACL;AAhBS;;;ACpCT;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAM,eAAe,CAAC;AACtB,IAAM,eAAe,CAAC;AACtB,SAASC,KAAI,GAAGA,KAAI,KAAKA,MAAK;AAC1B,MAAI,cAAcA,GAAE,SAAS,EAAE,EAAE,YAAY;AAC7C,MAAI,YAAY,WAAW,GAAG;AAC1B,kBAAc,IAAI,WAAW;AAAA,EACjC;AACA,eAAaA,EAAC,IAAI;AAClB,eAAa,WAAW,IAAIA;AAChC;AACO,SAAS,QAAQ,SAAS;AAC7B,MAAI,QAAQ,SAAS,MAAM,GAAG;AAC1B,UAAM,IAAI,MAAM,qDAAqD;AAAA,EACzE;AACA,QAAM,MAAM,IAAI,WAAW,QAAQ,SAAS,CAAC;AAC7C,WAASA,KAAI,GAAGA,KAAI,QAAQ,QAAQA,MAAK,GAAG;AACxC,UAAM,cAAc,QAAQ,MAAMA,IAAGA,KAAI,CAAC,EAAE,YAAY;AACxD,QAAI,eAAe,cAAc;AAC7B,UAAIA,KAAI,CAAC,IAAI,aAAa,WAAW;AAAA,IACzC,OACK;AACD,YAAM,IAAI,MAAM,uCAAuC,WAAW,iBAAiB;AAAA,IACvF;AAAA,EACJ;AACA,SAAO;AACX;AAfgB;AAgBT,SAAS,MAAM,OAAO;AACzB,MAAI,MAAM;AACV,WAASA,KAAI,GAAGA,KAAI,MAAM,YAAYA,MAAK;AACvC,WAAO,aAAa,MAAMA,EAAC,CAAC;AAAA,EAChC;AACA,SAAO;AACX;AANgB;;;AC1BhB;AAAA;AAAA;AAAA;AAAAC;;;A9BCO,IAAM,cAAc,8BAAO,aAAa,IAAI,WAAW,GAAGC,aAAY;AACzE,MAAI,sBAAsB,YAAY;AAClC,WAAO,sBAAsB,OAAO,UAAU;AAAA,EAClD;AACA,MAAI,CAAC,YAAY;AACb,WAAO,sBAAsB,OAAO,IAAI,WAAW,CAAC;AAAA,EACxD;AACA,QAAM,cAAcA,SAAQ,gBAAgB,UAAU;AACtD,SAAO,sBAAsB,OAAO,MAAM,WAAW;AACzD,GAT2B;;;A+BD3B;AAAA;AAAA;AAAA;AAAAC;AAAO,SAAS,2BAA2B,KAAK;AAC5C,SAAO,mBAAmB,GAAG,EAAE,QAAQ,YAAY,SAAUC,IAAG;AAC5D,WAAO,MAAMA,GAAE,WAAW,CAAC,EAAE,SAAS,EAAE,EAAE,YAAY;AAAA,EAC1D,CAAC;AACL;AAJgB;;;ACAhB;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,SAAS,WAAWC,UAAS,SAAS,OAAO;AAChD,MAAI,CAACA,SAAQ,kBAAkB;AAC3B,IAAAA,SAAQ,mBAAmB;AAAA,MACvB,UAAU,CAAC;AAAA,IACf;AAAA,EACJ,WACS,CAACA,SAAQ,iBAAiB,UAAU;AACzC,IAAAA,SAAQ,iBAAiB,WAAW,CAAC;AAAA,EACzC;AACA,EAAAA,SAAQ,iBAAiB,SAAS,OAAO,IAAI;AACjD;AAVgB;;;ACAhB;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,gCAAN,MAAoC;AAAA,EAA3C,OAA2C;AAAA;AAAA;AAAA,EACvC,YAAYC,SAAQ;AAChB,SAAK,cAAc,oBAAI,IAAI;AAC3B,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQA,OAAM,GAAG;AAC/C,UAAI,UAAU,QAAW;AACrB,aAAK,YAAY,IAAI,KAAK,KAAK;AAAA,MACnC;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,oBAAoB,UAAU;AAC1B,WAAO,KAAK,YAAY,IAAI,QAAQ;AAAA,EACxC;AACJ;;;ACZA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,kCAAkC,wBAAC,iBAAiB,CAAC,aAAa,2BAA2B,QAAQ,KAAK,SAAS,WAAW,QAAQ,IAAI,KAAK,IAAI,IAAI,cAArH;AACxC,IAAM,gBAAgB;AACtB,IAAM,oBAAoB,gCAAgC,aAAa;AACvE,IAAM,6BAA6B,wBAAC,aAAa,SAAS,eAAe,QAAtC;AACnC,IAAM,0BAA0B,wBAAC,UAAU,WAAW,oBAAoB;AAC7E,MAAI,aAAa,QAAW;AACxB,WAAO;AAAA,EACX;AACA,QAAM,qBAAqB,OAAO,aAAa,aAAa,YAAY,QAAQ,QAAQ,QAAQ,IAAI;AACpG,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,aAAa;AACjB,QAAM,mBAAmB,8BAAO,YAAY;AACxC,QAAI,CAAC,SAAS;AACV,gBAAU,mBAAmB,OAAO;AAAA,IACxC;AACA,QAAI;AACA,iBAAW,MAAM;AACjB,kBAAY;AACZ,mBAAa;AAAA,IACjB,UACA;AACI,gBAAU;AAAA,IACd;AACA,WAAO;AAAA,EACX,GAbyB;AAczB,MAAI,cAAc,QAAW;AACzB,WAAO,OAAO,YAAY;AACtB,UAAI,CAAC,aAAa,SAAS,cAAc;AACrC,mBAAW,MAAM,iBAAiB,OAAO;AAAA,MAC7C;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO,OAAO,YAAY;AACtB,QAAI,CAAC,aAAa,SAAS,cAAc;AACrC,iBAAW,MAAM,iBAAiB,OAAO;AAAA,IAC7C;AACA,QAAI,YAAY;AACZ,aAAO;AAAA,IACX;AACA,QAAI,CAAC,gBAAgB,QAAQ,GAAG;AAC5B,mBAAa;AACb,aAAO;AAAA,IACX;AACA,QAAI,UAAU,QAAQ,GAAG;AACrB,YAAM,iBAAiB,OAAO;AAC9B,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACJ,GAhDuC;;;A/DHhC,IAAM,oBAAoB;AACjC,SAAS,sBAAsB,OAAO;AAClC,MAAI,UAAU,QAAW;AACrB,WAAO;AAAA,EACX;AACA,SAAO,OAAO,UAAU,YAAY,MAAM,UAAU;AACxD;AALS;AAMF,SAAS,uBAAuB,OAAO;AAC1C,QAAM,0BAA0BC,mBAAkB,MAAM,kBAAkB,iBAAiB;AAC3F,QAAM,EAAE,gBAAgB,IAAI;AAC5B,SAAO,OAAO,OAAO,OAAO;AAAA,IACxB,iBAAiB,OAAO,oBAAoB,WAAW,CAAC,CAAC,eAAe,CAAC,IAAI;AAAA,IAC7E,gBAAgB,mCAAY;AACxB,YAAM,QAAQ,MAAM,wBAAwB;AAC5C,UAAI,CAAC,sBAAsB,KAAK,GAAG;AAC/B,cAAMC,UAAS,MAAM,QAAQ,aAAa,SAAS,gBAAgB,CAAC,MAAM,SAAS,UAAU,MAAM;AACnG,YAAI,OAAO,UAAU,UAAU;AAC3B,UAAAA,SAAQ,KAAK,+CAA+C;AAAA,QAChE,WACS,MAAM,SAAS,IAAI;AACxB,UAAAA,SAAQ,KAAK,0EAA0E;AAAA,QAC3F;AAAA,MACJ;AACA,aAAO;AAAA,IACX,GAZgB;AAAA,EAapB,CAAC;AACL;AAnBgB;;;AgERhB;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,gBAAN,MAAoB;AAAA,EAA3B,OAA2B;AAAA;AAAA;AAAA,EACvB,YAAY,EAAE,MAAM,OAAO,GAAG;AAC1B,SAAK,OAAO,oBAAI,IAAI;AACpB,SAAK,aAAa,CAAC;AACnB,SAAK,WAAW,QAAQ;AACxB,QAAI,QAAQ;AACR,WAAK,aAAa;AAAA,IACtB;AAAA,EACJ;AAAA,EACA,IAAI,gBAAgB,UAAU;AAC1B,UAAM,MAAM,KAAK,KAAK,cAAc;AACpC,QAAI,QAAQ,OAAO;AACf,aAAO,SAAS;AAAA,IACpB;AACA,QAAI,CAAC,KAAK,KAAK,IAAI,GAAG,GAAG;AACrB,UAAI,KAAK,KAAK,OAAO,KAAK,WAAW,IAAI;AACrC,cAAM,OAAO,KAAK,KAAK,KAAK;AAC5B,YAAIC,KAAI;AACR,eAAO,MAAM;AACT,gBAAM,EAAE,OAAO,KAAK,IAAI,KAAK,KAAK;AAClC,eAAK,KAAK,OAAO,KAAK;AACtB,cAAI,QAAQ,EAAEA,KAAI,IAAI;AAClB;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,WAAK,KAAK,IAAI,KAAK,SAAS,CAAC;AAAA,IACjC;AACA,WAAO,KAAK,KAAK,IAAI,GAAG;AAAA,EAC5B;AAAA,EACA,OAAO;AACH,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA,EACA,KAAK,gBAAgB;AACjB,QAAI,SAAS;AACb,UAAM,EAAE,WAAW,IAAI;AACvB,QAAI,WAAW,WAAW,GAAG;AACzB,aAAO;AAAA,IACX;AACA,eAAW,SAAS,YAAY;AAC5B,YAAMC,OAAM,OAAO,eAAe,KAAK,KAAK,EAAE;AAC9C,UAAIA,KAAI,SAAS,IAAI,GAAG;AACpB,eAAO;AAAA,MACX;AACA,gBAAUA,OAAM;AAAA,IACpB;AACA,WAAO;AAAA,EACX;AACJ;;;AChDA;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAM,cAAc,IAAI,OAAO,kGAAkG;AAC1H,IAAM,cAAc,wBAAC,UAAU,YAAY,KAAK,KAAK,KAAM,MAAM,WAAW,GAAG,KAAK,MAAM,SAAS,GAAG,GAAlF;;;ACD3B;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAM,yBAAyB,IAAI,OAAO,mCAAmC;AACtE,IAAM,mBAAmB,wBAAC,OAAO,kBAAkB,UAAU;AAChE,MAAI,CAAC,iBAAiB;AAClB,WAAO,uBAAuB,KAAK,KAAK;AAAA,EAC5C;AACA,QAAM,SAAS,MAAM,MAAM,GAAG;AAC9B,aAAW,SAAS,QAAQ;AACxB,QAAI,CAAC,iBAAiB,KAAK,GAAG;AAC1B,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX,GAXgC;;;ACDhC;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,0BAA0B,CAAC;;;ACAxC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,UAAU;;;ACAvB;AAAA;AAAA;AAAA;AAAAC;AAAO,SAAS,cAAc,OAAO;AACjC,MAAI,OAAO,UAAU,YAAY,SAAS,MAAM;AAC5C,WAAO;AAAA,EACX;AACA,MAAI,SAAS,OAAO;AAChB,WAAO,IAAI,cAAc,MAAM,GAAG,CAAC;AAAA,EACvC;AACA,MAAI,QAAQ,OAAO;AACf,WAAO,GAAG,MAAM,EAAE,KAAK,MAAM,QAAQ,CAAC,GAAG,IAAI,aAAa,EAAE,KAAK,IAAI,CAAC;AAAA,EAC1E;AACA,SAAO,KAAK,UAAU,OAAO,MAAM,CAAC;AACxC;AAXgB;;;ACAhB;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,gBAAN,cAA4B,MAAM;AAAA,EAAzC,OAAyC;AAAA;AAAA;AAAA,EACrC,YAAY,SAAS;AACjB,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EAChB;AACJ;;;ACLA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,gBAAgB,wBAAC,QAAQ,WAAW,WAAW,QAA/B;;;ACA7B;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,kBAAkB,wBAAC,SAAS;AACrC,QAAM,QAAQ,KAAK,MAAM,GAAG;AAC5B,QAAM,WAAW,CAAC;AAClB,aAAW,QAAQ,OAAO;AACtB,UAAM,qBAAqB,KAAK,QAAQ,GAAG;AAC3C,QAAI,uBAAuB,IAAI;AAC3B,UAAI,KAAK,QAAQ,GAAG,MAAM,KAAK,SAAS,GAAG;AACvC,cAAM,IAAI,cAAc,UAAU,IAAI,yBAAyB;AAAA,MACnE;AACA,YAAM,aAAa,KAAK,MAAM,qBAAqB,GAAG,EAAE;AACxD,UAAI,OAAO,MAAM,SAAS,UAAU,CAAC,GAAG;AACpC,cAAM,IAAI,cAAc,yBAAyB,UAAU,eAAe,IAAI,GAAG;AAAA,MACrF;AACA,UAAI,uBAAuB,GAAG;AAC1B,iBAAS,KAAK,KAAK,MAAM,GAAG,kBAAkB,CAAC;AAAA,MACnD;AACA,eAAS,KAAK,UAAU;AAAA,IAC5B,OACK;AACD,eAAS,KAAK,IAAI;AAAA,IACtB;AAAA,EACJ;AACA,SAAO;AACX,GAvB+B;;;ADCxB,IAAM,UAAU,wBAAC,OAAO,SAAS,gBAAgB,IAAI,EAAE,OAAO,CAAC,KAAK,UAAU;AACjF,MAAI,OAAO,QAAQ,UAAU;AACzB,UAAM,IAAI,cAAc,UAAU,KAAK,SAAS,IAAI,mBAAmB,KAAK,UAAU,KAAK,CAAC,GAAG;AAAA,EACnG,WACS,MAAM,QAAQ,GAAG,GAAG;AACzB,WAAO,IAAI,SAAS,KAAK,CAAC;AAAA,EAC9B;AACA,SAAO,IAAI,KAAK;AACpB,GAAG,KAAK,GARe;;;AEFvB;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,QAAQ,wBAAC,UAAU,SAAS,MAApB;;;ACArB;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,MAAM,wBAAC,UAAU,CAAC,OAAZ;;;ACAnB;AAAA;AAAA;AAAA;AAAAC;AAEA,IAAM,gBAAgB;AAAA,EAClB,CAAC,kBAAkB,IAAI,GAAG;AAAA,EAC1B,CAAC,kBAAkB,KAAK,GAAG;AAC/B;AACO,IAAM,WAAW,wBAAC,UAAU;AAC/B,QAAM,aAAa,MAAM;AACrB,QAAI;AACA,UAAI,iBAAiB,KAAK;AACtB,eAAO;AAAA,MACX;AACA,UAAI,OAAO,UAAU,YAAY,cAAc,OAAO;AAClD,cAAM,EAAE,UAAAC,WAAU,MAAM,UAAAC,YAAW,IAAI,OAAO,IAAI,QAAQ,CAAC,EAAE,IAAI;AACjE,cAAM,MAAM,IAAI,IAAI,GAAGA,SAAQ,KAAKD,SAAQ,GAAG,OAAO,IAAI,IAAI,KAAK,EAAE,GAAG,IAAI,EAAE;AAC9E,YAAI,SAAS,OAAO,QAAQ,KAAK,EAC5B,IAAI,CAAC,CAACE,IAAGC,EAAC,MAAM,GAAGD,EAAC,IAAIC,EAAC,EAAE,EAC3B,KAAK,GAAG;AACb,eAAO;AAAA,MACX;AACA,aAAO,IAAI,IAAI,KAAK;AAAA,IACxB,SACOC,QAAO;AACV,aAAO;AAAA,IACX;AAAA,EACJ,GAAG;AACH,MAAI,CAAC,WAAW;AACZ,YAAQ,MAAM,mBAAmB,KAAK,UAAU,KAAK,CAAC,mBAAmB;AACzE,WAAO;AAAA,EACX;AACA,QAAM,YAAY,UAAU;AAC5B,QAAM,EAAE,MAAM,UAAU,UAAU,UAAU,OAAO,IAAI;AACvD,MAAI,QAAQ;AACR,WAAO;AAAA,EACX;AACA,QAAM,SAAS,SAAS,MAAM,GAAG,EAAE;AACnC,MAAI,CAAC,OAAO,OAAO,iBAAiB,EAAE,SAAS,MAAM,GAAG;AACpD,WAAO;AAAA,EACX;AACA,QAAM,OAAO,YAAY,QAAQ;AACjC,QAAM,2BAA2B,UAAU,SAAS,GAAG,IAAI,IAAI,cAAc,MAAM,CAAC,EAAE,KACjF,OAAO,UAAU,YAAY,MAAM,SAAS,GAAG,IAAI,IAAI,cAAc,MAAM,CAAC,EAAE;AACnF,QAAM,YAAY,GAAG,IAAI,GAAG,2BAA2B,IAAI,cAAc,MAAM,CAAC,KAAK,EAAE;AACvF,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA,MAAM;AAAA,IACN,gBAAgB,SAAS,SAAS,GAAG,IAAI,WAAW,GAAG,QAAQ;AAAA,IAC/D;AAAA,EACJ;AACJ,GA5CwB;;;ACNxB;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,eAAe,wBAAC,QAAQ,WAAW,WAAW,QAA/B;;;ACA5B;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,YAAY,wBAAC,OAAO,OAAO,MAAM,YAAY;AACtD,MAAI,SAAS,QAAQ,MAAM,SAAS,MAAM;AACtC,WAAO;AAAA,EACX;AACA,MAAI,CAAC,SAAS;AACV,WAAO,MAAM,UAAU,OAAO,IAAI;AAAA,EACtC;AACA,SAAO,MAAM,UAAU,MAAM,SAAS,MAAM,MAAM,SAAS,KAAK;AACpE,GARyB;;;ACAzB;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,YAAY,wBAAC,UAAU,mBAAmB,KAAK,EAAE,QAAQ,YAAY,CAACC,OAAM,IAAIA,GAAE,WAAW,CAAC,EAAE,SAAS,EAAE,EAAE,YAAY,CAAC,EAAE,GAAhH;;;AVClB,IAAM,oBAAoB;AAAA,EAC7B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;;;AWXA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,mBAAmB,wBAAC,UAAU,YAAY;AACnD,QAAM,uBAAuB,CAAC;AAC9B,QAAM,kBAAkB;AAAA,IACpB,GAAG,QAAQ;AAAA,IACX,GAAG,QAAQ;AAAA,EACf;AACA,MAAI,eAAe;AACnB,SAAO,eAAe,SAAS,QAAQ;AACnC,UAAM,oBAAoB,SAAS,QAAQ,KAAK,YAAY;AAC5D,QAAI,sBAAsB,IAAI;AAC1B,2BAAqB,KAAK,SAAS,MAAM,YAAY,CAAC;AACtD;AAAA,IACJ;AACA,yBAAqB,KAAK,SAAS,MAAM,cAAc,iBAAiB,CAAC;AACzE,UAAM,oBAAoB,SAAS,QAAQ,KAAK,iBAAiB;AACjE,QAAI,sBAAsB,IAAI;AAC1B,2BAAqB,KAAK,SAAS,MAAM,iBAAiB,CAAC;AAC3D;AAAA,IACJ;AACA,QAAI,SAAS,oBAAoB,CAAC,MAAM,OAAO,SAAS,oBAAoB,CAAC,MAAM,KAAK;AACpF,2BAAqB,KAAK,SAAS,MAAM,oBAAoB,GAAG,iBAAiB,CAAC;AAClF,qBAAe,oBAAoB;AAAA,IACvC;AACA,UAAM,gBAAgB,SAAS,UAAU,oBAAoB,GAAG,iBAAiB;AACjF,QAAI,cAAc,SAAS,GAAG,GAAG;AAC7B,YAAM,CAAC,SAAS,QAAQ,IAAI,cAAc,MAAM,GAAG;AACnD,2BAAqB,KAAK,QAAQ,gBAAgB,OAAO,GAAG,QAAQ,CAAC;AAAA,IACzE,OACK;AACD,2BAAqB,KAAK,gBAAgB,aAAa,CAAC;AAAA,IAC5D;AACA,mBAAe,oBAAoB;AAAA,EACvC;AACA,SAAO,qBAAqB,KAAK,EAAE;AACvC,GAlCgC;;;ACDhC;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,oBAAoB,wBAAC,EAAE,IAAI,GAAG,YAAY;AACnD,QAAM,kBAAkB;AAAA,IACpB,GAAG,QAAQ;AAAA,IACX,GAAG,QAAQ;AAAA,EACf;AACA,SAAO,gBAAgB,GAAG;AAC9B,GANiC;;;AFI1B,IAAM,qBAAqB,wBAAC,KAAK,SAAS,YAAY;AACzD,MAAI,OAAO,QAAQ,UAAU;AACzB,WAAO,iBAAiB,KAAK,OAAO;AAAA,EACxC,WACS,IAAI,IAAI,GAAG;AAChB,WAAO,aAAa,KAAK,OAAO;AAAA,EACpC,WACS,IAAI,KAAK,GAAG;AACjB,WAAO,kBAAkB,KAAK,OAAO;AAAA,EACzC;AACA,QAAM,IAAI,cAAc,IAAI,OAAO,MAAM,OAAO,GAAG,CAAC,0CAA0C;AAClG,GAXkC;;;AZD3B,IAAM,eAAe,wBAAC,EAAE,IAAI,MAAAC,MAAK,GAAG,YAAY;AACnD,QAAM,gBAAgBA,MAAK,IAAI,CAAC,QAAQ,CAAC,WAAW,QAAQ,EAAE,SAAS,OAAO,GAAG,IAAI,MAAM,mBAAmB,KAAK,OAAO,OAAO,CAAC;AAClI,QAAM,aAAa,GAAG,MAAM,GAAG;AAC/B,MAAI,WAAW,CAAC,KAAK,2BAA2B,WAAW,CAAC,KAAK,MAAM;AACnE,WAAO,wBAAwB,WAAW,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC,EAAE,GAAG,aAAa;AAAA,EACjF;AACA,SAAO,kBAAkB,EAAE,EAAE,GAAG,aAAa;AACjD,GAP4B;;;ADArB,IAAM,oBAAoB,wBAAC,EAAE,QAAQ,GAAG,OAAO,GAAG,YAAY;AACjE,MAAI,UAAU,UAAU,QAAQ,iBAAiB;AAC7C,UAAM,IAAI,cAAc,IAAI,MAAM,2CAA2C;AAAA,EACjF;AACA,QAAM,QAAQ,aAAa,QAAQ,OAAO;AAC1C,UAAQ,QAAQ,QAAQ,GAAG,OAAO,uBAAuB,cAAc,MAAM,CAAC,MAAM,cAAc,KAAK,CAAC,EAAE;AAC1G,SAAO;AAAA,IACH,QAAQ,UAAU,KAAK,OAAO,CAAC,CAAC;AAAA,IAChC,GAAI,UAAU,QAAQ,EAAE,UAAU,EAAE,MAAM,QAAQ,MAAM,EAAE;AAAA,EAC9D;AACJ,GAViC;;;ADD1B,IAAM,qBAAqB,wBAAC,aAAa,CAAC,GAAG,YAAY;AAC5D,QAAM,4BAA4B,CAAC;AACnC,aAAW,aAAa,YAAY;AAChC,UAAM,EAAE,QAAQ,SAAS,IAAI,kBAAkB,WAAW;AAAA,MACtD,GAAG;AAAA,MACH,iBAAiB;AAAA,QACb,GAAG,QAAQ;AAAA,QACX,GAAG;AAAA,MACP;AAAA,IACJ,CAAC;AACD,QAAI,CAAC,QAAQ;AACT,aAAO,EAAE,OAAO;AAAA,IACpB;AACA,QAAI,UAAU;AACV,gCAA0B,SAAS,IAAI,IAAI,SAAS;AACpD,cAAQ,QAAQ,QAAQ,GAAG,OAAO,YAAY,SAAS,IAAI,OAAO,cAAc,SAAS,KAAK,CAAC,EAAE;AAAA,IACrG;AAAA,EACJ;AACA,SAAO,EAAE,QAAQ,MAAM,iBAAiB,0BAA0B;AACtE,GAnBkC;;;AiBFlC;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,qBAAqB,wBAAC,SAAS,YAAY,OAAO,QAAQ,OAAO,EAAE,OAAO,CAAC,KAAK,CAAC,WAAW,SAAS,OAAO;AAAA,EACrH,GAAG;AAAA,EACH,CAAC,SAAS,GAAG,UAAU,IAAI,CAAC,mBAAmB;AAC3C,UAAM,gBAAgB,mBAAmB,gBAAgB,sBAAsB,OAAO;AACtF,QAAI,OAAO,kBAAkB,UAAU;AACnC,YAAM,IAAI,cAAc,WAAW,SAAS,YAAY,aAAa,mBAAmB;AAAA,IAC5F;AACA,WAAO;AAAA,EACX,CAAC;AACL,IAAI,CAAC,CAAC,GAT4B;;;ACFlC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAGO,IAAM,sBAAsB,wBAAC,UAAU,YAAY;AACtD,MAAI,MAAM,QAAQ,QAAQ,GAAG;AACzB,WAAO,SAAS,IAAI,CAAC,kBAAkB,oBAAoB,eAAe,OAAO,CAAC;AAAA,EACtF;AACA,UAAQ,OAAO,UAAU;AAAA,IACrB,KAAK;AACD,aAAO,iBAAiB,UAAU,OAAO;AAAA,IAC7C,KAAK;AACD,UAAI,aAAa,MAAM;AACnB,cAAM,IAAI,cAAc,iCAAiC,QAAQ,EAAE;AAAA,MACvE;AACA,aAAO,sBAAsB,UAAU,OAAO;AAAA,IAClD,KAAK;AACD,aAAO;AAAA,IACX;AACI,YAAM,IAAI,cAAc,sCAAsC,OAAO,QAAQ,EAAE;AAAA,EACvF;AACJ,GAjBmC;;;ADF5B,IAAM,wBAAwB,wBAAC,YAAY,YAAY,OAAO,QAAQ,UAAU,EAAE,OAAO,CAAC,KAAK,CAAC,aAAa,WAAW,OAAO;AAAA,EAClI,GAAG;AAAA,EACH,CAAC,WAAW,GAAG,oBAAoB,aAAa,OAAO;AAC3D,IAAI,CAAC,CAAC,GAH+B;;;AEDrC;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,iBAAiB,wBAAC,aAAa,YAAY;AACpD,QAAM,aAAa,mBAAmB,aAAa,gBAAgB,OAAO;AAC1E,MAAI,OAAO,eAAe,UAAU;AAChC,QAAI;AACA,aAAO,IAAI,IAAI,UAAU;AAAA,IAC7B,SACOC,QAAO;AACV,cAAQ,MAAM,gCAAgC,UAAU,IAAIA,MAAK;AACjE,YAAMA;AAAA,IACV;AAAA,EACJ;AACA,QAAM,IAAI,cAAc,sCAAsC,OAAO,UAAU,EAAE;AACrF,GAZ8B;;;ArBGvB,IAAM,uBAAuB,wBAAC,cAAc,YAAY;AAC3D,QAAM,EAAE,YAAY,SAAS,IAAI;AACjC,QAAM,EAAE,QAAQ,gBAAgB,IAAI,mBAAmB,YAAY,OAAO;AAC1E,MAAI,CAAC,QAAQ;AACT;AAAA,EACJ;AACA,QAAM,sBAAsB;AAAA,IACxB,GAAG;AAAA,IACH,iBAAiB,EAAE,GAAG,QAAQ,iBAAiB,GAAG,gBAAgB;AAAA,EACtE;AACA,QAAM,EAAE,KAAK,YAAY,QAAQ,IAAI;AACrC,UAAQ,QAAQ,QAAQ,GAAG,OAAO,sCAAsC,cAAc,QAAQ,CAAC,EAAE;AACjG,SAAO;AAAA,IACH,GAAI,WAAW,UAAa;AAAA,MACxB,SAAS,mBAAmB,SAAS,mBAAmB;AAAA,IAC5D;AAAA,IACA,GAAI,cAAc,UAAa;AAAA,MAC3B,YAAY,sBAAsB,YAAY,mBAAmB;AAAA,IACrE;AAAA,IACA,KAAK,eAAe,KAAK,mBAAmB;AAAA,EAChD;AACJ,GArBoC;;;AsBLpC;AAAA;AAAA;AAAA;AAAAC;AAGO,IAAM,oBAAoB,wBAAC,WAAW,YAAY;AACrD,QAAM,EAAE,YAAY,OAAAC,OAAM,IAAI;AAC9B,QAAM,EAAE,QAAQ,gBAAgB,IAAI,mBAAmB,YAAY,OAAO;AAC1E,MAAI,CAAC,QAAQ;AACT;AAAA,EACJ;AACA,QAAM,IAAI,cAAc,mBAAmBA,QAAO,SAAS;AAAA,IACvD,GAAG;AAAA,IACH,iBAAiB,EAAE,GAAG,QAAQ,iBAAiB,GAAG,gBAAgB;AAAA,EACtE,CAAC,CAAC;AACN,GAViC;;;ACHjC;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,mBAAmB,wBAAC,UAAU,YAAY;AACnD,QAAM,EAAE,YAAY,MAAM,IAAI;AAC9B,QAAM,EAAE,QAAQ,gBAAgB,IAAI,mBAAmB,YAAY,OAAO;AAC1E,MAAI,CAAC,QAAQ;AACT;AAAA,EACJ;AACA,SAAO,cAAc,OAAO;AAAA,IACxB,GAAG;AAAA,IACH,iBAAiB,EAAE,GAAG,QAAQ,iBAAiB,GAAG,gBAAgB;AAAA,EACtE,CAAC;AACL,GAVgC;;;AxBEzB,IAAM,gBAAgB,wBAAC,OAAO,YAAY;AAC7C,aAAW,QAAQ,OAAO;AACtB,QAAI,KAAK,SAAS,YAAY;AAC1B,YAAM,sBAAsB,qBAAqB,MAAM,OAAO;AAC9D,UAAI,qBAAqB;AACrB,eAAO;AAAA,MACX;AAAA,IACJ,WACS,KAAK,SAAS,SAAS;AAC5B,wBAAkB,MAAM,OAAO;AAAA,IACnC,WACS,KAAK,SAAS,QAAQ;AAC3B,YAAM,sBAAsB,iBAAiB,MAAM,OAAO;AAC1D,UAAI,qBAAqB;AACrB,eAAO;AAAA,MACX;AAAA,IACJ,OACK;AACD,YAAM,IAAI,cAAc,0BAA0B,IAAI,EAAE;AAAA,IAC5D;AAAA,EACJ;AACA,QAAM,IAAI,cAAc,yBAAyB;AACrD,GAtB6B;;;AbDtB,IAAM,kBAAkB,wBAAC,eAAe,YAAY;AACvD,QAAM,EAAE,gBAAgB,QAAAC,QAAO,IAAI;AACnC,QAAM,EAAE,YAAY,MAAM,IAAI;AAC9B,UAAQ,QAAQ,QAAQ,GAAG,OAAO,4BAA4B,cAAc,cAAc,CAAC,EAAE;AAC7F,QAAM,oBAAoB,OAAO,QAAQ,UAAU,EAC9C,OAAO,CAAC,CAAC,EAAEC,EAAC,MAAMA,GAAE,WAAW,IAAI,EACnC,IAAI,CAAC,CAACC,IAAGD,EAAC,MAAM,CAACC,IAAGD,GAAE,OAAO,CAAC;AACnC,MAAI,kBAAkB,SAAS,GAAG;AAC9B,eAAW,CAAC,UAAU,iBAAiB,KAAK,mBAAmB;AAC3D,qBAAe,QAAQ,IAAI,eAAe,QAAQ,KAAK;AAAA,IAC3D;AAAA,EACJ;AACA,QAAM,iBAAiB,OAAO,QAAQ,UAAU,EAC3C,OAAO,CAAC,CAAC,EAAEA,EAAC,MAAMA,GAAE,QAAQ,EAC5B,IAAI,CAAC,CAACC,EAAC,MAAMA,EAAC;AACnB,aAAW,iBAAiB,gBAAgB;AACxC,QAAI,eAAe,aAAa,KAAK,MAAM;AACvC,YAAM,IAAI,cAAc,gCAAgC,aAAa,GAAG;AAAA,IAC5E;AAAA,EACJ;AACA,QAAM,WAAW,cAAc,OAAO,EAAE,gBAAgB,QAAAF,SAAQ,iBAAiB,CAAC,EAAE,CAAC;AACrF,UAAQ,QAAQ,QAAQ,GAAG,OAAO,uBAAuB,cAAc,QAAQ,CAAC,EAAE;AAClF,SAAO;AACX,GAvB+B;;;AsCH/B;AAAA;AAAA;AAAA;AAAAG;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ADEO,IAAM,4BAA4B,wBAAC,OAAO,kBAAkB,UAAU;AACzE,MAAI,iBAAiB;AACjB,eAAW,SAAS,MAAM,MAAM,GAAG,GAAG;AAClC,UAAI,CAAC,0BAA0B,KAAK,GAAG;AACnC,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACA,MAAI,CAAC,iBAAiB,KAAK,GAAG;AAC1B,WAAO;AAAA,EACX;AACA,MAAI,MAAM,SAAS,KAAK,MAAM,SAAS,IAAI;AACvC,WAAO;AAAA,EACX;AACA,MAAI,UAAU,MAAM,YAAY,GAAG;AAC/B,WAAO;AAAA,EACX;AACA,MAAI,YAAY,KAAK,GAAG;AACpB,WAAO;AAAA,EACX;AACA,SAAO;AACX,GAtByC;;;AEFzC;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAM,gBAAgB;AACtB,IAAM,qBAAqB;AACpB,IAAM,WAAW,wBAAC,UAAU;AAC/B,QAAM,WAAW,MAAM,MAAM,aAAa;AAC1C,MAAI,SAAS,SAAS;AAClB,WAAO;AACX,QAAM,CAAC,KAAKC,YAAW,SAAS,QAAQ,WAAW,GAAG,YAAY,IAAI;AACtE,MAAI,QAAQ,SAASA,eAAc,MAAM,YAAY,MAAM,aAAa,KAAK,aAAa,MAAM;AAC5F,WAAO;AACX,QAAM,aAAa,aAAa,IAAI,CAAC,aAAa,SAAS,MAAM,kBAAkB,CAAC,EAAE,KAAK;AAC3F,SAAO;AAAA,IACH,WAAAA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ,GAfwB;;;ACFxB;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA,EACI,YAAc,CAAC;AAAA,IACP,IAAM;AAAA,IACN,SAAW;AAAA,MACP,WAAa;AAAA,MACb,oBAAsB;AAAA,MACtB,sBAAwB;AAAA,MACxB,MAAQ;AAAA,MACR,mBAAqB;AAAA,MACrB,cAAgB;AAAA,IACpB;AAAA,IACA,aAAe;AAAA,IACf,SAAW;AAAA,MACP,cAAc;AAAA,QACV,aAAe;AAAA,MACnB;AAAA,MACA,aAAa;AAAA,QACT,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,MACA,cAAc;AAAA,QACV,aAAe;AAAA,MACnB;AAAA,MACA,cAAc;AAAA,QACV,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,MACA,cAAc;AAAA,QACV,aAAe;AAAA,MACnB;AAAA,MACA,gBAAgB;AAAA,QACZ,aAAe;AAAA,MACnB;AAAA,MACA,aAAa;AAAA,QACT,aAAe;AAAA,MACnB;AAAA,MACA,gBAAgB;AAAA,QACZ,aAAe;AAAA,MACnB;AAAA,MACA,gBAAgB;AAAA,QACZ,aAAe;AAAA,MACnB;AAAA,MACA,cAAc;AAAA,QACV,aAAe;AAAA,MACnB;AAAA,MACA,cAAc;AAAA,QACV,aAAe;AAAA,MACnB;AAAA,MACA,cAAc;AAAA,QACV,aAAe;AAAA,MACnB;AAAA,MACA,aAAa;AAAA,QACT,aAAe;AAAA,MACnB;AAAA,MACA,aAAa;AAAA,QACT,aAAe;AAAA,MACnB;AAAA,MACA,aAAa;AAAA,QACT,aAAe;AAAA,MACnB;AAAA,MACA,gBAAgB;AAAA,QACZ,aAAe;AAAA,MACnB;AAAA,MACA,gBAAgB;AAAA,QACZ,aAAe;AAAA,MACnB;AAAA,MACA,cAAc;AAAA,QACV,aAAe;AAAA,MACnB;AAAA,MACA,gBAAgB;AAAA,QACZ,aAAe;AAAA,MACnB;AAAA,MACA,aAAa;AAAA,QACT,aAAe;AAAA,MACnB;AAAA,MACA,aAAa;AAAA,QACT,aAAe;AAAA,MACnB;AAAA,MACA,aAAa;AAAA,QACT,aAAe;AAAA,MACnB;AAAA,MACA,aAAa;AAAA,QACT,aAAe;AAAA,MACnB;AAAA,MACA,aAAa;AAAA,QACT,aAAe;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ,GAAG;AAAA,IACC,IAAM;AAAA,IACN,SAAW;AAAA,MACP,WAAa;AAAA,MACb,oBAAsB;AAAA,MACtB,sBAAwB;AAAA,MACxB,MAAQ;AAAA,MACR,mBAAqB;AAAA,MACrB,cAAgB;AAAA,IACpB;AAAA,IACA,aAAe;AAAA,IACf,SAAW;AAAA,MACP,iBAAiB;AAAA,QACb,aAAe;AAAA,MACnB;AAAA,MACA,cAAc;AAAA,QACV,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ,GAAG;AAAA,IACC,IAAM;AAAA,IACN,SAAW;AAAA,MACP,WAAa;AAAA,MACb,oBAAsB;AAAA,MACtB,sBAAwB;AAAA,MACxB,MAAQ;AAAA,MACR,mBAAqB;AAAA,MACrB,cAAgB;AAAA,IACpB;AAAA,IACA,aAAe;AAAA,IACf,SAAW;AAAA,MACP,qBAAqB;AAAA,QACjB,aAAe;AAAA,MACnB;AAAA,MACA,iBAAiB;AAAA,QACb,aAAe;AAAA,MACnB;AAAA,MACA,iBAAiB;AAAA,QACb,aAAe;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ,GAAG;AAAA,IACC,IAAM;AAAA,IACN,SAAW;AAAA,MACP,WAAa;AAAA,MACb,oBAAsB;AAAA,MACtB,sBAAwB;AAAA,MACxB,MAAQ;AAAA,MACR,mBAAqB;AAAA,MACrB,cAAgB;AAAA,IACpB;AAAA,IACA,aAAe;AAAA,IACf,SAAW;AAAA,MACP,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,MACA,iBAAiB;AAAA,QACb,aAAe;AAAA,MACnB;AAAA,MACA,iBAAiB;AAAA,QACb,aAAe;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ,GAAG;AAAA,IACC,IAAM;AAAA,IACN,SAAW;AAAA,MACP,WAAa;AAAA,MACb,oBAAsB;AAAA,MACtB,sBAAwB;AAAA,MACxB,MAAQ;AAAA,MACR,mBAAqB;AAAA,MACrB,cAAgB;AAAA,IACpB;AAAA,IACA,aAAe;AAAA,IACf,SAAW;AAAA,MACP,oBAAoB;AAAA,QAChB,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ,GAAG;AAAA,IACC,IAAM;AAAA,IACN,SAAW;AAAA,MACP,WAAa;AAAA,MACb,oBAAsB;AAAA,MACtB,sBAAwB;AAAA,MACxB,MAAQ;AAAA,MACR,mBAAqB;AAAA,MACrB,cAAgB;AAAA,IACpB;AAAA,IACA,aAAe;AAAA,IACf,SAAW;AAAA,MACP,oBAAoB;AAAA,QAChB,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ,GAAG;AAAA,IACC,IAAM;AAAA,IACN,SAAW;AAAA,MACP,WAAa;AAAA,MACb,oBAAsB;AAAA,MACtB,sBAAwB;AAAA,MACxB,MAAQ;AAAA,MACR,mBAAqB;AAAA,MACrB,cAAgB;AAAA,IACpB;AAAA,IACA,aAAe;AAAA,IACf,SAAW;AAAA,MACP,oBAAoB;AAAA,QAChB,aAAe;AAAA,MACnB;AAAA,MACA,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,MACA,mBAAmB;AAAA,QACf,aAAe;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ,GAAG;AAAA,IACC,IAAM;AAAA,IACN,SAAW;AAAA,MACP,WAAa;AAAA,MACb,oBAAsB;AAAA,MACtB,sBAAwB;AAAA,MACxB,MAAQ;AAAA,MACR,mBAAqB;AAAA,MACrB,cAAgB;AAAA,IACpB;AAAA,IACA,aAAe;AAAA,IACf,SAAW;AAAA,MACP,kBAAkB;AAAA,QACd,aAAe;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ,CAAC;AAAA,EACL,SAAW;AACf;;;ADhQA,IAAI,yBAAyB;AAC7B,IAAI,0BAA0B;AACvB,IAAM,YAAY,wBAAC,UAAU;AAChC,QAAM,EAAE,WAAW,IAAI;AACvB,aAAWC,cAAa,YAAY;AAChC,UAAM,EAAE,SAAS,QAAQ,IAAIA;AAC7B,eAAW,CAAC,QAAQ,UAAU,KAAK,OAAO,QAAQ,OAAO,GAAG;AACxD,UAAI,WAAW,OAAO;AAClB,eAAO;AAAA,UACH,GAAG;AAAA,UACH,GAAG;AAAA,QACP;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACA,aAAWA,cAAa,YAAY;AAChC,UAAM,EAAE,aAAa,QAAQ,IAAIA;AACjC,QAAI,IAAI,OAAO,WAAW,EAAE,KAAK,KAAK,GAAG;AACrC,aAAO;AAAA,QACH,GAAG;AAAA,MACP;AAAA,IACJ;AAAA,EACJ;AACA,QAAM,oBAAoB,WAAW,KAAK,CAACA,eAAcA,WAAU,OAAO,KAAK;AAC/E,MAAI,CAAC,mBAAmB;AACpB,UAAM,IAAI,MAAM,mHACyC;AAAA,EAC7D;AACA,SAAO;AAAA,IACH,GAAG,kBAAkB;AAAA,EACzB;AACJ,GA7ByB;AAqClB,IAAM,qBAAqB,6BAAM,yBAAN;;;A/CpC3B,IAAM,uBAAuB;AAAA,EAChC;AAAA,EACA;AAAA,EACA;AACJ;AACA,wBAAwB,MAAM;;;AiDT9B;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,SAAS,qBAAqB,aAAa,SAAS,OAAO;AAC9D,MAAI,CAAC,YAAY,SAAS;AACtB,gBAAY,UAAU,CAAC;AAAA,EAC3B;AACA,cAAY,QAAQ,OAAO,IAAI;AAC/B,SAAO;AACX;AANgB;;;ACAhB;AAAA;AAAA;AAAA;AAAAC;AAAO,SAASC,YAAWC,UAAS,SAAS,OAAO;AAChD,MAAI,CAACA,SAAQ,mBAAmB;AAC5B,IAAAA,SAAQ,oBAAoB;AAAA,MACxB,UAAU,CAAC;AAAA,IACf;AAAA,EACJ,WACS,CAACA,SAAQ,kBAAkB,UAAU;AAC1C,IAAAA,SAAQ,kBAAkB,WAAW,CAAC;AAAA,EAC1C;AACA,EAAAA,SAAQ,kBAAkB,SAAS,OAAO,IAAI;AAClD;AAVgB,OAAAD,aAAA;;;ACAhB;AAAA;AAAA;AAAA;AAAAE;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,gBAAgB,wBAAC,aAAa,aAAa,WAAW,QAAQ,IAAI,SAAS,SAAS,QAAQ,SAAS,SAAS,OAAO,QAArG;;;ACD7B;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,uBAAuB,wBAAC,sBAAsB,IAAI,KAAK,KAAK,IAAI,IAAI,iBAAiB,GAA9D;;;ACApC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,gBAAgB,wBAAC,WAAW,sBAAsB,KAAK,IAAI,qBAAqB,iBAAiB,EAAE,QAAQ,IAAI,SAAS,KAAK,KAA7G;;;ADAtB,IAAM,8BAA8B,wBAAC,WAAW,6BAA6B;AAChF,QAAM,gBAAgB,KAAK,MAAM,SAAS;AAC1C,MAAI,cAAc,eAAe,wBAAwB,GAAG;AACxD,WAAO,gBAAgB,KAAK,IAAI;AAAA,EACpC;AACA,SAAO;AACX,GAN2C;;;AHC3C,IAAM,4BAA4B,wBAAC,MAAM,aAAa;AAClD,MAAI,CAAC,UAAU;AACX,UAAM,IAAI,MAAM,cAAc,IAAI,0CAA0C;AAAA,EAChF;AACA,SAAO;AACX,GALkC;AAM3B,IAAM,4BAA4B,8BAAO,sBAAsB;AAClE,QAAMC,WAAU,0BAA0B,WAAW,kBAAkB,OAAO;AAC9E,QAAMC,UAAS,0BAA0B,UAAU,kBAAkB,MAAM;AAC3E,QAAM,aAAaD,SAAQ,YAAY,YAAY,cAAc,CAAC;AAClE,QAAM,iBAAiB,0BAA0B,UAAUC,QAAO,MAAM;AACxE,QAAM,SAAS,MAAM,eAAe,UAAU;AAC9C,QAAM,gBAAgB,mBAAmB;AACzC,QAAM,mBAAmB,mBAAmB;AAC5C,QAAM,cAAc,mBAAmB;AACvC,SAAO;AAAA,IACH,QAAAA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ,GAhByC;AAiBlC,IAAM,oBAAN,MAAwB;AAAA,EAzB/B,OAyB+B;AAAA;AAAA;AAAA,EAC3B,MAAM,KAAK,aAAa,UAAU,mBAAmB;AACjD,QAAI,CAAC,YAAY,WAAW,WAAW,GAAG;AACtC,YAAM,IAAI,MAAM,sEAAsE;AAAA,IAC1F;AACA,UAAM,iBAAiB,MAAM,0BAA0B,iBAAiB;AACxE,UAAM,EAAE,QAAAA,SAAQ,OAAO,IAAI;AAC3B,QAAI,EAAE,eAAe,YAAY,IAAI;AACrC,UAAM,0BAA0B,kBAAkB;AAClD,QAAI,yBAAyB,aAAa,UAAU,IAAI,GAAG;AACvD,YAAM,CAAC,OAAO,MAAM,IAAI,wBAAwB;AAChD,UAAI,OAAO,SAAS,YAAY,QAAQ,SAAS,SAAS;AACtD,wBAAgB,QAAQ,iBAAiB;AACzC,sBAAc,QAAQ,eAAe;AAAA,MACzC;AAAA,IACJ;AACA,UAAM,gBAAgB,MAAM,OAAO,KAAK,aAAa;AAAA,MACjD,aAAa,qBAAqBA,QAAO,iBAAiB;AAAA,MAC1D;AAAA,MACA,gBAAgB;AAAA,IACpB,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,aAAa,mBAAmB;AAC5B,WAAO,CAACC,WAAU;AACd,YAAM,aAAaA,OAAM,cAAc,cAAcA,OAAM,SAAS;AACpE,UAAI,YAAY;AACZ,cAAMD,UAAS,0BAA0B,UAAU,kBAAkB,MAAM;AAC3E,cAAM,2BAA2BA,QAAO;AACxC,QAAAA,QAAO,oBAAoB,4BAA4B,YAAYA,QAAO,iBAAiB;AAC3F,cAAM,qBAAqBA,QAAO,sBAAsB;AACxD,YAAI,sBAAsBC,OAAM,WAAW;AACvC,UAAAA,OAAM,UAAU,qBAAqB;AAAA,QACzC;AAAA,MACJ;AACA,YAAMA;AAAA,IACV;AAAA,EACJ;AAAA,EACA,eAAe,cAAc,mBAAmB;AAC5C,UAAM,aAAa,cAAc,YAAY;AAC7C,QAAI,YAAY;AACZ,YAAMD,UAAS,0BAA0B,UAAU,kBAAkB,MAAM;AAC3E,MAAAA,QAAO,oBAAoB,4BAA4B,YAAYA,QAAO,iBAAiB;AAAA,IAC/F;AAAA,EACJ;AACJ;;;AKtEA;AAAA;AAAA;AAAA;AAAAE;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,UAAU,wBAAC,UAAU,WAAW,oBAAoB;AAC7D,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,aAAa;AACjB,QAAM,mBAAmB,mCAAY;AACjC,QAAI,CAAC,SAAS;AACV,gBAAU,SAAS;AAAA,IACvB;AACA,QAAI;AACA,iBAAW,MAAM;AACjB,kBAAY;AACZ,mBAAa;AAAA,IACjB,UACA;AACI,gBAAU;AAAA,IACd;AACA,WAAO;AAAA,EACX,GAbyB;AAczB,MAAI,cAAc,QAAW;AACzB,WAAO,OAAO,YAAY;AACtB,UAAI,CAAC,aAAa,SAAS,cAAc;AACrC,mBAAW,MAAM,iBAAiB;AAAA,MACtC;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO,OAAO,YAAY;AACtB,QAAI,CAAC,aAAa,SAAS,cAAc;AACrC,iBAAW,MAAM,iBAAiB;AAAA,IACtC;AACA,QAAI,YAAY;AACZ,aAAO;AAAA,IACX;AACA,QAAI,mBAAmB,CAAC,gBAAgB,QAAQ,GAAG;AAC/C,mBAAa;AACb,aAAO;AAAA,IACX;AACA,QAAI,UAAU,QAAQ,GAAG;AACrB,YAAM,iBAAiB;AACvB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACJ,GA5CuB;;;ACAvB;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,wBAAwB;AAC9B,IAAM,yBAAyB;AAC/B,IAAM,uBAAuB;AAC7B,IAAM,6BAA6B;AACnC,IAAM,sBAAsB;AAC5B,IAAM,wBAAwB;AAC9B,IAAM,oBAAoB;AAE1B,IAAM,cAAc;AACpB,IAAM,kBAAkB,qBAAqB,YAAY;AACzD,IAAM,cAAc;AACpB,IAAM,oBAAoB,CAAC,aAAa,iBAAiB,WAAW;AACpE,IAAM,mBAAmB,sBAAsB,YAAY;AAC3D,IAAM,gBAAgB;AACtB,IAAM,eAAe,kBAAkB,YAAY;AAEnD,IAAM,4BAA4B;AAAA,EACrC,eAAe;AAAA,EACf,iBAAiB;AAAA,EACjB,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,cAAc;AAAA,EACd,gBAAgB;AAAA,EAChB,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,IAAI;AAAA,EACJ,SAAS;AAAA,EACT,qBAAqB;AAAA,EACrB,SAAS;AAAA,EACT,cAAc;AAAA,EACd,mBAAmB;AACvB;AACO,IAAM,uBAAuB;AAC7B,IAAM,qBAAqB;AAE3B,IAAM,uBAAuB;AAE7B,IAAM,6BAA6B;AACnC,IAAM,mBAAmB;AACzB,IAAM,iBAAiB;AACvB,IAAM,sBAAsB;AAC5B,IAAM,oBAAoB,KAAK,KAAK,KAAK;;;AC1ChD;AAAA;AAAA;AAAA;AAAAC;AAGA,IAAM,kBAAkB,CAAC;AACzB,IAAM,aAAa,CAAC;AACb,IAAM,cAAc,wBAAC,WAAW,QAAQ,YAAY,GAAG,SAAS,IAAI,MAAM,IAAI,OAAO,IAAI,mBAAmB,IAAxF;AACpB,IAAM,gBAAgB,8BAAO,mBAAmB,aAAa,WAAW,QAAQ,YAAY;AAC/F,QAAM,YAAY,MAAM,KAAK,mBAAmB,YAAY,iBAAiB,YAAY,WAAW;AACpG,QAAM,WAAW,GAAG,SAAS,IAAI,MAAM,IAAI,OAAO,IAAI,MAAM,SAAS,CAAC,IAAI,YAAY,YAAY;AAClG,MAAI,YAAY,iBAAiB;AAC7B,WAAO,gBAAgB,QAAQ;AAAA,EACnC;AACA,aAAW,KAAK,QAAQ;AACxB,SAAO,WAAW,SAAS,gBAAgB;AACvC,WAAO,gBAAgB,WAAW,MAAM,CAAC;AAAA,EAC7C;AACA,MAAI,MAAM,OAAO,YAAY,eAAe;AAC5C,aAAW,YAAY,CAAC,WAAW,QAAQ,SAAS,mBAAmB,GAAG;AACtE,UAAM,MAAM,KAAK,mBAAmB,KAAK,QAAQ;AAAA,EACrD;AACA,SAAQ,gBAAgB,QAAQ,IAAI;AACxC,GAf6B;AAsB7B,IAAM,OAAO,wBAAC,MAAM,QAAQ,SAAS;AACjC,QAAM,OAAO,IAAI,KAAK,MAAM;AAC5B,OAAK,OAAO,aAAa,IAAI,CAAC;AAC9B,SAAO,KAAK,OAAO;AACvB,GAJa;;;AC5Bb;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,sBAAsB,wBAAC,EAAE,QAAQ,GAAG,mBAAmB,oBAAoB;AACpF,QAAM,YAAY,CAAC;AACnB,aAAW,cAAc,OAAO,KAAK,OAAO,EAAE,KAAK,GAAG;AAClD,QAAI,QAAQ,UAAU,KAAK,QAAW;AAClC;AAAA,IACJ;AACA,UAAM,sBAAsB,WAAW,YAAY;AACnD,QAAI,uBAAuB,6BACvB,mBAAmB,IAAI,mBAAmB,KAC1C,qBAAqB,KAAK,mBAAmB,KAC7C,mBAAmB,KAAK,mBAAmB,GAAG;AAC9C,UAAI,CAAC,mBAAoB,mBAAmB,CAAC,gBAAgB,IAAI,mBAAmB,GAAI;AACpF;AAAA,MACJ;AAAA,IACJ;AACA,cAAU,mBAAmB,IAAI,QAAQ,UAAU,EAAE,KAAK,EAAE,QAAQ,QAAQ,GAAG;AAAA,EACnF;AACA,SAAO;AACX,GAlBmC;;;ACDnC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,gBAAgB,wBAAC,QAAS,OAAO,gBAAgB,cAAc,eAAe,eACvF,OAAO,UAAU,SAAS,KAAK,GAAG,MAAM,wBADf;;;ADItB,IAAM,iBAAiB,8BAAO,EAAE,SAAS,KAAK,GAAG,oBAAoB;AACxE,aAAW,cAAc,OAAO,KAAK,OAAO,GAAG;AAC3C,QAAI,WAAW,YAAY,MAAM,eAAe;AAC5C,aAAO,QAAQ,UAAU;AAAA,IAC7B;AAAA,EACJ;AACA,MAAI,QAAQ,QAAW;AACnB,WAAO;AAAA,EACX,WACS,OAAO,SAAS,YAAY,YAAY,OAAO,IAAI,KAAK,cAAc,IAAI,GAAG;AAClF,UAAM,WAAW,IAAI,gBAAgB;AACrC,aAAS,OAAO,aAAa,IAAI,CAAC;AAClC,WAAO,MAAM,MAAM,SAAS,OAAO,CAAC;AAAA,EACxC;AACA,SAAO;AACX,GAf8B;;;AEJ9B;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,kBAAN,MAAsB;AAAA,EAF7B,OAE6B;AAAA;AAAA;AAAA,EACzB,OAAO,SAAS;AACZ,UAAM,SAAS,CAAC;AAChB,eAAW,cAAc,OAAO,KAAK,OAAO,GAAG;AAC3C,YAAM,QAAQ,SAAS,UAAU;AACjC,aAAO,KAAK,WAAW,KAAK,CAAC,MAAM,UAAU,CAAC,GAAG,OAAO,KAAK,kBAAkB,QAAQ,UAAU,CAAC,CAAC;AAAA,IACvG;AACA,UAAM,MAAM,IAAI,WAAW,OAAO,OAAO,CAAC,OAAO,UAAU,QAAQ,MAAM,YAAY,CAAC,CAAC;AACvF,QAAI,WAAW;AACf,eAAW,SAAS,QAAQ;AACxB,UAAI,IAAI,OAAO,QAAQ;AACvB,kBAAY,MAAM;AAAA,IACtB;AACA,WAAO;AAAA,EACX;AAAA,EACA,kBAAkB,QAAQ;AACtB,YAAQ,OAAO,MAAM;AAAA,MACjB,KAAK;AACD,eAAO,WAAW,KAAK,CAAC,OAAO,QAAQ,IAAI,CAAC,CAAC;AAAA,MACjD,KAAK;AACD,eAAO,WAAW,KAAK,CAAC,GAAG,OAAO,KAAK,CAAC;AAAA,MAC5C,KAAK;AACD,cAAM,YAAY,IAAI,SAAS,IAAI,YAAY,CAAC,CAAC;AACjD,kBAAU,SAAS,GAAG,CAAC;AACvB,kBAAU,SAAS,GAAG,OAAO,OAAO,KAAK;AACzC,eAAO,IAAI,WAAW,UAAU,MAAM;AAAA,MAC1C,KAAK;AACD,cAAM,UAAU,IAAI,SAAS,IAAI,YAAY,CAAC,CAAC;AAC/C,gBAAQ,SAAS,GAAG,CAAC;AACrB,gBAAQ,SAAS,GAAG,OAAO,OAAO,KAAK;AACvC,eAAO,IAAI,WAAW,QAAQ,MAAM;AAAA,MACxC,KAAK;AACD,cAAM,YAAY,IAAI,WAAW,CAAC;AAClC,kBAAU,CAAC,IAAI;AACf,kBAAU,IAAI,OAAO,MAAM,OAAO,CAAC;AACnC,eAAO;AAAA,MACX,KAAK;AACD,cAAM,UAAU,IAAI,SAAS,IAAI,YAAY,IAAI,OAAO,MAAM,UAAU,CAAC;AACzE,gBAAQ,SAAS,GAAG,CAAC;AACrB,gBAAQ,UAAU,GAAG,OAAO,MAAM,YAAY,KAAK;AACnD,cAAM,WAAW,IAAI,WAAW,QAAQ,MAAM;AAC9C,iBAAS,IAAI,OAAO,OAAO,CAAC;AAC5B,eAAO;AAAA,MACX,KAAK;AACD,cAAM,YAAY,SAAS,OAAO,KAAK;AACvC,cAAM,UAAU,IAAI,SAAS,IAAI,YAAY,IAAI,UAAU,UAAU,CAAC;AACtE,gBAAQ,SAAS,GAAG,CAAC;AACrB,gBAAQ,UAAU,GAAG,UAAU,YAAY,KAAK;AAChD,cAAM,WAAW,IAAI,WAAW,QAAQ,MAAM;AAC9C,iBAAS,IAAI,WAAW,CAAC;AACzB,eAAO;AAAA,MACX,KAAK;AACD,cAAM,UAAU,IAAI,WAAW,CAAC;AAChC,gBAAQ,CAAC,IAAI;AACb,gBAAQ,IAAI,MAAM,WAAW,OAAO,MAAM,QAAQ,CAAC,EAAE,OAAO,CAAC;AAC7D,eAAO;AAAA,MACX,KAAK;AACD,YAAI,CAAC,aAAa,KAAK,OAAO,KAAK,GAAG;AAClC,gBAAM,IAAI,MAAM,0BAA0B,OAAO,KAAK,EAAE;AAAA,QAC5D;AACA,cAAM,YAAY,IAAI,WAAW,EAAE;AACnC,kBAAU,CAAC,IAAI;AACf,kBAAU,IAAI,QAAQ,OAAO,MAAM,QAAQ,OAAO,EAAE,CAAC,GAAG,CAAC;AACzD,eAAO;AAAA,IACf;AAAA,EACJ;AACJ;AACA,IAAI;AAAA,CACH,SAAUC,oBAAmB;AAC1B,EAAAA,mBAAkBA,mBAAkB,UAAU,IAAI,CAAC,IAAI;AACvD,EAAAA,mBAAkBA,mBAAkB,WAAW,IAAI,CAAC,IAAI;AACxD,EAAAA,mBAAkBA,mBAAkB,MAAM,IAAI,CAAC,IAAI;AACnD,EAAAA,mBAAkBA,mBAAkB,OAAO,IAAI,CAAC,IAAI;AACpD,EAAAA,mBAAkBA,mBAAkB,SAAS,IAAI,CAAC,IAAI;AACtD,EAAAA,mBAAkBA,mBAAkB,MAAM,IAAI,CAAC,IAAI;AACnD,EAAAA,mBAAkBA,mBAAkB,WAAW,IAAI,CAAC,IAAI;AACxD,EAAAA,mBAAkBA,mBAAkB,QAAQ,IAAI,CAAC,IAAI;AACrD,EAAAA,mBAAkBA,mBAAkB,WAAW,IAAI,CAAC,IAAI;AACxD,EAAAA,mBAAkBA,mBAAkB,MAAM,IAAI,CAAC,IAAI;AACvD,GAAG,sBAAsB,oBAAoB,CAAC,EAAE;AAChD,IAAM,eAAe;AACd,IAAM,QAAN,MAAM,OAAM;AAAA,EAnFnB,OAmFmB;AAAA;AAAA;AAAA,EACf,YAAY,OAAO;AACf,SAAK,QAAQ;AACb,QAAI,MAAM,eAAe,GAAG;AACxB,YAAM,IAAI,MAAM,uCAAuC;AAAA,IAC3D;AAAA,EACJ;AAAA,EACA,OAAO,WAAW,QAAQ;AACtB,QAAI,SAAS,sBAAuB,SAAS,qBAAsB;AAC/D,YAAM,IAAI,MAAM,GAAG,MAAM,qEAAqE;AAAA,IAClG;AACA,UAAM,QAAQ,IAAI,WAAW,CAAC;AAC9B,aAASC,KAAI,GAAG,YAAY,KAAK,IAAI,KAAK,MAAM,MAAM,CAAC,GAAGA,KAAI,MAAM,YAAY,GAAGA,MAAK,aAAa,KAAK;AACtG,YAAMA,EAAC,IAAI;AAAA,IACf;AACA,QAAI,SAAS,GAAG;AACZ,aAAO,KAAK;AAAA,IAChB;AACA,WAAO,IAAI,OAAM,KAAK;AAAA,EAC1B;AAAA,EACA,UAAU;AACN,UAAM,QAAQ,KAAK,MAAM,MAAM,CAAC;AAChC,UAAM,WAAW,MAAM,CAAC,IAAI;AAC5B,QAAI,UAAU;AACV,aAAO,KAAK;AAAA,IAChB;AACA,WAAO,SAAS,MAAM,KAAK,GAAG,EAAE,KAAK,WAAW,KAAK;AAAA,EACzD;AAAA,EACA,WAAW;AACP,WAAO,OAAO,KAAK,QAAQ,CAAC;AAAA,EAChC;AACJ;AACA,SAAS,OAAO,OAAO;AACnB,WAASA,KAAI,GAAGA,KAAI,GAAGA,MAAK;AACxB,UAAMA,EAAC,KAAK;AAAA,EAChB;AACA,WAASA,KAAI,GAAGA,KAAI,IAAIA,MAAK;AACzB,UAAMA,EAAC;AACP,QAAI,MAAMA,EAAC,MAAM;AACb;AAAA,EACR;AACJ;AATS;;;ACnHT;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,YAAY,wBAAC,cAAc,YAAY;AAChD,iBAAe,aAAa,YAAY;AACxC,aAAW,cAAc,OAAO,KAAK,OAAO,GAAG;AAC3C,QAAI,iBAAiB,WAAW,YAAY,GAAG;AAC3C,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX,GARyB;;;ACAzB;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,qBAAqB,wBAAC,SAAS,UAAU,CAAC,MAAM;AACzD,QAAM,EAAE,SAAS,QAAQ,CAAC,EAAE,IAAI,YAAY,MAAM,OAAO;AACzD,aAAW,QAAQ,OAAO,KAAK,OAAO,GAAG;AACrC,UAAM,QAAQ,KAAK,YAAY;AAC/B,QAAK,MAAM,MAAM,GAAG,CAAC,MAAM,YAAY,CAAC,QAAQ,oBAAoB,IAAI,KAAK,KACzE,QAAQ,kBAAkB,IAAI,KAAK,GAAG;AACtC,YAAM,IAAI,IAAI,QAAQ,IAAI;AAC1B,aAAO,QAAQ,IAAI;AAAA,IACvB;AAAA,EACJ;AACA,SAAO;AAAA,IACH,GAAG;AAAA,IACH;AAAA,IACA;AAAA,EACJ;AACJ,GAfkC;;;ACDlC;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,iBAAiB,wBAAC,YAAY;AACvC,YAAU,YAAY,MAAM,OAAO;AACnC,aAAW,cAAc,OAAO,KAAK,QAAQ,OAAO,GAAG;AACnD,QAAI,kBAAkB,QAAQ,WAAW,YAAY,CAAC,IAAI,IAAI;AAC1D,aAAO,QAAQ,QAAQ,UAAU;AAAA,IACrC;AAAA,EACJ;AACA,SAAO;AACX,GAR8B;;;ACF9B;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,oBAAoB,wBAAC,EAAE,QAAQ,CAAC,EAAE,MAAM;AACjD,QAAM,OAAO,CAAC;AACd,QAAM,aAAa,CAAC;AACpB,aAAW,OAAO,OAAO,KAAK,KAAK,GAAG;AAClC,QAAI,IAAI,YAAY,MAAM,kBAAkB;AACxC;AAAA,IACJ;AACA,UAAM,aAAa,UAAU,GAAG;AAChC,SAAK,KAAK,UAAU;AACpB,UAAM,QAAQ,MAAM,GAAG;AACvB,QAAI,OAAO,UAAU,UAAU;AAC3B,iBAAW,UAAU,IAAI,GAAG,UAAU,IAAI,UAAU,KAAK,CAAC;AAAA,IAC9D,WACS,MAAM,QAAQ,KAAK,GAAG;AAC3B,iBAAW,UAAU,IAAI,MACpB,MAAM,CAAC,EACP,OAAO,CAAC,SAASC,WAAU,QAAQ,OAAO,CAAC,GAAG,UAAU,IAAI,UAAUA,MAAK,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EACpF,KAAK,EACL,KAAK,GAAG;AAAA,IACjB;AAAA,EACJ;AACA,SAAO,KACF,KAAK,EACL,IAAI,CAAC,QAAQ,WAAW,GAAG,CAAC,EAC5B,OAAO,CAACC,gBAAeA,WAAU,EACjC,KAAK,GAAG;AACjB,GA1BiC;;;ACFjC;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,UAAU,wBAACC,UAAS,OAAOA,KAAI,EACvC,YAAY,EACZ,QAAQ,aAAa,GAAG,GAFN;AAGhB,IAAM,SAAS,wBAACA,UAAS;AAC5B,MAAI,OAAOA,UAAS,UAAU;AAC1B,WAAO,IAAI,KAAKA,QAAO,GAAI;AAAA,EAC/B;AACA,MAAI,OAAOA,UAAS,UAAU;AAC1B,QAAI,OAAOA,KAAI,GAAG;AACd,aAAO,IAAI,KAAK,OAAOA,KAAI,IAAI,GAAI;AAAA,IACvC;AACA,WAAO,IAAI,KAAKA,KAAI;AAAA,EACxB;AACA,SAAOA;AACX,GAXsB;;;AFGf,IAAM,kBAAN,MAAsB;AAAA,EAN7B,OAM6B;AAAA;AAAA;AAAA,EACzB,YAAY,EAAE,eAAe,aAAa,QAAQ,SAAS,QAAQ,gBAAgB,KAAM,GAAG;AACxF,SAAK,UAAU;AACf,SAAK,SAAS;AACd,SAAK,gBAAgB;AACrB,SAAK,gBAAgB,OAAO,kBAAkB,YAAY,gBAAgB;AAC1E,SAAK,iBAAiB,kBAAkB,MAAM;AAC9C,SAAK,qBAAqB,kBAAkB,WAAW;AAAA,EAC3D;AAAA,EACA,uBAAuB,SAAS,kBAAkB,aAAa;AAC3D,UAAM,gBAAgB,OAAO,KAAK,gBAAgB,EAAE,KAAK;AACzD,WAAO,GAAG,QAAQ,MAAM;AAAA,EAC9B,KAAK,iBAAiB,OAAO,CAAC;AAAA,EAC9B,kBAAkB,OAAO,CAAC;AAAA,EAC1B,cAAc,IAAI,CAAC,SAAS,GAAG,IAAI,IAAI,iBAAiB,IAAI,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA,EAE3E,cAAc,KAAK,GAAG,CAAC;AAAA,EACvB,WAAW;AAAA,EACT;AAAA,EACA,MAAM,mBAAmB,UAAU,iBAAiB,kBAAkB,qBAAqB;AACvF,UAAM,OAAO,IAAI,KAAK,OAAO;AAC7B,SAAK,OAAO,aAAa,gBAAgB,CAAC;AAC1C,UAAM,gBAAgB,MAAM,KAAK,OAAO;AACxC,WAAO,GAAG,mBAAmB;AAAA,EACnC,QAAQ;AAAA,EACR,eAAe;AAAA,EACf,MAAM,aAAa,CAAC;AAAA,EAClB;AAAA,EACA,iBAAiB,EAAE,KAAK,GAAG;AACvB,QAAI,KAAK,eAAe;AACpB,YAAM,yBAAyB,CAAC;AAChC,iBAAW,eAAe,KAAK,MAAM,GAAG,GAAG;AACvC,YAAI,aAAa,WAAW;AACxB;AACJ,YAAI,gBAAgB;AAChB;AACJ,YAAI,gBAAgB,MAAM;AACtB,iCAAuB,IAAI;AAAA,QAC/B,OACK;AACD,iCAAuB,KAAK,WAAW;AAAA,QAC3C;AAAA,MACJ;AACA,YAAM,iBAAiB,GAAG,MAAM,WAAW,GAAG,IAAI,MAAM,EAAE,GAAG,uBAAuB,KAAK,GAAG,CAAC,GAAG,uBAAuB,SAAS,KAAK,MAAM,SAAS,GAAG,IAAI,MAAM,EAAE;AACnK,YAAM,gBAAgB,UAAU,cAAc;AAC9C,aAAO,cAAc,QAAQ,QAAQ,GAAG;AAAA,IAC5C;AACA,WAAO;AAAA,EACX;AAAA,EACA,4BAA4B,aAAa;AACrC,QAAI,OAAO,gBAAgB,YACvB,OAAO,YAAY,gBAAgB,YACnC,OAAO,YAAY,oBAAoB,UAAU;AACjD,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC7D;AAAA,EACJ;AAAA,EACA,WAAW,KAAK;AACZ,UAAM,WAAW,QAAQ,GAAG,EAAE,QAAQ,UAAU,EAAE;AAClD,WAAO;AAAA,MACH;AAAA,MACA,WAAW,SAAS,MAAM,GAAG,CAAC;AAAA,IAClC;AAAA,EACJ;AAAA,EACA,uBAAuB,SAAS;AAC5B,WAAO,OAAO,KAAK,OAAO,EAAE,KAAK,EAAE,KAAK,GAAG;AAAA,EAC/C;AACJ;;;AV7DO,IAAM,cAAN,cAA0B,gBAAgB;AAAA,EAXjD,OAWiD;AAAA;AAAA;AAAA,EAC7C,YAAY,EAAE,eAAe,aAAa,QAAQ,SAAS,QAAQ,gBAAgB,KAAM,GAAG;AACxF,UAAM;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ,CAAC;AACD,SAAK,kBAAkB,IAAI,gBAAgB;AAAA,EAC/C;AAAA,EACA,MAAM,QAAQ,iBAAiB,UAAU,CAAC,GAAG;AACzC,UAAM,EAAE,cAAc,oBAAI,KAAK,GAAG,YAAY,MAAM,mBAAmB,oBAAoB,iBAAiB,kBAAkB,eAAe,eAAgB,IAAI;AACjK,UAAM,cAAc,MAAM,KAAK,mBAAmB;AAClD,SAAK,4BAA4B,WAAW;AAC5C,UAAM,SAAS,iBAAkB,MAAM,KAAK,eAAe;AAC3D,UAAM,EAAE,UAAU,UAAU,IAAI,KAAK,WAAW,WAAW;AAC3D,QAAI,YAAY,mBAAmB;AAC/B,aAAO,QAAQ,OAAO,kGAA4G;AAAA,IACtI;AACA,UAAM,QAAQ,YAAY,WAAW,QAAQ,kBAAkB,KAAK,OAAO;AAC3E,UAAM,UAAU,mBAAmB,eAAe,eAAe,GAAG,EAAE,oBAAoB,iBAAiB,CAAC;AAC5G,QAAI,YAAY,cAAc;AAC1B,cAAQ,MAAM,iBAAiB,IAAI,YAAY;AAAA,IACnD;AACA,YAAQ,MAAM,qBAAqB,IAAI;AACvC,YAAQ,MAAM,sBAAsB,IAAI,GAAG,YAAY,WAAW,IAAI,KAAK;AAC3E,YAAQ,MAAM,oBAAoB,IAAI;AACtC,YAAQ,MAAM,mBAAmB,IAAI,UAAU,SAAS,EAAE;AAC1D,UAAM,mBAAmB,oBAAoB,SAAS,mBAAmB,eAAe;AACxF,YAAQ,MAAM,0BAA0B,IAAI,KAAK,uBAAuB,gBAAgB;AACxF,YAAQ,MAAM,qBAAqB,IAAI,MAAM,KAAK,aAAa,UAAU,OAAO,KAAK,cAAc,aAAa,QAAQ,WAAW,cAAc,GAAG,KAAK,uBAAuB,SAAS,kBAAkB,MAAM,eAAe,iBAAiB,KAAK,MAAM,CAAC,CAAC;AAC9P,WAAO;AAAA,EACX;AAAA,EACA,MAAM,KAAK,QAAQ,SAAS;AACxB,QAAI,OAAO,WAAW,UAAU;AAC5B,aAAO,KAAK,WAAW,QAAQ,OAAO;AAAA,IAC1C,WACS,OAAO,WAAW,OAAO,SAAS;AACvC,aAAO,KAAK,UAAU,QAAQ,OAAO;AAAA,IACzC,WACS,OAAO,SAAS;AACrB,aAAO,KAAK,YAAY,QAAQ,OAAO;AAAA,IAC3C,OACK;AACD,aAAO,KAAK,YAAY,QAAQ,OAAO;AAAA,IAC3C;AAAA,EACJ;AAAA,EACA,MAAM,UAAU,EAAE,SAAS,QAAQ,GAAG,EAAE,cAAc,oBAAI,KAAK,GAAG,gBAAgB,eAAe,eAAe,GAAG;AAC/G,UAAM,SAAS,iBAAkB,MAAM,KAAK,eAAe;AAC3D,UAAM,EAAE,WAAW,SAAS,IAAI,KAAK,WAAW,WAAW;AAC3D,UAAM,QAAQ,YAAY,WAAW,QAAQ,kBAAkB,KAAK,OAAO;AAC3E,UAAM,gBAAgB,MAAM,eAAe,EAAE,SAAS,CAAC,GAAG,MAAM,QAAQ,GAAG,KAAK,MAAM;AACtF,UAAM,OAAO,IAAI,KAAK,OAAO;AAC7B,SAAK,OAAO,OAAO;AACnB,UAAM,gBAAgB,MAAM,MAAM,KAAK,OAAO,CAAC;AAC/C,UAAM,eAAe;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ,EAAE,KAAK,IAAI;AACX,WAAO,KAAK,WAAW,cAAc,EAAE,aAAa,eAAe,QAAQ,eAAe,CAAC;AAAA,EAC/F;AAAA,EACA,MAAM,YAAY,iBAAiB,EAAE,cAAc,oBAAI,KAAK,GAAG,eAAe,eAAe,GAAG;AAC5F,UAAM,UAAU,KAAK,UAAU;AAAA,MAC3B,SAAS,KAAK,gBAAgB,OAAO,gBAAgB,QAAQ,OAAO;AAAA,MACpE,SAAS,gBAAgB,QAAQ;AAAA,IACrC,GAAG;AAAA,MACC;AAAA,MACA;AAAA,MACA;AAAA,MACA,gBAAgB,gBAAgB;AAAA,IACpC,CAAC;AACD,WAAO,QAAQ,KAAK,CAAC,cAAc;AAC/B,aAAO,EAAE,SAAS,gBAAgB,SAAS,UAAU;AAAA,IACzD,CAAC;AAAA,EACL;AAAA,EACA,MAAM,WAAW,cAAc,EAAE,cAAc,oBAAI,KAAK,GAAG,eAAe,eAAe,IAAI,CAAC,GAAG;AAC7F,UAAM,cAAc,MAAM,KAAK,mBAAmB;AAClD,SAAK,4BAA4B,WAAW;AAC5C,UAAM,SAAS,iBAAkB,MAAM,KAAK,eAAe;AAC3D,UAAM,EAAE,UAAU,IAAI,KAAK,WAAW,WAAW;AACjD,UAAM,OAAO,IAAI,KAAK,OAAO,MAAM,KAAK,cAAc,aAAa,QAAQ,WAAW,cAAc,CAAC;AACrG,SAAK,OAAO,aAAa,YAAY,CAAC;AACtC,WAAO,MAAM,MAAM,KAAK,OAAO,CAAC;AAAA,EACpC;AAAA,EACA,MAAM,YAAY,eAAe,EAAE,cAAc,oBAAI,KAAK,GAAG,iBAAiB,mBAAmB,eAAe,eAAgB,IAAI,CAAC,GAAG;AACpI,UAAM,cAAc,MAAM,KAAK,mBAAmB;AAClD,SAAK,4BAA4B,WAAW;AAC5C,UAAM,SAAS,iBAAkB,MAAM,KAAK,eAAe;AAC3D,UAAM,UAAU,eAAe,aAAa;AAC5C,UAAM,EAAE,UAAU,UAAU,IAAI,KAAK,WAAW,WAAW;AAC3D,UAAM,QAAQ,YAAY,WAAW,QAAQ,kBAAkB,KAAK,OAAO;AAC3E,YAAQ,QAAQ,eAAe,IAAI;AACnC,QAAI,YAAY,cAAc;AAC1B,cAAQ,QAAQ,YAAY,IAAI,YAAY;AAAA,IAChD;AACA,UAAM,cAAc,MAAM,eAAe,SAAS,KAAK,MAAM;AAC7D,QAAI,CAAC,UAAU,eAAe,QAAQ,OAAO,KAAK,KAAK,eAAe;AAClE,cAAQ,QAAQ,aAAa,IAAI;AAAA,IACrC;AACA,UAAM,mBAAmB,oBAAoB,SAAS,mBAAmB,eAAe;AACxF,UAAM,YAAY,MAAM,KAAK,aAAa,UAAU,OAAO,KAAK,cAAc,aAAa,QAAQ,WAAW,cAAc,GAAG,KAAK,uBAAuB,SAAS,kBAAkB,WAAW,CAAC;AAClM,YAAQ,QAAQ,WAAW,IACvB,GAAG,oBAAoB,eACL,YAAY,WAAW,IAAI,KAAK,mBAC7B,KAAK,uBAAuB,gBAAgB,CAAC,eACjD,SAAS;AAC9B,WAAO;AAAA,EACX;AAAA,EACA,MAAM,aAAa,UAAU,iBAAiB,YAAY,kBAAkB;AACxE,UAAM,eAAe,MAAM,KAAK,mBAAmB,UAAU,iBAAiB,kBAAkB,oBAAoB;AACpH,UAAM,OAAO,IAAI,KAAK,OAAO,MAAM,UAAU;AAC7C,SAAK,OAAO,aAAa,YAAY,CAAC;AACtC,WAAO,MAAM,MAAM,KAAK,OAAO,CAAC;AAAA,EACpC;AAAA,EACA,cAAc,aAAa,QAAQ,WAAW,SAAS;AACnD,WAAO,cAAc,KAAK,QAAQ,aAAa,WAAW,QAAQ,WAAW,KAAK,OAAO;AAAA,EAC7F;AACJ;;;AatIA;AAAA;AAAA;AAAA;AAAAC;;;AfGO,IAAM,2BAA2B,wBAACC,YAAW;AAChD,MAAI,mBAAmBA,QAAO;AAC9B,MAAI,iBAAiB,CAAC,CAACA,QAAO;AAC9B,MAAI,sBAAsB;AAC1B,SAAO,eAAeA,SAAQ,eAAe;AAAA,IACzC,IAAI,aAAa;AACb,UAAI,eAAe,gBAAgB,oBAAoB,gBAAgB,qBAAqB;AACxF,yBAAiB;AAAA,MACrB;AACA,yBAAmB;AACnB,YAAM,mBAAmB,4BAA4BA,SAAQ;AAAA,QACzD,aAAa;AAAA,QACb,2BAA2BA,QAAO;AAAA,MACtC,CAAC;AACD,YAAM,gBAAgB,iBAAiBA,SAAQ,gBAAgB;AAC/D,UAAI,kBAAkB,CAAC,cAAc,YAAY;AAC7C,8BAAsB,8BAAO,YAAY,cAAc,OAAO,EAAE,KAAK,CAAC,UAAU,qBAAqB,OAAO,oBAAoB,GAAG,CAAC,GAA9G;AACtB,4BAAoB,WAAW,cAAc;AAC7C,4BAAoB,cAAc,cAAc;AAChD,4BAAoB,aAAa;AAAA,MACrC,OACK;AACD,8BAAsB;AAAA,MAC1B;AAAA,IACJ;AAAA,IACA,MAAM;AACF,aAAO;AAAA,IACX;AAAA,IACA,YAAY;AAAA,IACZ,cAAc;AAAA,EAClB,CAAC;AACD,EAAAA,QAAO,cAAc;AACrB,QAAM,EAAE,oBAAoB,MAAM,oBAAoBA,QAAO,qBAAqB,GAAG,OAAQ,IAAIA;AACjG,MAAI;AACJ,MAAIA,QAAO,QAAQ;AACf,aAASC,mBAAkBD,QAAO,MAAM;AAAA,EAC5C,WACSA,QAAO,oBAAoB;AAChC,aAAS,6BAAMC,mBAAkBD,QAAO,MAAM,EAAE,EAC3C,KAAK,OAAO,WAAW;AAAA,MACvB,MAAMA,QAAO,mBAAmB,QAAQ;AAAA,QACrC,iBAAiB,MAAMA,QAAO,gBAAgB;AAAA,QAC9C,sBAAsB,MAAMA,QAAO,qBAAqB;AAAA,MAC5D,CAAC,KAAM,CAAC;AAAA,MACR;AAAA,IACJ,CAAC,EACI,KAAK,CAAC,CAAC,YAAY,MAAM,MAAM;AAChC,YAAM,EAAE,eAAe,eAAe,IAAI;AAC1C,MAAAA,QAAO,gBAAgBA,QAAO,iBAAiB,iBAAiB;AAChE,MAAAA,QAAO,cAAcA,QAAO,eAAe,kBAAkBA,QAAO;AACpE,YAAM,SAAS;AAAA,QACX,GAAGA;AAAA,QACH,aAAaA,QAAO;AAAA,QACpB,QAAQA,QAAO;AAAA,QACf,SAASA,QAAO;AAAA,QAChB;AAAA,QACA,eAAe;AAAA,MACnB;AACA,YAAM,aAAaA,QAAO,qBAAqB;AAC/C,aAAO,IAAI,WAAW,MAAM;AAAA,IAChC,CAAC,GAtBQ;AAAA,EAuBb,OACK;AACD,aAAS,8BAAO,eAAe;AAC3B,mBAAa,OAAO,OAAO,CAAC,GAAG;AAAA,QAC3B,MAAM;AAAA,QACN,aAAaA,QAAO,eAAeA,QAAO;AAAA,QAC1C,eAAe,MAAMC,mBAAkBD,QAAO,MAAM,EAAE;AAAA,QACtD,YAAY,CAAC;AAAA,MACjB,GAAG,UAAU;AACb,YAAM,gBAAgB,WAAW;AACjC,YAAM,iBAAiB,WAAW;AAClC,MAAAA,QAAO,gBAAgBA,QAAO,iBAAiB;AAC/C,MAAAA,QAAO,cAAcA,QAAO,eAAe,kBAAkBA,QAAO;AACpE,YAAM,SAAS;AAAA,QACX,GAAGA;AAAA,QACH,aAAaA,QAAO;AAAA,QACpB,QAAQA,QAAO;AAAA,QACf,SAASA,QAAO;AAAA,QAChB;AAAA,QACA,eAAe;AAAA,MACnB;AACA,YAAM,aAAaA,QAAO,qBAAqB;AAC/C,aAAO,IAAI,WAAW,MAAM;AAAA,IAChC,GArBS;AAAA,EAsBb;AACA,QAAM,iBAAiB,OAAO,OAAOA,SAAQ;AAAA,IACzC;AAAA,IACA;AAAA,IACA;AAAA,EACJ,CAAC;AACD,SAAO;AACX,GA5FwC;AA8FxC,SAAS,4BAA4BE,SAAQ,EAAE,aAAa,0BAA2B,GAAG;AACtF,MAAI;AACJ,MAAI,aAAa;AACb,QAAI,CAAC,aAAa,UAAU;AACxB,4BAAsB,wBAAwB,aAAa,mBAAmB,0BAA0B;AAAA,IAC5G,OACK;AACD,4BAAsB;AAAA,IAC1B;AAAA,EACJ,OACK;AACD,QAAI,2BAA2B;AAC3B,4BAAsBC,mBAAkB,0BAA0B,OAAO,OAAO,CAAC,GAAGD,SAAQ;AAAA,QACxF,oBAAoBA;AAAA,MACxB,CAAC,CAAC,CAAC;AAAA,IACP,OACK;AACD,4BAAsB,mCAAY;AAC9B,cAAM,IAAI,MAAM,uHAAuH;AAAA,MAC3I,GAFsB;AAAA,IAG1B;AAAA,EACJ;AACA,sBAAoB,WAAW;AAC/B,SAAO;AACX;AAxBS;AAyBT,SAAS,iBAAiBA,SAAQ,qBAAqB;AACnD,MAAI,oBAAoB,aAAa;AACjC,WAAO;AAAA,EACX;AACA,QAAM,KAAK,8BAAO,YAAY,oBAAoB,EAAE,GAAG,SAAS,oBAAoBA,QAAO,CAAC,GAAjF;AACX,KAAG,WAAW,oBAAoB;AAClC,KAAG,cAAc;AACjB,SAAO;AACX;AARS;;;AgB1HT;AAAA;AAAA;AAAA;AAAAE;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAM,gBAAgB,wBAAC,MAAM,YAAY;AACrC,QAAM,WAAW,CAAC;AAClB,MAAI,MAAM;AACN,aAAS,KAAK,IAAI;AAAA,EACtB;AACA,MAAI,SAAS;AACT,eAAW,SAAS,SAAS;AACzB,eAAS,KAAK,KAAK;AAAA,IACvB;AAAA,EACJ;AACA,SAAO;AACX,GAXsB;AAYtB,IAAM,+BAA+B,wBAAC,MAAM,YAAY;AACpD,SAAO,GAAG,QAAQ,WAAW,GAAG,WAAW,QAAQ,SAAS,IAAI,YAAY,QAAQ,KAAK,GAAG,CAAC,MAAM,EAAE;AACzG,GAFqC;AAG9B,IAAM,iBAAiB,6BAAM;AAChC,MAAI,kBAAkB,CAAC;AACvB,MAAI,kBAAkB,CAAC;AACvB,MAAI,oBAAoB;AACxB,QAAM,iBAAiB,oBAAI,IAAI;AAC/B,QAAM,OAAO,wBAAC,YAAY,QAAQ,KAAK,CAACC,IAAGC,OAAM,YAAYA,GAAE,IAAI,IAAI,YAAYD,GAAE,IAAI,KACrF,gBAAgBC,GAAE,YAAY,QAAQ,IAAI,gBAAgBD,GAAE,YAAY,QAAQ,CAAC,GADxE;AAEb,QAAM,eAAe,wBAAC,aAAa;AAC/B,QAAI,YAAY;AAChB,UAAM,WAAW,wBAAC,UAAU;AACxB,YAAM,UAAU,cAAc,MAAM,MAAM,MAAM,OAAO;AACvD,UAAI,QAAQ,SAAS,QAAQ,GAAG;AAC5B,oBAAY;AACZ,mBAAW,SAAS,SAAS;AACzB,yBAAe,OAAO,KAAK;AAAA,QAC/B;AACA,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX,GAViB;AAWjB,sBAAkB,gBAAgB,OAAO,QAAQ;AACjD,sBAAkB,gBAAgB,OAAO,QAAQ;AACjD,WAAO;AAAA,EACX,GAhBqB;AAiBrB,QAAM,oBAAoB,wBAAC,aAAa;AACpC,QAAI,YAAY;AAChB,UAAM,WAAW,wBAAC,UAAU;AACxB,UAAI,MAAM,eAAe,UAAU;AAC/B,oBAAY;AACZ,mBAAW,SAAS,cAAc,MAAM,MAAM,MAAM,OAAO,GAAG;AAC1D,yBAAe,OAAO,KAAK;AAAA,QAC/B;AACA,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX,GATiB;AAUjB,sBAAkB,gBAAgB,OAAO,QAAQ;AACjD,sBAAkB,gBAAgB,OAAO,QAAQ;AACjD,WAAO;AAAA,EACX,GAf0B;AAgB1B,QAAM,UAAU,wBAAC,YAAY;AACzB,oBAAgB,QAAQ,CAAC,UAAU;AAC/B,cAAQ,IAAI,MAAM,YAAY,EAAE,GAAG,MAAM,CAAC;AAAA,IAC9C,CAAC;AACD,oBAAgB,QAAQ,CAAC,UAAU;AAC/B,cAAQ,cAAc,MAAM,YAAY,EAAE,GAAG,MAAM,CAAC;AAAA,IACxD,CAAC;AACD,YAAQ,oBAAoB,MAAM,kBAAkB,CAAC;AACrD,WAAO;AAAA,EACX,GATgB;AAUhB,QAAM,+BAA+B,wBAAC,SAAS;AAC3C,UAAM,yBAAyB,CAAC;AAChC,SAAK,OAAO,QAAQ,CAAC,UAAU;AAC3B,UAAI,MAAM,OAAO,WAAW,KAAK,MAAM,MAAM,WAAW,GAAG;AACvD,+BAAuB,KAAK,KAAK;AAAA,MACrC,OACK;AACD,+BAAuB,KAAK,GAAG,6BAA6B,KAAK,CAAC;AAAA,MACtE;AAAA,IACJ,CAAC;AACD,2BAAuB,KAAK,IAAI;AAChC,SAAK,MAAM,QAAQ,EAAE,QAAQ,CAAC,UAAU;AACpC,UAAI,MAAM,OAAO,WAAW,KAAK,MAAM,MAAM,WAAW,GAAG;AACvD,+BAAuB,KAAK,KAAK;AAAA,MACrC,OACK;AACD,+BAAuB,KAAK,GAAG,6BAA6B,KAAK,CAAC;AAAA,MACtE;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX,GApBqC;AAqBrC,QAAM,oBAAoB,wBAACE,SAAQ,UAAU;AACzC,UAAM,4BAA4B,CAAC;AACnC,UAAM,4BAA4B,CAAC;AACnC,UAAM,2BAA2B,CAAC;AAClC,oBAAgB,QAAQ,CAAC,UAAU;AAC/B,YAAM,kBAAkB;AAAA,QACpB,GAAG;AAAA,QACH,QAAQ,CAAC;AAAA,QACT,OAAO,CAAC;AAAA,MACZ;AACA,iBAAW,SAAS,cAAc,gBAAgB,MAAM,gBAAgB,OAAO,GAAG;AAC9E,iCAAyB,KAAK,IAAI;AAAA,MACtC;AACA,gCAA0B,KAAK,eAAe;AAAA,IAClD,CAAC;AACD,oBAAgB,QAAQ,CAAC,UAAU;AAC/B,YAAM,kBAAkB;AAAA,QACpB,GAAG;AAAA,QACH,QAAQ,CAAC;AAAA,QACT,OAAO,CAAC;AAAA,MACZ;AACA,iBAAW,SAAS,cAAc,gBAAgB,MAAM,gBAAgB,OAAO,GAAG;AAC9E,iCAAyB,KAAK,IAAI;AAAA,MACtC;AACA,gCAA0B,KAAK,eAAe;AAAA,IAClD,CAAC;AACD,8BAA0B,QAAQ,CAAC,UAAU;AACzC,UAAI,MAAM,cAAc;AACpB,cAAM,eAAe,yBAAyB,MAAM,YAAY;AAChE,YAAI,iBAAiB,QAAW;AAC5B,cAAIA,QAAO;AACP;AAAA,UACJ;AACA,gBAAM,IAAI,MAAM,GAAG,MAAM,YAAY,6BAC9B,6BAA6B,MAAM,MAAM,MAAM,OAAO,CAAC,eAC5C,MAAM,QAAQ,IAAI,MAAM,YAAY,EAAE;AAAA,QAC5D;AACA,YAAI,MAAM,aAAa,SAAS;AAC5B,uBAAa,MAAM,KAAK,KAAK;AAAA,QACjC;AACA,YAAI,MAAM,aAAa,UAAU;AAC7B,uBAAa,OAAO,KAAK,KAAK;AAAA,QAClC;AAAA,MACJ;AAAA,IACJ,CAAC;AACD,UAAM,YAAY,KAAK,yBAAyB,EAC3C,IAAI,4BAA4B,EAChC,OAAO,CAAC,WAAW,2BAA2B;AAC/C,gBAAU,KAAK,GAAG,sBAAsB;AACxC,aAAO;AAAA,IACX,GAAG,CAAC,CAAC;AACL,WAAO;AAAA,EACX,GApD0B;AAqD1B,QAAM,QAAQ;AAAA,IACV,KAAK,wBAAC,YAAY,UAAU,CAAC,MAAM;AAC/B,YAAM,EAAE,MAAM,UAAU,SAAS,SAAS,IAAI;AAC9C,YAAM,QAAQ;AAAA,QACV,MAAM;AAAA,QACN,UAAU;AAAA,QACV;AAAA,QACA,GAAG;AAAA,MACP;AACA,YAAM,UAAU,cAAc,MAAM,QAAQ;AAC5C,UAAI,QAAQ,SAAS,GAAG;AACpB,YAAI,QAAQ,KAAK,CAAC,UAAU,eAAe,IAAI,KAAK,CAAC,GAAG;AACpD,cAAI,CAAC;AACD,kBAAM,IAAI,MAAM,8BAA8B,6BAA6B,MAAM,QAAQ,CAAC,GAAG;AACjG,qBAAW,SAAS,SAAS;AACzB,kBAAM,kBAAkB,gBAAgB,UAAU,CAACC,WAAUA,OAAM,SAAS,SAASA,OAAM,SAAS,KAAK,CAACH,OAAMA,OAAM,KAAK,CAAC;AAC5H,gBAAI,oBAAoB,IAAI;AACxB;AAAA,YACJ;AACA,kBAAM,aAAa,gBAAgB,eAAe;AAClD,gBAAI,WAAW,SAAS,MAAM,QAAQ,MAAM,aAAa,WAAW,UAAU;AAC1E,oBAAM,IAAI,MAAM,IAAI,6BAA6B,WAAW,MAAM,WAAW,OAAO,CAAC,qBAC9E,WAAW,QAAQ,gBAAgB,WAAW,IAAI,kCAChC,6BAA6B,MAAM,QAAQ,CAAC,qBAC9D,MAAM,QAAQ,gBAAgB,MAAM,IAAI,QAAQ;AAAA,YAC3D;AACA,4BAAgB,OAAO,iBAAiB,CAAC;AAAA,UAC7C;AAAA,QACJ;AACA,mBAAW,SAAS,SAAS;AACzB,yBAAe,IAAI,KAAK;AAAA,QAC5B;AAAA,MACJ;AACA,sBAAgB,KAAK,KAAK;AAAA,IAC9B,GAjCK;AAAA,IAkCL,eAAe,wBAAC,YAAY,YAAY;AACpC,YAAM,EAAE,MAAM,UAAU,SAAS,SAAS,IAAI;AAC9C,YAAM,QAAQ;AAAA,QACV;AAAA,QACA,GAAG;AAAA,MACP;AACA,YAAM,UAAU,cAAc,MAAM,QAAQ;AAC5C,UAAI,QAAQ,SAAS,GAAG;AACpB,YAAI,QAAQ,KAAK,CAAC,UAAU,eAAe,IAAI,KAAK,CAAC,GAAG;AACpD,cAAI,CAAC;AACD,kBAAM,IAAI,MAAM,8BAA8B,6BAA6B,MAAM,QAAQ,CAAC,GAAG;AACjG,qBAAW,SAAS,SAAS;AACzB,kBAAM,kBAAkB,gBAAgB,UAAU,CAACG,WAAUA,OAAM,SAAS,SAASA,OAAM,SAAS,KAAK,CAACH,OAAMA,OAAM,KAAK,CAAC;AAC5H,gBAAI,oBAAoB,IAAI;AACxB;AAAA,YACJ;AACA,kBAAM,aAAa,gBAAgB,eAAe;AAClD,gBAAI,WAAW,iBAAiB,MAAM,gBAAgB,WAAW,aAAa,MAAM,UAAU;AAC1F,oBAAM,IAAI,MAAM,IAAI,6BAA6B,WAAW,MAAM,WAAW,OAAO,CAAC,gBAC9E,WAAW,QAAQ,KAAK,WAAW,YAAY,yCAC3C,6BAA6B,MAAM,QAAQ,CAAC,gBAAgB,MAAM,QAAQ,KAC7E,MAAM,YAAY,eAAe;AAAA,YAC7C;AACA,4BAAgB,OAAO,iBAAiB,CAAC;AAAA,UAC7C;AAAA,QACJ;AACA,mBAAW,SAAS,SAAS;AACzB,yBAAe,IAAI,KAAK;AAAA,QAC5B;AAAA,MACJ;AACA,sBAAgB,KAAK,KAAK;AAAA,IAC9B,GA/Be;AAAA,IAgCf,OAAO,6BAAM,QAAQ,eAAe,CAAC,GAA9B;AAAA,IACP,KAAK,wBAAC,WAAW;AACb,aAAO,aAAa,KAAK;AAAA,IAC7B,GAFK;AAAA,IAGL,QAAQ,wBAAC,aAAa;AAClB,UAAI,OAAO,aAAa;AACpB,eAAO,aAAa,QAAQ;AAAA;AAE5B,eAAO,kBAAkB,QAAQ;AAAA,IACzC,GALQ;AAAA,IAMR,aAAa,wBAAC,aAAa;AACvB,UAAI,YAAY;AAChB,YAAM,WAAW,wBAAC,UAAU;AACxB,cAAM,EAAE,MAAM,MAAM,SAAS,SAAS,IAAI;AAC1C,YAAI,QAAQ,KAAK,SAAS,QAAQ,GAAG;AACjC,gBAAM,UAAU,cAAc,MAAM,QAAQ;AAC5C,qBAAW,SAAS,SAAS;AACzB,2BAAe,OAAO,KAAK;AAAA,UAC/B;AACA,sBAAY;AACZ,iBAAO;AAAA,QACX;AACA,eAAO;AAAA,MACX,GAXiB;AAYjB,wBAAkB,gBAAgB,OAAO,QAAQ;AACjD,wBAAkB,gBAAgB,OAAO,QAAQ;AACjD,aAAO;AAAA,IACX,GAjBa;AAAA,IAkBb,QAAQ,wBAAC,SAAS;AACd,YAAM,SAAS,QAAQ,eAAe,CAAC;AACvC,aAAO,IAAI,IAAI;AACf,aAAO,kBAAkB,qBAAqB,OAAO,kBAAkB,MAAM,KAAK,oBAAoB,KAAK,MAAM;AACjH,aAAO;AAAA,IACX,GALQ;AAAA,IAMR,cAAc;AAAA,IACd,UAAU,6BAAM;AACZ,aAAO,kBAAkB,IAAI,EAAE,IAAI,CAAC,OAAO;AACvC,cAAM,OAAO,GAAG,QACZ,GAAG,WACC,MACA,GAAG;AACX,eAAO,6BAA6B,GAAG,MAAM,GAAG,OAAO,IAAI,QAAQ;AAAA,MACvE,CAAC;AAAA,IACL,GARU;AAAA,IASV,kBAAkB,QAAQ;AACtB,UAAI,OAAO,WAAW;AAClB,4BAAoB;AACxB,aAAO;AAAA,IACX;AAAA,IACA,SAAS,wBAAC,SAASI,aAAY;AAC3B,iBAAW,cAAc,kBAAkB,EACtC,IAAI,CAAC,UAAU,MAAM,UAAU,EAC/B,QAAQ,GAAG;AACZ,kBAAU,WAAW,SAASA,QAAO;AAAA,MACzC;AACA,UAAI,mBAAmB;AACnB,gBAAQ,IAAI,MAAM,SAAS,CAAC;AAAA,MAChC;AACA,aAAO;AAAA,IACX,GAVS;AAAA,EAWb;AACA,SAAO;AACX,GA7P8B;AA8P9B,IAAM,cAAc;AAAA,EAChB,YAAY;AAAA,EACZ,WAAW;AAAA,EACX,OAAO;AAAA,EACP,iBAAiB;AAAA,EACjB,aAAa;AACjB;AACA,IAAM,kBAAkB;AAAA,EACpB,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,KAAK;AACT;;;AFvRO,IAAM,SAAN,MAAa;AAAA,EADpB,OACoB;AAAA;AAAA;AAAA,EAChB,YAAYC,SAAQ;AAChB,SAAK,SAASA;AACd,SAAK,kBAAkB,eAAe;AAAA,EAC1C;AAAA,EACA,KAAK,SAAS,aAAa,IAAI;AAC3B,UAAM,UAAU,OAAO,gBAAgB,aAAa,cAAc;AAClE,UAAM,WAAW,OAAO,gBAAgB,aAAa,cAAc;AACnE,UAAM,kBAAkB,YAAY,UAAa,KAAK,OAAO,oBAAoB;AACjF,QAAI;AACJ,QAAI,iBAAiB;AACjB,UAAI,CAAC,KAAK,UAAU;AAChB,aAAK,WAAW,oBAAI,QAAQ;AAAA,MAChC;AACA,YAAM,WAAW,KAAK;AACtB,UAAI,SAAS,IAAI,QAAQ,WAAW,GAAG;AACnC,kBAAU,SAAS,IAAI,QAAQ,WAAW;AAAA,MAC9C,OACK;AACD,kBAAU,QAAQ,kBAAkB,KAAK,iBAAiB,KAAK,QAAQ,OAAO;AAC9E,iBAAS,IAAI,QAAQ,aAAa,OAAO;AAAA,MAC7C;AAAA,IACJ,OACK;AACD,aAAO,KAAK;AACZ,gBAAU,QAAQ,kBAAkB,KAAK,iBAAiB,KAAK,QAAQ,OAAO;AAAA,IAClF;AACA,QAAI,UAAU;AACV,cAAQ,OAAO,EACV,KAAK,CAAC,WAAW,SAAS,MAAM,OAAO,MAAM,GAAG,CAAC,QAAQ,SAAS,GAAG,CAAC,EACtE,MAAM,MAAM;AAAA,MAAE,CAAC;AAAA,IACxB,OACK;AACD,aAAO,QAAQ,OAAO,EAAE,KAAK,CAAC,WAAW,OAAO,MAAM;AAAA,IAC1D;AAAA,EACJ;AAAA,EACA,UAAU;AACN,SAAK,QAAQ,gBAAgB,UAAU;AACvC,WAAO,KAAK;AAAA,EAChB;AACJ;;;AGzCA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,UAAN,MAAc;AAAA,EAFrB,OAEqB;AAAA;AAAA;AAAA,EACjB,cAAc;AACV,SAAK,kBAAkB,eAAe;AAAA,EAC1C;AAAA,EACA,OAAO,eAAe;AAClB,WAAO,IAAI,aAAa;AAAA,EAC5B;AAAA,EACA,6BAA6B,aAAa,eAAe,SAAS,EAAE,cAAc,YAAY,aAAa,yBAAyB,0BAA0B,eAAe,mBAAmB,YAAa,GAAG;AAC5M,eAAW,MAAM,aAAa,KAAK,IAAI,EAAE,aAAa,aAAa,eAAe,OAAO,GAAG;AACxF,WAAK,gBAAgB,IAAI,EAAE;AAAA,IAC/B;AACA,UAAM,QAAQ,YAAY,OAAO,KAAK,eAAe;AACrD,UAAM,EAAE,QAAAC,QAAO,IAAI;AACnB,UAAM,0BAA0B;AAAA,MAC5B,QAAAA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,CAAC,kBAAkB,GAAG;AAAA,QAClB,iBAAiB;AAAA,QACjB,GAAG;AAAA,MACP;AAAA,MACA,GAAG;AAAA,IACP;AACA,UAAM,EAAE,eAAe,IAAI;AAC3B,WAAO,MAAM,QAAQ,CAAC,YAAY,eAAe,OAAO,QAAQ,SAAS,WAAW,CAAC,CAAC,GAAG,uBAAuB;AAAA,EACpH;AACJ;AACA,IAAM,eAAN,MAAmB;AAAA,EA/BnB,OA+BmB;AAAA;AAAA;AAAA,EACf,cAAc;AACV,SAAK,QAAQ,MAAM;AAAA,IAAE;AACrB,SAAK,MAAM,CAAC;AACZ,SAAK,gBAAgB,MAAM,CAAC;AAC5B,SAAK,eAAe;AACpB,SAAK,cAAc;AACnB,SAAK,qBAAqB,CAAC;AAC3B,SAAK,iBAAiB,CAAC;AACvB,SAAK,2BAA2B,CAACC,OAAMA;AACvC,SAAK,4BAA4B,CAACA,OAAMA;AACxC,SAAK,cAAc;AACnB,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,KAAK,IAAI;AACL,SAAK,QAAQ;AAAA,EACjB;AAAA,EACA,GAAG,+BAA+B;AAC9B,SAAK,MAAM;AACX,WAAO;AAAA,EACX;AAAA,EACA,EAAE,oBAAoB;AAClB,SAAK,gBAAgB;AACrB,WAAO;AAAA,EACX;AAAA,EACA,EAAE,SAAS,WAAW,gBAAgB,CAAC,GAAG;AACtC,SAAK,iBAAiB;AAAA,MAClB;AAAA,MACA;AAAA,MACA,GAAG;AAAA,IACP;AACA,WAAO;AAAA,EACX;AAAA,EACA,EAAE,oBAAoB,CAAC,GAAG;AACtB,SAAK,qBAAqB;AAC1B,WAAO;AAAA,EACX;AAAA,EACA,EAAE,YAAY,aAAa;AACvB,SAAK,cAAc;AACnB,SAAK,eAAe;AACpB,WAAO;AAAA,EACX;AAAA,EACA,EAAE,cAAc,CAACA,OAAMA,IAAG,eAAe,CAACA,OAAMA,IAAG;AAC/C,SAAK,2BAA2B;AAChC,SAAK,4BAA4B;AACjC,WAAO;AAAA,EACX;AAAA,EACA,IAAI,YAAY;AACZ,SAAK,cAAc;AACnB,WAAO;AAAA,EACX;AAAA,EACA,GAAG,cAAc;AACb,SAAK,gBAAgB;AACrB,WAAO;AAAA,EACX;AAAA,EACA,QAAQ;AACJ,UAAM,UAAU;AAChB,QAAI;AACJ,WAAQ,aAAa,cAAc,QAAQ;AAAA,MAzFnD,OAyFmD;AAAA;AAAA;AAAA,MACvC,OAAO,mCAAmC;AACtC,eAAO,QAAQ;AAAA,MACnB;AAAA,MACA,eAAe,CAAC,KAAK,GAAG;AACpB,cAAM;AACN,aAAK,YAAY,QAAQ;AACzB,aAAK,cAAc,QAAQ;AAC3B,aAAK,QAAQ,SAAS,CAAC;AACvB,gBAAQ,MAAM,IAAI;AAAA,MACtB;AAAA,MACA,kBAAkB,OAAO,eAAe,SAAS;AAC7C,eAAO,KAAK,6BAA6B,OAAO,eAAe,SAAS;AAAA,UACpE,aAAa;AAAA,UACb,cAAc,QAAQ;AAAA,UACtB,YAAY,QAAQ;AAAA,UACpB,aAAa,QAAQ;AAAA,UACrB,yBAAyB,QAAQ;AAAA,UACjC,0BAA0B,QAAQ;AAAA,UAClC,eAAe,QAAQ;AAAA,UACvB,mBAAmB,QAAQ;AAAA,QAC/B,CAAC;AAAA,MACL;AAAA,IACJ;AAAA,EACJ;AACJ;;;AClHA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,mBAAN,MAAM,0BAAyB,MAAM;AAAA,EAA5C,OAA4C;AAAA;AAAA;AAAA,EACxC,YAAY,SAAS;AACjB,UAAM,QAAQ,OAAO;AACrB,WAAO,eAAe,MAAM,OAAO,eAAe,IAAI,EAAE,YAAY,SAAS;AAC7E,SAAK,OAAO,QAAQ;AACpB,SAAK,SAAS,QAAQ;AACtB,SAAK,YAAY,QAAQ;AAAA,EAC7B;AAAA,EACA,OAAO,WAAW,OAAO;AACrB,QAAI,CAAC;AACD,aAAO;AACX,UAAM,YAAY;AAClB,WAAQ,kBAAiB,UAAU,cAAc,SAAS,KACrD,QAAQ,UAAU,MAAM,KACrB,QAAQ,UAAU,SAAS,MAC1B,UAAU,WAAW,YAAY,UAAU,WAAW;AAAA,EACnE;AAAA,EACA,QAAQ,OAAO,WAAW,EAAE,UAAU;AAClC,QAAI,CAAC;AACD,aAAO;AACX,UAAM,YAAY;AAClB,QAAI,SAAS,mBAAkB;AAC3B,aAAO,kBAAiB,WAAW,QAAQ;AAAA,IAC/C;AACA,QAAI,kBAAiB,WAAW,QAAQ,GAAG;AACvC,UAAI,UAAU,QAAQ,KAAK,MAAM;AAC7B,eAAO,KAAK,UAAU,cAAc,QAAQ,KAAK,UAAU,SAAS,KAAK;AAAA,MAC7E;AACA,aAAO,KAAK,UAAU,cAAc,QAAQ;AAAA,IAChD;AACA,WAAO;AAAA,EACX;AACJ;AACO,IAAM,2BAA2B,wBAAC,WAAW,YAAY,CAAC,MAAM;AACnE,SAAO,QAAQ,SAAS,EACnB,OAAO,CAAC,CAAC,EAAEC,EAAC,MAAMA,OAAM,MAAS,EACjC,QAAQ,CAAC,CAACC,IAAGD,EAAC,MAAM;AACrB,QAAI,UAAUC,EAAC,KAAK,UAAa,UAAUA,EAAC,MAAM,IAAI;AAClD,gBAAUA,EAAC,IAAID;AAAA,IACnB;AAAA,EACJ,CAAC;AACD,QAAM,UAAU,UAAU,WAAW,UAAU,WAAW;AAC1D,YAAU,UAAU;AACpB,SAAO,UAAU;AACjB,SAAO;AACX,GAZwC;;;ADhCjC,IAAM,oBAAoB,wBAAC,EAAE,QAAQ,YAAY,eAAe,UAAU,MAAM;AACnF,QAAM,YAAY,oBAAoB,MAAM;AAC5C,QAAM,aAAa,UAAU,iBAAiB,UAAU,iBAAiB,KAAK;AAC9E,QAAM,WAAW,IAAI,cAAc;AAAA,IAC/B,MAAM,YAAY,QAAQ,YAAY,QAAQ,aAAa,cAAc;AAAA,IACzE,QAAQ;AAAA,IACR;AAAA,EACJ,CAAC;AACD,QAAM,yBAAyB,UAAU,UAAU;AACvD,GATiC;AAU1B,IAAM,oBAAoB,wBAAC,kBAAkB;AAChD,SAAO,CAAC,EAAE,QAAQ,YAAY,UAAU,MAAM;AAC1C,sBAAkB,EAAE,QAAQ,YAAY,eAAe,eAAe,UAAU,CAAC;AAAA,EACrF;AACJ,GAJiC;AAKjC,IAAM,sBAAsB,wBAAC,YAAY;AAAA,EACrC,gBAAgB,OAAO;AAAA,EACvB,WAAW,OAAO,QAAQ,kBAAkB,KAAK,OAAO,QAAQ,mBAAmB,KAAK,OAAO,QAAQ,kBAAkB;AAAA,EACzH,mBAAmB,OAAO,QAAQ,YAAY;AAAA,EAC9C,MAAM,OAAO,QAAQ,aAAa;AACtC,IAL4B;;;AEhB5B;AAAA;AAAA;AAAA;AAAAE;AAAO,IAAM,4BAA4B,wBAAC,SAAS;AAC/C,UAAQ,MAAM;AAAA,IACV,KAAK;AACD,aAAO;AAAA,QACH,WAAW;AAAA,QACX,mBAAmB;AAAA,MACvB;AAAA,IACJ,KAAK;AACD,aAAO;AAAA,QACH,WAAW;AAAA,QACX,mBAAmB;AAAA,MACvB;AAAA,IACJ,KAAK;AACD,aAAO;AAAA,QACH,WAAW;AAAA,QACX,mBAAmB;AAAA,MACvB;AAAA,IACJ,KAAK;AACD,aAAO;AAAA,QACH,WAAW;AAAA,QACX,mBAAmB;AAAA,MACvB;AAAA,IACJ;AACI,aAAO,CAAC;AAAA,EAChB;AACJ,GAzByC;;;ACAzC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAMC,4BAA2B,wBAAC,kBAAkB;AACvD,QAAM,qBAAqB,CAAC;AAC5B,aAAW,MAAM,aAAa;AAC1B,UAAM,cAAc,YAAY,EAAE;AAClC,QAAI,cAAc,WAAW,MAAM,QAAW;AAC1C;AAAA,IACJ;AACA,uBAAmB,KAAK;AAAA,MACpB,aAAa,6BAAM,aAAN;AAAA,MACb,qBAAqB,6BAAM,cAAc,WAAW,GAA/B;AAAA,IACzB,CAAC;AAAA,EACL;AACA,SAAO;AAAA,IACH,qBAAqB,MAAM;AACvB,yBAAmB,KAAK,IAAI;AAAA,IAChC;AAAA,IACA,qBAAqB;AACjB,aAAO;AAAA,IACX;AAAA,EACJ;AACJ,GApBwC;AAqBjC,IAAMC,gCAA+B,wBAAC,iBAAiB;AAC1D,QAAM,gBAAgB,CAAC;AACvB,eAAa,mBAAmB,EAAE,QAAQ,CAAC,sBAAsB;AAC7D,kBAAc,kBAAkB,YAAY,CAAC,IAAI,kBAAkB,oBAAoB;AAAA,EAC3F,CAAC;AACD,SAAO;AACX,GAN4C;;;ACvB5C;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,wBAAwB,wBAAC,kBAAkB;AACpD,SAAO;AAAA,IACH,iBAAiB,eAAe;AAC5B,oBAAc,gBAAgB;AAAA,IAClC;AAAA,IACA,gBAAgB;AACZ,aAAO,cAAc;AAAA,IACzB;AAAA,EACJ;AACJ,GATqC;AAU9B,IAAM,4BAA4B,wBAAC,+BAA+B;AACrE,QAAM,gBAAgB,CAAC;AACvB,gBAAc,gBAAgB,2BAA2B,cAAc;AACvE,SAAO;AACX,GAJyC;;;AFRlC,IAAM,mCAAmC,wBAAC,kBAAkB;AAC/D,SAAO,OAAO,OAAOC,0BAAyB,aAAa,GAAG,sBAAsB,aAAa,CAAC;AACtG,GAFgD;AAIzC,IAAM,8BAA8B,wBAACC,YAAW;AACnD,SAAO,OAAO,OAAOC,8BAA6BD,OAAM,GAAG,0BAA0BA,OAAM,CAAC;AAChG,GAF2C;;;AGN3C;AAAA;AAAA;AAAA;AAAAE;AAAO,IAAM,uBAAuB,wBAAC,eAAe,MAAM,QAAQ,UAAU,IAAI,aAAa,CAAC,UAAU,GAApE;;;ACApC;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,uBAAuB,wBAAC,QAAQ;AACzC,QAAM,eAAe;AACrB,aAAW,OAAO,KAAK;AACnB,QAAI,IAAI,eAAe,GAAG,KAAK,IAAI,GAAG,EAAE,YAAY,MAAM,QAAW;AACjE,UAAI,GAAG,IAAI,IAAI,GAAG,EAAE,YAAY;AAAA,IACpC,WACS,OAAO,IAAI,GAAG,MAAM,YAAY,IAAI,GAAG,MAAM,MAAM;AACxD,UAAI,GAAG,IAAI,qBAAqB,IAAI,GAAG,CAAC;AAAA,IAC5C;AAAA,EACJ;AACA,SAAO;AACX,GAXoC;;;ACApC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,aAAN,MAAiB;AAAA,EAAxB,OAAwB;AAAA;AAAA;AAAA,EACpB,QAAQ;AAAA,EAAE;AAAA,EACV,QAAQ;AAAA,EAAE;AAAA,EACV,OAAO;AAAA,EAAE;AAAA,EACT,OAAO;AAAA,EAAE;AAAA,EACT,QAAQ;AAAA,EAAE;AACd;;;ACNA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAaO,IAAM,oBAAoB,wBAAC,SAAS,KAAK,YAAY,EAAE,QAAQ,SAAS,GAAG,GAAjD;;;ACbjC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,eAAe,wBAAC,UAAU;AACnC,UAAQ,OAAO;AAAA,IACX,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AACD,aAAO;AAAA,IACX;AACI,YAAM,IAAI,MAAM,kCAAkC,KAAK,GAAG;AAAA,EAClE;AACJ,GAT4B;AA0CrB,IAAM,eAAe,wBAAC,UAAU;AACnC,MAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,WAAO;AAAA,EACX;AACA,MAAI,OAAO,UAAU,UAAU;AAC3B,UAAM,SAAS,WAAW,KAAK;AAC/B,QAAI,CAAC,OAAO,MAAM,MAAM,GAAG;AACvB,UAAI,OAAO,MAAM,MAAM,OAAO,KAAK,GAAG;AAClC,eAAO,KAAK,kBAAkB,wCAAwC,KAAK,EAAE,CAAC;AAAA,MAClF;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AACA,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO;AAAA,EACX;AACA,QAAM,IAAI,UAAU,wBAAwB,OAAO,KAAK,KAAK,KAAK,EAAE;AACxE,GAjB4B;AAkB5B,IAAM,YAAY,KAAK,KAAK,KAAK,OAAO,IAAI,KAAK,IAAI;AAC9C,IAAM,gBAAgB,wBAAC,UAAU;AACpC,QAAM,WAAW,aAAa,KAAK;AACnC,MAAI,aAAa,UAAa,CAAC,OAAO,MAAM,QAAQ,KAAK,aAAa,YAAY,aAAa,WAAW;AACtG,QAAI,KAAK,IAAI,QAAQ,IAAI,WAAW;AAChC,YAAM,IAAI,UAAU,8BAA8B,KAAK,EAAE;AAAA,IAC7D;AAAA,EACJ;AACA,SAAO;AACX,GAR6B;AAStB,IAAM,aAAa,wBAAC,UAAU;AACjC,MAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,WAAO;AAAA,EACX;AACA,MAAI,OAAO,UAAU,KAAK,KAAK,CAAC,OAAO,MAAM,KAAK,GAAG;AACjD,WAAO;AAAA,EACX;AACA,QAAM,IAAI,UAAU,yBAAyB,OAAO,KAAK,KAAK,KAAK,EAAE;AACzE,GAR0B;AAUnB,IAAM,cAAc,wBAAC,UAAU,eAAe,OAAO,EAAE,GAAnC;AACpB,IAAM,cAAc,wBAAC,UAAU,eAAe,OAAO,EAAE,GAAnC;AACpB,IAAM,aAAa,wBAAC,UAAU,eAAe,OAAO,CAAC,GAAlC;AAC1B,IAAM,iBAAiB,wBAAC,OAAO,SAAS;AACpC,QAAM,WAAW,WAAW,KAAK;AACjC,MAAI,aAAa,UAAa,QAAQ,UAAU,IAAI,MAAM,UAAU;AAChE,UAAM,IAAI,UAAU,YAAY,IAAI,qBAAqB,KAAK,EAAE;AAAA,EACpE;AACA,SAAO;AACX,GANuB;AAOvB,IAAM,UAAU,wBAAC,OAAO,SAAS;AAC7B,UAAQ,MAAM;AAAA,IACV,KAAK;AACD,aAAO,WAAW,GAAG,KAAK,EAAE,CAAC;AAAA,IACjC,KAAK;AACD,aAAO,WAAW,GAAG,KAAK,EAAE,CAAC;AAAA,IACjC,KAAK;AACD,aAAO,UAAU,GAAG,KAAK,EAAE,CAAC;AAAA,EACpC;AACJ,GATgB;AAUT,IAAM,gBAAgB,wBAAC,OAAO,aAAa;AAC9C,MAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,QAAI,UAAU;AACV,YAAM,IAAI,UAAU,iCAAiC,QAAQ,EAAE;AAAA,IACnE;AACA,UAAM,IAAI,UAAU,2BAA2B;AAAA,EACnD;AACA,SAAO;AACX,GAR6B;AAmBtB,IAAM,eAAe,wBAAC,UAAU;AACnC,MAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,WAAO;AAAA,EACX;AACA,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO;AAAA,EACX;AACA,MAAI,CAAC,WAAW,UAAU,QAAQ,EAAE,SAAS,OAAO,KAAK,GAAG;AACxD,WAAO,KAAK,kBAAkB,wBAAwB,OAAO,KAAK,KAAK,KAAK,EAAE,CAAC;AAC/E,WAAO,OAAO,KAAK;AAAA,EACvB;AACA,QAAM,IAAI,UAAU,wBAAwB,OAAO,KAAK,KAAK,KAAK,EAAE;AACxE,GAZ4B;AA6BrB,IAAM,oBAAoB,wBAAC,UAAU;AACxC,MAAI,OAAO,SAAS,UAAU;AAC1B,WAAO,aAAa,YAAY,KAAK,CAAC;AAAA,EAC1C;AACA,SAAO,aAAa,KAAK;AAC7B,GALiC;AAM1B,IAAM,mBAAmB;AACzB,IAAM,qBAAqB,wBAAC,UAAU;AACzC,MAAI,OAAO,SAAS,UAAU;AAC1B,WAAO,cAAc,YAAY,KAAK,CAAC;AAAA,EAC3C;AACA,SAAO,cAAc,KAAK;AAC9B,GALkC;AAMlC,IAAM,eAAe;AACrB,IAAM,cAAc,wBAAC,UAAU;AAC3B,QAAM,UAAU,MAAM,MAAM,YAAY;AACxC,MAAI,YAAY,QAAQ,QAAQ,CAAC,EAAE,WAAW,MAAM,QAAQ;AACxD,UAAM,IAAI,UAAU,wCAAwC;AAAA,EAChE;AACA,SAAO,WAAW,KAAK;AAC3B,GANoB;AAwCb,IAAM,mBAAmB,wBAAC,UAAU;AACvC,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO,YAAY,YAAY,KAAK,CAAC;AAAA,EACzC;AACA,SAAO,YAAY,KAAK;AAC5B,GALgC;AAMzB,IAAM,mBAAmB,wBAAC,UAAU;AACvC,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO,YAAY,YAAY,KAAK,CAAC;AAAA,EACzC;AACA,SAAO,YAAY,KAAK;AAC5B,GALgC;AAMzB,IAAM,kBAAkB,wBAAC,UAAU;AACtC,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO,WAAW,YAAY,KAAK,CAAC;AAAA,EACxC;AACA,SAAO,WAAW,KAAK;AAC3B,GAL+B;AAM/B,IAAM,oBAAoB,wBAAC,YAAY;AACnC,SAAO,OAAO,IAAI,UAAU,OAAO,EAAE,SAAS,OAAO,EAChD,MAAM,IAAI,EACV,MAAM,GAAG,CAAC,EACV,OAAO,CAACC,OAAM,CAACA,GAAE,SAAS,mBAAmB,CAAC,EAC9C,KAAK,IAAI;AAClB,GAN0B;AAOnB,IAAM,SAAS;AAAA,EAClB,MAAM,QAAQ;AAClB;;;ACrOA;AAAA;AAAA;AAAA;AAAAC;AAEA,IAAM,SAAS,CAAC,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,KAAK;AAelG,IAAM,UAAU,IAAI,OAAO,sEAAsE;AAkBjG,IAAM,sBAAsB,IAAI,OAAO,2FAA2F;AAC3H,IAAM,iCAAiC,wBAAC,UAAU;AACrD,MAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,WAAO;AAAA,EACX;AACA,MAAI,OAAO,UAAU,UAAU;AAC3B,UAAM,IAAI,UAAU,kDAAkD;AAAA,EAC1E;AACA,QAAM,QAAQ,oBAAoB,KAAK,KAAK;AAC5C,MAAI,CAAC,OAAO;AACR,UAAM,IAAI,UAAU,kCAAkC;AAAA,EAC1D;AACA,QAAM,CAACC,IAAG,SAAS,UAAU,QAAQ,OAAO,SAAS,SAAS,wBAAwB,SAAS,IAAI;AACnG,QAAM,OAAO,iBAAiB,mBAAmB,OAAO,CAAC;AACzD,QAAM,QAAQ,eAAe,UAAU,SAAS,GAAG,EAAE;AACrD,QAAM,MAAM,eAAe,QAAQ,OAAO,GAAG,EAAE;AAC/C,QAAM,OAAO,UAAU,MAAM,OAAO,KAAK,EAAE,OAAO,SAAS,SAAS,uBAAuB,CAAC;AAC5F,MAAI,UAAU,YAAY,KAAK,KAAK;AAChC,SAAK,QAAQ,KAAK,QAAQ,IAAI,0BAA0B,SAAS,CAAC;AAAA,EACtE;AACA,SAAO;AACX,GApB8C;AAqB9C,IAAM,cAAc,IAAI,OAAO,gJAAgJ;AAC/K,IAAM,eAAe,IAAI,OAAO,6KAA6K;AAC7M,IAAM,WAAW,IAAI,OAAO,kJAAkJ;AAoD9K,IAAM,YAAY,wBAAC,MAAM,OAAO,KAAKC,UAAS;AAC1C,QAAM,gBAAgB,QAAQ;AAC9B,qBAAmB,MAAM,eAAe,GAAG;AAC3C,SAAO,IAAI,KAAK,KAAK,IAAI,MAAM,eAAe,KAAK,eAAeA,MAAK,OAAO,QAAQ,GAAG,EAAE,GAAG,eAAeA,MAAK,SAAS,UAAU,GAAG,EAAE,GAAG,eAAeA,MAAK,SAAS,WAAW,GAAG,EAAE,GAAG,kBAAkBA,MAAK,sBAAsB,CAAC,CAAC;AAChP,GAJkB;AAalB,IAAM,wBAAwB,KAAK,MAAM,KAAK,KAAK,KAAK;AAcxD,IAAM,gBAAgB,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;AACrE,IAAM,qBAAqB,wBAAC,MAAM,OAAO,QAAQ;AAC7C,MAAI,UAAU,cAAc,KAAK;AACjC,MAAI,UAAU,KAAK,WAAW,IAAI,GAAG;AACjC,cAAU;AAAA,EACd;AACA,MAAI,MAAM,SAAS;AACf,UAAM,IAAI,UAAU,mBAAmB,OAAO,KAAK,CAAC,OAAO,IAAI,KAAK,GAAG,EAAE;AAAA,EAC7E;AACJ,GAR2B;AAS3B,IAAM,aAAa,wBAAC,SAAS;AACzB,SAAO,OAAO,MAAM,MAAM,OAAO,QAAQ,KAAK,OAAO,QAAQ;AACjE,GAFmB;AAGnB,IAAM,iBAAiB,wBAAC,OAAO,MAAM,OAAO,UAAU;AAClD,QAAM,UAAU,gBAAgB,mBAAmB,KAAK,CAAC;AACzD,MAAI,UAAU,SAAS,UAAU,OAAO;AACpC,UAAM,IAAI,UAAU,GAAG,IAAI,oBAAoB,KAAK,QAAQ,KAAK,aAAa;AAAA,EAClF;AACA,SAAO;AACX,GANuB;AAOvB,IAAM,oBAAoB,wBAAC,UAAU;AACjC,MAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,WAAO;AAAA,EACX;AACA,SAAO,mBAAmB,OAAO,KAAK,IAAI;AAC9C,GAL0B;AAM1B,IAAM,4BAA4B,wBAAC,UAAU;AACzC,QAAM,eAAe,MAAM,CAAC;AAC5B,MAAI,YAAY;AAChB,MAAI,gBAAgB,KAAK;AACrB,gBAAY;AAAA,EAChB,WACS,gBAAgB,KAAK;AAC1B,gBAAY;AAAA,EAChB,OACK;AACD,UAAM,IAAI,UAAU,qBAAqB,YAAY,sBAAsB;AAAA,EAC/E;AACA,QAAM,OAAO,OAAO,MAAM,UAAU,GAAG,CAAC,CAAC;AACzC,QAAM,SAAS,OAAO,MAAM,UAAU,GAAG,CAAC,CAAC;AAC3C,SAAO,aAAa,OAAO,KAAK,UAAU,KAAK;AACnD,GAfkC;AAgBlC,IAAM,qBAAqB,wBAAC,UAAU;AAClC,MAAI,MAAM;AACV,SAAO,MAAM,MAAM,SAAS,KAAK,MAAM,OAAO,GAAG,MAAM,KAAK;AACxD;AAAA,EACJ;AACA,MAAI,QAAQ,GAAG;AACX,WAAO;AAAA,EACX;AACA,SAAO,MAAM,MAAM,GAAG;AAC1B,GAT2B;;;ACpL3B;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,iBAAiB,gCAASC,gBAAeC,MAAK;AACvD,QAAM,MAAM,OAAO,OAAO,IAAI,OAAOA,IAAG,GAAG;AAAA,IACvC,kBAAkB;AACd,aAAO,KAAK,MAAM,OAAOA,IAAG,CAAC;AAAA,IACjC;AAAA,IACA,WAAW;AACP,aAAO,OAAOA,IAAG;AAAA,IACrB;AAAA,IACA,SAAS;AACL,aAAO,OAAOA,IAAG;AAAA,IACrB;AAAA,EACJ,CAAC;AACD,SAAO;AACX,GAb8B;AAc9B,eAAe,OAAO,CAAC,WAAW;AAC9B,MAAI,UAAU,OAAO,WAAW,aAAa,kBAAkB,kBAAkB,qBAAqB,SAAS;AAC3G,WAAO;AAAA,EACX,WACS,OAAO,WAAW,YAAY,OAAO,eAAe,MAAM,MAAM,OAAO,WAAW;AACvF,WAAO,eAAe,OAAO,MAAM,CAAC;AAAA,EACxC;AACA,SAAO,eAAe,KAAK,UAAU,MAAM,CAAC;AAChD;AACA,eAAe,aAAa,eAAe;;;ACvB3C;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,oBAAoB,wBAAC,YAAYC,aAAY,YAAY,YAAYA,QAAO,EAAE,KAAK,CAAC,SAASA,SAAQ,YAAY,IAAI,CAAC,GAAlG;;;ACDjC;AAAA;AAAA;AAAA;AAAAC;AACA,6BAA0B;AAEnB,IAAM,eAAe,wBAAC,YAAYC,aAAY,kBAAkB,YAAYA,QAAO,EAAE,KAAK,CAAC,YAAY;AAC1G,MAAI,QAAQ,QAAQ;AAChB,UAAM,SAAS,IAAI,iCAAU;AAAA,MACzB,qBAAqB;AAAA,MACrB,cAAc;AAAA,MACd,kBAAkB;AAAA,MAClB,mBAAmB;AAAA,MACnB,eAAe;AAAA,MACf,YAAY;AAAA,MACZ,mBAAmB,wBAACC,IAAGC,SAASA,KAAI,KAAK,MAAM,MAAMA,KAAI,SAAS,IAAI,IAAI,KAAK,QAA5D;AAAA,IACvB,CAAC;AACD,WAAO,UAAU,OAAO,IAAI;AAC5B,WAAO,UAAU,OAAO,IAAI;AAC5B,QAAI;AACJ,QAAI;AACA,kBAAY,OAAO,MAAM,SAAS,IAAI;AAAA,IAC1C,SACOC,IAAG;AACN,UAAIA,MAAK,OAAOA,OAAM,UAAU;AAC5B,eAAO,eAAeA,IAAG,qBAAqB;AAAA,UAC1C,OAAO;AAAA,QACX,CAAC;AAAA,MACL;AACA,YAAMA;AAAA,IACV;AACA,UAAM,eAAe;AACrB,UAAM,MAAM,OAAO,KAAK,SAAS,EAAE,CAAC;AACpC,UAAM,oBAAoB,UAAU,GAAG;AACvC,QAAI,kBAAkB,YAAY,GAAG;AACjC,wBAAkB,GAAG,IAAI,kBAAkB,YAAY;AACvD,aAAO,kBAAkB,YAAY;AAAA,IACzC;AACA,WAAO,qBAAqB,iBAAiB;AAAA,EACjD;AACA,SAAO,CAAC;AACZ,CAAC,GAnC2B;AAoCrB,IAAM,oBAAoB,8BAAO,WAAWH,aAAY;AAC3D,QAAM,QAAQ,MAAM,aAAa,WAAWA,QAAO;AACnD,MAAI,MAAM,OAAO;AACb,UAAM,MAAM,UAAU,MAAM,MAAM,WAAW,MAAM,MAAM;AAAA,EAC7D;AACA,SAAO;AACX,GANiC;;;AlEtCjC,IAAM,4BAA4B;AAClC,eAAsB,cAAcI,UAASC,SAAQ,MAAM;AACvD,QAAM,UAAU,KAAK;AACrB,MAAI,SAAS,UAAU,iBAAiB,MAAM,eAAe;AACzD,IAAAC,YAAWF,UAAS,wBAAwB,GAAG;AAAA,EACnD;AACA,MAAI,OAAOC,QAAO,kBAAkB,YAAY;AAC5C,UAAM,gBAAgB,MAAMA,QAAO,cAAc;AACjD,QAAI,OAAO,cAAc,6BAA6B,YAAY;AAC9D,UAAI,cAAc,aAAa,MAAM,SAAS,UAAU,GAAG;AACvD,QAAAC,YAAWF,UAAS,uBAAuB,GAAG;AAAA,MAClD,OACK;AACD,QAAAE,YAAWF,UAAS,uBAAuB,GAAG;AAAA,MAClD;AAAA,IACJ,OACK;AACD,MAAAE,YAAWF,UAAS,qBAAqB,GAAG;AAAA,IAChD;AAAA,EACJ;AACA,MAAI,OAAOC,QAAO,0BAA0B,YAAY;AACpD,UAAM,aAAaD,SAAQ;AAC3B,QAAI,OAAO,YAAY,KAAK,QAAQ,EAAE,MAAM,yBAAyB,GAAG;AACpE,MAAAE,YAAWF,UAAS,uBAAuB,GAAG;AAAA,IAClD;AACA,YAAQ,MAAMC,QAAO,wBAAwB,GAAG;AAAA,MAC5C,KAAK;AACD,QAAAC,YAAWF,UAAS,4BAA4B,GAAG;AACnD;AAAA,MACJ,KAAK;AACD,QAAAE,YAAWF,UAAS,6BAA6B,GAAG;AACpD;AAAA,MACJ,KAAK;AACD,QAAAE,YAAWF,UAAS,4BAA4B,GAAG;AACnD;AAAA,IACR;AAAA,EACJ;AACA,QAAM,WAAWA,SAAQ,kBAAkB,wBAAwB;AACnE,MAAI,UAAU,SAAS;AACnB,UAAM,cAAc;AACpB,QAAI,YAAY,WAAW;AACvB,MAAAE,YAAWF,UAAS,uBAAuB,GAAG;AAAA,IAClD;AACA,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,YAAY,WAAW,CAAC,CAAC,GAAG;AAClE,MAAAE,YAAWF,UAAS,KAAK,KAAK;AAAA,IAClC;AAAA,EACJ;AACJ;AA9CsB;;;AmEFtB;AAAA;AAAA;AAAA;AAAAG;AAAO,IAAM,aAAa;AACnB,IAAM,mBAAmB;AACzB,IAAM,QAAQ;AACd,IAAM,oBAAoB;AAC1B,IAAM,uBAAuB;AAC7B,IAAM,wBAAwB;AAC9B,IAAM,iBAAiB;;;ACN9B;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAM,aAAa;AACZ,SAAS,eAAeC,WAAU;AACrC,MAAI,SAAS;AACb,aAAW,OAAOA,WAAU;AACxB,UAAMC,OAAMD,UAAS,GAAG;AACxB,QAAI,OAAO,SAASC,KAAI,SAAS,KAAK,YAAY;AAC9C,UAAI,OAAO,QAAQ;AACf,kBAAU,MAAMA;AAAA,MACpB,OACK;AACD,kBAAUA;AAAA,MACd;AACA;AAAA,IACJ;AACA;AAAA,EACJ;AACA,SAAO;AACX;AAhBgB;;;A/HIT,IAAM,sBAAsB,wBAAC,YAAY,CAAC,MAAMC,aAAY,OAAO,SAAS;AAC/E,QAAM,EAAE,QAAQ,IAAI;AACpB,MAAI,CAAC,YAAY,WAAW,OAAO,GAAG;AAClC,WAAO,KAAK,IAAI;AAAA,EACpB;AACA,QAAM,EAAE,QAAQ,IAAI;AACpB,QAAM,YAAYA,UAAS,WAAW,IAAI,eAAe,KAAK,CAAC;AAC/D,QAAM,oBAAoB,MAAM,QAAQ,yBAAyB,GAAG,IAAI,eAAe;AACvF,QAAM,cAAcA,UAAS,SAAS,IAAI;AAC1C,QAAM,aAAaA;AACnB,mBAAiB,KAAK,KAAK,eAAe,OAAO,OAAO,CAAC,GAAGA,SAAQ,kBAAkB,UAAU,WAAW,mBAAmB,QAAQ,CAAC,CAAC,EAAE;AAC1I,QAAM,kBAAkB,SAAS,iBAAiB,IAAI,eAAe,KAAK,CAAC;AAC3E,QAAM,QAAQ,MAAM,QAAQ,eAAe;AAC3C,MAAI,OAAO;AACP,qBAAiB,KAAK,gBAAgB,CAAC,OAAO,KAAK,EAAE,CAAC,CAAC;AAAA,EAC3D;AACA,QAAM,SAAS,mBAAmB;AAClC,QAAM,qBAAqB,SAAS,CAAC,MAAM,IAAI,CAAC,GAC3C,OAAO,CAAC,GAAG,kBAAkB,GAAG,WAAW,GAAG,eAAe,CAAC,EAC9D,KAAK,KAAK;AACf,QAAM,gBAAgB;AAAA,IAClB,GAAG,iBAAiB,OAAO,CAAC,YAAY,QAAQ,WAAW,UAAU,CAAC;AAAA,IACtE,GAAG;AAAA,EACP,EAAE,KAAK,KAAK;AACZ,MAAI,QAAQ,YAAY,WAAW;AAC/B,QAAI,eAAe;AACf,cAAQ,gBAAgB,IAAI,QAAQ,gBAAgB,IAC9C,GAAG,QAAQ,UAAU,CAAC,IAAI,aAAa,KACvC;AAAA,IACV;AACA,YAAQ,UAAU,IAAI;AAAA,EAC1B,OACK;AACD,YAAQ,gBAAgB,IAAI;AAAA,EAChC;AACA,SAAO,KAAK;AAAA,IACR,GAAG;AAAA,IACH;AAAA,EACJ,CAAC;AACL,GAvCmC;AAwCnC,IAAM,kBAAkB,wBAAC,kBAAkB;AACvC,QAAM,OAAO,cAAc,CAAC,EACvB,MAAM,iBAAiB,EACvB,IAAI,CAAC,SAAS,KAAK,QAAQ,sBAAsB,cAAc,CAAC,EAChE,KAAK,iBAAiB;AAC3B,QAAMC,WAAU,cAAc,CAAC,GAAG,QAAQ,uBAAuB,cAAc;AAC/E,QAAM,uBAAuB,KAAK,QAAQ,iBAAiB;AAC3D,QAAM,SAAS,KAAK,UAAU,GAAG,oBAAoB;AACrD,MAAI,SAAS,KAAK,UAAU,uBAAuB,CAAC;AACpD,MAAI,WAAW,OAAO;AAClB,aAAS,OAAO,YAAY;AAAA,EAChC;AACA,SAAO,CAAC,QAAQ,QAAQA,QAAO,EAC1B,OAAO,CAAC,SAAS,QAAQ,KAAK,SAAS,CAAC,EACxC,OAAO,CAAC,KAAK,MAAM,UAAU;AAC9B,YAAQ,OAAO;AAAA,MACX,KAAK;AACD,eAAO;AAAA,MACX,KAAK;AACD,eAAO,GAAG,GAAG,IAAI,IAAI;AAAA,MACzB;AACI,eAAO,GAAG,GAAG,IAAI,IAAI;AAAA,IAC7B;AAAA,EACJ,GAAG,EAAE;AACT,GAxBwB;AAyBjB,IAAM,gCAAgC;AAAA,EACzC,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,MAAM,CAAC,kBAAkB,YAAY;AAAA,EACrC,UAAU;AACd;AACO,IAAM,qBAAqB,wBAACC,aAAY;AAAA,EAC3C,cAAc,wBAAC,gBAAgB;AAC3B,gBAAY,IAAI,oBAAoBA,OAAM,GAAG,6BAA6B;AAAA,EAC9E,GAFc;AAGlB,IAJkC;;;AgI7ElC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAI;AAAA,CACV,SAAUC,eAAc;AACrB,EAAAA,cAAa,KAAK,IAAI;AACtB,EAAAA,cAAa,QAAQ,IAAI;AAC7B,GAAG,iBAAiB,eAAe,CAAC,EAAE;;;AJD/B,IAAM,iCAAiC;;;AKH9C;AAAA;AAAA;AAAA;AAAAC;AAGO,IAAM,4BAA4B;;;ACHzC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,eAAe,wBAAC,WAAW,OAAO,WAAW,aAAa,OAAO,WAAW,OAAO,KAAK,OAAO,SAAS,OAAO,IAAhG;;;ADCrB,IAAM,gBAAgB,wBAAC,WAAW,aAAa,MAAM,IACtD,CAAC,mBAAmB,UAAU,EAAE,SAAS,MAAM,IAC3C,cACA,OAAO,QAAQ,4BAA4B,EAAE,IACjD,QAJuB;;;ADCtB,IAAM,sBAAsB,wBAAC,UAAU;AAC1C,QAAM,EAAE,QAAQ,gBAAgB,IAAI;AACpC,MAAI,CAAC,QAAQ;AACT,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACvC;AACA,SAAO,OAAO,OAAO,OAAO;AAAA,IACxB,QAAQ,mCAAY;AAChB,UAAI,OAAO,WAAW,UAAU;AAC5B,eAAO,cAAc,MAAM;AAAA,MAC/B;AACA,YAAM,iBAAiB,MAAM,OAAO;AACpC,aAAO,cAAc,cAAc;AAAA,IACvC,GANQ;AAAA,IAOR,iBAAiB,mCAAY;AACzB,YAAM,iBAAiB,OAAO,WAAW,WAAW,SAAS,MAAM,OAAO;AAC1E,UAAI,aAAa,cAAc,GAAG;AAC9B,eAAO;AAAA,MACX;AACA,aAAO,OAAO,oBAAoB,aAAa,QAAQ,QAAQ,CAAC,CAAC,eAAe,IAAI,gBAAgB;AAAA,IACxG,GANiB;AAAA,EAOrB,CAAC;AACL,GArBmC;;;AGFnC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AACA,IAAM,wBAAwB;AACvB,SAAS,wBAAwB,mBAAmB;AACvD,SAAO,CAAC,SAAS,OAAO,SAAS;AAC7B,UAAM,UAAU,KAAK;AACrB,QAAI,YAAY,WAAW,OAAO,GAAG;AACjC,YAAM,EAAE,MAAM,QAAQ,IAAI;AAC1B,UAAI,QACA,OAAO,KAAK,OAAO,EACd,IAAI,CAAC,QAAQ,IAAI,YAAY,CAAC,EAC9B,QAAQ,qBAAqB,MAAM,IAAI;AAC5C,YAAI;AACA,gBAAM,SAAS,kBAAkB,IAAI;AACrC,kBAAQ,UAAU;AAAA,YACd,GAAG,QAAQ;AAAA,YACX,CAAC,qBAAqB,GAAG,OAAO,MAAM;AAAA,UAC1C;AAAA,QACJ,SACOC,QAAO;AAAA,QACd;AAAA,MACJ;AAAA,IACJ;AACA,WAAO,KAAK;AAAA,MACR,GAAG;AAAA,MACH;AAAA,IACJ,CAAC;AAAA,EACL;AACJ;AAzBgB;AA0BT,IAAM,iCAAiC;AAAA,EAC1C,MAAM;AAAA,EACN,MAAM,CAAC,sBAAsB,gBAAgB;AAAA,EAC7C,MAAM;AAAA,EACN,UAAU;AACd;AACO,IAAM,yBAAyB,wBAAC,aAAa;AAAA,EAChD,cAAc,wBAAC,gBAAgB;AAC3B,gBAAY,IAAI,wBAAwB,QAAQ,iBAAiB,GAAG,8BAA8B;AAAA,EACtG,GAFc;AAGlB,IAJsC;;;AClCtC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,qBAAqB,8BAAO,mBAAmB;AACxD,QAAM,SAAS,gBAAgB,UAAU;AACzC,MAAI,OAAO,eAAe,WAAW,UAAU;AAC3C,mBAAe,SAAS,OAAO,QAAQ,MAAM,mBAAmB,GAAG,CAAC,EAAE,QAAQ,OAAO,mBAAmB,GAAG,CAAC;AAAA,EAChH;AACA,MAAI,gBAAgB,MAAM,GAAG;AACzB,QAAI,eAAe,mBAAmB,MAAM;AACxC,YAAM,IAAI,MAAM,uDAAuD;AAAA,IAC3E;AAAA,EACJ,WACS,CAAC,0BAA0B,MAAM,KACrC,OAAO,QAAQ,GAAG,MAAM,MAAM,CAAC,OAAO,eAAe,QAAQ,EAAE,WAAW,OAAO,KAClF,OAAO,YAAY,MAAM,UACzB,OAAO,SAAS,GAAG;AACnB,mBAAe,iBAAiB;AAAA,EACpC;AACA,MAAI,eAAe,gCAAgC;AAC/C,mBAAe,iCAAiC;AAChD,mBAAe,cAAc;AAAA,EACjC;AACA,SAAO;AACX,GArBkC;AAsBlC,IAAM,iBAAiB;AACvB,IAAM,qBAAqB;AAC3B,IAAM,eAAe;AAGd,IAAM,4BAA4B,wBAAC,eAAe,eAAe,KAAK,UAAU,KAAK,CAAC,mBAAmB,KAAK,UAAU,KAAK,CAAC,aAAa,KAAK,UAAU,GAAxH;AAClC,IAAM,kBAAkB,wBAAC,eAAe;AAC3C,QAAM,CAAC,KAAKC,YAAW,SAAS,EAAE,EAAE,MAAM,IAAI,WAAW,MAAM,GAAG;AAClE,QAAM,QAAQ,QAAQ,SAAS,WAAW,MAAM,GAAG,EAAE,UAAU;AAC/D,QAAM,aAAa,QAAQ,SAASA,cAAa,WAAW,MAAM;AAClE,MAAI,SAAS,CAAC,YAAY;AACtB,UAAM,IAAI,MAAM,gBAAgB,UAAU,sBAAsB;AAAA,EACpE;AACA,SAAO;AACX,GAR+B;;;AC5B/B;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,4BAA4B,wBAAC,WAAW,2BAA2BC,YAAW;AACvF,QAAM,iBAAiB,mCAAY;AAC/B,UAAM,cAAcA,QAAO,SAAS,KAAKA,QAAO,yBAAyB;AACzE,QAAI,OAAO,gBAAgB,YAAY;AACnC,aAAO,YAAY;AAAA,IACvB;AACA,WAAO;AAAA,EACX,GANuB;AAOvB,MAAI,cAAc,qBAAqB,8BAA8B,mBAAmB;AACpF,WAAO,YAAY;AACf,YAAM,cAAc,OAAOA,QAAO,gBAAgB,aAAa,MAAMA,QAAO,YAAY,IAAIA,QAAO;AACnG,YAAM,cAAc,aAAa,mBAAmB,aAAa;AACjE,aAAO;AAAA,IACX;AAAA,EACJ;AACA,MAAI,cAAc,eAAe,8BAA8B,aAAa;AACxE,WAAO,YAAY;AACf,YAAM,cAAc,OAAOA,QAAO,gBAAgB,aAAa,MAAMA,QAAO,YAAY,IAAIA,QAAO;AACnG,YAAM,cAAc,aAAa,aAAa,aAAa;AAC3D,aAAO;AAAA,IACX;AAAA,EACJ;AACA,MAAI,cAAc,cAAc,8BAA8B,YAAY;AACtE,WAAO,YAAY;AACf,YAAM,WAAW,MAAM,eAAe;AACtC,UAAI,YAAY,OAAO,aAAa,UAAU;AAC1C,YAAI,SAAS,UAAU;AACnB,iBAAO,SAAS,IAAI;AAAA,QACxB;AACA,YAAI,cAAc,UAAU;AACxB,gBAAM,EAAE,UAAU,UAAU,MAAM,KAAK,IAAI;AAC3C,iBAAO,GAAG,QAAQ,KAAK,QAAQ,GAAG,OAAO,MAAM,OAAO,EAAE,GAAG,IAAI;AAAA,QACnE;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX,GAtCyC;;;ACAzC;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,wBAAwB,8BAAO,cAAc,QAArB;;;ACArC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,SAAS,iBAAiB,aAAa;AAC1C,QAAM,QAAQ,CAAC;AACf,gBAAc,YAAY,QAAQ,OAAO,EAAE;AAC3C,MAAI,aAAa;AACb,eAAW,QAAQ,YAAY,MAAM,GAAG,GAAG;AACvC,UAAI,CAAC,KAAK,QAAQ,IAAI,IAAI,KAAK,MAAM,GAAG;AACxC,YAAM,mBAAmB,GAAG;AAC5B,UAAI,OAAO;AACP,gBAAQ,mBAAmB,KAAK;AAAA,MACpC;AACA,UAAI,EAAE,OAAO,QAAQ;AACjB,cAAM,GAAG,IAAI;AAAA,MACjB,WACS,MAAM,QAAQ,MAAM,GAAG,CAAC,GAAG;AAChC,cAAM,GAAG,EAAE,KAAK,KAAK;AAAA,MACzB,OACK;AACD,cAAM,GAAG,IAAI,CAAC,MAAM,GAAG,GAAG,KAAK;AAAA,MACnC;AAAA,IACJ;AAAA,EACJ;AACA,SAAO;AACX;AAtBgB;;;ADCT,IAAM,WAAW,wBAAC,QAAQ;AAC7B,MAAI,OAAO,QAAQ,UAAU;AACzB,WAAO,SAAS,IAAI,IAAI,GAAG,CAAC;AAAA,EAChC;AACA,QAAM,EAAE,UAAU,UAAU,MAAM,UAAU,OAAO,IAAI;AACvD,MAAI;AACJ,MAAI,QAAQ;AACR,YAAQ,iBAAiB,MAAM;AAAA,EACnC;AACA,SAAO;AAAA,IACH;AAAA,IACA,MAAM,OAAO,SAAS,IAAI,IAAI;AAAA,IAC9B;AAAA,IACA,MAAM;AAAA,IACN;AAAA,EACJ;AACJ,GAhBwB;;;ADAjB,IAAM,eAAe,wBAAC,aAAa;AACtC,MAAI,OAAO,aAAa,UAAU;AAC9B,QAAI,SAAS,UAAU;AACnB,aAAO,SAAS,SAAS,GAAG;AAAA,IAChC;AACA,WAAO;AAAA,EACX;AACA,SAAO,SAAS,QAAQ;AAC5B,GAR4B;;;ALGrB,IAAM,8BAA8B,8BAAO,cAAc,sBAAsB,cAAcC,aAAY;AAC5G,MAAI,CAAC,aAAa,UAAU;AACxB,QAAI;AACJ,QAAI,aAAa,2BAA2B;AACxC,2BAAqB,MAAM,aAAa,0BAA0B;AAAA,IACtE,OACK;AACD,2BAAqB,MAAM,sBAAsB,aAAa,SAAS;AAAA,IAC3E;AACA,QAAI,oBAAoB;AACpB,mBAAa,WAAW,MAAM,QAAQ,QAAQ,aAAa,kBAAkB,CAAC;AAAA,IAClF;AAAA,EACJ;AACA,QAAM,iBAAiB,MAAM,cAAc,cAAc,sBAAsB,YAAY;AAC3F,MAAI,OAAO,aAAa,qBAAqB,YAAY;AACrD,UAAM,IAAI,MAAM,qCAAqC;AAAA,EACzD;AACA,QAAM,WAAW,aAAa,iBAAiB,gBAAgBA,QAAO;AACtE,SAAO;AACX,GAnB2C;AAoBpC,IAAM,gBAAgB,8BAAO,cAAc,sBAAsB,iBAAiB;AACrF,QAAM,iBAAiB,CAAC;AACxB,QAAM,eAAe,sBAAsB,mCAAmC,KAAK,CAAC;AACpF,aAAW,CAAC,MAAM,WAAW,KAAK,OAAO,QAAQ,YAAY,GAAG;AAC5D,YAAQ,YAAY,MAAM;AAAA,MACtB,KAAK;AACD,uBAAe,IAAI,IAAI,YAAY;AACnC;AAAA,MACJ,KAAK;AACD,uBAAe,IAAI,IAAI,aAAa,YAAY,IAAI;AACpD;AAAA,MACJ,KAAK;AAAA,MACL,KAAK;AACD,uBAAe,IAAI,IAAI,MAAM,0BAA0B,YAAY,MAAM,MAAM,YAAY,EAAE;AAC7F;AAAA,MACJ,KAAK;AACD,uBAAe,IAAI,IAAI,YAAY,IAAI,YAAY;AACnD;AAAA,MACJ;AACI,cAAM,IAAI,MAAM,kDAAkD,KAAK,UAAU,WAAW,CAAC;AAAA,IACrG;AAAA,EACJ;AACA,MAAI,OAAO,KAAK,YAAY,EAAE,WAAW,GAAG;AACxC,WAAO,OAAO,gBAAgB,YAAY;AAAA,EAC9C;AACA,MAAI,OAAO,aAAa,SAAS,EAAE,YAAY,MAAM,MAAM;AACvD,UAAM,mBAAmB,cAAc;AAAA,EAC3C;AACA,SAAO;AACX,GA7B6B;;;AQxB7B;AAAA;AAAA;AAAA;AAAAC;AAGO,IAAM,qBAAqB,wBAAC,EAAE,QAAAC,SAAQ,aAAc,MAAM;AAC7D,SAAO,CAAC,MAAMC,aAAY,OAAO,SAAS;AACtC,QAAID,QAAO,UAAU;AACjB,iBAAWC,UAAS,qBAAqB,GAAG;AAAA,IAChD;AACA,UAAM,WAAW,MAAM,4BAA4B,KAAK,OAAO;AAAA,MAC3D,mCAAmC;AAC/B,eAAO;AAAA,MACX;AAAA,IACJ,GAAG,EAAE,GAAGD,QAAO,GAAGC,QAAO;AACzB,IAAAA,SAAQ,aAAa;AACrB,IAAAA,SAAQ,cAAc,SAAS,YAAY;AAC3C,UAAM,aAAaA,SAAQ,cAAc,CAAC;AAC1C,QAAI,YAAY;AACZ,MAAAA,SAAQ,gBAAgB,IAAI,WAAW;AACvC,MAAAA,SAAQ,iBAAiB,IAAI,WAAW;AACxC,YAAM,gBAAgB,iBAAiBA,QAAO;AAC9C,YAAM,iBAAiB,eAAe,wBAAwB;AAC9D,UAAI,gBAAgB;AAChB,uBAAe,oBAAoB,OAAO,OAAO,eAAe,qBAAqB,CAAC,GAAG;AAAA,UACrF,gBAAgB,WAAW;AAAA,UAC3B,eAAe,WAAW;AAAA,UAC1B,iBAAiB,WAAW;AAAA,UAC5B,aAAa,WAAW;AAAA,UACxB,kBAAkB,WAAW;AAAA,QACjC,GAAG,WAAW,UAAU;AAAA,MAC5B;AAAA,IACJ;AACA,WAAO,KAAK;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AAAA,EACL;AACJ,GAhCkC;;;ACHlC;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,4BAA4B;AAAA,EACrC,MAAM;AAAA,EACN,MAAM,CAAC,uBAAuB,eAAe,UAAU;AAAA,EACvD,MAAM;AAAA,EACN,UAAU;AAAA,EACV,UAAU;AAAA,EACV,cAAc,2BAA2B;AAC7C;AACO,IAAM,oBAAoB,wBAACC,SAAQ,kBAAkB;AAAA,EACxD,cAAc,wBAAC,gBAAgB;AAC3B,gBAAY,cAAc,mBAAmB;AAAA,MACzC,QAAAA;AAAA,MACA;AAAA,IACJ,CAAC,GAAG,yBAAyB;AAAA,EACjC,GALc;AAMlB,IAPiC;;;ACVjC;AAAA;AAAA;AAAA;AAAAC;AAGO,IAAM,wBAAwB,wBAAC,UAAU;AAC5C,QAAM,MAAM,MAAM,OAAO;AACzB,QAAM,EAAE,UAAU,sBAAsB,gBAAgB,IAAI;AAC5D,QAAM,yBAAyB,YAAY,OAAO,YAAY,aAAa,MAAM,kBAAkB,QAAQ,EAAE,CAAC,IAAI;AAClH,QAAM,mBAAmB,CAAC,CAAC;AAC3B,QAAM,iBAAiB,OAAO,OAAO,OAAO;AAAA,IACxC,UAAU;AAAA,IACV;AAAA,IACA;AAAA,IACA,sBAAsB,kBAAkB,wBAAwB,KAAK;AAAA,IACrE,iBAAiB,kBAAkB,mBAAmB,KAAK;AAAA,EAC/D,CAAC;AACD,MAAI,4BAA4B;AAChC,iBAAe,4BAA4B,YAAY;AACnD,QAAI,MAAM,aAAa,CAAC,2BAA2B;AAC/C,kCAA4B,sBAAsB,MAAM,SAAS;AAAA,IACrE;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX,GApBqC;;;ACHrC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAI;AAAA,CACV,SAAUC,cAAa;AACpB,EAAAA,aAAY,UAAU,IAAI;AAC1B,EAAAA,aAAY,UAAU,IAAI;AAC9B,GAAG,gBAAgB,cAAc,CAAC,EAAE;AAC7B,IAAM,uBAAuB;AAC7B,IAAM,qBAAqB,YAAY;;;ACN9C;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAQO,IAAM,yBAAyB;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACO,IAAM,wBAAwB,CAAC,gBAAgB,kBAAkB,yBAAyB;AAC1F,IAAM,+BAA+B,CAAC,KAAK,KAAK,KAAK,GAAG;AACxD,IAAM,6BAA6B,CAAC,cAAc,gBAAgB,SAAS,WAAW;;;ADvBtF,IAAM,4BAA4B,wBAACC,WAAUA,OAAM,WAAW,oBAA5B;AAClC,IAAM,wBAAwB,wBAACA,WAAU;AAC5C,QAAM,gBAAgB,oBAAI,IAAI;AAAA,IAC1B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,CAAC;AACD,QAAM,UAAUA,UAASA,kBAAiB;AAC1C,MAAI,CAAC,SAAS;AACV,WAAO;AAAA,EACX;AACA,SAAO,cAAc,IAAIA,OAAM,OAAO;AAC1C,GAbqC;AAc9B,IAAM,oBAAoB,wBAACA,WAAUA,OAAM,WAAW,mBAAmB,OAC5E,uBAAuB,SAASA,OAAM,IAAI,KAC1CA,OAAM,YAAY,cAAc,MAFH;AAG1B,IAAM,mBAAmB,wBAACA,QAAO,QAAQ,MAAM,0BAA0BA,MAAK,KACjF,sBAAsB,SAASA,OAAM,IAAI,KACzC,2BAA2B,SAASA,QAAO,QAAQ,EAAE,KACrD,6BAA6B,SAASA,OAAM,WAAW,kBAAkB,CAAC,KAC1E,sBAAsBA,MAAK,KAC1BA,OAAM,UAAU,UAAa,SAAS,MAAM,iBAAiBA,OAAM,OAAO,QAAQ,CAAC,GALxD;AAMzB,IAAM,gBAAgB,wBAACA,WAAU;AACpC,MAAIA,OAAM,WAAW,mBAAmB,QAAW;AAC/C,UAAM,aAAaA,OAAM,UAAU;AACnC,QAAI,OAAO,cAAc,cAAc,OAAO,CAAC,iBAAiBA,MAAK,GAAG;AACpE,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX,GAT6B;;;AD1BtB,IAAM,qBAAN,MAAM,oBAAmB;AAAA,EADhC,OACgC;AAAA;AAAA;AAAA,EAC5B,YAAY,SAAS;AACjB,SAAK,kBAAkB;AACvB,SAAK,UAAU;AACf,SAAK,cAAc;AACnB,SAAK,iBAAiB;AACtB,SAAK,eAAe;AACpB,SAAK,gBAAgB;AACrB,SAAK,aAAa;AAClB,SAAK,OAAO,SAAS,QAAQ;AAC7B,SAAK,cAAc,SAAS,eAAe;AAC3C,SAAK,cAAc,SAAS,eAAe;AAC3C,SAAK,gBAAgB,SAAS,iBAAiB;AAC/C,SAAK,SAAS,SAAS,UAAU;AACjC,UAAM,uBAAuB,KAAK,wBAAwB;AAC1D,SAAK,mBAAmB;AACxB,SAAK,mBAAmB,KAAK,MAAM,KAAK,wBAAwB,CAAC;AACjE,SAAK,WAAW,KAAK;AACrB,SAAK,cAAc,KAAK;AAAA,EAC5B;AAAA,EACA,0BAA0B;AACtB,WAAO,KAAK,IAAI,IAAI;AAAA,EACxB;AAAA,EACA,MAAM,eAAe;AACjB,WAAO,KAAK,mBAAmB,CAAC;AAAA,EACpC;AAAA,EACA,MAAM,mBAAmB,QAAQ;AAC7B,QAAI,CAAC,KAAK,SAAS;AACf;AAAA,IACJ;AACA,SAAK,kBAAkB;AACvB,QAAI,SAAS,KAAK,iBAAiB;AAC/B,YAAM,SAAU,SAAS,KAAK,mBAAmB,KAAK,WAAY;AAClE,YAAM,IAAI,QAAQ,CAAC,YAAY,oBAAmB,aAAa,SAAS,KAAK,CAAC;AAAA,IAClF;AACA,SAAK,kBAAkB,KAAK,kBAAkB;AAAA,EAClD;AAAA,EACA,oBAAoB;AAChB,UAAM,YAAY,KAAK,wBAAwB;AAC/C,QAAI,CAAC,KAAK,eAAe;AACrB,WAAK,gBAAgB;AACrB;AAAA,IACJ;AACA,UAAM,cAAc,YAAY,KAAK,iBAAiB,KAAK;AAC3D,SAAK,kBAAkB,KAAK,IAAI,KAAK,aAAa,KAAK,kBAAkB,UAAU;AACnF,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,wBAAwB,UAAU;AAC9B,QAAI;AACJ,SAAK,mBAAmB;AACxB,QAAI,kBAAkB,QAAQ,GAAG;AAC7B,YAAM,YAAY,CAAC,KAAK,UAAU,KAAK,iBAAiB,KAAK,IAAI,KAAK,gBAAgB,KAAK,QAAQ;AACnG,WAAK,cAAc;AACnB,WAAK,oBAAoB;AACzB,WAAK,mBAAmB,KAAK,wBAAwB;AACrD,uBAAiB,KAAK,cAAc,SAAS;AAC7C,WAAK,kBAAkB;AAAA,IAC3B,OACK;AACD,WAAK,oBAAoB;AACzB,uBAAiB,KAAK,aAAa,KAAK,wBAAwB,CAAC;AAAA,IACrE;AACA,UAAM,UAAU,KAAK,IAAI,gBAAgB,IAAI,KAAK,cAAc;AAChE,SAAK,sBAAsB,OAAO;AAAA,EACtC;AAAA,EACA,sBAAsB;AAClB,SAAK,aAAa,KAAK,WAAW,KAAK,IAAK,KAAK,eAAe,IAAI,KAAK,QAAS,KAAK,eAAe,IAAI,CAAC,CAAC;AAAA,EAChH;AAAA,EACA,cAAc,WAAW;AACrB,WAAO,KAAK,WAAW,YAAY,KAAK,IAAI;AAAA,EAChD;AAAA,EACA,aAAa,WAAW;AACpB,WAAO,KAAK,WAAW,KAAK,gBAAgB,KAAK,IAAI,YAAY,KAAK,mBAAmB,KAAK,YAAY,CAAC,IAAI,KAAK,WAAW;AAAA,EACnI;AAAA,EACA,oBAAoB;AAChB,SAAK,UAAU;AAAA,EACnB;AAAA,EACA,sBAAsB,SAAS;AAC3B,SAAK,kBAAkB;AACvB,SAAK,WAAW,KAAK,IAAI,SAAS,KAAK,WAAW;AAClD,SAAK,cAAc,KAAK,IAAI,SAAS,KAAK,WAAW;AACrD,SAAK,kBAAkB,KAAK,IAAI,KAAK,iBAAiB,KAAK,WAAW;AAAA,EAC1E;AAAA,EACA,qBAAqB;AACjB,UAAMC,KAAI,KAAK,wBAAwB;AACvC,UAAM,aAAa,KAAK,MAAMA,KAAI,CAAC,IAAI;AACvC,SAAK;AACL,QAAI,aAAa,KAAK,kBAAkB;AACpC,YAAM,cAAc,KAAK,gBAAgB,aAAa,KAAK;AAC3D,WAAK,iBAAiB,KAAK,WAAW,cAAc,KAAK,SAAS,KAAK,kBAAkB,IAAI,KAAK,OAAO;AACzG,WAAK,eAAe;AACpB,WAAK,mBAAmB;AAAA,IAC5B;AAAA,EACJ;AAAA,EACA,WAAW,KAAK;AACZ,WAAO,WAAW,IAAI,QAAQ,CAAC,CAAC;AAAA,EACpC;AACJ;AACA,mBAAmB,eAAe;;;AGnGlC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,2BAA2B;AACjC,IAAM,sBAAsB,KAAK;AACjC,IAAM,8BAA8B;AACpC,IAAM,uBAAuB;AAC7B,IAAM,aAAa;AACnB,IAAM,qBAAqB;AAC3B,IAAM,qBAAqB;AAC3B,IAAM,uBAAuB;AAC7B,IAAM,iBAAiB;;;ACR9B;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,iCAAiC,6BAAM;AAChD,MAAI,YAAY;AAChB,QAAM,0BAA0B,wBAAC,aAAa;AAC1C,WAAO,KAAK,MAAM,KAAK,IAAI,qBAAqB,KAAK,OAAO,IAAI,KAAK,WAAW,SAAS,CAAC;AAAA,EAC9F,GAFgC;AAGhC,QAAM,eAAe,wBAAC,UAAU;AAC5B,gBAAY;AAAA,EAChB,GAFqB;AAGrB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,EACJ;AACJ,GAZ8C;;;ACD9C;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,0BAA0B,wBAAC,EAAE,YAAY,YAAY,UAAW,MAAM;AAC/E,QAAM,gBAAgB,6BAAM,YAAN;AACtB,QAAM,gBAAgB,6BAAM,KAAK,IAAI,qBAAqB,UAAU,GAA9C;AACtB,QAAM,eAAe,6BAAM,WAAN;AACrB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ,GATuC;;;AHGhC,IAAM,wBAAN,MAA4B;AAAA,EAJnC,OAImC;AAAA;AAAA;AAAA,EAC/B,YAAY,aAAa;AACrB,SAAK,cAAc;AACnB,SAAK,OAAO,YAAY;AACxB,SAAK,WAAW;AAChB,SAAK,uBAAuB,+BAA+B;AAC3D,SAAK,sBAAsB,OAAO,gBAAgB,aAAa,cAAc,YAAY;AAAA,EAC7F;AAAA,EACA,MAAM,yBAAyB,iBAAiB;AAC5C,WAAO,wBAAwB;AAAA,MAC3B,YAAY;AAAA,MACZ,YAAY;AAAA,IAChB,CAAC;AAAA,EACL;AAAA,EACA,MAAM,0BAA0B,OAAO,WAAW;AAC9C,UAAM,cAAc,MAAM,KAAK,eAAe;AAC9C,QAAI,KAAK,YAAY,OAAO,WAAW,WAAW,GAAG;AACjD,YAAM,YAAY,UAAU;AAC5B,WAAK,qBAAqB,aAAa,cAAc,eAAe,8BAA8B,wBAAwB;AAC1H,YAAM,qBAAqB,KAAK,qBAAqB,wBAAwB,MAAM,cAAc,CAAC;AAClG,YAAM,aAAa,UAAU,iBACvB,KAAK,IAAI,UAAU,eAAe,QAAQ,IAAI,KAAK,IAAI,KAAK,GAAG,kBAAkB,IACjF;AACN,YAAM,eAAe,KAAK,gBAAgB,SAAS;AACnD,WAAK,YAAY;AACjB,aAAO,wBAAwB;AAAA,QAC3B;AAAA,QACA,YAAY,MAAM,cAAc,IAAI;AAAA,QACpC,WAAW;AAAA,MACf,CAAC;AAAA,IACL;AACA,UAAM,IAAI,MAAM,0BAA0B;AAAA,EAC9C;AAAA,EACA,cAAc,OAAO;AACjB,SAAK,WAAW,KAAK,IAAI,sBAAsB,KAAK,YAAY,MAAM,aAAa,KAAK,mBAAmB;AAAA,EAC/G;AAAA,EACA,cAAc;AACV,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,MAAM,iBAAiB;AACnB,QAAI;AACA,aAAO,MAAM,KAAK,oBAAoB;AAAA,IAC1C,SACOC,QAAO;AACV,cAAQ,KAAK,6DAA6D,oBAAoB,EAAE;AAChG,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,YAAY,cAAc,WAAW,aAAa;AAC9C,UAAM,WAAW,aAAa,cAAc,IAAI;AAChD,WAAQ,WAAW,eACf,KAAK,YAAY,KAAK,gBAAgB,UAAU,SAAS,KACzD,KAAK,iBAAiB,UAAU,SAAS;AAAA,EACjD;AAAA,EACA,gBAAgB,WAAW;AACvB,WAAO,cAAc,cAAc,qBAAqB;AAAA,EAC5D;AAAA,EACA,iBAAiB,WAAW;AACxB,WAAO,cAAc,gBAAgB,cAAc;AAAA,EACvD;AACJ;;;AL7DO,IAAM,wBAAN,MAA4B;AAAA,EAHnC,OAGmC;AAAA;AAAA;AAAA,EAC/B,YAAY,qBAAqB,SAAS;AACtC,SAAK,sBAAsB;AAC3B,SAAK,OAAO,YAAY;AACxB,UAAM,EAAE,YAAY,IAAI,WAAW,CAAC;AACpC,SAAK,cAAc,eAAe,IAAI,mBAAmB;AACzD,SAAK,wBAAwB,IAAI,sBAAsB,mBAAmB;AAAA,EAC9E;AAAA,EACA,MAAM,yBAAyB,iBAAiB;AAC5C,UAAM,KAAK,YAAY,aAAa;AACpC,WAAO,KAAK,sBAAsB,yBAAyB,eAAe;AAAA,EAC9E;AAAA,EACA,MAAM,0BAA0B,cAAc,WAAW;AACrD,SAAK,YAAY,wBAAwB,SAAS;AAClD,WAAO,KAAK,sBAAsB,0BAA0B,cAAc,SAAS;AAAA,EACvF;AAAA,EACA,cAAc,OAAO;AACjB,SAAK,YAAY,wBAAwB,CAAC,CAAC;AAC3C,SAAK,sBAAsB,cAAc,KAAK;AAAA,EAClD;AACJ;;;ASvBA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAGA,IAAI;AACJ,IAAM,QAAQ,IAAI,WAAW,EAAE;AAChB,SAAR,MAAuB;AAE5B,MAAI,CAAC,iBAAiB;AAEpB,sBAAkB,OAAO,WAAW,eAAe,OAAO,mBAAmB,OAAO,gBAAgB,KAAK,MAAM;AAE/G,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI,MAAM,0GAA0G;AAAA,IAC5H;AAAA,EACF;AAEA,SAAO,gBAAgB,KAAK;AAC9B;AAZwB;;;ACLxB;AAAA;AAAA;AAAA;AAAAC;AAMA,IAAM,YAAY,CAAC;AAEnB,SAASC,KAAI,GAAGA,KAAI,KAAK,EAAEA,IAAG;AAC5B,YAAU,MAAMA,KAAI,KAAO,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC;AAClD;AAEO,SAAS,gBAAgB,KAAK,SAAS,GAAG;AAG/C,SAAO,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC;AACnf;AAJgB;;;ACZhB;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAM,aAAa,OAAO,WAAW,eAAe,OAAO,cAAc,OAAO,WAAW,KAAK,MAAM;AACtG,IAAO,iBAAQ;AAAA,EACb;AACF;;;ADCA,SAAS,GAAG,SAAS,KAAK,QAAQ;AAChC,MAAI,eAAO,cAAc,CAAC,OAAO,CAAC,SAAS;AACzC,WAAO,eAAO,WAAW;AAAA,EAC3B;AAEA,YAAU,WAAW,CAAC;AACtB,QAAM,OAAO,QAAQ,WAAW,QAAQ,OAAO,KAAK;AAEpD,OAAK,CAAC,IAAI,KAAK,CAAC,IAAI,KAAO;AAC3B,OAAK,CAAC,IAAI,KAAK,CAAC,IAAI,KAAO;AAE3B,MAAI,KAAK;AACP,aAAS,UAAU;AAEnB,aAASC,KAAI,GAAGA,KAAI,IAAI,EAAEA,IAAG;AAC3B,UAAI,SAASA,EAAC,IAAI,KAAKA,EAAC;AAAA,IAC1B;AAEA,WAAO;AAAA,EACT;AAEA,SAAO,gBAAgB,IAAI;AAC7B;AAtBS;AAwBT,IAAO,aAAQ;;;AE5Bf;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,aAAa,wBAACC,WAAU;AACjC,MAAIA,kBAAiB;AACjB,WAAOA;AACX,MAAIA,kBAAiB;AACjB,WAAO,OAAO,OAAO,IAAI,MAAM,GAAGA,MAAK;AAC3C,MAAI,OAAOA,WAAU;AACjB,WAAO,IAAI,MAAMA,MAAK;AAC1B,SAAO,IAAI,MAAM,6BAA6BA,MAAK,EAAE;AACzD,GAR0B;;;ACA1B;AAAA;AAAA;AAAA;AAAAC;AA2BO,IAAM,qBAAqB,wBAAC,UAAU;AACzC,QAAM,EAAE,eAAe,WAAW,YAAY,aAAa,aAAa,IAAI;AAC5E,QAAM,cAAc,kBAAkB,gBAAgB,oBAAoB;AAC1E,SAAO,OAAO,OAAO,OAAO;AAAA,IACxB;AAAA,IACA,eAAe,mCAAY;AACvB,UAAI,eAAe;AACf,eAAO;AAAA,MACX;AACA,YAAM,YAAY,MAAM,kBAAkB,UAAU,EAAE;AACtD,UAAI,cAAc,YAAY,UAAU;AACpC,eAAO,IAAI,sBAAsB,WAAW;AAAA,MAChD;AACA,aAAO,IAAI,sBAAsB,WAAW;AAAA,IAChD,GATe;AAAA,EAUnB,CAAC;AACL,GAhBkC;;;AC3BlC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,qBAAqB,wBAAC,YAAY,SAAS,gBAAgB,gBAAtC;;;ADO3B,IAAM,kBAAkB,wBAAC,YAAY,CAAC,MAAMC,aAAY,OAAO,SAAS;AAC3E,MAAI,gBAAgB,MAAM,QAAQ,cAAc;AAChD,QAAM,cAAc,MAAM,QAAQ,YAAY;AAC9C,MAAI,kBAAkB,aAAa,GAAG;AAClC,oBAAgB;AAChB,QAAI,aAAa,MAAM,cAAc,yBAAyBA,SAAQ,cAAc,CAAC;AACrF,QAAI,YAAY,IAAI,MAAM;AAC1B,QAAI,WAAW;AACf,QAAI,kBAAkB;AACtB,UAAM,EAAE,QAAQ,IAAI;AACpB,UAAM,YAAY,YAAY,WAAW,OAAO;AAChD,QAAI,WAAW;AACX,cAAQ,QAAQ,oBAAoB,IAAI,WAAG;AAAA,IAC/C;AACA,WAAO,MAAM;AACT,UAAI;AACA,YAAI,WAAW;AACX,kBAAQ,QAAQ,cAAc,IAAI,WAAW,WAAW,CAAC,SAAS,WAAW;AAAA,QACjF;AACA,cAAM,EAAE,UAAU,OAAO,IAAI,MAAM,KAAK,IAAI;AAC5C,sBAAc,cAAc,UAAU;AACtC,eAAO,UAAU,WAAW,WAAW;AACvC,eAAO,UAAU,kBAAkB;AACnC,eAAO,EAAE,UAAU,OAAO;AAAA,MAC9B,SACOC,IAAG;AACN,cAAM,iBAAiB,kBAAkBA,EAAC;AAC1C,oBAAY,WAAWA,EAAC;AACxB,YAAI,aAAa,mBAAmB,OAAO,GAAG;AAC1C,WAACD,SAAQ,kBAAkB,aAAa,UAAUA,SAAQ,SAAS,KAAK,gEAAgE;AACxI,gBAAM;AAAA,QACV;AACA,YAAI;AACA,uBAAa,MAAM,cAAc,0BAA0B,YAAY,cAAc;AAAA,QACzF,SACO,cAAc;AACjB,cAAI,CAAC,UAAU,WAAW;AACtB,sBAAU,YAAY,CAAC;AAAA,UAC3B;AACA,oBAAU,UAAU,WAAW,WAAW;AAC1C,oBAAU,UAAU,kBAAkB;AACtC,gBAAM;AAAA,QACV;AACA,mBAAW,WAAW,cAAc;AACpC,cAAM,QAAQ,WAAW,cAAc;AACvC,2BAAmB;AACnB,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,KAAK,CAAC;AAAA,MAC7D;AAAA,IACJ;AAAA,EACJ,OACK;AACD,oBAAgB;AAChB,QAAI,eAAe;AACf,MAAAA,SAAQ,YAAY,CAAC,GAAIA,SAAQ,aAAa,CAAC,GAAI,CAAC,kBAAkB,cAAc,IAAI,CAAC;AAC7F,WAAO,cAAc,MAAM,MAAM,IAAI;AAAA,EACzC;AACJ,GAxD+B;AAyD/B,IAAM,oBAAoB,wBAAC,kBAAkB,OAAO,cAAc,6BAA6B,eAC3F,OAAO,cAAc,8BAA8B,eACnD,OAAO,cAAc,kBAAkB,aAFjB;AAG1B,IAAM,oBAAoB,wBAACE,WAAU;AACjC,QAAM,YAAY;AAAA,IACd,OAAAA;AAAA,IACA,WAAW,kBAAkBA,MAAK;AAAA,EACtC;AACA,QAAM,iBAAiB,kBAAkBA,OAAM,SAAS;AACxD,MAAI,gBAAgB;AAChB,cAAU,iBAAiB;AAAA,EAC/B;AACA,SAAO;AACX,GAV0B;AAW1B,IAAM,oBAAoB,wBAACA,WAAU;AACjC,MAAI,kBAAkBA,MAAK;AACvB,WAAO;AACX,MAAI,iBAAiBA,MAAK;AACtB,WAAO;AACX,MAAI,cAAcA,MAAK;AACnB,WAAO;AACX,SAAO;AACX,GAR0B;AASnB,IAAM,yBAAyB;AAAA,EAClC,MAAM;AAAA,EACN,MAAM,CAAC,OAAO;AAAA,EACd,MAAM;AAAA,EACN,UAAU;AAAA,EACV,UAAU;AACd;AACO,IAAM,iBAAiB,wBAAC,aAAa;AAAA,EACxC,cAAc,wBAAC,gBAAgB;AAC3B,gBAAY,IAAI,gBAAgB,OAAO,GAAG,sBAAsB;AAAA,EACpE,GAFc;AAGlB,IAJ8B;AAKvB,IAAM,oBAAoB,wBAAC,aAAa;AAC3C,MAAI,CAAC,aAAa,WAAW,QAAQ;AACjC;AACJ,QAAM,uBAAuB,OAAO,KAAK,SAAS,OAAO,EAAE,KAAK,CAAC,QAAQ,IAAI,YAAY,MAAM,aAAa;AAC5G,MAAI,CAAC;AACD;AACJ,QAAM,aAAa,SAAS,QAAQ,oBAAoB;AACxD,QAAM,oBAAoB,OAAO,UAAU;AAC3C,MAAI,CAAC,OAAO,MAAM,iBAAiB;AAC/B,WAAO,IAAI,KAAK,oBAAoB,GAAI;AAC5C,QAAM,iBAAiB,IAAI,KAAK,UAAU;AAC1C,SAAO;AACX,GAZiC;;;AEnGjC;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,6CAA6C,8BAAOC,SAAQC,UAAS,UAAU;AACxF,SAAO;AAAA,IACH,WAAW,iBAAiBA,QAAO,EAAE;AAAA,IACrC,QAAS,MAAM,kBAAkBD,QAAO,MAAM,EAAE,MAC3C,MAAM;AACH,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC7E,GAAG;AAAA,EACX;AACJ,GAR0D;AAS1D,SAAS,iCAAiC,gBAAgB;AACtD,SAAO;AAAA,IACH,UAAU;AAAA,IACV,mBAAmB;AAAA,MACf,MAAM;AAAA,MACN,QAAQ,eAAe;AAAA,IAC3B;AAAA,IACA,qBAAqB,wBAACA,SAAQC,cAAa;AAAA,MACvC,mBAAmB;AAAA,QACf,QAAAD;AAAA,QACA,SAAAC;AAAA,MACJ;AAAA,IACJ,IALqB;AAAA,EAMzB;AACJ;AAdS;AAeF,IAAM,mCAAmC,wBAAC,mBAAmB;AAChE,QAAM,UAAU,CAAC;AACjB,UAAQ,eAAe,WAAW;AAAA,IAC9B,SAAS;AACL,cAAQ,KAAK,iCAAiC,cAAc,CAAC;AAAA,IACjE;AAAA,EACJ;AACA,SAAO;AACX,GARgD;AASzC,IAAM,8BAA8B,wBAACD,YAAW;AACnD,QAAM,WAAW,yBAAyBA,OAAM;AAChD,SAAO,OAAO,OAAO,UAAU;AAAA,IAC3B,sBAAsB,kBAAkBA,QAAO,wBAAwB,CAAC,CAAC;AAAA,EAC7E,CAAC;AACL,GAL2C;;;ACnC3C;AAAA;AAAA;AAAA;AAAAE;AAAO,IAAM,kCAAkC,wBAAC,YAAY;AACxD,SAAO,OAAO,OAAO,SAAS;AAAA,IAC1B,sBAAsB,QAAQ,wBAAwB;AAAA,IACtD,iBAAiB,QAAQ,mBAAmB;AAAA,IAC5C,oBAAoB;AAAA,EACxB,CAAC;AACL,GAN+C;AAOxC,IAAM,eAAe;AAAA,EACxB,SAAS,EAAE,MAAM,iBAAiB,MAAM,kBAAkB;AAAA,EAC1D,UAAU,EAAE,MAAM,iBAAiB,MAAM,WAAW;AAAA,EACpD,QAAQ,EAAE,MAAM,iBAAiB,MAAM,SAAS;AAAA,EAChD,cAAc,EAAE,MAAM,iBAAiB,MAAM,uBAAuB;AACxE;;;ACZA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA,EACE,MAAQ;AAAA,EACR,aAAe;AAAA,EACf,SAAW;AAAA,EACX,SAAW;AAAA,IACT,OAAS;AAAA,IACT,aAAa;AAAA,IACb,YAAY;AAAA,IACZ,sBAAsB;AAAA,IACtB,eAAe;AAAA,IACf,yBAAyB;AAAA,IACzB,OAAS;AAAA,IACT,gBAAgB;AAAA,IAChB,mBAAmB;AAAA,EACrB;AAAA,EACA,MAAQ;AAAA,EACR,OAAS;AAAA,EACT,QAAU;AAAA,EACV,aAAe;AAAA,EACf,cAAgB;AAAA,IACd,8BAA8B;AAAA,IAC9B,yBAAyB;AAAA,IACzB,iBAAiB;AAAA,IACjB,qCAAqC;AAAA,IACrC,mCAAmC;AAAA,IACnC,8BAA8B;AAAA,IAC9B,2CAA2C;AAAA,IAC3C,+BAA+B;AAAA,IAC/B,kCAAkC;AAAA,IAClC,mCAAmC;AAAA,IACnC,kBAAkB;AAAA,IAClB,2BAA2B;AAAA,IAC3B,oCAAoC;AAAA,IACpC,iCAAiC;AAAA,IACjC,2BAA2B;AAAA,IAC3B,gBAAgB;AAAA,IAChB,8BAA8B;AAAA,IAC9B,qBAAqB;AAAA,IACrB,8BAA8B;AAAA,IAC9B,qCAAqC;AAAA,IACrC,+BAA+B;AAAA,IAC/B,4BAA4B;AAAA,IAC5B,4BAA4B;AAAA,IAC5B,4BAA4B;AAAA,IAC5B,gCAAgC;AAAA,IAChC,6BAA6B;AAAA,IAC7B,yBAAyB;AAAA,IACzB,yBAAyB;AAAA,IACzB,iBAAiB;AAAA,IACjB,sBAAsB;AAAA,IACtB,uBAAuB;AAAA,IACvB,oCAAoC;AAAA,IACpC,iCAAiC;AAAA,IACjC,sCAAsC;AAAA,IACtC,mCAAmC;AAAA,IACnC,0BAA0B;AAAA,IAC1B,2BAA2B;AAAA,IAC3B,sBAAsB;AAAA,IACtB,qBAAqB;AAAA,IACrB,uBAAuB;AAAA,IACvB,eAAe;AAAA,IACf,OAAS;AAAA,IACT,MAAQ;AAAA,EACV;AAAA,EACA,iBAAmB;AAAA,IACjB,oBAAoB;AAAA,IACpB,eAAe;AAAA,IACf,cAAgB;AAAA,IAChB,iBAAiB;AAAA,IACjB,QAAU;AAAA,IACV,YAAc;AAAA,EAChB;AAAA,EACA,SAAW;AAAA,IACT,MAAQ;AAAA,EACV;AAAA,EACA,eAAiB;AAAA,IACf,QAAQ;AAAA,MACN,gBAAgB;AAAA,QACd;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,OAAS;AAAA,IACP;AAAA,EACF;AAAA,EACA,QAAU;AAAA,IACR,MAAQ;AAAA,IACR,KAAO;AAAA,EACT;AAAA,EACA,SAAW;AAAA,EACX,SAAW;AAAA,IACT,2BAA2B;AAAA,EAC7B;AAAA,EACA,gBAAgB;AAAA,IACd,2BAA2B;AAAA,EAC7B;AAAA,EACA,UAAY;AAAA,EACZ,YAAc;AAAA,IACZ,MAAQ;AAAA,IACR,KAAO;AAAA,IACP,WAAa;AAAA,EACf;AACF;;;ACtGA;;;;AAAAC;;;ACAA;;;;AAAAC;;;ACCA;;;;AAAAC;;;ACDA;;;;AAAAC;;;ACAA;;;;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAMC,YAAW,wBAAC,UAAU,IAAI,YAAY,EAAE,OAAO,KAAK,GAAzC;;;ACAxB;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;AJOA,IAAMC,YACJ,OAAO,WAAW,eAAe,OAAO,OACpC,SAAC,OAAa;AAAK,SAAA,OAAO,KAAK,OAAO,MAAM;AAAzB,IACnBA;AAEA,SAAU,gBAAgB,MAAgB;AAE9C,MAAI,gBAAgB;AAAY,WAAO;AAEvC,MAAI,OAAO,SAAS,UAAU;AAC5B,WAAOA,UAAS,IAAI;;AAGtB,MAAI,YAAY,OAAO,IAAI,GAAG;AAC5B,WAAO,IAAI,WACT,KAAK,QACL,KAAK,YACL,KAAK,aAAa,WAAW,iBAAiB;;AAIlD,SAAO,IAAI,WAAW,IAAI;AAC5B;AAjBgB;;;AKZhB;;;;AAAAC;AAKM,SAAU,YAAY,MAAgB;AAC1C,MAAI,OAAO,SAAS,UAAU;AAC5B,WAAO,KAAK,WAAW;;AAGzB,SAAO,KAAK,eAAe;AAC7B;AANgB;;;ACLhB;;;;AAAAC;;;ACAA;;;;AAAAC;;;ACAA;;;;AAAAC;AAAO,IAAM,eAAoC,EAAE,MAAM,UAAS;AAE3D,IAAM,oBAAiE;EAC5E,MAAM;EACN,MAAM;;AAGD,IAAM,qBAAqB,IAAI,WAAW;EAC/C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;CACD;;;ACxCD;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAM,iBAAiB,CAAC;AACjB,SAAS,eAAe;AAC3B,MAAI,OAAO,WAAW,aAAa;AAC/B,WAAO;AAAA,EACX,WACS,OAAO,SAAS,aAAa;AAClC,WAAO;AAAA,EACX;AACA,SAAO;AACX;AARgB;;;AXQhB,IAAA;;EAAA,WAAA;AAKE,aAAAC,QAAY,QAAmB;AAFvB,WAAA,SAAqB,IAAI,WAAW,CAAC;AAG3C,WAAK,SAAS;AACd,WAAK,MAAK;IACZ;AAHA,WAAAA,SAAA;AAKA,IAAAA,QAAA,UAAA,SAAA,SAAO,MAAgB;AACrB,UAAI,YAAY,IAAI,GAAG;AACrB;;AAGF,UAAM,SAAS,gBAAgB,IAAI;AACnC,UAAM,aAAa,IAAI,WACrB,KAAK,OAAO,aAAa,OAAO,UAAU;AAE5C,iBAAW,IAAI,KAAK,QAAQ,CAAC;AAC7B,iBAAW,IAAI,QAAQ,KAAK,OAAO,UAAU;AAC7C,WAAK,SAAS;IAChB;AAEA,IAAAA,QAAA,UAAA,SAAA,WAAA;AAAA,UAAA,QAAA;AACE,UAAI,KAAK,KAAK;AACZ,eAAO,KAAK,IAAI,KAAK,SAAC,KAAG;AACvB,iBAAA,aAAY,EACT,OAAO,OAAO,KAAK,mBAAmB,KAAK,MAAK,MAAM,EACtD,KAAK,SAAC,MAAI;AAAK,mBAAA,IAAI,WAAW,IAAI;UAAnB,CAAoB;QAFtC,CAEuC;;AAI3C,UAAI,YAAY,KAAK,MAAM,GAAG;AAC5B,eAAO,QAAQ,QAAQ,kBAAkB;;AAG3C,aAAO,QAAQ,QAAO,EACnB,KAAK,WAAA;AACJ,eAAA,aAAY,EAAG,OAAO,OAAO,OAAO,cAAc,MAAK,MAAM;MAA7D,CAA8D,EAE/D,KAAK,SAAC,MAAI;AAAK,eAAA,QAAQ,QAAQ,IAAI,WAAW,IAAI,CAAC;MAApC,CAAqC;IACzD;AAEA,IAAAA,QAAA,UAAA,QAAA,WAAA;AAAA,UAAA,QAAA;AACE,WAAK,SAAS,IAAI,WAAW,CAAC;AAC9B,UAAI,KAAK,UAAU,KAAK,WAAW,QAAQ;AACzC,aAAK,MAAM,IAAI,QAAQ,SAAC,SAAS,QAAM;AACrC,uBAAY,EACP,OAAO,OAAO,UACf,OACA,gBAAgB,MAAK,MAAoB,GACzC,mBACA,OACA,CAAC,MAAM,CAAC,EAEP,KAAK,SAAS,MAAM;QAC3B,CAAC;AACD,aAAK,IAAI,MAAM,WAAA;QAAO,CAAC;;IAE3B;AACF,WAAAA;EAAA,EA7DA;;;;AYTA;;;;AAAAC;A;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAkHO,SAAS,UAAU,SAAS,YAAY,GAAG,WAAW;AAC3D,WAAS,MAAM,OAAO;AAAE,WAAO,iBAAiB,IAAI,QAAQ,IAAI,EAAE,SAAU,SAAS;AAAE,cAAQ,KAAK;AAAA,IAAG,CAAC;AAAA,EAAG;AAAlG;AACT,SAAO,KAAK,MAAM,IAAI,UAAU,SAAU,SAAS,QAAQ;AACvD,aAAS,UAAU,OAAO;AAAE,UAAI;AAAE,aAAK,UAAU,KAAK,KAAK,CAAC;AAAA,MAAG,SAASC,IAAG;AAAE,eAAOA,EAAC;AAAA,MAAG;AAAA,IAAE;AAAjF;AACT,aAAS,SAAS,OAAO;AAAE,UAAI;AAAE,aAAK,UAAU,OAAO,EAAE,KAAK,CAAC;AAAA,MAAG,SAASA,IAAG;AAAE,eAAOA,EAAC;AAAA,MAAG;AAAA,IAAE;AAApF;AACT,aAAS,KAAK,QAAQ;AAAE,aAAO,OAAO,QAAQ,OAAO,KAAK,IAAI,MAAM,OAAO,KAAK,EAAE,KAAK,WAAW,QAAQ;AAAA,IAAG;AAApG;AACT,UAAM,YAAY,UAAU,MAAM,SAAS,cAAc,CAAC,CAAC,GAAG,KAAK,CAAC;AAAA,EACxE,CAAC;AACH;AARgB;AAUT,SAAS,YAAY,SAAS,MAAM;AACzC,MAAIC,KAAI,EAAE,OAAO,GAAG,MAAM,kCAAW;AAAE,QAAIC,GAAE,CAAC,IAAI,EAAG,OAAMA,GAAE,CAAC;AAAG,WAAOA,GAAE,CAAC;AAAA,EAAG,GAApD,SAAuD,MAAM,CAAC,GAAG,KAAK,CAAC,EAAE,GAAGC,IAAG,GAAGD,IAAGE,KAAI,OAAO,QAAQ,OAAO,aAAa,aAAa,WAAW,QAAQ,SAAS;AAC/L,SAAOA,GAAE,OAAO,KAAK,CAAC,GAAGA,GAAE,OAAO,IAAI,KAAK,CAAC,GAAGA,GAAE,QAAQ,IAAI,KAAK,CAAC,GAAG,OAAO,WAAW,eAAeA,GAAE,OAAO,QAAQ,IAAI,WAAW;AAAE,WAAO;AAAA,EAAM,IAAIA;AAC1J,WAAS,KAAKC,IAAG;AAAE,WAAO,SAAUC,IAAG;AAAE,aAAO,KAAK,CAACD,IAAGC,EAAC,CAAC;AAAA,IAAG;AAAA,EAAG;AAAxD;AACT,WAAS,KAAK,IAAI;AACd,QAAIH,GAAG,OAAM,IAAI,UAAU,iCAAiC;AAC5D,WAAOC,OAAMA,KAAI,GAAG,GAAG,CAAC,MAAMH,KAAI,KAAKA,GAAG,KAAI;AAC1C,UAAIE,KAAI,GAAG,MAAMD,KAAI,GAAG,CAAC,IAAI,IAAI,EAAE,QAAQ,IAAI,GAAG,CAAC,IAAI,EAAE,OAAO,OAAOA,KAAI,EAAE,QAAQ,MAAMA,GAAE,KAAK,CAAC,GAAG,KAAK,EAAE,SAAS,EAAEA,KAAIA,GAAE,KAAK,GAAG,GAAG,CAAC,CAAC,GAAG,KAAM,QAAOA;AAC3J,UAAI,IAAI,GAAGA,GAAG,MAAK,CAAC,GAAG,CAAC,IAAI,GAAGA,GAAE,KAAK;AACtC,cAAQ,GAAG,CAAC,GAAG;AAAA,QACX,KAAK;AAAA,QAAG,KAAK;AAAG,UAAAA,KAAI;AAAI;AAAA,QACxB,KAAK;AAAG,UAAAD,GAAE;AAAS,iBAAO,EAAE,OAAO,GAAG,CAAC,GAAG,MAAM,MAAM;AAAA,QACtD,KAAK;AAAG,UAAAA,GAAE;AAAS,cAAI,GAAG,CAAC;AAAG,eAAK,CAAC,CAAC;AAAG;AAAA,QACxC,KAAK;AAAG,eAAKA,GAAE,IAAI,IAAI;AAAG,UAAAA,GAAE,KAAK,IAAI;AAAG;AAAA,QACxC;AACI,cAAI,EAAEC,KAAID,GAAE,MAAMC,KAAIA,GAAE,SAAS,KAAKA,GAAEA,GAAE,SAAS,CAAC,OAAO,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,MAAM,IAAI;AAAE,YAAAD,KAAI;AAAG;AAAA,UAAU;AAC3G,cAAI,GAAG,CAAC,MAAM,MAAM,CAACC,MAAM,GAAG,CAAC,IAAIA,GAAE,CAAC,KAAK,GAAG,CAAC,IAAIA,GAAE,CAAC,IAAK;AAAE,YAAAD,GAAE,QAAQ,GAAG,CAAC;AAAG;AAAA,UAAO;AACrF,cAAI,GAAG,CAAC,MAAM,KAAKA,GAAE,QAAQC,GAAE,CAAC,GAAG;AAAE,YAAAD,GAAE,QAAQC,GAAE,CAAC;AAAG,YAAAA,KAAI;AAAI;AAAA,UAAO;AACpE,cAAIA,MAAKD,GAAE,QAAQC,GAAE,CAAC,GAAG;AAAE,YAAAD,GAAE,QAAQC,GAAE,CAAC;AAAG,YAAAD,GAAE,IAAI,KAAK,EAAE;AAAG;AAAA,UAAO;AAClE,cAAIC,GAAE,CAAC,EAAG,CAAAD,GAAE,IAAI,IAAI;AACpB,UAAAA,GAAE,KAAK,IAAI;AAAG;AAAA,MACtB;AACA,WAAK,KAAK,KAAK,SAASA,EAAC;AAAA,IAC7B,SAASD,IAAG;AAAE,WAAK,CAAC,GAAGA,EAAC;AAAG,UAAI;AAAA,IAAG,UAAE;AAAU,MAAAG,KAAID,KAAI;AAAA,IAAG;AACzD,QAAI,GAAG,CAAC,IAAI,EAAG,OAAM,GAAG,CAAC;AAAG,WAAO,EAAE,OAAO,GAAG,CAAC,IAAI,GAAG,CAAC,IAAI,QAAQ,MAAM,KAAK;AAAA,EACnF;AArBS;AAsBX;AA1BgB;;;AC5HhB;;;;AAAAK;AAGO,IAAM,aAAqB;AAK3B,IAAM,gBAAwB;AAK9B,IAAM,MAAM,IAAI,YAAY;EACjC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;CACD;AAKM,IAAM,OAAO;EAClB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AAMK,IAAM,sBAAsB,KAAA,IAAA,GAAK,EAAE,IAAG;;;ACjG7C;;;;AAAAC;AAWA,IAAA;;EAAA,WAAA;AAAA,aAAAC,aAAA;AACU,WAAA,QAAoB,WAAW,KAAK,IAAI;AACxC,WAAA,OAAmB,IAAI,WAAW,EAAE;AACpC,WAAA,SAAqB,IAAI,WAAW,EAAE;AACtC,WAAA,eAAuB;AACvB,WAAA,cAAsB;AAK9B,WAAA,WAAoB;IA8ItB;AAxJA,WAAAA,YAAA;AAYE,IAAAA,WAAA,UAAA,SAAA,SAAO,MAAgB;AACrB,UAAI,KAAK,UAAU;AACjB,cAAM,IAAI,MAAM,+CAA+C;;AAGjE,UAAI,WAAW;AACT,UAAA,aAAe,KAAI;AACzB,WAAK,eAAe;AAEpB,UAAI,KAAK,cAAc,IAAI,qBAAqB;AAC9C,cAAM,IAAI,MAAM,qCAAqC;;AAGvD,aAAO,aAAa,GAAG;AACrB,aAAK,OAAO,KAAK,cAAc,IAAI,KAAK,UAAU;AAClD;AAEA,YAAI,KAAK,iBAAiB,YAAY;AACpC,eAAK,WAAU;AACf,eAAK,eAAe;;;IAG1B;AAEA,IAAAA,WAAA,UAAA,SAAA,WAAA;AACE,UAAI,CAAC,KAAK,UAAU;AAClB,YAAM,aAAa,KAAK,cAAc;AACtC,YAAM,aAAa,IAAI,SACrB,KAAK,OAAO,QACZ,KAAK,OAAO,YACZ,KAAK,OAAO,UAAU;AAGxB,YAAM,oBAAoB,KAAK;AAC/B,mBAAW,SAAS,KAAK,gBAAgB,GAAI;AAG7C,YAAI,oBAAoB,cAAc,aAAa,GAAG;AACpD,mBAASC,KAAI,KAAK,cAAcA,KAAI,YAAYA,MAAK;AACnD,uBAAW,SAASA,IAAG,CAAC;;AAE1B,eAAK,WAAU;AACf,eAAK,eAAe;;AAGtB,iBAASA,KAAI,KAAK,cAAcA,KAAI,aAAa,GAAGA,MAAK;AACvD,qBAAW,SAASA,IAAG,CAAC;;AAE1B,mBAAW,UACT,aAAa,GACb,KAAK,MAAM,aAAa,UAAW,GACnC,IAAI;AAEN,mBAAW,UAAU,aAAa,GAAG,UAAU;AAE/C,aAAK,WAAU;AAEf,aAAK,WAAW;;AAKlB,UAAM,MAAM,IAAI,WAAW,aAAa;AACxC,eAASA,KAAI,GAAGA,KAAI,GAAGA,MAAK;AAC1B,YAAIA,KAAI,CAAC,IAAK,KAAK,MAAMA,EAAC,MAAM,KAAM;AACtC,YAAIA,KAAI,IAAI,CAAC,IAAK,KAAK,MAAMA,EAAC,MAAM,KAAM;AAC1C,YAAIA,KAAI,IAAI,CAAC,IAAK,KAAK,MAAMA,EAAC,MAAM,IAAK;AACzC,YAAIA,KAAI,IAAI,CAAC,IAAK,KAAK,MAAMA,EAAC,MAAM,IAAK;;AAG3C,aAAO;IACT;AAEQ,IAAAD,WAAA,UAAA,aAAR,WAAA;AACQ,UAAA,KAAoB,MAAlB,SAAM,GAAA,QAAE,QAAK,GAAA;AAErB,UAAI,SAAS,MAAM,CAAC,GAClB,SAAS,MAAM,CAAC,GAChB,SAAS,MAAM,CAAC,GAChB,SAAS,MAAM,CAAC,GAChB,SAAS,MAAM,CAAC,GAChB,SAAS,MAAM,CAAC,GAChB,SAAS,MAAM,CAAC,GAChB,SAAS,MAAM,CAAC;AAElB,eAASC,KAAI,GAAGA,KAAI,YAAYA,MAAK;AACnC,YAAIA,KAAI,IAAI;AACV,eAAK,KAAKA,EAAC,KACP,OAAOA,KAAI,CAAC,IAAI,QAAS,MACzB,OAAOA,KAAI,IAAI,CAAC,IAAI,QAAS,MAC7B,OAAOA,KAAI,IAAI,CAAC,IAAI,QAAS,IAC9B,OAAOA,KAAI,IAAI,CAAC,IAAI;eAClB;AACL,cAAIC,KAAI,KAAK,KAAKD,KAAI,CAAC;AACvB,cAAM,QACFC,OAAM,KAAOA,MAAK,OAASA,OAAM,KAAOA,MAAK,MAAQA,OAAM;AAE/D,UAAAA,KAAI,KAAK,KAAKD,KAAI,EAAE;AACpB,cAAM,QACFC,OAAM,IAAMA,MAAK,OAASA,OAAM,KAAOA,MAAK,MAAQA,OAAM;AAE9D,eAAK,KAAKD,EAAC,KACP,OAAK,KAAK,KAAKA,KAAI,CAAC,IAAK,MAAO,OAAK,KAAK,KAAKA,KAAI,EAAE,IAAK;;AAGhE,YAAM,QACE,WAAW,IAAM,UAAU,OAC7B,WAAW,KAAO,UAAU,OAC5B,WAAW,KAAO,UAAU,OAC5B,SAAS,SAAW,CAAC,SAAS,UAChC,MACE,UAAW,IAAIA,EAAC,IAAI,KAAK,KAAKA,EAAC,IAAK,KAAM,KAC9C;AAEF,YAAME,QACA,WAAW,IAAM,UAAU,OAC3B,WAAW,KAAO,UAAU,OAC5B,WAAW,KAAO,UAAU,QAC5B,SAAS,SAAW,SAAS,SAAW,SAAS,UACrD;AAEF,iBAAS;AACT,iBAAS;AACT,iBAAS;AACT,iBAAU,SAAS,KAAM;AACzB,iBAAS;AACT,iBAAS;AACT,iBAAS;AACT,iBAAU,KAAKA,MAAM;;AAGvB,YAAM,CAAC,KAAK;AACZ,YAAM,CAAC,KAAK;AACZ,YAAM,CAAC,KAAK;AACZ,YAAM,CAAC,KAAK;AACZ,YAAM,CAAC,KAAK;AACZ,YAAM,CAAC,KAAK;AACZ,YAAM,CAAC,KAAK;AACZ,YAAM,CAAC,KAAK;IACd;AACF,WAAAH;EAAA,EAxJA;;;;ACNA,IAAAI;;EAAA,WAAA;AAME,aAAAA,QAAY,QAAmB;AAC7B,WAAK,SAAS;AACd,WAAK,OAAO,IAAI,UAAS;AACzB,WAAK,MAAK;IACZ;AAJA,WAAAA,SAAA;AAMA,IAAAA,QAAA,UAAA,SAAA,SAAO,QAAkB;AACvB,UAAI,YAAY,MAAM,KAAK,KAAK,OAAO;AACrC;;AAGF,UAAI;AACF,aAAK,KAAK,OAAO,gBAAgB,MAAM,CAAC;eACjCC,IAAG;AACV,aAAK,QAAQA;;IAEjB;AAKA,IAAAD,QAAA,UAAA,aAAA,WAAA;AACE,UAAI,KAAK,OAAO;AACd,cAAM,KAAK;;AAGb,UAAI,KAAK,OAAO;AACd,YAAI,CAAC,KAAK,MAAM,UAAU;AACxB,eAAK,MAAM,OAAO,KAAK,KAAK,OAAM,CAAE;;AAGtC,eAAO,KAAK,MAAM,OAAM;;AAG1B,aAAO,KAAK,KAAK,OAAM;IACzB;AAOM,IAAAA,QAAA,UAAA,SAAN,WAAA;;;AACE,iBAAA,CAAA,GAAO,KAAK,WAAU,CAAE;;;;AAG1B,IAAAA,QAAA,UAAA,QAAA,WAAA;AACE,WAAK,OAAO,IAAI,UAAS;AACzB,UAAI,KAAK,QAAQ;AACf,aAAK,QAAQ,IAAI,UAAS;AAC1B,YAAM,QAAQ,iBAAiB,KAAK,MAAM;AAC1C,YAAM,QAAQ,IAAI,WAAW,UAAU;AACvC,cAAM,IAAI,KAAK;AAEf,iBAASE,KAAI,GAAGA,KAAI,YAAYA,MAAK;AACnC,gBAAMA,EAAC,KAAK;AACZ,gBAAMA,EAAC,KAAK;;AAGd,aAAK,KAAK,OAAO,KAAK;AACtB,aAAK,MAAM,OAAO,KAAK;AAGvB,iBAASA,KAAI,GAAGA,KAAI,MAAM,YAAYA,MAAK;AACzC,gBAAMA,EAAC,IAAI;;;IAGjB;AACF,WAAAF;EAAA,EA1EA;;AA4EA,SAAS,iBAAiB,QAAkB;AAC1C,MAAI,QAAQ,gBAAgB,MAAM;AAElC,MAAI,MAAM,aAAa,YAAY;AACjC,QAAM,aAAa,IAAI,UAAS;AAChC,eAAW,OAAO,KAAK;AACvB,YAAQ,WAAW,OAAM;;AAG3B,MAAM,SAAS,IAAI,WAAW,UAAU;AACxC,SAAO,IAAI,KAAK;AAChB,SAAO;AACT;AAZS;;;ACjFT;;;;AAAAG;A;;;;;;;ACUA,IAAM,sBAAiD;EACrD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AAGI,SAAU,kBAAkBC,SAAc;AAC9C,MACE,qBAAqBA,OAAM,KAC3B,OAAOA,QAAO,OAAO,WAAW,UAChC;AACQ,QAAA,SAAWA,QAAO,OAAM;AAEhC,WAAO,qBAAqB,MAAM;;AAGpC,SAAO;AACT;AAXgB;AAaV,SAAU,qBAAqBA,SAAc;AACjD,MAAI,OAAOA,YAAW,YAAY,OAAOA,QAAO,WAAW,UAAU;AAC3D,QAAAC,mBAAoBD,QAAO,OAAM;AAEzC,WAAO,OAAOC,qBAAoB;;AAGpC,SAAO;AACT;AARgB;AAUV,SAAU,qBAAqB,QAAoB;AACvD,SACE,UACA,oBAAoB,MAClB,SAAA,YAAU;AAAI,WAAA,OAAO,OAAO,UAAU,MAAM;EAA9B,CAAwC;AAG5D;AAPgB;;;AnBrChB,IAAAC;;EAAA,WAAA;AAGE,aAAAA,QAAY,QAAmB;AAC7B,UAAI,kBAAkB,aAAY,CAAE,GAAG;AACrC,aAAK,OAAO,IAAI,OAAgB,MAAM;aACjC;AACL,aAAK,OAAO,IAAIA,QAAS,MAAM;;IAEnC;AANA,WAAAA,SAAA;AAQA,IAAAA,QAAA,UAAA,SAAA,SAAO,MAAkB,UAAsC;AAC7D,WAAK,KAAK,OAAO,gBAAgB,IAAI,CAAC;IACxC;AAEA,IAAAA,QAAA,UAAA,SAAA,WAAA;AACE,aAAO,KAAK,KAAK,OAAM;IACzB;AAEA,IAAAA,QAAA,UAAA,QAAA,WAAA;AACE,WAAK,KAAK,MAAK;IACjB;AACF,WAAAA;EAAA,EAtBA;;;;AoBPA;AAAA;AAAA;AAAA;AAAAC;AAAA,oBAAmB;AACZ,IAAM,iCAAiC,wBAAC,EAAE,WAAW,cAAc,MAAM,OAAOC,YAAW;AAC9F,QAAM,WAAW,OAAO,WAAW,eAAe,QAAQ,WAAW,YAC/D,cAAAC,QAAO,MAAM,OAAO,UAAU,SAAS,IACvC;AACN,QAAM,WAAW;AAAA,IACb,CAAC,cAAc,aAAa;AAAA,IAC5B,CAAC,MAAM,KAAK;AAAA,IACZ,CAAC,MAAM,UAAU,IAAI,QAAQ,OAAO,IAAI,UAAU,IAAI,OAAO;AAAA,IAC7D,CAAC,SAAS;AAAA,IACV,CAAC,cAAc,GAAG,UAAU,SAAS,QAAQ,SAAS,IAAI,UAAU,SAAS,WAAW,SAAS,EAAE;AAAA,EACvG;AACA,MAAI,WAAW;AACX,aAAS,KAAK,CAAC,OAAO,SAAS,IAAI,aAAa,CAAC;AAAA,EACrD;AACA,QAAM,QAAQ,MAAMD,SAAQ,iBAAiB;AAC7C,MAAI,OAAO;AACP,aAAS,KAAK,CAAC,OAAO,KAAK,EAAE,CAAC;AAAA,EAClC;AACA,SAAO;AACX,GAnB8C;;;ACD9C;AAAA;AAAA;AAAA;AAAAE;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,kBAAkB,wBAAC,YAAY,MAAM,QAAQ,OAAO,OAAO,GAAzC;;;ACA/B;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAM,eAAe,OAAO,eAAe,aAAa,IAAI,YAAY,IAAI;AACrE,IAAM,sBAAsB,wBAAC,SAAS;AACzC,MAAI,OAAO,SAAS,UAAU;AAC1B,QAAI,cAAc;AACd,aAAO,aAAa,OAAO,IAAI,EAAE;AAAA,IACrC;AACA,QAAI,MAAM,KAAK;AACf,aAASC,KAAI,MAAM,GAAGA,MAAK,GAAGA,MAAK;AAC/B,YAAM,OAAO,KAAK,WAAWA,EAAC;AAC9B,UAAI,OAAO,OAAQ,QAAQ;AACvB;AAAA,eACK,OAAO,QAAS,QAAQ;AAC7B,eAAO;AACX,UAAI,QAAQ,SAAU,QAAQ;AAC1B,QAAAA;AAAA,IACR;AACA,WAAO;AAAA,EACX,WACS,OAAO,KAAK,eAAe,UAAU;AAC1C,WAAO,KAAK;AAAA,EAChB,WACS,OAAO,KAAK,SAAS,UAAU;AACpC,WAAO,KAAK;AAAA,EAChB;AACA,QAAM,IAAI,MAAM,sCAAsC,IAAI,EAAE;AAChE,GAxBmC;;;ACDnC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAM,IAAI;AAAV,IAAsB,IAAI;AAA1B,IAAgC,IAAI;AAApC,IAA4C,IAAI;AAChD,IAAM,IAAI;AAAV,IAAgB,IAAI;AAApB,IAA6B,IAAI;AAAjC,IAAkD,IAAI;AAAtD,IAA+D,IAAI;AAAnE,IAA+E,IAAI;AAAnF,IAA2F,IAAI;AAA/F,IAAkH,IAAI;AAAtH,IAAiI,IAAI,EAAE,CAAC,CAAC,GAAG,OAAO,QAAQ,SAAS;AAApK,IAAuK,IAAI,EAAE,CAAC,CAAC,GAAG,MAAM,WAAW,OAAO,QAAQ,UAAU;AAA5N,IAA+N,IAAI,EAAE,CAAC,CAAC,GAAG,WAAW;AAArP,IAAwP,IAAI,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,UAAU,GAAG,IAAI,EAAE;AAAtS,IAAyS,IAAI,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,eAAe,GAAG,IAAI,EAAE;AAA5V,IAA+V,IAAI,CAAC;AAApW,IAAuW,IAAI,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,cAAc,EAAE;AAAvZ,IAA0Z,IAAI,EAAE,CAAC,CAAC,GAAG,EAAE;AAAva,IAA0a,IAAI,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,mBAAmB,EAAE,CAAC,EAAE;AAA/e,IAAkf,IAAI,CAAC,CAAC;AAAxf,IAA2f,IAAI,CAAC,CAAC;AAAjgB,IAAogB,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,SAAS,CAAC;AAC1hB,IAAM,QAAQ,EAAE,SAAS,OAAO,YAAY,EAAE,QAAQ,GAAG,cAAc,GAAG,SAAS,GAAG,UAAU,EAAE,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,YAAY,GAAG,OAAO,qEAAqE,MAAM,EAAE,GAAG,EAAE,YAAY,GAAG,OAAO,0EAA0E,MAAM,EAAE,GAAG,EAAE,UAAU,EAAE,KAAK,GAAG,YAAY,GAAG,SAAS,EAAE,GAAG,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,EAAE,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,iBAAiB,CAAC,CAAC,GAAG,GAAG,QAAQ,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,GAAG,OAAO,CAAC,EAAE,UAAU,EAAE,KAAK,kEAAkE,YAAY,GAAG,SAAS,EAAE,GAAG,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,EAAE,OAAO,mFAAmF,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,EAAE,YAAY,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,gBAAgB,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,MAAM,EAAE,GAAG,YAAY,EAAE,CAAC,GAAG,UAAU,EAAE,KAAK,sCAAsC,YAAY,GAAG,SAAS,EAAE,GAAG,MAAM,EAAE,GAAG,EAAE,UAAU,EAAE,KAAK,yDAAyD,YAAY,GAAG,SAAS,EAAE,GAAG,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,EAAE,OAAO,4DAA4D,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,EAAE,YAAY,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC,CAAC,GAAG,OAAO,CAAC,EAAE,UAAU,EAAE,KAAK,6DAA6D,YAAY,GAAG,SAAS,EAAE,GAAG,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,EAAE,OAAO,sEAAsE,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,EAAE,UAAU,EAAE,KAAK,oDAAoD,YAAY,GAAG,SAAS,EAAE,GAAG,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,EAAE,OAAO,yCAAyC,MAAM,EAAE,CAAC,EAAE;AACrzD,IAAM,UAAU;;;ADAvB,IAAM,QAAQ,IAAI,cAAc;AAAA,EAC5B,MAAM;AAAA,EACN,QAAQ,CAAC,YAAY,UAAU,gBAAgB,SAAS;AAC5D,CAAC;AACM,IAAM,0BAA0B,wBAAC,gBAAgBC,WAAU,CAAC,MAAM;AACrE,SAAO,MAAM,IAAI,gBAAgB,MAAM,gBAAgB,SAAS;AAAA,IAC5D;AAAA,IACA,QAAQA,SAAQ;AAAA,EACpB,CAAC,CAAC;AACN,GALuC;AAMvC,wBAAwB,MAAM;;;ADNvB,IAAM,mBAAmB,wBAACC,YAAW;AACxC,SAAO;AAAA,IACH,YAAY;AAAA,IACZ,eAAeA,SAAQ,iBAAiB;AAAA,IACxC,eAAeA,SAAQ,iBAAiB;AAAA,IACxC,mBAAmBA,SAAQ,qBAAqB;AAAA,IAChD,kBAAkBA,SAAQ,oBAAoB;AAAA,IAC9C,YAAYA,SAAQ,cAAc,CAAC;AAAA,IACnC,wBAAwBA,SAAQ,0BAA0B;AAAA,IAC1D,iBAAiBA,SAAQ,mBAAmB;AAAA,MACxC;AAAA,QACI,UAAU;AAAA,QACV,kBAAkB,wBAAC,QAAQ,IAAI,oBAAoB,gBAAgB,GAAjD;AAAA,QAClB,QAAQ,IAAI,kBAAkB;AAAA,MAClC;AAAA,IACJ;AAAA,IACA,QAAQA,SAAQ,UAAU,IAAI,WAAW;AAAA,IACzC,WAAWA,SAAQ,aAAa;AAAA,IAChC,WAAWA,SAAQ,aAAa;AAAA,IAChC,aAAaA,SAAQ,eAAe;AAAA,IACpC,aAAaA,SAAQ,eAAe;AAAA,EACxC;AACJ,GAtBgC;;;AGPhC;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AACA,IAAAC,iBAAmB;;;ACDnB;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,wBAAwB,CAAC,aAAa,gBAAgB,UAAU,YAAY,QAAQ;;;ADG1F,IAAM,4BAA4B,wBAAC,EAAE,aAAc,IAAI,CAAC,MAAM,QAAQ,YAAY;AACrF,QAAM,OAAO,OAAO,iBAAiB,aAAa,MAAM,aAAa,IAAI;AACzE,UAAQ,MAAM,YAAY,GAAG;AAAA,IACzB,KAAK;AACD,aAAO,QAAQ,QAAQ,gBAAgB,IAAI,WAAW,UAAU;AAAA,IACpE,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACD,aAAO,QAAQ,QAAQ,MAAM,kBAAkB,CAAC;AAAA,IACpD,KAAK;AACD,aAAO,QAAQ,QAAQ,QAAQ;AAAA,IACnC;AACI,YAAM,IAAI,MAAM,gDAAgD,sBAAsB,KAAK,IAAI,CAAC,SAAS,IAAI,EAAE;AAAA,EACvH;AACJ,CAAC,GAhBwC;AAiBzC,IAAM,kBAAkB,6BAAM;AAC1B,QAAM,WAAW,OAAO,WAAW,eAAe,QAAQ,WAAW,YAC/D,eAAAC,QAAO,MAAM,OAAO,UAAU,SAAS,IACvC;AACN,QAAMC,YAAW,UAAU,UAAU;AACrC,SAAOA,cAAa,YAAYA,cAAa;AACjD,GANwB;;;AjCTjB,IAAMC,oBAAmB,wBAACC,YAAW;AACxC,QAAM,eAAe,0BAA0BA,OAAM;AACrD,QAAM,wBAAwB,6BAAM,aAAa,EAAE,KAAK,yBAAyB,GAAnD;AAC9B,QAAM,qBAAqB,iBAAuBA,OAAM;AACxD,SAAO;AAAA,IACH,GAAG;AAAA,IACH,GAAGA;AAAA,IACH,SAAS;AAAA,IACT;AAAA,IACA,mBAAmBA,SAAQ,qBAAqB;AAAA,IAChD,2BAA2BA,SAAQ,8BAA8B,CAACC,OAAM,MAAM,QAAQ,OAAO,IAAI,MAAM,uBAAuB,CAAC;AAAA,IAC/H,0BAA0BD,SAAQ,4BAC9B,+BAA+B,EAAE,WAAW,mBAAmB,WAAW,eAAe,gBAAY,QAAQ,CAAC;AAAA,IAClH,aAAaA,SAAQ,eAAe;AAAA,IACpC,QAAQA,SAAQ,UAAU,gBAAgB,mBAAmB;AAAA,IAC7D,gBAAgB,iBAAe,OAAOA,SAAQ,kBAAkB,qBAAqB;AAAA,IACrF,WAAWA,SAAQ,cAAc,aAAa,MAAM,sBAAsB,GAAG,aAAa;AAAA,IAC1F,QAAQA,SAAQ,UAAUE;AAAA,IAC1B,iBAAiBF,SAAQ,mBAAmB;AAAA,IAC5C,sBAAsBA,SAAQ,yBAAyB,MAAM,QAAQ,QAAQ,8BAA8B;AAAA,IAC3G,iBAAiBA,SAAQ,oBAAoB,MAAM,QAAQ,QAAQ,yBAAyB;AAAA,EAChG;AACJ,GAtBgC;;;AmCXhC;AAAA;AAAA;AAAA;AAAAG;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,qCAAqC,wBAAC,kBAAkB;AACjE,SAAO;AAAA,IACH,UAAU,QAAQ;AACd,oBAAc,SAAS;AAAA,IAC3B;AAAA,IACA,SAAS;AACL,aAAO,cAAc;AAAA,IACzB;AAAA,EACJ;AACJ,GATkD;AAU3C,IAAM,yCAAyC,wBAAC,oCAAoC;AACvF,SAAO;AAAA,IACH,QAAQ,gCAAgC,OAAO;AAAA,EACnD;AACJ,GAJsD;;;ACVtD;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAM,oCAAoC,wBAAC,kBAAkB;AAChE,QAAM,mBAAmB,cAAc;AACvC,MAAI,0BAA0B,cAAc;AAC5C,MAAI,eAAe,cAAc;AACjC,SAAO;AAAA,IACH,kBAAkB,gBAAgB;AAC9B,YAAM,QAAQ,iBAAiB,UAAU,CAAC,WAAW,OAAO,aAAa,eAAe,QAAQ;AAChG,UAAI,UAAU,IAAI;AACd,yBAAiB,KAAK,cAAc;AAAA,MACxC,OACK;AACD,yBAAiB,OAAO,OAAO,GAAG,cAAc;AAAA,MACpD;AAAA,IACJ;AAAA,IACA,kBAAkB;AACd,aAAO;AAAA,IACX;AAAA,IACA,0BAA0B,wBAAwB;AAC9C,gCAA0B;AAAA,IAC9B;AAAA,IACA,yBAAyB;AACrB,aAAO;AAAA,IACX;AAAA,IACA,eAAe,aAAa;AACxB,qBAAe;AAAA,IACnB;AAAA,IACA,cAAc;AACV,aAAO;AAAA,IACX;AAAA,EACJ;AACJ,GA9BiD;AA+B1C,IAAM,+BAA+B,wBAACC,YAAW;AACpD,SAAO;AAAA,IACH,iBAAiBA,QAAO,gBAAgB;AAAA,IACxC,wBAAwBA,QAAO,uBAAuB;AAAA,IACtD,aAAaA,QAAO,YAAY;AAAA,EACpC;AACJ,GAN4C;;;AR3BrC,IAAM,2BAA2B,wBAAC,eAAe,eAAe;AACnE,QAAM,yBAAyB,OAAO,OAAO,mCAAmC,aAAa,GAAG,iCAAiC,aAAa,GAAG,qCAAqC,aAAa,GAAG,kCAAkC,aAAa,CAAC;AACtP,aAAW,QAAQ,CAAC,cAAc,UAAU,UAAU,sBAAsB,CAAC;AAC7E,SAAO,OAAO,OAAO,eAAe,uCAAuC,sBAAsB,GAAG,4BAA4B,sBAAsB,GAAG,gCAAgC,sBAAsB,GAAG,6BAA6B,sBAAsB,CAAC;AAC1Q,GAJwC;;;AtXWjC,IAAM,YAAN,cAAwB,OAAS;AAAA,EAfxC,OAewC;AAAA;AAAA;AAAA,EACpC;AAAA,EACA,eAAe,CAAC,aAAa,GAAG;AAC5B,UAAM,YAAYC,kBAAmB,iBAAiB,CAAC,CAAC;AACxD,UAAM,SAAS;AACf,SAAK,aAAa;AAClB,UAAM,YAAY,gCAAgC,SAAS;AAC3D,UAAM,YAAY,uBAAuB,SAAS;AAClD,UAAM,YAAY,mBAAmB,SAAS;AAC9C,UAAM,YAAY,oBAAoB,SAAS;AAC/C,UAAM,YAAY,wBAAwB,SAAS;AACnD,UAAM,YAAY,sBAAsB,SAAS;AACjD,UAAM,YAAY,4BAA4B,SAAS;AACvD,UAAM,YAAY,yBAAyB,WAAW,eAAe,cAAc,CAAC,CAAC;AACrF,SAAK,SAAS;AACd,SAAK,gBAAgB,IAAI,mBAAmB,KAAK,MAAM,CAAC;AACxD,SAAK,gBAAgB,IAAI,eAAe,KAAK,MAAM,CAAC;AACpD,SAAK,gBAAgB,IAAI,uBAAuB,KAAK,MAAM,CAAC;AAC5D,SAAK,gBAAgB,IAAI,oBAAoB,KAAK,MAAM,CAAC;AACzD,SAAK,gBAAgB,IAAI,gBAAgB,KAAK,MAAM,CAAC;AACrD,SAAK,gBAAgB,IAAI,4BAA4B,KAAK,MAAM,CAAC;AACjE,SAAK,gBAAgB,IAAI,uCAAuC,KAAK,QAAQ;AAAA,MACzE,kCAAkC;AAAA,MAClC,gCAAgC,8BAAOC,YAAW,IAAI,8BAA8B;AAAA,QAChF,kBAAkBA,QAAO;AAAA,MAC7B,CAAC,GAF+B;AAAA,IAGpC,CAAC,CAAC;AACF,SAAK,gBAAgB,IAAI,qBAAqB,KAAK,MAAM,CAAC;AAAA,EAC9D;AAAA,EACA,UAAU;AACN,UAAM,QAAQ;AAAA,EAClB;AACJ;;;A+X/CA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,sBAAN,MAAM,6BAA4B,iBAAmB;AAAA,EAF5D,OAE4D;AAAA;AAAA;AAAA,EACxD,YAAY,SAAS;AACjB,UAAM,OAAO;AACb,WAAO,eAAe,MAAM,qBAAoB,SAAS;AAAA,EAC7D;AACJ;;;AD84FO,IAAM,8BAA8B,8BAAO,OAAOC,aAAY;AACjE,QAAM,UAAU;AAChB,MAAI;AACJ,SAAO,0BAA0B;AAAA,IAC7B,GAAG,4BAA4B,OAAOA,QAAO;AAAA,IAC7C,CAAC,EAAE,GAAG;AAAA,IACN,CAAC,EAAE,GAAG;AAAA,EACV,CAAC;AACD,SAAO,oBAAoBA,UAAS,SAAS,KAAK,QAAW,IAAI;AACrE,GAT2C;AAy/OpC,IAAM,8BAA8B,8BAAO,QAAQC,aAAY;AAClE,MAAI,OAAO,cAAc,KAAK;AAC1B,WAAO,gBAAgB,QAAQA,QAAO;AAAA,EAC1C;AACA,QAAM,OAAO,MAAM,aAAU,OAAO,MAAMA,QAAO;AACjD,MAAI,WAAW,CAAC;AAChB,aAAW,2BAA2B,MAAMA,QAAO;AACnD,QAAM,WAAW;AAAA,IACb,WAAWC,qBAAoB,MAAM;AAAA,IACrC,GAAG;AAAA,EACP;AACA,SAAO;AACX,GAZ2C;AA03J3C,IAAM,kBAAkB,8BAAO,QAAQC,aAAY;AAC/C,QAAM,eAAe;AAAA,IACjB,GAAG;AAAA,IACH,MAAM,MAAM,kBAAe,OAAO,MAAMA,QAAO;AAAA,EACnD;AACA,QAAM,YAAY,iBAAiB,QAAQ,aAAa,IAAI;AAC5D,QAAM,aAAa,aAAa;AAChC,SAAOC,mBAAkB;AAAA,IACrB;AAAA,IACA,YAAY,WAAW,OAAO;AAAA,IAC9B;AAAA,EACJ,CAAC;AACL,GAZwB;AAwlPxB,IAAM,8BAA8B,wBAAC,OAAOC,aAAY;AACpD,QAAM,UAAU,CAAC;AACjB,MAAI,MAAM,KAAK,KAAK,MAAM;AACtB,UAAM,gBAAgB,wBAAwB,MAAM,KAAK,GAAGA,QAAO;AACnE,WAAO,QAAQ,aAAa,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,YAAM,MAAM,cAAc,IAAI,UAAU,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAC;AAC7D,cAAQ,GAAG,IAAI;AAAA,IACnB,CAAC;AAAA,EACL;AACA,MAAI,MAAM,IAAI,KAAK,MAAM;AACrB,YAAQ,IAAI,IAAI,MAAM,IAAI;AAAA,EAC9B;AACA,MAAI,MAAM,GAAG,KAAK,MAAM;AACpB,UAAM,gBAAgB,cAAc,MAAM,GAAG,GAAGA,QAAO;AACvD,WAAO,QAAQ,aAAa,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,YAAM,MAAM,UAAU,IAAI,UAAU,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAC;AACzD,cAAQ,GAAG,IAAI;AAAA,IACnB,CAAC;AAAA,EACL;AACA,MAAI,MAAM,GAAG,KAAK,MAAM;AACpB,YAAQ,GAAG,IAAI,MAAM,GAAG;AAAA,EAC5B;AACA,MAAI,MAAM,GAAG,KAAK,MAAM;AACpB,YAAQ,GAAG,IAAI,MAAM,GAAG;AAAA,EAC5B;AACA,SAAO;AACX,GA1BoC;AA4nIpC,IAAM,YAAY,wBAAC,OAAOC,aAAY;AAClC,QAAM,UAAU,CAAC;AACjB,MAAI,MAAM,EAAE,KAAK,MAAM;AACnB,YAAQ,EAAE,IAAI,MAAM,EAAE;AAAA,EAC1B;AACA,MAAI,MAAM,IAAI,KAAK,MAAM;AACrB,UAAM,gBAAgB,mBAAmB,MAAM,IAAI,GAAGA,QAAO;AAC7D,WAAO,QAAQ,aAAa,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,YAAM,MAAM,SAAS,IAAI,UAAU,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAC;AACxD,cAAQ,GAAG,IAAI;AAAA,IACnB,CAAC;AAAA,EACL;AACA,SAAO;AACX,GAbkB;AAclB,IAAM,gBAAgB,wBAAC,OAAOA,aAAY;AACtC,QAAM,UAAU,CAAC;AACjB,MAAI,UAAU;AACd,aAAW,SAAS,OAAO;AACvB,QAAI,UAAU,MAAM;AAChB;AAAA,IACJ;AACA,UAAM,gBAAgB,UAAU,OAAOA,QAAO;AAC9C,WAAO,QAAQ,aAAa,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,cAAQ,UAAU,OAAO,IAAI,GAAG,EAAE,IAAI;AAAA,IAC1C,CAAC;AACD;AAAA,EACJ;AACA,SAAO;AACX,GAdsB;AA26DtB,IAAM,0BAA0B,wBAAC,OAAOC,aAAY;AAChD,QAAM,UAAU,CAAC;AACjB,MAAI,UAAU;AACd,aAAW,SAAS,OAAO;AACvB,QAAI,UAAU,MAAM;AAChB;AAAA,IACJ;AACA,YAAQ,cAAc,OAAO,EAAE,IAAI;AACnC;AAAA,EACJ;AACA,SAAO;AACX,GAXgC;AAiuRhC,IAAM,qBAAqB,wBAAC,OAAOC,aAAY;AAC3C,QAAM,UAAU,CAAC;AACjB,MAAI,UAAU;AACd,aAAW,SAAS,OAAO;AACvB,QAAI,UAAU,MAAM;AAChB;AAAA,IACJ;AACA,YAAQ,QAAQ,OAAO,EAAE,IAAI;AAC7B;AAAA,EACJ;AACA,SAAO;AACX,GAX2B;AAy/E3B,IAAM,8CAA8C,wBAAC,QAAQC,aAAY;AACrE,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,qCAAqC,OAAO,IAAI,GAAGA,QAAO;AAAA,EAChF;AACA,SAAO;AACX,GAToD;AAUpD,IAAM,uCAAuC,wBAAC,QAAQA,aAAY;AAC9D,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,MAAM,KAAK,MAAM;AACxB,aAAS,MAAM,IAAI,aAAe,OAAO,MAAM,CAAC;AAAA,EACpD;AACA,SAAO;AACX,GAT6C;AAqmB7C,IAAM,6CAA6C,wBAAC,QAAQC,aAAY;AACpE,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,iBAAmB,OAAO,IAAI,CAAC;AAAA,EACpD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,iBAAmB,OAAO,IAAI,CAAC;AAAA,EACpD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,GAAG,IAAI,iBAAmB,OAAO,IAAI,CAAC;AAAA,EACnD;AACA,SAAO;AACX,GAZmD;AAkFnD,IAAM,gBAAgB,wBAAC,QAAQC,aAAY;AACvC,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,GAAG,IAAI,iBAAmB,OAAO,IAAI,CAAC;AAAA,EACnD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,iBAAmB,OAAO,IAAI,CAAC;AAAA,EACpD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,SAAO;AACX,GAZsB;AA44EtB,IAAM,6BAA6B,wBAAC,QAAQC,aAAY;AACpD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,GAAG,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAC/C;AACA,MAAI,OAAO,mBAAmB,IAAI;AAC9B,aAAS,KAAK,IAAI,CAAC;AAAA,EACvB,WACS,OAAO,KAAK,KAAK,QAAQ,OAAO,KAAK,EAAE,EAAE,KAAK,MAAM;AACzD,aAAS,KAAK,IAAI,mBAAmB,qBAAuB,OAAO,KAAK,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EAC3F;AACA,SAAO;AACX,GAZmC;AAgjEnC,IAAM,4BAA4B,wBAAC,QAAQC,aAAY;AACnD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,cAAgB,+BAAiC,OAAO,IAAI,CAAC,CAAC;AAAA,EACpF;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,MAAM,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,EAAE,IAAI,oBAAoB,OAAO,GAAG,GAAGA,QAAO;AAAA,EAC3D;AACA,SAAO;AACX,GAxBkC;AA2KlC,IAAM,2BAA2B,wBAAC,QAAQC,aAAY;AAClD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EACjD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,SAAO;AACX,GAfiC;AAgBjC,IAAM,+BAA+B,wBAAC,QAAQA,aAAY;AACtD,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,yBAAyB,OAAOD,QAAO;AAAA,EAClD,CAAC;AACL,GANqC;AA+DrC,IAAM,4CAA4C,wBAAC,QAAQE,aAAY;AACnE,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,MAAM,KAAK,MAAM;AACxB,aAAS,MAAM,IAAI,aAAe,OAAO,MAAM,CAAC;AAAA,EACpD;AACA,MAAI,OAAO,MAAM,KAAK,MAAM;AACxB,aAAS,MAAM,IAAI,aAAe,OAAO,MAAM,CAAC;AAAA,EACpD;AACA,MAAI,OAAO,MAAM,KAAK,MAAM;AACxB,aAAS,MAAM,IAAI,cAAgB,+BAAiC,OAAO,MAAM,CAAC,CAAC;AAAA,EACvF;AACA,SAAO;AACX,GAfkD;AAgBlD,IAAM,gDAAgD,wBAAC,QAAQA,aAAY;AACvE,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,0CAA0C,OAAOD,QAAO;AAAA,EACnE,CAAC;AACL,GANsD;AAkRtD,IAAM,oBAAoB,wBAAC,QAAQE,aAAY;AAC3C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GAN0B;AA+wD1B,IAAM,qBAAqB,wBAAC,QAAQC,aAAY;AAC5C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GAT2B;AAU3B,IAAM,yBAAyB,wBAAC,QAAQA,aAAY;AAChD,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,mBAAmB,OAAOD,QAAO;AAAA,EAC5C,CAAC;AACL,GAN+B;AAqB/B,IAAM,wBAAwB,wBAAC,QAAQE,aAAY;AAC/C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,SAAO;AACX,GAN8B;AA8P9B,IAAM,wBAAwB,wBAAC,QAAQC,aAAY;AAC/C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GAT8B;AAisB9B,IAAM,cAAc,wBAAC,QAAQC,aAAY;AACrC,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,uBAAuB,IAAI;AAClC,aAAS,IAAI,IAAI,CAAC;AAAA,EACtB,WACS,OAAO,IAAI,KAAK,QAAQ,OAAO,IAAI,EAAE,EAAE,KAAK,MAAM;AACvD,aAAS,IAAI,IAAI,kCAAkC,qBAAuB,OAAO,IAAI,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EACxG;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC/C;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,IAAI,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EACjD;AACA,MAAI,OAAO,EAAE,KAAK,MAAM;AACpB,aAAS,EAAE,IAAI,aAAe,OAAO,EAAE,CAAC;AAAA,EAC5C;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,sBAAsB,OAAO,IAAI,GAAGA,QAAO;AAAA,EAChE;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,6BAA6B,IAAI;AACxC,aAAS,IAAI,IAAI,CAAC;AAAA,EACtB,WACS,OAAO,MAAM,KAAK,QAAQ,OAAO,MAAM,EAAE,EAAE,KAAK,MAAM;AAC3D,aAAS,IAAI,IAAI,6BAA6B,qBAAuB,OAAO,MAAM,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EACrG;AACA,MAAI,OAAO,8CAA8C,IAAI;AACzD,aAAS,MAAM,IAAI,CAAC;AAAA,EACxB,WACS,OAAO,OAAO,KAAK,QAAQ,OAAO,OAAO,EAAE,EAAE,KAAK,MAAM;AAC7D,aAAS,MAAM,IAAI,8CAA8C,qBAAuB,OAAO,OAAO,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EACzH;AACA,MAAI,OAAO,wBAAwB,IAAI;AACnC,aAAS,GAAG,IAAI,CAAC;AAAA,EACrB,WACS,OAAO,IAAI,KAAK,QAAQ,OAAO,IAAI,EAAE,EAAE,KAAK,MAAM;AACvD,aAAS,GAAG,IAAI,gCAAgC,qBAAuB,OAAO,IAAI,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EACrG;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,aAAa,IAAI;AACxB,aAAS,GAAG,IAAI,CAAC;AAAA,EACrB,WACS,OAAO,GAAG,KAAK,QAAQ,OAAO,GAAG,EAAE,EAAE,KAAK,MAAM;AACrD,aAAS,GAAG,IAAI,uBAAuB,qBAAuB,OAAO,GAAG,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EAC3F;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,MAAM,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EACnD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,IAAI,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EACjD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,eAAe,OAAO,IAAI,GAAGA,QAAO;AAAA,EACzD;AACA,MAAI,OAAO,WAAW,IAAI;AACtB,aAAS,GAAG,IAAI,CAAC;AAAA,EACrB,WACS,OAAO,GAAG,KAAK,QAAQ,OAAO,GAAG,EAAE,EAAE,KAAK,MAAM;AACrD,aAAS,GAAG,IAAI,WAAW,qBAAuB,OAAO,GAAG,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EAC/E;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EACjD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,cAAc,OAAO,GAAG,GAAGA,QAAO;AAAA,EACvD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,4CAA4C,OAAO,KAAK,GAAGA,QAAO;AAAA,EACxF;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,sBAAsB,OAAO,GAAG,GAAGA,QAAO;AAAA,EAC9D;AACA,MAAI,OAAO,eAAe,IAAI;AAC1B,aAAS,IAAI,IAAI,CAAC;AAAA,EACtB,WACS,OAAO,IAAI,KAAK,QAAQ,OAAO,IAAI,EAAE,EAAE,KAAK,MAAM;AACvD,aAAS,IAAI,IAAI,eAAe,qBAAuB,OAAO,IAAI,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EACrF;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,mCAAmC,OAAO,GAAG,GAAGA,QAAO;AAAA,EAC3E;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,kBAAkB,OAAO,IAAI,GAAGA,QAAO;AAAA,EAC5D;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,cAAgB,+BAAiC,OAAO,KAAK,CAAC,CAAC;AAAA,EACrF;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,iCAAiC,OAAO,KAAK,GAAGA,QAAO;AAAA,EAC7E;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,8BAA8B,OAAO,IAAI,GAAGA,QAAO;AAAA,EACxE;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,qCAAqC,OAAO,IAAI,GAAGA,QAAO;AAAA,EAC/E;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,EAAE,IAAI,oBAAoB,OAAO,GAAG,GAAGA,QAAO;AAAA,EAC3D;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC/C;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,MAAM,KAAK,MAAM;AACxB,aAAS,KAAK,IAAI,iBAAiB,OAAO,MAAM,GAAGA,QAAO;AAAA,EAC9D;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EACjD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EACjD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,iBAAmB,OAAO,IAAI,CAAC;AAAA,EACpD;AACA,MAAI,OAAO,iBAAiB,IAAI;AAC5B,aAAS,IAAI,IAAI,CAAC;AAAA,EACtB,WACS,OAAO,GAAG,KAAK,QAAQ,OAAO,GAAG,EAAE,EAAE,KAAK,MAAM;AACrD,aAAS,IAAI,IAAI,mBAAmB,qBAAuB,OAAO,GAAG,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EACxF;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,MAAM,IAAI,cAAgB,+BAAiC,OAAO,KAAK,CAAC,CAAC;AAAA,EACtF;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,GAAG,IAAI,aAAa,OAAO,IAAI,GAAGA,QAAO;AAAA,EACtD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC/C;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,cAAc,OAAO,GAAG,GAAGA,QAAO;AAAA,EACvD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EACjD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EACjD;AACA,SAAO;AACX,GA5MoB;AA6MpB,IAAM,2CAA2C,wBAAC,QAAQA,aAAY;AAClE,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,4CAA4C,OAAO,KAAK,GAAGA,QAAO;AAAA,EACxF;AACA,SAAO;AACX,GATiD;AAUjD,IAAM,8CAA8C,wBAAC,QAAQA,aAAY;AACrE,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,SAAO;AACX,GANoD;AAuEpD,IAAM,gCAAgC,wBAAC,QAAQC,aAAY;AACvD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,EAAE,IAAI,0BAA0B,OAAO,GAAG,GAAGA,QAAO;AAAA,EACjE;AACA,SAAO;AACX,GATsC;AAUtC,IAAM,oCAAoC,wBAAC,QAAQA,aAAY;AAC3D,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,8BAA8B,OAAOD,QAAO;AAAA,EACvD,CAAC;AACL,GAN0C;AAsP1C,IAAM,wBAAwB,wBAAC,QAAQE,aAAY;AAC/C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,MAAM,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EACnD;AACA,SAAO;AACX,GAN8B;AAO9B,IAAM,4BAA4B,wBAAC,QAAQA,aAAY;AACnD,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,sBAAsB,OAAOD,QAAO;AAAA,EAC/C,CAAC;AACL,GANkC;AAOlC,IAAM,yBAAyB,wBAAC,QAAQA,aAAY;AAChD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EACjD;AACA,SAAO;AACX,GAT+B;AAU/B,IAAM,6BAA6B,wBAAC,QAAQA,aAAY;AACpD,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,uBAAuB,OAAOD,QAAO;AAAA,EAChD,CAAC;AACL,GANmC;AAOnC,IAAM,wBAAwB,wBAAC,QAAQA,aAAY;AAC/C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,MAAM,KAAK,MAAM;AACxB,aAAS,OAAO,IAAI,aAAe,OAAO,MAAM,CAAC;AAAA,EACrD;AACA,SAAO;AACX,GAN8B;AAO9B,IAAM,4BAA4B,wBAAC,QAAQA,aAAY;AACnD,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,sBAAsB,OAAOD,QAAO;AAAA,EAC/C,CAAC;AACL,GANkC;AAOlC,IAAM,kBAAkB,wBAAC,QAAQA,aAAY;AACzC,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,YAAY,OAAOD,QAAO;AAAA,EACrC,CAAC;AACL,GANwB;AAOxB,IAAM,gCAAgC,wBAAC,QAAQA,aAAY;AACvD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC/C;AACA,SAAO;AACX,GATsC;AAgCtC,IAAM,qCAAqC,wBAAC,QAAQE,aAAY;AAC5D,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,KAAK,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,MAAM,KAAK,MAAM;AACxB,aAAS,MAAM,IAAI,iBAAmB,OAAO,MAAM,CAAC;AAAA,EACxD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,SAAO;AACX,GArB2C;AAuC3C,IAAM,8BAA8B,wBAAC,QAAQC,aAAY;AACrD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,uCAAuC,OAAO,IAAI,GAAGA,QAAO;AAAA,EAClF;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,sCAAsC,OAAO,GAAG,GAAGA,QAAO;AAAA,EAC/E;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,aAAa,IAAI;AACxB,aAAS,EAAE,IAAI,CAAC;AAAA,EACpB,WACS,OAAO,GAAG,KAAK,QAAQ,OAAO,GAAG,EAAE,EAAE,KAAK,MAAM;AACrD,aAAS,EAAE,IAAI,uBAAuB,qBAAuB,OAAO,GAAG,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EAC1F;AACA,MAAI,OAAO,qBAAqB,IAAI;AAChC,aAAS,GAAG,IAAI,CAAC;AAAA,EACrB,WACS,OAAO,KAAK,KAAK,QAAQ,OAAO,KAAK,EAAE,EAAE,KAAK,MAAM;AACzD,aAAS,GAAG,IAAI,2BAA2B,qBAAuB,OAAO,KAAK,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EACjG;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,KAAK,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,0BAA0B,IAAI;AACrC,aAAS,IAAI,IAAI,CAAC;AAAA,EACtB,WACS,OAAO,KAAK,KAAK,QAAQ,OAAO,KAAK,EAAE,EAAE,KAAK,MAAM;AACzD,aAAS,IAAI,IAAI,gCAAgC,qBAAuB,OAAO,KAAK,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EACvG;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,MAAM,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EACjD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,IAAI,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EACjD;AACA,MAAI,OAAO,kBAAkB,IAAI;AAC7B,aAAS,IAAI,IAAI,CAAC;AAAA,EACtB,WACS,OAAO,MAAM,KAAK,QAAQ,OAAO,MAAM,EAAE,EAAE,KAAK,MAAM;AAC3D,aAAS,IAAI,IAAI,0BAA0B,qBAAuB,OAAO,MAAM,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EAClG;AACA,MAAI,OAAO,kBAAkB,IAAI;AAC7B,aAAS,GAAG,IAAI,CAAC;AAAA,EACrB,WACS,OAAO,OAAO,KAAK,QAAQ,OAAO,OAAO,EAAE,EAAE,KAAK,MAAM;AAC7D,aAAS,GAAG,IAAI,0BAA0B,qBAAuB,OAAO,OAAO,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EAClG;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,2CAA2C,OAAO,IAAI,GAAGA,QAAO;AAAA,EACrF;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,EAAE,IAAI,oBAAoB,OAAO,GAAG,GAAGA,QAAO;AAAA,EAC3D;AACA,SAAO;AACX,GA9EoC;AA+EpC,IAAM,yCAAyC,wBAAC,QAAQA,aAAY;AAChE,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC/C;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,IAAI,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EACjD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GAlB+C;AAmB/C,IAAM,wCAAwC,wBAAC,QAAQA,aAAY;AAC/D,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,cAAgB,+BAAiC,OAAO,IAAI,CAAC,CAAC;AAAA,EACpF;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,iBAAmB,OAAO,IAAI,CAAC;AAAA,EACrD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,MAAM,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,iBAAmB,OAAO,IAAI,CAAC;AAAA,EACpD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,yCAAyC,OAAO,IAAI,GAAGA,QAAO;AAAA,EACnF;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,iBAAmB,OAAO,IAAI,CAAC;AAAA,EACpD;AACA,SAAO;AACX,GA3B8C;AA4B9C,IAAM,kCAAkC,wBAAC,QAAQA,aAAY;AACzD,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,4BAA4B,OAAOD,QAAO;AAAA,EACrD,CAAC;AACL,GANwC;AAsGxC,IAAM,uCAAuC,wBAAC,QAAQE,aAAY;AAC9D,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GAN6C;AAO7C,IAAM,8BAA8B,wBAAC,QAAQA,aAAY;AACrD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,uCAAuC,OAAO,IAAI,GAAGA,QAAO;AAAA,EAClF;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,SAAO;AACX,GAfoC;AAgBpC,IAAM,kCAAkC,wBAAC,QAAQA,aAAY;AACzD,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,4BAA4B,OAAOD,QAAO;AAAA,EACrD,CAAC;AACL,GANwC;AAqHxC,IAAM,mBAAmB,wBAAC,QAAQE,aAAY;AAC1C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,iBAAmB,OAAO,GAAG,CAAC;AAAA,EACnD;AACA,MAAI,OAAO,EAAE,KAAK,MAAM;AACpB,aAAS,EAAE,IAAI,aAAe,OAAO,EAAE,CAAC;AAAA,EAC5C;AACA,SAAO;AACX,GATyB;AAwlEzB,IAAM,0BAA0B,wBAAC,QAAQC,aAAY;AACjD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,SAAO;AACX,GANgC;AAOhC,IAAM,iBAAiB,wBAAC,QAAQA,aAAY;AACxC,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,wBAAwB,OAAOD,QAAO;AAAA,EACjD,CAAC;AACL,GANuB;AA4oCvB,IAAM,gBAAgB,wBAAC,QAAQE,aAAY;AACvC,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,KAAK,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAChD;AACA,SAAO;AACX,GANsB;AA6/BtB,IAAM,sBAAsB,wBAAC,QAAQC,aAAY;AAC7C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,EAAE,KAAK,MAAM;AACpB,aAAS,KAAK,IAAI,aAAe,OAAO,EAAE,CAAC;AAAA,EAC/C;AACA,SAAO;AACX,GAT4B;AAiW5B,IAAM,eAAe,wBAAC,QAAQC,aAAY;AACtC,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,iBAAmB,OAAO,GAAG,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC/C;AACA,MAAI,OAAO,EAAE,KAAK,MAAM;AACpB,aAAS,GAAG,IAAI,aAAe,OAAO,EAAE,CAAC;AAAA,EAC7C;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GA9BqB;AAoTrB,IAAM,mCAAmC,wBAAC,QAAQC,aAAY;AAC1D,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,OAAO,KAAK,MAAM;AACzB,aAAS,OAAO,IAAI,aAAe,OAAO,OAAO,CAAC;AAAA,EACtD;AACA,MAAI,OAAO,UAAU,KAAK,MAAM;AAC5B,aAAS,UAAU,IAAI,aAAe,OAAO,UAAU,CAAC;AAAA,EAC5D;AACA,SAAO;AACX,GAZyC;AAoDzC,IAAM,iBAAiB,wBAAC,QAAQC,aAAY;AACxC,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,KAAK,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EACjD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC/C;AACA,SAAO;AACX,GATuB;AAUvB,IAAM,qBAAqB,wBAAC,QAAQA,aAAY;AAC5C,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,eAAe,OAAOD,QAAO;AAAA,EACxC,CAAC;AACL,GAN2B;AAuiB3B,IAAM,iBAAiB,wBAAC,QAAQE,aAAY;AACxC,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,MAAM,KAAK,MAAM;AACxB,aAAS,OAAO,IAAI,aAAe,OAAO,MAAM,CAAC;AAAA,EACrD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,KAAK,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAChD;AACA,MAAI,OAAO,KAAK,KAAK,MAAM;AACvB,aAAS,KAAK,IAAI,aAAe,OAAO,KAAK,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,aAAa,IAAI;AACxB,aAAS,EAAE,IAAI,CAAC;AAAA,EACpB,WACS,OAAO,GAAG,KAAK,QAAQ,OAAO,GAAG,EAAE,EAAE,KAAK,MAAM;AACrD,aAAS,EAAE,IAAI,uBAAuB,qBAAuB,OAAO,GAAG,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EAC1F;AACA,MAAI,OAAO,iBAAiB,IAAI;AAC5B,aAAS,GAAG,IAAI,CAAC;AAAA,EACrB,WACS,OAAO,IAAI,KAAK,QAAQ,OAAO,IAAI,EAAE,EAAE,KAAK,MAAM;AACvD,aAAS,GAAG,IAAI,gBAAgB,qBAAuB,OAAO,IAAI,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EACrF;AACA,SAAO;AACX,GAxBuB;AAyBvB,IAAM,qBAAqB,wBAAC,QAAQA,aAAY;AAC5C,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,eAAe,OAAOD,QAAO;AAAA,EACxC,CAAC;AACL,GAN2B;AA4kF3B,IAAM,iBAAiB,wBAAC,QAAQE,aAAY;AACxC,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,IAAI,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC/C;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GATuB;AAsVvB,IAAM,SAAS,wBAAC,QAAQC,aAAY;AAChC,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,EAAE,KAAK,MAAM;AACpB,aAAS,GAAG,IAAI,aAAe,OAAO,EAAE,CAAC;AAAA,EAC7C;AACA,MAAI,OAAO,EAAE,KAAK,MAAM;AACpB,aAAS,GAAG,IAAI,aAAe,OAAO,EAAE,CAAC;AAAA,EAC7C;AACA,SAAO;AACX,GATe;AAiCf,IAAM,aAAa,wBAAC,QAAQC,aAAY;AACpC,UAAQ,UAAU,CAAC,GACd,OAAO,CAACC,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,OAAO,OAAOD,QAAO;AAAA,EAChC,CAAC;AACL,GANmB;AAm5GnB,IAAME,uBAAsB,wBAAC,YAAY;AAAA,EACrC,gBAAgB,OAAO;AAAA,EACvB,WAAW,OAAO,QAAQ,kBAAkB,KAAK,OAAO,QAAQ,mBAAmB,KAAK,OAAO,QAAQ,kBAAkB;AAAA,EACzH,mBAAmB,OAAO,QAAQ,YAAY;AAAA,EAC9C,MAAM,OAAO,QAAQ,aAAa;AACtC,IAL4B;AAO5B,IAAMC,qBAAoB,kBAAkB,mBAAe;AAC3D,IAAM,sBAAsB,8BAAOC,UAAS,SAAS,MAAM,kBAAkB,SAAS;AAClF,QAAM,EAAE,UAAU,WAAW,SAAS,MAAM,MAAM,SAAS,IAAI,MAAMA,SAAQ,SAAS;AACtF,QAAM,WAAW;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR,MAAM,SAAS,SAAS,GAAG,IAAI,SAAS,MAAM,GAAG,EAAE,IAAI,OAAO,WAAW;AAAA,IACzE;AAAA,EACJ;AACA,MAAI,qBAAqB,QAAW;AAChC,aAAS,WAAW;AAAA,EACxB;AACA,MAAI,SAAS,QAAW;AACpB,aAAS,OAAO;AAAA,EACpB;AACA,SAAO,IAAI,YAAc,QAAQ;AACrC,GAjB4B;AAkB5B,IAAM,iBAAiB;AAAA,EACnB,gBAAgB;AACpB;AACA,IAAM,IAAI;AACV,IAAM,KAAK;AAkFX,IAAM,OAAO;AAIb,IAAM,OAAO;AAgDb,IAAM,OAAO;AAEb,IAAM,OAAO;AAcb,IAAM,OAAO;AAkCb,IAAM,QAAQ;AAcd,IAAM,MAAM;AAaZ,IAAM,MAAM;AAEZ,IAAM,MAAM;AACZ,IAAM,OAAO;AAGb,IAAM,QAAQ;AAEd,IAAM,OAAO;AAWb,IAAM,OAAO;AASb,IAAM,MAAM;AAkBZ,IAAM,MAAM;AAkCZ,IAAM,MAAM;AA2DZ,IAAM,QAAQ;AAcd,IAAM,OAAO;AAsDb,IAAM,OAAO;AAIb,IAAM,OAAO;AAmBb,IAAM,OAAO;AAQb,IAAM,OAAO;AACb,IAAM,SAAS;AAKf,IAAM,QAAQ;AAEd,IAAM,QAAQ;AA4Bd,IAAM,OAAO;AAoBb,IAAM,OAAO;AAqCb,IAAM,OAAO;AAGb,IAAM,QAAQ;AAyJd,IAAM,SAAS;AAGf,IAAM,QAAQ;AAmCd,IAAM,MAAM;AA+BZ,IAAM,OAAO;AAqDb,IAAM,OAAO;AA4Ib,IAAM,MAAM;AASZ,IAAM,KAAK;AAkCX,IAAM,OAAO;AACb,IAAM,QAAQ;AACd,IAAM,QAAQ;AACd,IAAM,QAAQ;AAGd,IAAM,QAAQ;AASd,IAAM,QAAQ;AACd,IAAM,SAAS;AACf,IAAM,SAAS;AACf,IAAM,SAAS;AACf,IAAM,SAAS;AAwBf,IAAM,MAAM;AAOZ,IAAM,OAAO;AAKb,IAAM,OAAO;AAEb,IAAM,aAAa;AAEnB,IAAM,UAAU;AAMhB,IAAM,OAAO;AACb,IAAM,OAAO;AAGb,IAAM,QAAQ;AACd,IAAM,QAAQ;AAEd,IAAM,OAAO;AA0Bb,IAAM,MAAM;AA+DZ,IAAM,MAAM;AAOZ,IAAM,KAAK;AAmCX,IAAM,OAAO;AAUb,IAAM,MAAM;AA+BZ,IAAM,KAAK;AAEX,IAAM,MAAM;AAGZ,IAAM,OAAO;AAEb,IAAM,MAAM;AAEZ,IAAM,OAAO;AACb,IAAM,SAAS;AAGf,IAAM,QAAQ;AAMd,IAAM,MAAM;AACZ,IAAM,OAAO;AAKb,IAAM,MAAM;AAcZ,IAAM,QAAQ;AA0Dd,IAAM,OAAO;AASb,IAAM,QAAQ;AAEd,IAAM,OAAO;AACb,IAAM,QAAQ;AAOd,IAAM,OAAO;AAKb,IAAM,OAAO;AAQb,IAAM,OAAO;AAGb,IAAM,MAAM;AAaZ,IAAM,QAAQ;AAYd,IAAM,OAAO;AAQb,IAAM,SAAS;AACf,IAAM,UAAU;AA6ChB,IAAM,MAAM;AAUZ,IAAM,OAAO;AAUb,IAAM,MAAM;AAGZ,IAAM,MAAM;AAYZ,IAAM,MAAM;AAIZ,IAAM,MAAM;AAQZ,IAAM,MAAM;AAoBZ,IAAM,OAAO;AAqFb,IAAM,SAAS;AAUf,IAAM,OAAO;AAYb,IAAM,OAAO;AAsEb,IAAM,MAAM;AAGZ,IAAM,OAAO;AAQb,IAAM,MAAM;AA+DZ,IAAM,QAAQ;AAEd,IAAM,MAAM;AAKZ,IAAM,OAAO;AAEb,IAAM,KAAK;AAcX,IAAM,OAAO;AAUb,IAAM,MAAM;AAoBZ,IAAM,OAAO;AA0Bb,IAAM,OAAO;AAOb,IAAM,MAAM;AAKZ,IAAM,KAAK;AACX,IAAM,MAAM;AAsBZ,IAAM,QAAQ;AAmDd,IAAM,QAAQ;AAGd,IAAM,OAAO;AAIb,IAAM,OAAO;AAUb,IAAM,OAAO;AAEb,IAAM,QAAQ;AAId,IAAM,QAAQ;AAQd,IAAM,OAAO;AAqBb,IAAM,MAAM;AACZ,IAAM,OAAO;AAOb,IAAM,QAAQ;AACd,IAAM,QAAQ;AAiCd,IAAM,MAAM;AAsDZ,IAAM,MAAM;AACZ,IAAM,OAAO;AAKb,IAAM,QAAQ;AACd,IAAM,QAAQ;AAuCd,IAAM,OAAO;AAGb,IAAM,OAAO;AAgDb,IAAM,OAAO;AAIb,IAAM,QAAQ;AAGd,IAAM,UAAU;AAShB,IAAM,OAAO;AA6Gb,IAAM,QAAQ;AAkCd,IAAM,OAAO;AAUb,IAAM,OAAO;AAcb,IAAM,MAAM;AAiCZ,IAAM,SAAS;AAef,IAAM,QAAQ;AAuBd,IAAM,OAAO;AA2Bb,IAAM,OAAO;AA2Bb,IAAM,QAAQ;AAmCd,IAAM,QAAQ;AACd,IAAM,SAAS;AAyBf,IAAM,OAAO;AA6Fb,IAAM,OAAO;AAmBb,IAAM,OAAO;AAab,IAAM,MAAM;AAEZ,IAAM,MAAM;AA+BZ,IAAM,MAAM;AACZ,IAAM,QAAQ;AAWd,IAAM,OAAO;AAIb,IAAM,MAAM;AAMZ,IAAM,KAAK;AA0DX,IAAM,MAAM;AAIZ,IAAM,OAAO;AASb,IAAM,OAAO;AAkBb,IAAM,QAAQ;AAEd,IAAM,MAAM;AACZ,IAAM,OAAO;AAqEb,IAAM,OAAO;AAGb,IAAM,OAAO;AAgCb,IAAM,OAAO;AACb,IAAM,OAAO;AAIb,IAAM,OAAO;AA0Bb,IAAM,OAAO;AAQb,IAAM,MAAM;AAUZ,IAAM,MAAM;AAEZ,IAAM,MAAM;AACZ,IAAM,OAAO;AAEb,IAAM,OAAO;AACb,IAAM,MAAM;AAWZ,IAAM,OAAO;AAUb,IAAM,MAAM;AAeZ,IAAM,MAAM;AAkCZ,IAAM,OAAO;AAuBb,IAAM,MAAM;AACZ,IAAM,QAAQ;AA+Bd,IAAM,MAAM;AACZ,IAAM,OAAO;AAkBb,IAAM,OAAO;AAIb,IAAM,OAAO;AACb,IAAM,SAAS;AAEf,IAAM,QAAQ;AACd,IAAM,OAAO;AAcb,IAAM,MAAM;AACZ,IAAM,OAAO;AAoBb,IAAM,MAAM;AAEZ,IAAM,QAAQ;AAkCd,IAAM,OAAO;AAOb,IAAM,MAAM;AAGZ,IAAM,OAAO;AAKb,IAAM,OAAO;AAiDb,IAAM,MAAM;AA8BZ,IAAM,QAAQ;AACd,IAAM,QAAQ;AACd,IAAM,SAAS;AACf,IAAM,QAAQ;AAEd,IAAM,OAAO;AAOb,IAAM,QAAQ;AACd,IAAM,SAAS;AACf,IAAM,SAAS;AACf,IAAM,UAAU;AAChB,IAAM,SAAS;AAiBf,IAAM,MAAM;AAMZ,IAAM,OAAO;AAIb,IAAM,OAAO;AACb,IAAM,aAAa;AACnB,IAAM,UAAU;AAEhB,IAAM,OAAO;AACb,IAAM,OAAO;AAGb,IAAM,QAAQ;AACd,IAAM,QAAQ;AAGd,IAAM,QAAQ;AAkBd,IAAM,MAAM;AACZ,IAAM,MAAM;AAiEZ,IAAM,OAAO;AAMb,IAAM,MAAM;AAEZ,IAAM,MAAM;AAIZ,IAAM,KAAK;AAEX,IAAM,MAAM;AACZ,IAAM,MAAM;AAGZ,IAAM,MAAM;AAEZ,IAAM,OAAO;AACb,IAAM,SAAS;AAGf,IAAM,QAAQ;AAMd,IAAM,MAAM;AACZ,IAAM,OAAO;AAEb,IAAM,KAAK;AAQX,IAAM,QAAQ;AAId,IAAM,OAAO;AAEb,IAAM,QAAQ;AA+Cd,IAAM,MAAM;AAGZ,IAAM,OAAO;AAOb,IAAM,QAAQ;AAId,IAAM,OAAO;AAKb,IAAM,OAAO;AAMb,IAAM,QAAQ;AAad,IAAM,OAAO;AAOb,IAAM,SAAS;AACf,IAAM,UAAU;AAUhB,IAAM,QAAQ;AAEd,IAAM,SAAS;AAkCf,IAAM,OAAO;AAEb,IAAM,SAAS;AAMf,IAAM,MAAM;AAYZ,IAAM,QAAQ;AAOd,IAAM,MAAM;AAQZ,IAAM,KAAK;AAIX,IAAM,MAAM;AAIZ,IAAM,MAAM;AA0BZ,IAAM,OAAO;AAoDb,IAAM,OAAO;AAiBb,IAAM,QAAQ;AAiBd,IAAM,OAAO;AA4Bb,IAAM,MAAM;AAGZ,IAAM,OAAO;AA2Bb,IAAM,QAAQ;AAEd,IAAM,MAAM;AAIZ,IAAM,MAAM;AAEZ,IAAM,KAAK;AAaX,IAAM,OAAO;AA0Bb,IAAM,OAAO;AAUb,IAAM,OAAO;AAcb,IAAM,OAAO;AAUb,IAAM,OAAO;AAEb,IAAM,MAAM;AAaZ,IAAM,MAAM;AA4BZ,IAAM,MAAM;AAKZ,IAAM,KAAK;AAYX,IAAM,MAAM;AASZ,IAAM,OAAO;AAQb,IAAM,OAAO;AAEb,IAAM,QAAQ;AAId,IAAM,QAAQ;AAQd,IAAM,OAAO;AAkBb,IAAM,MAAM;AAEZ,IAAM,QAAQ;AAId,IAAM,QAAQ;AA2Bd,IAAM,MAAM;AAwCZ,IAAM,MAAM;AACZ,IAAM,OAAO;AAMb,IAAM,QAAQ;AAwBd,IAAM,OAAO;AAGb,IAAM,OAAO;AA+Bb,IAAM,OAAO;AAEb,IAAM,QAAQ;AAEd,IAAM,SAAS;AACf,IAAM,MAAM;AAyCZ,IAAM,QAAQ;AA6Bd,IAAM,OAAO;AA8Bb,IAAM,OAAO;AAMb,IAAM,OAAO;AA4Cb,IAAM,QAAQ;AASd,IAAM,OAAO;AAqBb,IAAM,QAAQ;AAuBd,IAAM,OAAO;AA8Cb,IAAM,MAAM;AACZ,IAAM,OAAO;AASb,IAAM,KAAK;AAeX,IAAM,OAAO;AA+Eb,IAAM,OAAO;AAOb,IAAM,MAAM;AAUZ,IAAM,OAAO;AAkBb,IAAM,MAAM;AAoBZ,IAAM,MAAM;AACZ,IAAM,QAAQ;AAOd,IAAM,OAAO;AAIb,IAAM,OAAO;AAGb,IAAM,KAAK;AAiDX,IAAM,MAAM;AAGZ,IAAM,OAAO;AAMb,IAAM,OAAO;AAmBb,IAAM,OAAO;AAiBb,IAAM,4BAA4B,wBAAC,gBAAgB,OAAO,QAAQ,WAAW,EACxE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,2BAA6B,GAAG,IAAI,MAAM,2BAA6B,KAAK,CAAC,EACnG,KAAK,GAAG,GAFqB;AAGlC,IAAM,mBAAmB,wBAAC,QAAQ,SAAS;AACvC,MAAI,KAAK,OAAO,OAAO,SAAS,QAAW;AACvC,WAAO,KAAK,OAAO,MAAM;AAAA,EAC7B;AACA,MAAI,OAAO,cAAc,KAAK;AAC1B,WAAO;AAAA,EACX;AACJ,GAPyB;;;AEn8jEzB;AAAA;AAAA;AAAA;AAAAC;AAMO,IAAM,2BAAN,cAAuC,QACzC,aAAa,EACb,GAAG,YAAY,EACf,EAAE,SAAUC,UAAS,IAAIC,SAAQC,IAAG;AACrC,SAAO;AAAA,IACH,eAAeD,SAAQ,KAAK,WAAW,KAAK,WAAW;AAAA,IACvD,kBAAkBA,SAAQD,SAAQ,iCAAiC,CAAC;AAAA,EACxE;AACJ,CAAC,EACI,EAAE,aAAa,qBAAqB,CAAC,CAAC,EACtC,EAAE,aAAa,0BAA0B,EACzC,EAAE,QAAQ,MAAM,EAChB,IAAI,2BAA2B,EAC/B,GAAG,2BAA2B,EAC9B,MAAM,EAAE;AAAA,EApBb,OAoBa;AAAA;AAAA;AACb;;;ACrBA;AAAA;AAAA;AAAA;AAAAG;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAGO,IAAM,sCAAsC;;;ACHnD;AAAA;AAAA;AAAA;AAAAC;AAGO,IAAM,kDAAkD;;;ACH/D;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAI;AAAA,CACV,SAAUC,uBAAsB;AAC7B,EAAAA,sBAAqB,MAAM,IAAI;AACnC,GAAG,yBAAyB,uBAAuB,CAAC,EAAE;AAC/C,IAAM,8BAA8B,CAAC,qBAAqB,IAAI;;;ACJrE;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AACO,IAAM,2BAA2B,wBAAC,UAAU;AAC/C,QAAM,EAAE,2BAA2B,gCAAgC,gCAAgC,IAAI;AACvG,SAAO,OAAO,OAAO,OAAO;AAAA,IACxB,2BAA2B,kBAAkB,yBAAyB;AAAA,IACtE,gCAAgC,mCAAY;AACxC,YAAM,iCAAiC,MAAM,kBAAkB,+BAA+B,EAAE;AAChG,UAAI,iCAAiC,KAAK,iCAAiC,UAAU;AACjF,cAAM,IAAI,WAAW,6GACK,8BAA8B,0BAA0B;AAAA,MACtF;AACA,aAAO;AAAA,IACX,GAPgC;AAAA,EAQpC,CAAC;AACL,GAbwC;;;ACDxC;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,oDAAoD,8BAAOC,SAAQC,UAAS,UAAU;AAC/F,SAAO;AAAA,IACH,WAAW,iBAAiBA,QAAO,EAAE;AAAA,IACrC,QAAS,MAAM,kBAAkBD,QAAO,MAAM,EAAE,MAC3C,MAAM;AACH,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC7E,GAAG;AAAA,EACX;AACJ,GARiE;AASjE,SAASE,kCAAiC,gBAAgB;AACtD,SAAO;AAAA,IACH,UAAU;AAAA,IACV,mBAAmB;AAAA,MACf,MAAM;AAAA,MACN,QAAQ,eAAe;AAAA,IAC3B;AAAA,IACA,qBAAqB,wBAACF,SAAQC,cAAa;AAAA,MACvC,mBAAmB;AAAA,QACf,QAAAD;AAAA,QACA,SAAAC;AAAA,MACJ;AAAA,IACJ,IALqB;AAAA,EAMzB;AACJ;AAdS,OAAAC,mCAAA;AAeF,IAAM,0CAA0C,wBAAC,mBAAmB;AACvE,QAAM,UAAU,CAAC;AACjB,UAAQ,eAAe,WAAW;AAAA,IAC9B,SAAS;AACL,cAAQ,KAAKA,kCAAiC,cAAc,CAAC;AAAA,IACjE;AAAA,EACJ;AACA,SAAO;AACX,GARuD;AAShD,IAAMC,+BAA8B,wBAACH,YAAW;AACnD,QAAM,WAAW,yBAAyBA,OAAM;AAChD,SAAO,OAAO,OAAO,UAAU;AAAA,IAC3B,sBAAsB,kBAAkBA,QAAO,wBAAwB,CAAC,CAAC;AAAA,EAC7E,CAAC;AACL,GAL2C;;;ACnC3C;AAAA;AAAA;AAAA;AAAAI;AAAO,IAAMC,mCAAkC,wBAAC,YAAY;AACxD,SAAO,OAAO,OAAO,SAAS;AAAA,IAC1B,sBAAsB,QAAQ,wBAAwB;AAAA,IACtD,iBAAiB,QAAQ,mBAAmB;AAAA,IAC5C,oBAAoB;AAAA,EACxB,CAAC;AACL,GAN+C;AAOxC,IAAMC,gBAAe;AAAA,EACxB,SAAS,EAAE,MAAM,iBAAiB,MAAM,kBAAkB;AAAA,EAC1D,UAAU,EAAE,MAAM,iBAAiB,MAAM,WAAW;AAAA,EACpD,QAAQ,EAAE,MAAM,iBAAiB,MAAM,SAAS;AAAA,EAChD,cAAc,EAAE,MAAM,iBAAiB,MAAM,uBAAuB;AACxE;;;ACZA;AAAA;AAAA;AAAA;AAAAC;;;ACAA,IAAAC,mBAAA;AAAA,EACE,MAAQ;AAAA,EACR,aAAe;AAAA,EACf,SAAW;AAAA,EACX,SAAW;AAAA,IACT,OAAS;AAAA,IACT,aAAa;AAAA,IACb,YAAY;AAAA,IACZ,sBAAsB;AAAA,IACtB,eAAe;AAAA,IACf,yBAAyB;AAAA,IACzB,OAAS;AAAA,IACT,gBAAgB;AAAA,IAChB,mBAAmB;AAAA,EACrB;AAAA,EACA,MAAQ;AAAA,EACR,OAAS;AAAA,EACT,QAAU;AAAA,EACV,aAAe;AAAA,EACf,cAAgB;AAAA,IACd,8BAA8B;AAAA,IAC9B,yBAAyB;AAAA,IACzB,iBAAiB;AAAA,IACjB,qCAAqC;AAAA,IACrC,mCAAmC;AAAA,IACnC,8BAA8B;AAAA,IAC9B,2CAA2C;AAAA,IAC3C,kCAAkC;AAAA,IAClC,mCAAmC;AAAA,IACnC,kBAAkB;AAAA,IAClB,2BAA2B;AAAA,IAC3B,oCAAoC;AAAA,IACpC,iCAAiC;AAAA,IACjC,2BAA2B;AAAA,IAC3B,gBAAgB;AAAA,IAChB,8BAA8B;AAAA,IAC9B,qBAAqB;AAAA,IACrB,8BAA8B;AAAA,IAC9B,kCAAkC;AAAA,IAClC,qCAAqC;AAAA,IACrC,+BAA+B;AAAA,IAC/B,4BAA4B;AAAA,IAC5B,4BAA4B;AAAA,IAC5B,4BAA4B;AAAA,IAC5B,gCAAgC;AAAA,IAChC,6BAA6B;AAAA,IAC7B,yBAAyB;AAAA,IACzB,yBAAyB;AAAA,IACzB,iBAAiB;AAAA,IACjB,sBAAsB;AAAA,IACtB,uBAAuB;AAAA,IACvB,oCAAoC;AAAA,IACpC,iCAAiC;AAAA,IACjC,sCAAsC;AAAA,IACtC,mCAAmC;AAAA,IACnC,0BAA0B;AAAA,IAC1B,2BAA2B;AAAA,IAC3B,sBAAsB;AAAA,IACtB,qBAAqB;AAAA,IACrB,uBAAuB;AAAA,IACvB,OAAS;AAAA,EACX;AAAA,EACA,iBAAmB;AAAA,IACjB,oBAAoB;AAAA,IACpB,eAAe;AAAA,IACf,cAAgB;AAAA,IAChB,iBAAiB;AAAA,IACjB,QAAU;AAAA,IACV,YAAc;AAAA,EAChB;AAAA,EACA,SAAW;AAAA,IACT,MAAQ;AAAA,EACV;AAAA,EACA,eAAiB;AAAA,IACf,QAAQ;AAAA,MACN,gBAAgB;AAAA,QACd;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,OAAS;AAAA,IACP;AAAA,EACF;AAAA,EACA,QAAU;AAAA,IACR,MAAQ;AAAA,IACR,KAAO;AAAA,EACT;AAAA,EACA,SAAW;AAAA,EACX,SAAW;AAAA,IACT,2BAA2B;AAAA,EAC7B;AAAA,EACA,gBAAgB;AAAA,IACd,2BAA2B;AAAA,EAC7B;AAAA,EACA,UAAY;AAAA,EACZ,YAAc;AAAA,IACZ,MAAQ;AAAA,IACR,KAAO;AAAA,IACP,WAAa;AAAA,EACf;AACF;;;ACpGA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAA,IAAMC,KAAI;AAAV,IAAsBC,KAAI;AAA1B,IAAgCC,KAAI;AAApC,IAA4CC,KAAI;AAChD,IAAMC,KAAI;AAAV,IAAgBC,KAAI;AAApB,IAA6BC,KAAI;AAAjC,IAAkDC,KAAI;AAAtD,IAA+DC,KAAI;AAAnE,IAA+EC,KAAI;AAAnF,IAA2FC,KAAI;AAA/F,IAAkHC,KAAI;AAAtH,IAAiIC,KAAI,EAAE,CAACZ,EAAC,GAAG,OAAO,QAAQ,SAAS;AAApK,IAAuKa,KAAI,EAAE,CAACb,EAAC,GAAG,MAAM,WAAW,OAAO,QAAQ,UAAU;AAA5N,IAA+Nc,KAAI,EAAE,CAACX,EAAC,GAAG,WAAW;AAArP,IAAwPY,KAAI,EAAE,CAACd,EAAC,GAAGK,IAAG,CAACJ,EAAC,GAAG,CAAC,EAAE,CAACC,EAAC,GAAG,UAAU,GAAG,IAAI,EAAE;AAAtS,IAAySa,KAAI,EAAE,CAACf,EAAC,GAAGK,IAAG,CAACJ,EAAC,GAAG,CAAC,EAAE,CAACC,EAAC,GAAG,eAAe,GAAG,IAAI,EAAE;AAA5V,IAA+Vc,KAAI,CAAC;AAApW,IAAuWC,KAAI,EAAE,CAACjB,EAAC,GAAGU,IAAG,CAACT,EAAC,GAAG,CAAC,EAAE,CAACC,EAAC,GAAGO,GAAE,GAAG,cAAc,EAAE;AAAvZ,IAA0ZS,KAAI,EAAE,CAAChB,EAAC,GAAGO,GAAE;AAAva,IAA0aU,KAAI,EAAE,CAACnB,EAAC,GAAGK,IAAG,CAACJ,EAAC,GAAG,CAAC,MAAM,EAAE,CAACD,EAAC,GAAGU,IAAG,CAACT,EAAC,GAAG,CAACiB,IAAG,mBAAmB,EAAE,CAAC,EAAE;AAA/e,IAAkfE,KAAI,CAACN,EAAC;AAAxf,IAA2fO,KAAI,CAACN,EAAC;AAAjgB,IAAogBO,KAAI,CAAC,EAAE,CAACpB,EAAC,GAAG,SAAS,CAAC;AAC1hB,IAAMqB,SAAQ,EAAE,SAAS,OAAO,YAAY,EAAE,QAAQZ,IAAG,cAAcC,IAAG,SAASA,IAAG,UAAUD,GAAE,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,CAACX,EAAC,GAAGI,IAAG,CAACH,EAAC,GAAG,CAACY,EAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,YAAYO,IAAG,OAAO,qEAAqE,MAAMd,GAAE,GAAG,EAAE,YAAYe,IAAG,OAAO,0EAA0E,MAAMf,GAAE,GAAG,EAAE,UAAU,EAAE,KAAKO,IAAG,YAAYG,IAAG,SAASA,GAAE,GAAG,MAAMT,GAAE,CAAC,GAAG,MAAMC,GAAE,GAAG,EAAE,YAAY,CAAC,EAAE,CAACR,EAAC,GAAGI,IAAG,CAACH,EAAC,GAAGqB,GAAE,CAAC,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,CAACtB,EAAC,GAAG,iBAAiB,CAACC,EAAC,GAAGqB,IAAG,QAAQb,GAAE,CAAC,GAAG,OAAO,CAAC,EAAE,YAAY,CAACK,IAAGC,EAAC,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,CAACf,EAAC,GAAGK,IAAG,CAACJ,EAAC,GAAG,CAACE,IAAGc,EAAC,EAAE,GAAGE,EAAC,GAAG,OAAO,CAAC,EAAE,UAAU,EAAE,KAAK,yEAAyE,YAAYH,IAAG,SAASA,GAAE,GAAG,MAAMT,GAAE,CAAC,GAAG,MAAMC,GAAE,GAAG,EAAE,OAAO,mFAAmF,MAAMF,GAAE,CAAC,GAAG,MAAME,GAAE,GAAG,EAAE,YAAYY,IAAG,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,CAACpB,EAAC,GAAGK,IAAG,CAACJ,EAAC,GAAG,CAACgB,IAAGd,EAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,CAACH,EAAC,GAAG,gBAAgB,CAACC,EAAC,GAAG,CAAC,EAAE,CAACD,EAAC,GAAGU,IAAG,CAACT,EAAC,GAAG,CAACiB,IAAG,MAAM,EAAE,GAAG,YAAY,EAAE,CAAC,GAAG,UAAU,EAAE,KAAK,6CAA6C,YAAYF,IAAG,SAASA,GAAE,GAAG,MAAMT,GAAE,GAAG,EAAE,UAAU,EAAE,KAAK,gEAAgE,YAAYS,IAAG,SAASA,GAAE,GAAG,MAAMT,GAAE,CAAC,GAAG,MAAMC,GAAE,GAAG,EAAE,OAAO,4DAA4D,MAAMF,GAAE,CAAC,GAAG,MAAME,GAAE,GAAG,EAAE,YAAYa,IAAG,OAAO,CAAC,EAAE,YAAY,CAACF,EAAC,GAAG,OAAO,CAAC,EAAE,UAAU,EAAE,KAAK,oEAAoE,YAAYH,IAAG,SAASA,GAAE,GAAG,MAAMT,GAAE,CAAC,GAAG,MAAMC,GAAE,GAAG,EAAE,OAAO,sEAAsE,MAAMF,GAAE,CAAC,GAAG,MAAME,GAAE,GAAG,EAAE,UAAU,EAAE,KAAK,2DAA2D,YAAYQ,IAAG,SAASA,GAAE,GAAG,MAAMT,GAAE,CAAC,GAAG,MAAMC,GAAE,CAAC,GAAG,MAAMA,GAAE,GAAG,EAAE,OAAO,yCAAyC,MAAMF,GAAE,CAAC,EAAE;AACx1D,IAAMkB,WAAUD;;;ADAvB,IAAME,SAAQ,IAAI,cAAc;AAAA,EAC5B,MAAM;AAAA,EACN,QAAQ,CAAC,YAAY,UAAU,gBAAgB,SAAS;AAC5D,CAAC;AACM,IAAMC,2BAA0B,wBAAC,gBAAgBC,WAAU,CAAC,MAAM;AACrE,SAAOF,OAAM,IAAI,gBAAgB,MAAM,gBAAgBG,UAAS;AAAA,IAC5D;AAAA,IACA,QAAQD,SAAQ;AAAA,EACpB,CAAC,CAAC;AACN,GALuC;AAMvC,wBAAwB,MAAM;;;ADNvB,IAAME,oBAAmB,wBAACC,YAAW;AACxC,SAAO;AAAA,IACH,YAAY;AAAA,IACZ,eAAeA,SAAQ,iBAAiB;AAAA,IACxC,eAAeA,SAAQ,iBAAiB;AAAA,IACxC,mBAAmBA,SAAQ,qBAAqB;AAAA,IAChD,kBAAkBA,SAAQ,oBAAoBC;AAAA,IAC9C,YAAYD,SAAQ,cAAc,CAAC;AAAA,IACnC,wBAAwBA,SAAQ,0BAA0B;AAAA,IAC1D,iBAAiBA,SAAQ,mBAAmB;AAAA,MACxC;AAAA,QACI,UAAU;AAAA,QACV,kBAAkB,wBAAC,QAAQ,IAAI,oBAAoB,gBAAgB,GAAjD;AAAA,QAClB,QAAQ,IAAI,kBAAkB;AAAA,MAClC;AAAA,IACJ;AAAA,IACA,QAAQA,SAAQ,UAAU,IAAI,WAAW;AAAA,IACzC,WAAWA,SAAQ,aAAa;AAAA,IAChC,WAAWA,SAAQ,aAAa;AAAA,IAChC,aAAaA,SAAQ,eAAe;AAAA,IACpC,aAAaA,SAAQ,eAAe;AAAA,EACxC;AACJ,GAtBgC;;;AFKzB,IAAME,oBAAmB,wBAACC,YAAW;AACxC,QAAM,eAAe,0BAA0BA,OAAM;AACrD,QAAM,wBAAwB,6BAAM,aAAa,EAAE,KAAK,yBAAyB,GAAnD;AAC9B,QAAM,qBAAqBD,kBAAuBC,OAAM;AACxD,SAAO;AAAA,IACH,GAAG;AAAA,IACH,GAAGA;AAAA,IACH,SAAS;AAAA,IACT;AAAA,IACA,mBAAmBA,SAAQ,qBAAqB;AAAA,IAChD,2BAA2BA,SAAQ,8BAA8B,CAACC,OAAM,MAAM,QAAQ,OAAO,IAAI,MAAM,uBAAuB,CAAC;AAAA,IAC/H,0BAA0BD,SAAQ,4BAC9B,+BAA+B,EAAE,WAAW,mBAAmB,WAAW,eAAeE,iBAAY,QAAQ,CAAC;AAAA,IAClH,2BAA2BF,SAAQ,6BAA6B;AAAA,IAChE,aAAaA,SAAQ,eAAe;AAAA,IACpC,QAAQA,SAAQ,UAAU,gBAAgB,mBAAmB;AAAA,IAC7D,gBAAgB,iBAAe,OAAOA,SAAQ,kBAAkB,qBAAqB;AAAA,IACrF,gCAAgCA,SAAQ,kCAAkC;AAAA,IAC1E,WAAWA,SAAQ,cAAc,aAAa,MAAM,sBAAsB,GAAG,aAAa;AAAA,IAC1F,QAAQA,SAAQ,UAAUG;AAAA,IAC1B,iBAAiBH,SAAQ,mBAAmB;AAAA,IAC5C,sBAAsBA,SAAQ,yBAAyB,MAAM,QAAQ,QAAQ,8BAA8B;AAAA,IAC3G,iBAAiBA,SAAQ,oBAAoB,MAAM,QAAQ,QAAQ,yBAAyB;AAAA,EAChG;AACJ,GAxBgC;;;AKZhC;AAAA;AAAA;AAAA;AAAAI;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAAO,IAAMC,qCAAoC,wBAAC,kBAAkB;AAChE,QAAM,mBAAmB,cAAc;AACvC,MAAI,0BAA0B,cAAc;AAC5C,MAAI,eAAe,cAAc;AACjC,SAAO;AAAA,IACH,kBAAkB,gBAAgB;AAC9B,YAAM,QAAQ,iBAAiB,UAAU,CAAC,WAAW,OAAO,aAAa,eAAe,QAAQ;AAChG,UAAI,UAAU,IAAI;AACd,yBAAiB,KAAK,cAAc;AAAA,MACxC,OACK;AACD,yBAAiB,OAAO,OAAO,GAAG,cAAc;AAAA,MACpD;AAAA,IACJ;AAAA,IACA,kBAAkB;AACd,aAAO;AAAA,IACX;AAAA,IACA,0BAA0B,wBAAwB;AAC9C,gCAA0B;AAAA,IAC9B;AAAA,IACA,yBAAyB;AACrB,aAAO;AAAA,IACX;AAAA,IACA,eAAe,aAAa;AACxB,qBAAe;AAAA,IACnB;AAAA,IACA,cAAc;AACV,aAAO;AAAA,IACX;AAAA,EACJ;AACJ,GA9BiD;AA+B1C,IAAMC,gCAA+B,wBAACC,YAAW;AACpD,SAAO;AAAA,IACH,iBAAiBA,QAAO,gBAAgB;AAAA,IACxC,wBAAwBA,QAAO,uBAAuB;AAAA,IACtD,aAAaA,QAAO,YAAY;AAAA,EACpC;AACJ,GAN4C;;;AD3BrC,IAAMC,4BAA2B,wBAAC,eAAe,eAAe;AACnE,QAAM,yBAAyB,OAAO,OAAO,mCAAmC,aAAa,GAAG,iCAAiC,aAAa,GAAG,qCAAqC,aAAa,GAAGC,mCAAkC,aAAa,CAAC;AACtP,aAAW,QAAQ,CAAC,cAAc,UAAU,UAAU,sBAAsB,CAAC;AAC7E,SAAO,OAAO,OAAO,eAAe,uCAAuC,sBAAsB,GAAG,4BAA4B,sBAAsB,GAAG,gCAAgC,sBAAsB,GAAGC,8BAA6B,sBAAsB,CAAC;AAC1Q,GAJwC;;;AnBYjC,IAAM,mBAAN,cAA+B,OAAS;AAAA,EAhB/C,OAgB+C;AAAA;AAAA;AAAA,EAC3C;AAAA,EACA,eAAe,CAAC,aAAa,GAAG;AAC5B,UAAM,YAAYC,kBAAmB,iBAAiB,CAAC,CAAC;AACxD,UAAM,SAAS;AACf,SAAK,aAAa;AAClB,UAAM,YAAYC,iCAAgC,SAAS;AAC3D,UAAM,YAAY,uBAAuB,SAAS;AAClD,UAAM,YAAY,mBAAmB,SAAS;AAC9C,UAAM,YAAY,oBAAoB,SAAS;AAC/C,UAAM,YAAY,wBAAwB,SAAS;AACnD,UAAM,YAAY,sBAAsB,SAAS;AACjD,UAAM,YAAYC,6BAA4B,SAAS;AACvD,UAAM,YAAY,yBAAyB,SAAS;AACpD,UAAM,YAAYC,0BAAyB,WAAW,eAAe,cAAc,CAAC,CAAC;AACrF,SAAK,SAAS;AACd,SAAK,gBAAgB,IAAI,mBAAmB,KAAK,MAAM,CAAC;AACxD,SAAK,gBAAgB,IAAI,eAAe,KAAK,MAAM,CAAC;AACpD,SAAK,gBAAgB,IAAI,uBAAuB,KAAK,MAAM,CAAC;AAC5D,SAAK,gBAAgB,IAAI,oBAAoB,KAAK,MAAM,CAAC;AACzD,SAAK,gBAAgB,IAAI,gBAAgB,KAAK,MAAM,CAAC;AACrD,SAAK,gBAAgB,IAAI,4BAA4B,KAAK,MAAM,CAAC;AACjE,SAAK,gBAAgB,IAAI,uCAAuC,KAAK,QAAQ;AAAA,MACzE,kCAAkC;AAAA,MAClC,gCAAgC,8BAAOC,YAAW,IAAI,8BAA8B;AAAA,QAChF,kBAAkBA,QAAO;AAAA,MAC7B,CAAC,GAF+B;AAAA,IAGpC,CAAC,CAAC;AACF,SAAK,gBAAgB,IAAI,qBAAqB,KAAK,MAAM,CAAC;AAAA,EAC9D;AAAA,EACA,UAAU;AACN,UAAM,QAAQ;AAAA,EAClB;AACJ;;;AqBjDA;AAAA;AAAA;AAAA;AAAAC;;;ACAA;AAAA;AAAA;AAAA;AAAAC;AAEO,IAAM,6BAAN,MAAM,oCAAmC,iBAAmB;AAAA,EAFnE,OAEmE;AAAA;AAAA;AAAA,EAC/D,YAAY,SAAS;AACjB,UAAM,OAAO;AACb,WAAO,eAAe,MAAM,4BAA2B,SAAS;AAAA,EACpE;AACJ;;;ACPA;AAAA;AAAA;AAAA;AAAAC;AAmEO,IAAM,kCAAN,MAAM,yCAAwC,2BAAgB;AAAA,EAnErE,OAmEqE;AAAA;AAAA;AAAA,EACjE,OAAO;AAAA,EACP,SAAS;AAAA,EACT;AAAA,EACA,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,iCAAgC,SAAS;AACrE,SAAK,UAAU,KAAK;AAAA,EACxB;AACJ;AACO,IAAM,oBAAN,MAAM,2BAA0B,2BAAgB;AAAA,EAjFvD,OAiFuD;AAAA;AAAA;AAAA,EACnD,OAAO;AAAA,EACP,SAAS;AAAA,EACT;AAAA,EACA,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,mBAAkB,SAAS;AACvD,SAAK,UAAU,KAAK;AAAA,EACxB;AACJ;AACO,IAAM,6BAAN,MAAM,oCAAmC,2BAAgB;AAAA,EA/FhE,OA+FgE;AAAA;AAAA;AAAA,EAC5D,OAAO;AAAA,EACP,SAAS;AAAA,EACT;AAAA,EACA,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,4BAA2B,SAAS;AAChE,SAAK,8BAA8B,KAAK;AAAA,EAC5C;AACJ;AAaO,IAAM,mBAAN,MAAM,0BAAyB,2BAAgB;AAAA,EAzHtD,OAyHsD;AAAA;AAAA;AAAA,EAClD,OAAO;AAAA,EACP,SAAS;AAAA,EACT,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,kBAAiB,SAAS;AAAA,EAC1D;AACJ;AACO,IAAM,uBAAN,MAAM,8BAA6B,2BAAgB;AAAA,EArI1D,OAqI0D;AAAA;AAAA;AAAA,EACtD,OAAO;AAAA,EACP,SAAS;AAAA,EACT;AAAA,EACA,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,sBAAqB,SAAS;AAC1D,SAAK,UAAU,KAAK;AAAA,EACxB;AACJ;AACO,IAAM,uCAAN,MAAM,8CAA6C,2BAAgB;AAAA,EAnJ1E,OAmJ0E;AAAA;AAAA;AAAA,EACtE,OAAO;AAAA,EACP,SAAS;AAAA,EACT,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,sCAAqC,SAAS;AAAA,EAC9E;AACJ;AACO,IAAM,iCAAN,MAAM,wCAAuC,2BAAgB;AAAA,EA/JpE,OA+JoE;AAAA;AAAA;AAAA,EAChE,OAAO;AAAA,EACP,SAAS;AAAA,EACT,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,gCAA+B,SAAS;AAAA,EACxE;AACJ;AACO,IAAM,oCAAN,MAAM,2CAA0C,2BAAgB;AAAA,EA3KvE,OA2KuE;AAAA;AAAA;AAAA,EACnE,OAAO;AAAA,EACP,SAAS;AAAA,EACT,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,mCAAkC,SAAS;AAAA,EAC3E;AACJ;AACO,IAAM,4BAAN,MAAM,mCAAkC,2BAAgB;AAAA,EAvL/D,OAuL+D;AAAA;AAAA;AAAA,EAC3D,OAAO;AAAA,EACP,SAAS;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,2BAA0B,SAAS;AAC/D,SAAK,eAAe,KAAK;AACzB,SAAK,aAAa,KAAK;AACvB,SAAK,UAAU,KAAK;AAAA,EACxB;AACJ;AAKO,IAAM,mBAAN,MAAM,0BAAyB,2BAAgB;AAAA,EA7MtD,OA6MsD;AAAA;AAAA;AAAA,EAClD,OAAO;AAAA,EACP,SAAS;AAAA,EACT,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,kBAAiB,SAAS;AAAA,EAC1D;AACJ;AAWO,IAAM,yBAAN,MAAM,gCAA+B,2BAAgB;AAAA,EAnO5D,OAmO4D;AAAA;AAAA;AAAA,EACxD,OAAO;AAAA,EACP,SAAS;AAAA,EACT;AAAA,EACA,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,wBAAuB,SAAS;AAC5D,SAAK,UAAU,KAAK;AAAA,EACxB;AACJ;AAeO,IAAM,qBAAN,MAAM,4BAA2B,2BAAgB;AAAA,EA/PxD,OA+PwD;AAAA;AAAA;AAAA,EACpD,OAAO;AAAA,EACP,SAAS;AAAA,EACT,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,oBAAmB,SAAS;AAAA,EAC5D;AACJ;AACO,IAAM,qBAAN,MAAM,4BAA2B,2BAAgB;AAAA,EA3QxD,OA2QwD;AAAA;AAAA;AAAA,EACpD,OAAO;AAAA,EACP,SAAS;AAAA,EACT,YAAY,MAAM;AACd,UAAM;AAAA,MACF,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAG;AAAA,IACP,CAAC;AACD,WAAO,eAAe,MAAM,oBAAmB,SAAS;AAAA,EAC5D;AACJ;;;AFvGO,IAAM,gCAAgC,8BAAO,OAAOC,aAAY;AACnE,QAAM,UAAUC;AAChB,MAAI;AACJ,SAAOC,2BAA0B;AAAA,IAC7B,GAAG,4BAA4B,OAAOF,QAAO;AAAA,IAC7C,CAACG,GAAE,GAAG;AAAA,IACN,CAACC,GAAE,GAAGC;AAAA,EACV,CAAC;AACD,SAAOC,qBAAoBN,UAAS,SAAS,KAAK,QAAW,IAAI;AACrE,GAT6C;AAsatC,IAAM,gCAAgC,8BAAO,QAAQO,aAAY;AACpE,MAAI,OAAO,cAAc,KAAK;AAC1B,WAAOC,iBAAgB,QAAQD,QAAO;AAAA,EAC1C;AACA,QAAM,OAAO,MAAM,aAAU,OAAO,MAAMA,QAAO;AACjD,MAAI,WAAW,CAAC;AAChB,aAAW,6BAA6B,KAAK,2BAA2BA,QAAO;AAC/E,QAAM,WAAW;AAAA,IACb,WAAWE,qBAAoB,MAAM;AAAA,IACrC,GAAG;AAAA,EACP;AACA,SAAO;AACX,GAZ6C;AAqQ7C,IAAMC,mBAAkB,8BAAO,QAAQC,aAAY;AAC/C,QAAM,eAAe;AAAA,IACjB,GAAG;AAAA,IACH,MAAM,MAAM,kBAAe,OAAO,MAAMA,QAAO;AAAA,EACnD;AACA,QAAM,YAAY,mBAAmB,QAAQ,aAAa,IAAI;AAC9D,UAAQ,WAAW;AAAA,IACf,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,uBAAuB,cAAcA,QAAO;AAAA,IAC5D,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,2BAA2B,cAAcA,QAAO;AAAA,IAChE,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,2CAA2C,cAAcA,QAAO;AAAA,IAChF,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,qCAAqC,cAAcA,QAAO;AAAA,IAC1E,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,wCAAwC,cAAcA,QAAO;AAAA,IAC7E,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,gCAAgC,cAAcA,QAAO;AAAA,IACrE,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,wBAAwB,cAAcA,QAAO;AAAA,IAC7D,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,uBAAuB,cAAcA,QAAO;AAAA,IAC5D,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,6BAA6B,cAAcA,QAAO;AAAA,IAClE,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,yBAAyB,cAAcA,QAAO;AAAA,IAC9D,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,iCAAiC,cAAcA,QAAO;AAAA,IACtE,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,sCAAsC,cAAcA,QAAO;AAAA,IAC3E,KAAK;AAAA,IACL,KAAK;AACD,YAAM,MAAM,yBAAyB,cAAcA,QAAO;AAAA,IAC9D;AACI,YAAM,aAAa,aAAa;AAChC,aAAOC,mBAAkB;AAAA,QACrB;AAAA,QACA,YAAY,WAAW;AAAA,QACvB;AAAA,MACJ,CAAC;AAAA,EACT;AACJ,GAtDwB;AAuDxB,IAAM,wCAAwC,8BAAO,cAAcD,aAAY;AAC3E,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,mCAAmC,KAAK,OAAOA,QAAO;AAC3E,QAAM,YAAY,IAAI,gCAAgC;AAAA,IAClD,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GAR8C;AAS9C,IAAM,0BAA0B,8BAAO,cAAcF,aAAY;AAC7D,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,qBAAqB,KAAK,OAAOA,QAAO;AAC7D,QAAM,YAAY,IAAI,kBAAkB;AAAA,IACpC,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GARgC;AAShC,IAAM,mCAAmC,8BAAO,cAAcF,aAAY;AACtE,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,8BAA8B,KAAK,OAAOA,QAAO;AACtE,QAAM,YAAY,IAAI,2BAA2B;AAAA,IAC7C,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GARyC;AASzC,IAAM,6BAA6B,8BAAO,cAAcF,aAAY;AAChE,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,wBAAwB,KAAK,OAAOA,QAAO;AAChE,QAAM,YAAY,IAAI,qBAAqB;AAAA,IACvC,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GARmC;AASnC,IAAM,2BAA2B,8BAAO,cAAcF,aAAY;AAC9D,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,sBAAsB,KAAK,OAAOA,QAAO;AAC9D,QAAM,YAAY,IAAI,mBAAmB;AAAA,IACrC,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GARiC;AASjC,IAAM,yBAAyB,8BAAO,cAAcF,aAAY;AAC5D,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,oBAAoB,KAAK,OAAOA,QAAO;AAC5D,QAAM,YAAY,IAAI,iBAAiB;AAAA,IACnC,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GAR+B;AAS/B,IAAM,6CAA6C,8BAAO,cAAcF,aAAY;AAChF,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,wCAAwC,KAAK,OAAOA,QAAO;AAChF,QAAM,YAAY,IAAI,qCAAqC;AAAA,IACvD,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GARmD;AASnD,IAAM,uCAAuC,8BAAO,cAAcF,aAAY;AAC1E,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,kCAAkC,KAAK,OAAOA,QAAO;AAC1E,QAAM,YAAY,IAAI,+BAA+B;AAAA,IACjD,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GAR6C;AAS7C,IAAM,+BAA+B,8BAAO,cAAcF,aAAY;AAClE,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,0BAA0B,KAAK,OAAOA,QAAO;AAClE,QAAM,YAAY,IAAI,uBAAuB;AAAA,IACzC,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GARqC;AASrC,IAAM,2BAA2B,8BAAO,cAAcF,aAAY;AAC9D,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,sBAAsB,KAAK,OAAOA,QAAO;AAC9D,QAAM,YAAY,IAAI,mBAAmB;AAAA,IACrC,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GARiC;AASjC,IAAM,0CAA0C,8BAAO,cAAcF,aAAY;AAC7E,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,qCAAqC,KAAK,OAAOA,QAAO;AAC7E,QAAM,YAAY,IAAI,kCAAkC;AAAA,IACpD,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GARgD;AAShD,IAAM,yBAAyB,8BAAO,cAAcF,aAAY;AAC5D,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,oBAAoB,KAAK,OAAOA,QAAO;AAC5D,QAAM,YAAY,IAAI,iBAAiB;AAAA,IACnC,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GAR+B;AAS/B,IAAM,kCAAkC,8BAAO,cAAcF,aAAY;AACrE,QAAM,OAAO,aAAa;AAC1B,QAAM,eAAe,6BAA6B,KAAK,OAAOA,QAAO;AACrE,QAAM,YAAY,IAAI,0BAA0B;AAAA,IAC5C,WAAWE,qBAAoB,YAAY;AAAA,IAC3C,GAAG;AAAA,EACP,CAAC;AACD,SAAO,yBAA2B,WAAW,IAAI;AACrD,GARwC;AAyVxC,IAAM,eAAe,wBAAC,OAAOC,aAAY;AACrC,QAAM,UAAU,CAAC;AACjB,MAAI,MAAM,GAAG,KAAK,MAAM;AACpB,YAAQ,GAAG,IAAI,MAAM,GAAG;AAAA,EAC5B;AACA,MAAI,MAAMC,IAAG,KAAK,MAAM;AACpB,YAAQA,IAAG,IAAI,MAAMA,IAAG;AAAA,EAC5B;AACA,SAAO;AACX,GATqB;AAmCrB,IAAM,gBAAgB,wBAAC,OAAOC,aAAY;AACtC,QAAM,UAAU,CAAC;AACjB,MAAI,UAAU;AACd,aAAW,SAAS,OAAO;AACvB,QAAI,UAAU,MAAM;AAChB;AAAA,IACJ;AACA,UAAM,gBAAgB,aAAa,OAAOA,QAAO;AACjD,WAAO,QAAQ,aAAa,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,cAAQ,UAAU,OAAO,IAAI,GAAG,EAAE,IAAI;AAAA,IAC1C,CAAC;AACD;AAAA,EACJ;AACA,SAAO;AACX,GAdsB;AAqJtB,IAAM,wBAAwB,wBAAC,OAAOC,aAAY;AAC9C,QAAM,UAAU,CAAC;AACjB,MAAI,UAAU;AACd,aAAW,SAAS,OAAO;AACvB,QAAI,UAAU,MAAM;AAChB;AAAA,IACJ;AACA,YAAQ,UAAU,OAAO,EAAE,IAAI;AAC/B;AAAA,EACJ;AACA,SAAO;AACX,GAX8B;AAuF9B,IAAM,8BAA8B,wBAAC,OAAOC,aAAY;AACpD,QAAM,UAAU,CAAC;AACjB,MAAI,MAAMC,GAAE,KAAK,MAAM;AACnB,YAAQA,GAAE,IAAI,MAAMA,GAAE;AAAA,EAC1B;AACA,MAAI,MAAM,GAAG,KAAK,MAAM;AACpB,YAAQ,GAAG,IAAI,MAAM,GAAG;AAAA,EAC5B;AACA,MAAI,MAAM,EAAE,KAAK,MAAM;AACnB,UAAM,gBAAgB,cAAc,MAAM,EAAE,GAAGD,QAAO;AACtD,QAAI,MAAM,EAAE,GAAG,WAAW,GAAG;AACzB,cAAQ,aAAa,CAAC;AAAA,IAC1B;AACA,WAAO,QAAQ,aAAa,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,YAAM,MAAM,cAAc,GAAG;AAC7B,cAAQ,GAAG,IAAI;AAAA,IACnB,CAAC;AAAA,EACL;AACA,MAAI,MAAM,GAAG,KAAK,MAAM;AACpB,YAAQ,GAAG,IAAI,kBAAoB,MAAM,GAAG,CAAC;AAAA,EACjD;AACA,MAAI,MAAM,GAAG,KAAK,MAAM;AACpB,YAAQ,GAAG,IAAI,kBAAoB,MAAM,GAAG,CAAC;AAAA,EACjD;AACA,MAAI,MAAM,EAAE,KAAK,MAAM;AACnB,YAAQ,EAAE,IAAI,MAAM,EAAE;AAAA,EAC1B;AACA,MAAI,MAAM,IAAI,KAAK,MAAM;AACrB,UAAM,gBAAgB,cAAc,MAAM,IAAI,GAAGA,QAAO;AACxD,QAAI,MAAM,IAAI,GAAG,WAAW,GAAG;AAC3B,cAAQ,aAAa,CAAC;AAAA,IAC1B;AACA,WAAO,QAAQ,aAAa,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,YAAM,MAAM,cAAc,GAAG;AAC7B,cAAQ,GAAG,IAAI;AAAA,IACnB,CAAC;AAAA,EACL;AACA,MAAI,MAAM,IAAI,KAAK,MAAM;AACrB,UAAM,gBAAgB,sBAAsB,MAAM,IAAI,GAAGA,QAAO;AAChE,QAAI,MAAM,IAAI,GAAG,WAAW,GAAG;AAC3B,cAAQ,qBAAqB,CAAC;AAAA,IAClC;AACA,WAAO,QAAQ,aAAa,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,YAAM,MAAM,sBAAsB,GAAG;AACrC,cAAQ,GAAG,IAAI;AAAA,IACnB,CAAC;AAAA,EACL;AACA,MAAI,MAAM,EAAE,KAAK,MAAM;AACnB,YAAQ,EAAE,IAAI,MAAM,EAAE;AAAA,EAC1B;AACA,SAAO;AACX,GAnDoC;AAg8BpC,IAAM,gBAAgB,wBAAC,OAAOE,aAAY;AACtC,QAAM,UAAU,CAAC;AACjB,MAAI,UAAU;AACd,aAAW,SAAS,OAAO;AACvB,QAAI,UAAU,MAAM;AAChB;AAAA,IACJ;AACA,YAAQ,UAAU,OAAO,EAAE,IAAI;AAC/B;AAAA,EACJ;AACA,SAAO;AACX,GAXsB;AA2StB,IAAM,qCAAqC,wBAAC,QAAQC,aAAY;AAC5D,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,SAAO;AACX,GAN2C;AAO3C,IAAM,uBAAuB,wBAAC,QAAQA,aAAY;AAC9C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,SAAO;AACX,GAN6B;AA8B7B,IAAM,gCAAgC,wBAAC,QAAQC,aAAY;AACvD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAOC,IAAG,KAAK,MAAM;AACrB,aAASA,IAAG,IAAI,aAAe,OAAOA,IAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,gCAAgC,IAAI;AAC3C,aAAS,IAAI,IAAI,CAAC;AAAA,EACtB,WACS,OAAO,IAAI,KAAK,QAAQ,OAAO,IAAI,EAAE,EAAE,KAAK,MAAM;AACvD,aAAS,IAAI,IAAI,+BAA+B,qBAAuB,OAAO,IAAI,EAAE,EAAE,CAAC,GAAGD,QAAO;AAAA,EACrG;AACA,SAAO;AACX,GAZsC;AAatC,IAAM,gCAAgC,wBAAC,QAAQA,aAAY;AACvD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,SAAO;AACX,GATsC;AAUtC,IAAM,iCAAiC,wBAAC,QAAQA,aAAY;AACxD,UAAQ,UAAU,CAAC,GACd,OAAO,CAACE,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,8BAA8B,OAAOF,QAAO;AAAA,EACvD,CAAC;AACL,GANuC;AAOvC,IAAM,eAAe,wBAAC,QAAQA,aAAY;AACtC,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,cAAgB,+BAAiC,OAAO,GAAG,CAAC,CAAC;AAAA,EACjF;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,iBAAmB,OAAO,IAAI,CAAC;AAAA,EACpD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,iBAAmB,OAAO,GAAG,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,iBAAmB,OAAO,GAAG,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,iBAAmB,OAAO,GAAG,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,iBAAmB,OAAO,GAAG,CAAC;AAAA,EAClD;AACA,MAAI,OAAO,EAAE,KAAK,MAAM;AACpB,aAAS,EAAE,IAAI,aAAe,OAAO,EAAE,CAAC;AAAA,EAC5C;AACA,MAAI,OAAO,uBAAuB,IAAI;AAClC,aAAS,IAAI,IAAI,CAAC;AAAA,EACtB,WACS,OAAO,IAAI,KAAK,QAAQ,OAAO,IAAI,EAAE,EAAE,KAAK,MAAM;AACvD,aAAS,IAAI,IAAI,qBAAqB,qBAAuB,OAAO,IAAI,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EAC3F;AACA,SAAO;AACX,GA9BqB;AA+BrB,IAAM,gBAAgB,wBAAC,QAAQA,aAAY;AACvC,UAAQ,UAAU,CAAC,GACd,OAAO,CAACE,OAAMA,MAAK,IAAI,EACvB,IAAI,CAAC,UAAU;AAChB,WAAO,aAAa,OAAOF,QAAO;AAAA,EACtC,CAAC;AACL,GANsB;AAOtB,IAAM,uBAAuB,wBAAC,QAAQA,aAAY;AAC9C,SAAO,OAAO,OAAO,CAAC,KAAK,SAAS;AAChC,QAAI,KAAK,OAAO,MAAM,MAAM;AACxB,aAAO;AAAA,IACX;AACA,QAAI,KAAK,KAAK,CAAC,IAAI,iBAAmB,KAAK,OAAO,CAAC;AACnD,WAAO;AAAA,EACX,GAAG,CAAC,CAAC;AACT,GAR6B;AA8M7B,IAAM,+BAA+B,wBAAC,QAAQG,aAAY;AACtD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,EAAE,KAAK,MAAM;AACpB,aAAS,EAAE,IAAI,aAAe,OAAO,EAAE,CAAC;AAAA,EAC5C;AACA,MAAI,OAAO,eAAe,IAAI;AAC1B,aAAS,GAAG,IAAI,CAAC;AAAA,EACrB,WACS,OAAO,GAAG,KAAK,QAAQ,OAAO,GAAG,EAAE,EAAE,KAAK,MAAM;AACrD,aAAS,GAAG,IAAI,cAAc,qBAAuB,OAAO,GAAG,EAAE,EAAE,CAAC,GAAGA,QAAO;AAAA,EAClF;AACA,SAAO;AACX,GAZqC;AA8LrC,IAAM,0BAA0B,wBAAC,QAAQC,aAAY;AACjD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,SAAO;AACX,GANgC;AAOhC,IAAM,wBAAwB,wBAAC,QAAQA,aAAY;AAC/C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAOC,IAAG,KAAK,MAAM;AACrB,aAASA,IAAG,IAAI,aAAe,OAAOA,IAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GAN8B;AAO9B,IAAM,sBAAsB,wBAAC,QAAQD,aAAY;AAC7C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAOC,IAAG,KAAK,MAAM;AACrB,aAASA,IAAG,IAAI,aAAe,OAAOA,IAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GAN4B;AAO5B,IAAM,0CAA0C,wBAAC,QAAQD,aAAY;AACjE,QAAM,WAAW,CAAC;AAClB,MAAI,OAAOC,IAAG,KAAK,MAAM;AACrB,aAASA,IAAG,IAAI,aAAe,OAAOA,IAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GANgD;AAOhD,IAAM,oCAAoC,wBAAC,QAAQD,aAAY;AAC3D,QAAM,WAAW,CAAC;AAClB,MAAI,OAAOC,IAAG,KAAK,MAAM;AACrB,aAASA,IAAG,IAAI,aAAe,OAAOA,IAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GAN0C;AAO1C,IAAM,4BAA4B,wBAAC,QAAQD,aAAY;AACnD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,SAAO;AACX,GANkC;AAOlC,IAAM,wBAAwB,wBAAC,QAAQA,aAAY;AAC/C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAOC,IAAG,KAAK,MAAM;AACrB,aAASA,IAAG,IAAI,aAAe,OAAOA,IAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GAN8B;AAmd9B,IAAM,uCAAuC,wBAAC,QAAQC,aAAY;AAC9D,QAAM,WAAW,CAAC;AAClB,MAAI,OAAOC,IAAG,KAAK,MAAM;AACrB,aAASA,IAAG,IAAI,aAAe,OAAOA,IAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GAN6C;AAkF7C,IAAM,sBAAsB,wBAAC,QAAQC,aAAY;AAC7C,QAAM,WAAW,CAAC;AAClB,MAAI,OAAOC,IAAG,KAAK,MAAM;AACrB,aAASA,IAAG,IAAI,aAAe,OAAOA,IAAG,CAAC;AAAA,EAC9C;AACA,SAAO;AACX,GAN4B;AAO5B,IAAM,+BAA+B,wBAAC,QAAQD,aAAY;AACtD,QAAM,WAAW,CAAC;AAClB,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,GAAG,KAAK,MAAM;AACrB,aAAS,GAAG,IAAI,aAAe,OAAO,GAAG,CAAC;AAAA,EAC9C;AACA,MAAI,OAAO,IAAI,KAAK,MAAM;AACtB,aAAS,IAAI,IAAI,aAAe,OAAO,IAAI,CAAC;AAAA,EAChD;AACA,SAAO;AACX,GAZqC;AA2ErC,IAAME,uBAAsB,wBAAC,YAAY;AAAA,EACrC,gBAAgB,OAAO;AAAA,EACvB,WAAW,OAAO,QAAQ,kBAAkB,KAAK,OAAO,QAAQ,mBAAmB,KAAK,OAAO,QAAQ,kBAAkB;AAAA,EACzH,mBAAmB,OAAO,QAAQ,YAAY;AAAA,EAC9C,MAAM,OAAO,QAAQ,aAAa;AACtC,IAL4B;AAO5B,IAAMC,qBAAoB,kBAAkB,0BAAe;AAC3D,IAAMC,uBAAsB,8BAAOC,UAAS,SAAS,MAAM,kBAAkB,SAAS;AAClF,QAAM,EAAE,UAAU,WAAW,SAAS,MAAM,MAAM,SAAS,IAAI,MAAMA,SAAQ,SAAS;AACtF,QAAM,WAAW;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR,MAAM,SAAS,SAAS,GAAG,IAAI,SAAS,MAAM,GAAG,EAAE,IAAI,OAAO,WAAW;AAAA,IACzE;AAAA,EACJ;AACA,MAAI,qBAAqB,QAAW;AAChC,aAAS,WAAW;AAAA,EACxB;AACA,MAAI,SAAS,QAAW;AACpB,aAAS,OAAO;AAAA,EACpB;AACA,SAAO,IAAI,YAAc,QAAQ;AACrC,GAjB4B;AAkB5B,IAAMC,kBAAiB;AAAA,EACnB,gBAAgB;AACpB;AACA,IAAMC,KAAI;AACV,IAAMC,MAAK;AA+BX,IAAM,MAAM;AASZ,IAAM,KAAK;AAmBX,IAAM,MAAM;AAGZ,IAAM,MAAM;AAYZ,IAAM,OAAO;AACb,IAAM,MAAM;AAaZ,IAAM,OAAO;AAiBb,IAAM,KAAK;AAoBX,IAAM,MAAM;AAUZ,IAAM,MAAM;AAEZ,IAAM,OAAO;AAEb,IAAM,MAAM;AACZ,IAAMC,MAAK;AAEX,IAAM,MAAM;AAOZ,IAAM,KAAK;AAgBX,IAAM,MAAM;AAIZ,IAAM,MAAM;AAKZ,IAAM,OAAO;AAUb,IAAM,MAAM;AAQZ,IAAM,OAAO;AAEb,IAAM,MAAM;AASZ,IAAM,MAAM;AAEZ,IAAM,KAAK;AAGX,IAAMC,MAAK;AACX,IAAMC,OAAM;AAEZ,IAAM,OAAO;AACb,IAAM,KAAK;AACX,IAAM,KAAK;AACX,IAAMC,OAAM;AACZ,IAAMC,6BAA4B,wBAAC,gBAAgB,OAAO,QAAQ,WAAW,EACxE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,2BAA6B,GAAG,IAAI,MAAM,2BAA6B,KAAK,CAAC,EACnG,KAAK,GAAG,GAFqB;AAGlC,IAAM,qBAAqB,wBAAC,QAAQ,SAAS;AACzC,MAAI,KAAK,OAAO,SAAS,QAAW;AAChC,WAAO,KAAK,MAAM;AAAA,EACtB;AACA,MAAI,OAAO,cAAc,KAAK;AAC1B,WAAO;AAAA,EACX;AACJ,GAP2B;;;AG9tI3B;AAAA;AAAA;AAAA;AAAAC;AAMO,IAAM,6BAAN,cAAyC,QAC3C,aAAa,EACb,GAAGC,aAAY,EACf,EAAE,SAAUC,UAAS,IAAIC,SAAQC,IAAG;AACrC,SAAO;AAAA,IACH,eAAeD,SAAQ,KAAK,WAAW,KAAK,WAAW;AAAA,IACvD,kBAAkBA,SAAQD,SAAQ,iCAAiC,CAAC;AAAA,EACxE;AACJ,CAAC,EACI,EAAE,iCAAiC,uBAAuB,CAAC,CAAC,EAC5D,EAAE,oBAAoB,4BAA4B,EAClD,EAAE,QAAQ,MAAM,EAChB,IAAI,6BAA6B,EACjC,GAAG,6BAA6B,EAChC,MAAM,EAAE;AAAA,EApBb,OAoBa;AAAA;AAAA;AACb;;;A3ZfA,SAAS,YAAY,OAAO;AAC1B,QAAM,QAAQ,CAAC,KAAK,MAAM,MAAM,MAAM,IAAI;AAC1C,MAAI,QAAQ;AACZ,MAAI,YAAY;AAEhB,SAAO,SAAS,QAAQ,YAAY,MAAM,SAAS,GAAG;AACpD,aAAS;AACT;AAAA,EACF;AAEA,SAAO,GAAG,MAAM,QAAQ,CAAC,CAAC,IAAI,MAAM,SAAS,CAAC;AAChD;AAXS;AAaT,SAAS,eAAe,MAAM;AAE5B,QAAM,aAAa,CAAC;AACpB,MAAI,UAAU,GAAG,WAAW;AAC5B,OAAK,QAAQ,YAAU;AACrB,UAAM,OAAO,IAAI,KAAK,OAAO,SAAS,EAAE,YAAY,EAAE,MAAM,GAAG,EAAE,CAAC;AAClE,QAAI,CAAC,WAAW,IAAI,EAAG,YAAW,IAAI,IAAI,EAAE,IAAI,GAAG,KAAK,GAAG,OAAO,EAAE;AACpE,eAAW,IAAI,EAAE,MAAM,OAAO;AAC9B,eAAW,IAAI,EAAE,OAAO,OAAO,cAAc;AAC7C,eAAW,IAAI,EAAE;AAAA,EACnB,CAAC;AACD,QAAM,OAAO,CAAC;AACd,SAAO,QAAQ,UAAU,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC,MAAM,KAAK,MAAM;AAC3D,UAAM,QAAQ,MAAM,KAAK,MAAM;AAC/B,UAAM,SAAS,MAAM,MAAM,MAAM;AACjC,eAAW;AACX,gBAAY;AACZ,SAAK,KAAK,CAAC,MAAM,YAAY,KAAK,GAAG,YAAY,MAAM,CAAC,CAAC;AAAA,EAC3D,CAAC;AACD,OAAK,KAAK,CAAC,gBAAM,YAAY,OAAO,GAAG,YAAY,QAAQ,CAAC,CAAC;AAC7D,SAAO;AACT;AArBS;AAuBT,SAAS,gBAAgB,MAAM;AAE7B,QAAM,YAAY,CAAC,GAAG,GAAG,CAAC;AAC1B,QAAM,SAAS,CAAC,gBAAM,4BAAQ,0BAAM;AACpC,GAAC,QAAQ,GAAG,IAAI,EAAE,QAAQ,SAAO;AAC/B,QAAI,QAAQ,CAAC,MAAMG,OAAM;AACvB,gBAAUA,EAAC,IAAI,KAAK,IAAI,UAAUA,EAAC,GAAG,KAAK,MAAM;AAAA,IACnD,CAAC;AAAA,EACH,CAAC;AAED,QAAM,QAAQ,CAAC;AACf,QAAM,aAAa,OAAO,IAAI,CAACC,IAAGD,OAAMC,GAAE,OAAO,UAAUD,EAAC,GAAG,GAAG,CAAC,EAAE,KAAK,IAAI;AAC9E,QAAM,KAAK,UAAU;AACrB,QAAM,KAAK,IAAI,OAAO,WAAW,MAAM,CAAC;AACxC,OAAK,MAAM,GAAG,EAAE,EAAE,QAAQ,SAAO;AAC/B,UAAM,KAAK,IAAI,IAAI,CAAC,MAAMA,OAAM,KAAK,OAAO,UAAUA,EAAC,GAAG,GAAG,CAAC,EAAE,KAAK,IAAI,CAAC;AAAA,EAC5E,CAAC;AAED,QAAM,KAAK,IAAI,OAAO,WAAW,MAAM,CAAC;AACxC,QAAM,WAAW,KAAK,KAAK,SAAS,CAAC,EAAE,IAAI,CAAC,MAAMA,OAAM,KAAK,OAAO,UAAUA,EAAC,GAAG,GAAG,CAAC,EAAE,KAAK,IAAI;AACjG,QAAM,KAAK,QAAQ;AACnB,SAAO,MAAM,KAAK,IAAI;AACxB;AAtBS;AAwBT,SAAS,mBAAmB,MAAM;AAChC,MAAI,KAAK;AACT,OAAK,MAAM,GAAG,EAAE,EAAE,QAAQ,SAAO;AAC/B,UAAM,KAAK,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC;AAAA;AAAA,EAC3C,CAAC;AACD,QAAM,QAAQ,KAAK,KAAK,SAAS,CAAC;AAClC,QAAM,OAAO,MAAM,CAAC,CAAC,UAAU,MAAM,CAAC,CAAC,UAAU,MAAM,CAAC,CAAC;AAAA;AACzD,SAAO;AACT;AARS;AAUT,eAAe,kBAAkB,KAAK,OAAO,SAAS;AACpD,QAAM,YAAY,GAAG,GAAG,UAAU,KAAK;AACvC,QAAM,OAAO,KAAK,UAAU;AAAA,IAC1B,OAAO;AAAA,IACP;AAAA,IACA,UAAU;AAAA,EACZ,CAAC;AACD,SAAO,MAAM,MAAM,WAAW;AAAA,IAC5B,QAAQ;AAAA,IACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,IAC9C;AAAA,EACF,CAAC;AACH;AAZe;AAcf,eAAe,oBAAoB,UAAU,QAAQ,SAAS;AAE5D,QAAM,MAAM,+BAA+B,QAAQ;AACnD,QAAM,OAAO,KAAK,UAAU;AAAA,IAC1B,SAAS;AAAA,IACT,MAAM,UAAU,UAAU;AAAA,IAC1B,YAAY;AAAA,EACd,CAAC;AACD,UAAQ,IAAI,wCAAoB,GAAG;AACnC,UAAQ,IAAI,yCAAqB,IAAI;AACrC,MAAI;AACF,UAAM,OAAO,MAAM,MAAM,KAAK;AAAA,MAC5B,QAAQ;AAAA,MACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAC9C;AAAA,IACF,CAAC;AACD,YAAQ,IAAI,iDAAmB,KAAK,MAAM;AAC1C,UAAM,WAAW,MAAM,KAAK,KAAK;AACjC,YAAQ,IAAI,iDAAmB,QAAQ;AACvC,WAAO;AAAA,EACT,SAAS,KAAK;AACZ,YAAQ,IAAI,qCAAiB,GAAG;AAChC,UAAM;AAAA,EACR;AACF;AAxBe;AA0Bf,IAAO,cAAQ;AAAA,EACb,MAAM,MAAM,SAASE,MAAK,KAAK;AAC/B,IAAO,SAAK,EAAE,KAAK,iEAAiE,CAAC;AAGnF,UAAM,SAAS,IAAI,IAAI,QAAQ,GAAG;AAClC,UAAM,aAAa,OAAO,aAAa;AAGvC,UAAM,YAAY,IAAI,UAAU;AAAA,MAC9B,QAAQA,KAAI;AAAA,MACZ,aAAa;AAAA,QACX,aAAaA,KAAI;AAAA,QACjB,iBAAiBA,KAAI;AAAA,MACvB;AAAA,IACF,CAAC;AAED,UAAM,mBAAmB,IAAI,iBAAiB;AAAA,MAC5C,QAAQA,KAAI;AAAA,MACZ,aAAa;AAAA,QACX,aAAaA,KAAI;AAAA,QACjB,iBAAiBA,KAAI;AAAA,MACvB;AAAA,IACF,CAAC;AAED,QAAI;AAEF,YAAM,aAAa,IAAI,yBAAyB;AAAA,QAC9C,aAAa,CAACA,KAAI,eAAe;AAAA,MACnC,CAAC;AACD,YAAM,UAAU,KAAK,UAAU;AAG/B,YAAM,MAAM,oBAAI,KAAK;AACrB,YAAM,aAAa,IAAI,YAAY,EAAE,MAAM,GAAG,EAAE,CAAC;AACjD,YAAM,YAAY,IAAI,KAAK,IAAI,YAAY,GAAG,IAAI,SAAS,GAAG,CAAC;AAC/D,YAAM,UAAU,IAAI,KAAK,IAAI,YAAY,GAAG,IAAI,SAAS,IAAI,GAAG,GAAG,IAAI,IAAI,EAAE;AAG7E,YAAM,mBAAmB,IAAI,2BAA2B;AAAA,QACtD,WAAW;AAAA,QACX,YAAY;AAAA,QACZ,YAAY;AAAA,UACV;AAAA,YACE,MAAM;AAAA,YACN,OAAOA,KAAI;AAAA,UACb;AAAA,QACF;AAAA,QACA,WAAW;AAAA,QACX,SAAS;AAAA,QACT,QAAQ;AAAA;AAAA,QACR,YAAY,CAAC,SAAS;AAAA,MACxB,CAAC;AAGD,YAAM,oBAAoB,IAAI,2BAA2B;AAAA,QACvD,WAAW;AAAA,QACX,YAAY;AAAA,QACZ,YAAY;AAAA,UACV;AAAA,YACE,MAAM;AAAA,YACN,OAAOA,KAAI;AAAA,UACb;AAAA,QACF;AAAA,QACA,WAAW;AAAA,QACX,SAAS;AAAA,QACT,QAAQ;AAAA;AAAA,QACR,YAAY,CAAC,SAAS;AAAA,MACxB,CAAC;AAED,YAAM,CAAC,mBAAmB,kBAAkB,IAAI,MAAM,QAAQ,IAAI;AAAA,QAChE,iBAAiB,KAAK,gBAAgB;AAAA,QACtC,iBAAiB,KAAK,iBAAiB;AAAA,MACzC,CAAC;AAGD,YAAM,kBAAkB,kBAAkB,WAAW,IAAI,CAAC,UAAU,WAAW;AAAA,QAC7E,GAAG;AAAA,QACH,YAAY,mBAAmB,WAAW,KAAK,GAAG,WAAW;AAAA,MAC/D,EAAE;AAGF,YAAM,OAAO,eAAe,eAAe;AAE3C,YAAM,aAAa,gBAAgB,IAAI;AACvC,YAAMC,SAAQ,GAAG,UAAU;AAC3B,YAAM,cAAc,GAAGA,MAAK;AAAA;AAAA,EAAO,UAAU;AAG7C,YAAMC,WAAUF,KAAI,gBAAgB;AACpC,UAAI,YAAY;AACd,YAAIE,aAAY,OAAOA,aAAY,KAAK;AACtC,cAAIF,KAAI,cAAcA,KAAI,cAAc;AACtC,oBAAQ,IAAI,mCAAe;AAC3B,gBAAI;AACF,oBAAM,aAAa,MAAM,kBAAkBA,KAAI,YAAYA,KAAI,cAAc,WAAW;AACxF,sBAAQ,IAAI,+CAAiB,WAAW,MAAM;AAC9C,oBAAM,aAAa,MAAM,WAAW,KAAK;AACzC,sBAAQ,IAAI,+CAAiB,UAAU;AAAA,YACzC,SAAS,SAAS;AAChB,sBAAQ,IAAI,mCAAe,OAAO;AAAA,YACpC;AAAA,UACF,OAAO;AACL,oBAAQ,IAAI,8EAAsC;AAAA,UACpD;AAAA,QACF;AACA,YAAIE,aAAY,OAAOA,aAAY,KAAK;AACtC,cAAIF,KAAI,gBAAgBA,KAAI,YAAY;AACtC,oBAAQ,IAAI,qCAAiB;AAC7B,gBAAI;AACF,oBAAM,oBAAoBA,KAAI,cAAcA,KAAI,YAAY,WAAW;AAAA,YACzE,SAAS,OAAO;AACd,sBAAQ,IAAI,qCAAiB,KAAK;AAAA,YACpC;AAAA,UACF,OAAO;AACL,oBAAQ,IAAI,gFAAwC;AAAA,UACtD;AAAA,QACF;AAAA,MACF,OAAO;AACL,gBAAQ,IAAI,uFAAsB,OAAO,QAAQ;AAAA,MACnD;AAGA,YAAM,gBAAgB,mBAAmB,IAAI;AAC7C,aAAO,IAAI,SAAS,eAAe;AAAA,QACjC,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,+BAA+B;AAAA,QACjC;AAAA,MACF,CAAC;AAAA,IACH,SAASG,QAAO;AACd,cAAQ,IAAI,mCAAUA,MAAK;AAC3B,aAAO,IAAI,SAAS,iBAAOA,OAAM,OAAO,IAAI;AAAA,QAC1C,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,+BAA+B;AAAA,QACjC;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACF;;;A4ZjQA;AAAA;AAAA;AAAA;AAAAC;AAEA,IAAM,YAAwB,8BAAO,SAASC,MAAK,MAAM,kBAAkB;AAC1E,MAAI;AACH,WAAO,MAAM,cAAc,KAAK,SAASA,IAAG;AAAA,EAC7C,UAAE;AACD,QAAI;AACH,UAAI,QAAQ,SAAS,QAAQ,CAAC,QAAQ,UAAU;AAC/C,cAAM,SAAS,QAAQ,KAAK,UAAU;AACtC,eAAO,EAAE,MAAM,OAAO,KAAK,GAAG,MAAM;AAAA,QAAC;AAAA,MACtC;AAAA,IACD,SAASC,IAAG;AACX,cAAQ,MAAM,4CAA4CA,EAAC;AAAA,IAC5D;AAAA,EACD;AACD,GAb8B;AAe9B,IAAO,6CAAQ;;;ACjBf;AAAA;AAAA;AAAA;AAAAC;AASA,SAAS,YAAYC,IAAmB;AACvC,SAAO;AAAA,IACN,MAAMA,IAAG;AAAA,IACT,SAASA,IAAG,WAAW,OAAOA,EAAC;AAAA,IAC/B,OAAOA,IAAG;AAAA,IACV,OAAOA,IAAG,UAAU,SAAY,SAAY,YAAYA,GAAE,KAAK;AAAA,EAChE;AACD;AAPS;AAUT,IAAM,YAAwB,8BAAO,SAASC,MAAK,MAAM,kBAAkB;AAC1E,MAAI;AACH,WAAO,MAAM,cAAc,KAAK,SAASA,IAAG;AAAA,EAC7C,SAASD,IAAQ;AAChB,UAAME,SAAQ,YAAYF,EAAC;AAC3B,WAAO,SAAS,KAAKE,QAAO;AAAA,MAC3B,QAAQ;AAAA,MACR,SAAS,EAAE,+BAA+B,OAAO;AAAA,IAClD,CAAC;AAAA,EACF;AACD,GAV8B;AAY9B,IAAO,2CAAQ;;;A9ZzBJ,IAAM,mCAAmC;AAAA,EAE9B;AAAA,EAAyB;AAC3C;AACA,IAAO,sCAAQ;;;A+ZVnB;AAAA;AAAA;AAAA;AAAAC;AAwBA,IAAM,wBAAsC,CAAC;AAKtC,SAAS,uBAAuB,MAAqC;AAC3E,wBAAsB,KAAK,GAAG,KAAK,KAAK,CAAC;AAC1C;AAFgB;AAShB,SAAS,uBACR,SACAC,MACA,KACA,UACA,iBACsB;AACtB,QAAM,CAAC,MAAM,GAAG,IAAI,IAAI;AACxB,QAAM,gBAAmC;AAAA,IACxC;AAAA,IACA,KAAK,YAAY,QAAQ;AACxB,aAAO,uBAAuB,YAAY,QAAQ,KAAK,UAAU,IAAI;AAAA,IACtE;AAAA,EACD;AACA,SAAO,KAAK,SAASA,MAAK,KAAK,aAAa;AAC7C;AAfS;AAiBF,SAAS,kBACf,SACAA,MACA,KACA,UACA,iBACsB;AACtB,SAAO,uBAAuB,SAASA,MAAK,KAAK,UAAU;AAAA,IAC1D,GAAG;AAAA,IACH;AAAA,EACD,CAAC;AACF;AAXgB;;;Aha3ChB,IAAM,iCAAN,MAAM,gCAA8D;AAAA,EAGnE,YACU,eACA,MACT,SACC;AAHQ;AACA;AAGT,SAAK,WAAW;AAAA,EACjB;AAAA,EArBD,OAYoE;AAAA;AAAA;AAAA,EAC1D;AAAA,EAUT,UAAU;AACT,QAAI,EAAE,gBAAgB,kCAAiC;AACtD,YAAM,IAAI,UAAU,oBAAoB;AAAA,IACzC;AAEA,SAAK,SAAS;AAAA,EACf;AACD;AAEA,SAAS,oBAAoB,QAA0C;AAEtE,MACC,qCAAqC,UACrC,iCAAiC,WAAW,GAC3C;AACD,WAAO;AAAA,EACR;AAEA,aAAW,cAAc,kCAAkC;AAC1D,wBAAoB,UAAU;AAAA,EAC/B;AAEA,QAAM,kBAA+C,gCACpD,SACAC,MACA,KACC;AACD,QAAI,OAAO,UAAU,QAAW;AAC/B,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC9D;AACA,WAAO,OAAO,MAAM,SAASA,MAAK,GAAG;AAAA,EACtC,GATqD;AAWrD,SAAO;AAAA,IACN,GAAG;AAAA,IACH,MAAM,SAASA,MAAK,KAAK;AACxB,YAAM,aAAyB,gCAAU,MAAMC,OAAM;AACpD,YAAI,SAAS,eAAe,OAAO,cAAc,QAAW;AAC3D,gBAAM,aAAa,IAAI;AAAA,YACtB,KAAK,IAAI;AAAA,YACTA,MAAK,QAAQ;AAAA,YACb,MAAM;AAAA,YAAC;AAAA,UACR;AACA,iBAAO,OAAO,UAAU,YAAYD,MAAK,GAAG;AAAA,QAC7C;AAAA,MACD,GAT+B;AAU/B,aAAO,kBAAkB,SAASA,MAAK,KAAK,YAAY,eAAe;AAAA,IACxE;AAAA,EACD;AACD;AAxCS;AA0CT,SAAS,qBACR,OAC8B;AAE9B,MACC,qCAAqC,UACrC,iCAAiC,WAAW,GAC3C;AACD,WAAO;AAAA,EACR;AAEA,aAAW,cAAc,kCAAkC;AAC1D,wBAAoB,UAAU;AAAA,EAC/B;AAGA,SAAO,cAAc,MAAM;AAAA,IAC1B,mBAAyE,wBACxE,SACAA,MACA,QACI;AACJ,WAAK,MAAMA;AACX,WAAK,MAAM;AACX,UAAI,MAAM,UAAU,QAAW;AAC9B,cAAM,IAAI,MAAM,sDAAsD;AAAA,MACvE;AACA,aAAO,MAAM,MAAM,OAAO;AAAA,IAC3B,GAXyE;AAAA,IAazE,cAA0B,wBAAC,MAAMC,UAAS;AACzC,UAAI,SAAS,eAAe,MAAM,cAAc,QAAW;AAC1D,cAAM,aAAa,IAAI;AAAA,UACtB,KAAK,IAAI;AAAA,UACTA,MAAK,QAAQ;AAAA,UACb,MAAM;AAAA,UAAC;AAAA,QACR;AACA,eAAO,MAAM,UAAU,UAAU;AAAA,MAClC;AAAA,IACD,GAT0B;AAAA,IAW1B,MAAM,SAAwD;AAC7D,aAAO;AAAA,QACN;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,MACN;AAAA,IACD;AAAA,EACD;AACD;AAnDS;AAqDT,IAAI;AACJ,IAAI,OAAO,wCAAU,UAAU;AAC9B,kBAAgB,oBAAoB,mCAAK;AAC1C,WAAW,OAAO,wCAAU,YAAY;AACvC,kBAAgB,qBAAqB,mCAAK;AAC3C;AACA,IAAO,kCAAQ;",
  "names": ["init", "init_performance", "init_performance", "PerformanceMark", "e", "init_performance", "init_performance", "init_performance", "init_performance", "clear", "count", "countReset", "createTask", "debug", "dir", "dirxml", "error", "group", "groupCollapsed", "groupEnd", "info", "log", "profile", "profileEnd", "table", "time", "timeEnd", "timeLog", "timeStamp", "trace", "warn", "init_console", "init_performance", "init_console", "init_performance", "hrtime", "init_performance", "dir", "x", "env", "count", "init_performance", "init_performance", "init_performance", "init_performance", "cwd", "hrtime", "assert", "init_process", "init_performance", "init_process", "init_performance", "init_performance", "v", "a", "i", "init_performance", "i", "t", "count", "init_performance", "val", "init_performance", "val", "init_performance", "i", "entityName", "val", "init_performance", "init_performance", "_", "i", "val", "result", "entityName", "init_performance", "i", "val", "init_performance", "XMLParser", "init_performance", "i", "attStr", "init_performance", "a", "val", "j", "i", "init_performance", "XMLParser", "init_performance", "e", "t", "r", "n", "i", "s", "a", "o", "u", "d", "c", "f", "l", "h", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "HttpAuthLocation", "init_performance", "HttpApiKeyAuthLocation", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "EndpointURLScheme", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "AlgorithmId", "init_performance", "init_performance", "init_performance", "FieldPosition", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "IniSectionType", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "RequestHandlerProtocol", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "context", "logger", "error", "init_performance", "h", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "context", "init_performance", "init_performance", "config", "context", "init_performance", "config", "init_performance", "init_performance", "init_performance", "context", "error", "e", "k", "init_performance", "init_performance", "context", "config", "init_performance", "init_performance", "error", "config", "context", "init_performance", "config", "init_performance", "normalizeProvider", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "i", "i", "j", "k", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "i", "j", "k", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "c", "init_performance", "i", "init_performance", "init_performance", "body", "config", "init_performance", "init_performance", "i", "init_performance", "context", "init_performance", "c", "init_performance", "init_performance", "init_performance", "context", "init_performance", "init_performance", "config", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "normalizeProvider", "logger", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "i", "val", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "hostname", "protocol", "k", "v", "error", "init_performance", "init_performance", "init_performance", "c", "init_performance", "init_performance", "init_performance", "argv", "init_performance", "init_performance", "init_performance", "init_performance", "error", "init_performance", "error", "init_performance", "logger", "v", "k", "init_performance", "init_performance", "init_performance", "partition", "init_performance", "partition", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "setFeature", "context", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "context", "config", "error", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "HEADER_VALUE_TYPE", "i", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "value", "serialized", "init_performance", "time", "init_performance", "config", "normalizeProvider", "config", "normalizeProvider", "init_performance", "init_performance", "init_performance", "init_performance", "a", "b", "debug", "entry", "context", "config", "init_performance", "init_performance", "logger", "_", "init_performance", "init_performance", "init_performance", "init_performance", "v", "k", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "getChecksumConfiguration", "resolveChecksumRuntimeConfig", "init_performance", "getChecksumConfiguration", "config", "resolveChecksumRuntimeConfig", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "s", "init_performance", "_", "time", "init_performance", "init_performance", "init_performance", "init_performance", "LazyJsonString", "val", "init_performance", "init_performance", "context", "init_performance", "context", "_", "val", "e", "context", "config", "setFeature", "init_performance", "init_performance", "features", "val", "context", "version", "config", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "SelectorType", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "error", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "partition", "init_performance", "config", "init_performance", "init_performance", "init_performance", "init_performance", "context", "init_performance", "config", "context", "init_performance", "config", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "RETRY_MODES", "init_performance", "init_performance", "init_performance", "error", "t", "init_performance", "init_performance", "init_performance", "init_performance", "error", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "i", "init_performance", "init_performance", "i", "init_performance", "init_performance", "init_performance", "init_performance", "error", "init_performance", "init_performance", "init_performance", "init_performance", "context", "e", "error", "init_performance", "config", "context", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "fromUtf8", "init_performance", "init_performance", "fromUtf8", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "Sha256", "init_performance", "init_performance", "e", "_", "t", "f", "g", "n", "v", "init_performance", "init_performance", "RawSha256", "i", "u", "t2", "Sha256", "e", "i", "init_performance", "window", "getRandomValues", "Sha256", "init_performance", "config", "bowser", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "i", "init_performance", "init_performance", "init_performance", "context", "config", "init_performance", "init_performance", "import_bowser", "init_performance", "bowser", "platform", "getRuntimeConfig", "config", "_", "Sha256", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "config", "getRuntimeConfig", "config", "init_performance", "init_performance", "context", "context", "deserializeMetadata", "context", "throwDefaultError", "context", "context", "context", "context", "context", "context", "context", "context", "context", "context", "e", "context", "e", "context", "context", "e", "context", "context", "context", "context", "e", "context", "e", "context", "context", "e", "context", "e", "context", "context", "e", "context", "context", "context", "context", "context", "e", "context", "e", "context", "context", "context", "e", "deserializeMetadata", "throwDefaultError", "context", "init_performance", "Command", "config", "o", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "CompressionAlgorithm", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "config", "context", "createAwsAuthSigv4HttpAuthOption", "resolveHttpAuthSchemeConfig", "init_performance", "resolveClientEndpointParameters", "commonParams", "init_performance", "package_default", "init_performance", "init_performance", "init_performance", "u", "v", "w", "x", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "_data", "ruleSet", "cache", "defaultEndpointResolver", "context", "ruleSet", "getRuntimeConfig", "config", "defaultEndpointResolver", "getRuntimeConfig", "config", "_", "package_default", "Sha256", "init_performance", "init_performance", "getHttpAuthExtensionConfiguration", "resolveHttpAuthRuntimeConfig", "config", "resolveRuntimeExtensions", "getHttpAuthExtensionConfiguration", "resolveHttpAuthRuntimeConfig", "getRuntimeConfig", "resolveClientEndpointParameters", "resolveHttpAuthSchemeConfig", "resolveRuntimeExtensions", "config", "init_performance", "init_performance", "init_performance", "context", "SHARED_HEADERS", "buildFormUrlencodedString", "_A", "_V", "_", "buildHttpRpcRequest", "context", "de_CommandError", "deserializeMetadata", "de_CommandError", "context", "throwDefaultError", "deserializeMetadata", "context", "_Va", "context", "context", "context", "_N", "context", "context", "context", "_me", "e", "context", "context", "_me", "context", "_me", "context", "_me", "deserializeMetadata", "throwDefaultError", "buildHttpRpcRequest", "context", "SHARED_HEADERS", "_", "_A", "_N", "_V", "_Va", "_me", "buildFormUrlencodedString", "init_performance", "commonParams", "Command", "config", "o", "i", "h", "env", "title", "channel", "error", "init_performance", "env", "e", "init_performance", "e", "env", "error", "init_performance", "env", "env", "init"]
}
